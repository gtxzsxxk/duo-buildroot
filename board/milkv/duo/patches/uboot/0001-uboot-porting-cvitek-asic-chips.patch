From 3a4bcfca2fce0e9d1f093b4c95dc77ebbc144ca0 Mon Sep 17 00:00:00 2001
From: "sam.xiang" <sam.xiang@sophgo.com>
Date: Wed, 22 Feb 2023 13:43:23 +0800
Subject: [PATCH 1/9] [uboot] porting cvitek asic chips: 	1. add cvitek
 folders to u-boot-2021.10 	2. add cv183x/cv182x part 	3. add
 cv181x/cv180x part

Change-Id: I6dc2e5ff509dbab16bd60bfb3fd61852da5e01f6
Signed-off-by: Hanyuan Zhao <hanyuan-z@qq.com>
---
 Makefile                       |    5 +
 arch/Kconfig                   |   18 +-
 arch/arm/Kconfig               |    6 +-
 arch/arm/dts/Makefile          |    5 +-
 .../arch/arm/include/asm/arch-armv8/boot0.h   |   28 +
 .../arch/arm/include/asm/mach-types.h         |    4 +-
 .../arch/arm/include/asm/u-boot-arm.h         |    1 +
 arch/arm/lib/bootm.c           |    3 +
 arch/riscv/Kconfig             |    5 +-
 arch/riscv/config.mk           |    2 +
 .../arch/riscv/cpu/generic/Makefile           |    1 +
 arch/riscv/cpu/generic/cache.c |   66 +
 arch/riscv/cpu/start.S         |    2 +
 arch/riscv/dts/Makefile        |    2 +
 .../riscv/dts/cv1800b_wdmb_0008a_spinor.dts   |   14 +
 .../riscv/dts/cv1800b_wevb_0008a_spinor.dts   |   14 +
 .../riscv/dts/cv1800c_wevb_0009a_spinor.dts   |   14 +
 .../riscv/dts/cv1801b_wevb_0008a_spinor.dts   |   14 +
 .../riscv/dts/cv1801c_wdmb_0009a_spinor.dts   |   17 +
 .../riscv/dts/cv1801c_wevb_0009a_spinand.dts  |   13 +
 .../riscv/dts/cv1801c_wevb_0009a_spinor.dts   |   14 +
 .../arch/riscv/dts/cv180x_asic_bga.dtsi       |   12 +
 .../arch/riscv/dts/cv180x_asic_qfn.dtsi       |  114 ++
 .../arch/riscv/dts/cv180x_asic_spinand.dtsi   |    5 +
 .../arch/riscv/dts/cv180x_asic_spinor.dtsi    |    5 +
 .../arch/riscv/dts/cv180x_base.dtsi           |  881 ++++++++
 .../arch/riscv/dts/cv180x_base_riscv.dtsi     |  374 ++++
 .../arch/riscv/dts/cv180x_default_memmap.dtsi |   26 +
 arch/riscv/dts/cv180x_fpga.dts |   16 +
 .../arch/riscv/dts/cv180x_palladium.dts       |   22 +
 .../riscv/dts/cv180zb_wdmb_0008a_spinor.dts   |   14 +
 .../riscv/dts/cv180zb_wevb_0008a_spinor.dts   |   14 +
 arch/riscv/include/asm/boot0.h |   31 +
 arch/riscv/include/asm/cache.h |    3 +-
 arch/riscv/include/asm/io.h    |   18 +-
 .../arch/riscv/include/asm/u-boot-riscv.h     |    1 +
 arch/riscv/lib/bootm.c         |   16 +
 arch/riscv/lib/reset.c         |    5 +-
 board/cvitek/Kconfig           |   35 +
 board/cvitek/cv180x/Kconfig    |   76 +
 board/cvitek/cv180x/Makefile   |    2 +
 board/cvitek/cv180x/board.c    |  304 +++
 .../cvitek/cv180x/cv180x_pinlist_swconfig.h   |  407 ++++
 .../board/cvitek/cv180x/cv180x_reg.h          |  186 ++
 .../cvitek/cv180x/cv180x_reg_fmux_gpio.h      |  337 +++
 .../board/cvitek/cv180x/sdhci_reg.h           |  130 ++
 board/cvitek/cv181x/Kconfig    |   73 +
 .../board/cvitek/cv181x/MAINTAINERS           |    4 +
 board/cvitek/cv181x/Makefile   |    2 +
 board/cvitek/cv181x/board.c    |  286 +++
 .../cvitek/cv181x/cv181x_pinlist_swconfig.h   |  674 ++++++
 .../board/cvitek/cv181x/cv181x_reg.h          |  185 ++
 .../cvitek/cv181x/cv181x_reg_fmux_gpio.h      |  481 +++++
 .../board/cvitek/cv181x/sdhci_reg.h           |  130 ++
 board/cvitek/cv1822/Kconfig    |   44 +
 .../board/cvitek/cv1822/MAINTAINERS           |    4 +
 board/cvitek/cv1822/Makefile   |    2 +
 board/cvitek/cv1822/board.c    |  418 ++++
 .../cvitek/cv1822/cv1822_pinlist_swconfig.h   |  614 ++++++
 .../board/cvitek/cv1822/cv1822_reg.h          |  160 ++
 .../cvitek/cv1822/cv1822_reg_fmux_gpio.h      |  457 +++++
 .../board/cvitek/cv1822/sdhci_reg.h           |  130 ++
 board/cvitek/cv1835/Kconfig    |   44 +
 .../board/cvitek/cv1835/MAINTAINERS           |    4 +
 board/cvitek/cv1835/Makefile   |    2 +
 board/cvitek/cv1835/board.c    |  492 +++++
 .../cvitek/cv1835/cv1835_pinlist_swconfig.h   |  521 +++++
 .../board/cvitek/cv1835/cv1835_reg.h          |  117 ++
 .../cvitek/cv1835/cv1835_reg_fmux_gpio.h      |  463 +++++
 .../board/cvitek/cv1835/sdhci_reg.h           |  122 ++
 cmd/Kconfig                    |    7 +
 cmd/Makefile                   |    5 +
 cmd/cvi_sd_update.c            |   68 +
 cmd/cvi_sd_update_spinand_v3.c |  981 +++++++++
 cmd/cvi_update.c               |  319 +++
 cmd/cvi_utask.c                |   39 +
 cmd/efuse.c                    |  711 +++++++
 cmd/mmc.c                      |   62 +-
 cmd/nand.c                     |   10 +-
 cmd/net.c                      |    9 +-
 cmd/sf.c                       |   12 +
 common/Kconfig.boot            |    2 +-
 common/autoboot.c              |    1 +
 common/board_f.c               |   18 +-
 common/board_r.c               |    6 +-
 common/image.c                 |   14 +
 cvitek.mk                      |   51 +
 drivers/adc/Kconfig            |    9 +
 drivers/adc/Makefile           |    1 +
 drivers/adc/adc-uclass.c       |    2 +-
 drivers/adc/cvitek-adc.c       |  219 ++
 drivers/cvi_usb/Makefile       |    5 +
 .../drivers/cvi_usb/utask/cv181x/cps_cvi.c    |   46 +
 .../cvi_usb/utask/cv181x/cvi_udc_otg.c        | 1117 ++++++++++
 .../utask/cv181x/cvi_udc_otg_xfer_dma.c       | 1584 +++++++++++++++
 .../drivers/cvi_usb/utask/cv181x/cvi_usb.c    |   47 +
 .../cvi_usb/utask/cv181x/include/big_endian.h |   24 +
 .../cvi_usb/utask/cv181x/include/byteorder.h  |   12 +
 .../cvi_usb/utask/cv181x/include/cvi_ch9.h    |  890 ++++++++
 .../cvi_usb/utask/cv181x/include/cvi_drv_if.h |  817 ++++++++
 .../cvi_usb/utask/cv181x/include/cvi_errno.h  |   92 +
 .../utask/cv181x/include/cvi_private.h        |   42 +
 .../cvi_usb/utask/cv181x/include/cvi_stdint.h |   29 +
 .../cvi_usb/utask/cv181x/include/cvi_stdio.h  |    1 +
 .../utask/cv181x/include/cvi_stdtypes.h       |   22 +
 .../cvi_usb/utask/cv181x/include/cvi_string.h |    1 +
 .../cvi_usb/utask/cv181x/include/cvi_udc.h    |   94 +
 .../utask/cv181x/include/cvi_udc_otg_priv.h   |  113 +
 .../utask/cv181x/include/cvi_udc_otg_regs.h   |  335 +++
 .../cvi_usb/utask/cv181x/include/cvi_usb.h    |   87 +
 .../cvi_usb/utask/cv181x/include/debug.h      |   61 +
 .../cvi_usb/utask/cv181x/include/dps.h        |  133 ++
 .../utask/cv181x/include/little_endian.h      |   25 +
 .../utask/cv181x/include/platform_def.h       |   22 +
 .../cvi_usb/utask/cv181x/include/swap.h       |   13 +
 .../utask/cv181x/include/system_common.h      |  334 +++
 .../cvi_usb/utask/cv181x/include/usb_tty.h    |  428 ++++
 .../drivers/cvi_usb/utask/cv181x/usb_tty.c    | 1537 ++++++++++++++
 .../drivers/cvi_usb/utask/test/README         |    3 +
 .../cvi_usb/utask/test/utask_memcpy.py        |  686 +++++++
 drivers/gpio/dwapb_gpio.c      |    1 -
 drivers/mmc/Kconfig            |   26 +
 drivers/mmc/Makefile           |    6 +
 .../drivers/mmc/cvitek/sdhci-cv180x.c         |  657 ++++++
 .../drivers/mmc/cvitek/sdhci-cv181x.c         |  672 ++++++
 .../drivers/mmc/cvitek/sdhci-cv182x.c         |  632 ++++++
 .../drivers/mmc/cvitek/sdhci-cv183x.c         |  698 +++++++
 drivers/mmc/mmc-uclass.c       |    2 +-
 drivers/mmc/mmc.c              |   85 +-
 drivers/mmc/sdhci.c            |  240 ++-
 drivers/mtd/nand/raw/Kconfig   |    8 +
 drivers/mtd/nand/raw/Makefile  |    1 +
 .../drivers/mtd/nand/raw/cvitek/Makefile      |    3 +
 .../drivers/mtd/nand/raw/cvitek/cvsnfc.c      | 1810 +++++++++++++++++
 .../mtd/nand/raw/cvitek/cvsnfc_common.c       |  185 ++
 .../mtd/nand/raw/cvitek/cvsnfc_spi_ids.c      | 1529 ++++++++++++++
 drivers/mtd/nand/raw/nand.c    |    2 +-
 .../drivers/mtd/nand/raw/nand_base.c          |  710 +------
 .../drivers/mtd/nand/raw/nand_bbt.c           |   36 +
 drivers/mtd/spi/Kconfig        |   22 +-
 drivers/mtd/spi/sf_internal.h  |    1 +
 drivers/mtd/spi/spi-nor-core.c |  158 +-
 drivers/mtd/spi/spi-nor-ids.c  |  401 +---
 drivers/net/designware.c       |    2 +-
 drivers/net/phy/Kconfig        |    8 +
 drivers/net/phy/Makefile       |    1 +
 drivers/net/phy/cv182xa.c      |  349 ++++
 drivers/net/phy/phy.c          |    3 +
 drivers/pwm/Kconfig            |   11 +
 drivers/pwm/Makefile           |    1 +
 drivers/pwm/cvitek_pwm.c       |  199 ++
 drivers/spi/Kconfig            |    9 +
 drivers/spi/Makefile           |    1 +
 drivers/spi/cvi_spif.c         |  455 +++++
 drivers/spi/cvi_spif.h         |  165 ++
 drivers/spi/spi-mem.c          |   25 +-
 drivers/spi/spi-uclass.c       |    4 +-
 drivers/usb/gadget/config.c    |    2 +-
 drivers/video/cvitek/Kconfig   |   69 +
 drivers/video/cvitek/Makefile  |   11 +
 .../drivers/video/cvitek/cvi_disp.c           |  132 ++
 drivers/video/cvitek/cvi_i80.c |  247 +++
 .../drivers/video/cvitek/cvi_lvds.c           |  170 ++
 .../drivers/video/cvitek/cvi_mipi.c           |  226 ++
 drivers/video/cvitek/dsi_phy.c |  244 +++
 drivers/video/cvitek/dsi_phy.h |   33 +
 drivers/video/cvitek/reg.c     |   14 +
 drivers/video/cvitek/reg.h     |   11 +
 .../drivers/video/cvitek/reg_vip_sys.h        |  397 ++++
 drivers/video/cvitek/scaler.c  | 1425 +++++++++++++
 drivers/video/cvitek/scaler.h  |  488 +++++
 .../drivers/video/cvitek/scaler_reg.h         |  146 ++
 .../drivers/video/cvitek/vip_common.h         |  150 ++
 drivers/video/cvitek/vip_sys.c |  180 ++
 .../drivers/watchdog/designware_wdt.c         |    5 +
 dts/Makefile                   |    3 +-
 env/Kconfig                    |   13 +-
 fs/fat/fat.c                   |    2 +-
 fs/fs.c                        |    2 +-
 include/configs/cv180x-asic.h  |  322 +++
 include/configs/cv180x-fpga.h  |  328 +++
 .../include/configs/cv180x-palladium.h        |  328 +++
 include/configs/cv181x-asic.h  |  324 +++
 include/configs/cv181x-fpga.h  |  334 +++
 .../include/configs/cv181x-palladium.h        |  325 +++
 include/configs/cv1822-asic.h  |  320 +++
 include/configs/cv1822-fpga.h  |  224 ++
 .../include/configs/cv1822-palladium.h        |  168 ++
 include/configs/cv1835-asic.h  |  313 +++
 include/configs/cv1835-fpga.h  |  222 ++
 .../include/configs/cv1835-palladium.h        |  159 ++
 include/crc.h                  |   43 +
 include/cvi_efuse.h            |   58 +
 include/cvi_update.h           |   15 +
 include/cvitek/cv183x_reg.h    |  116 ++
 include/cvitek/cvi_disp.h      |   28 +
 include/cvitek/cvi_efuse.h     |   58 +
 include/cvitek/cvi_i80.h       |   93 +
 include/cvitek/cvi_mipi.h      |  121 ++
 .../cvitek/cvi_panels/cvi_panel_diffs.h       |   24 +
 .../include/cvitek/cvi_panels/cvi_panels.h    |  132 ++
 .../cvitek/cvi_panels/dsi_3aml069lp01g.h      |  202 ++
 .../cvitek/cvi_panels/dsi_hx8394_evb.h        |  141 ++
 .../include/cvitek/cvi_panels/dsi_icn9707.h   |  143 ++
 .../include/cvitek/cvi_panels/dsi_ili9881c.h  |  428 ++++
 .../include/cvitek/cvi_panels/dsi_ili9881d.h  |  419 ++++
 .../include/cvitek/cvi_panels/dsi_jd9366ab.h  |  393 ++++
 .../include/cvitek/cvi_panels/dsi_nt35521.h   |  206 ++
 .../include/cvitek/cvi_panels/dsi_ota7290b.h  |  547 +++++
 .../cvitek/cvi_panels/dsi_ota7290b_1920.h     |  553 +++++
 .../include/cvitek/cvi_panels/dsi_st7701.h    |  170 ++
 .../include/cvitek/cvi_panels/i80_st7789v.h   |  101 +
 include/cvitek/cvi_reboot.h    |    7 +
 include/cvitek/cvi_utask.h     |    4 +
 include/cvitek/mmio.h          |   67 +
 include/cvsnfc.h               |  765 +++++++
 include/cvsnfc_common.h        |  166 ++
 include/cvsnfc_spi_ids.h       |  167 ++
 include/display_options.h      |    2 +-
 .../include/dt-bindings/clock/cv180x-clock.h  |  171 ++
 .../include/dt-bindings/clock/cv181x-clock.h  |  171 ++
 .../include/dt-bindings/dma/cv180x-dmamap.h   |   48 +
 .../include/dt-bindings/dma/cv181x-dmamap.h   |   48 +
 .../include/dt-bindings/reset/cv180x-resets.h |  172 ++
 .../include/dt-bindings/reset/cv181x-resets.h |  172 ++
 include/env_default.h          |    9 +
 include/linux/mtd/cfi.h        |   42 +-
 include/linux/mtd/rawnand.h    |    9 +-
 include/linux/mtd/spi-nor.h    |   14 +-
 include/lmb.h                  |    1 +
 include/mmc.h                  |   27 +-
 include/nand.h                 |    4 +
 include/phy.h                  |    1 +
 include/sdhci.h                |   27 +-
 include/spi.h                  |    4 +
 include/spi_flash.h            |    8 +
 lib/display_options.c          |    4 +-
 lib/lmb.c                      |   34 +
 scripts/Makefile.lib           |    3 +-
 scripts/check-config.sh        |    8 +-
 scripts/config_whitelist.txt   |   31 +
 tools/Makefile                 |    1 -
 tools/env/fw_env.c             |    1 +
 243 files changed, 41234 insertions(+), 1257 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-armv8/boot0.h
 create mode 100644 arch/riscv/cpu/generic/cache.c
 create mode 100644 arch/riscv/dts/cv1800b_wdmb_0008a_spinor.dts
 create mode 100644 arch/riscv/dts/cv1800b_wevb_0008a_spinor.dts
 create mode 100644 arch/riscv/dts/cv1800c_wevb_0009a_spinor.dts
 create mode 100644 arch/riscv/dts/cv1801b_wevb_0008a_spinor.dts
 create mode 100644 arch/riscv/dts/cv1801c_wdmb_0009a_spinor.dts
 create mode 100644 arch/riscv/dts/cv1801c_wevb_0009a_spinand.dts
 create mode 100644 arch/riscv/dts/cv1801c_wevb_0009a_spinor.dts
 create mode 100644 arch/riscv/dts/cv180x_asic_bga.dtsi
 create mode 100644 arch/riscv/dts/cv180x_asic_qfn.dtsi
 create mode 100644 arch/riscv/dts/cv180x_asic_spinand.dtsi
 create mode 100644 arch/riscv/dts/cv180x_asic_spinor.dtsi
 create mode 100644 arch/riscv/dts/cv180x_base.dtsi
 create mode 100644 arch/riscv/dts/cv180x_base_riscv.dtsi
 create mode 100644 arch/riscv/dts/cv180x_default_memmap.dtsi
 create mode 100644 arch/riscv/dts/cv180x_fpga.dts
 create mode 100644 arch/riscv/dts/cv180x_palladium.dts
 create mode 100644 arch/riscv/dts/cv180zb_wdmb_0008a_spinor.dts
 create mode 100644 arch/riscv/dts/cv180zb_wevb_0008a_spinor.dts
 create mode 100644 arch/riscv/include/asm/boot0.h
 create mode 100644 board/cvitek/Kconfig
 create mode 100644 board/cvitek/cv180x/Kconfig
 create mode 100644 board/cvitek/cv180x/Makefile
 create mode 100644 board/cvitek/cv180x/board.c
 create mode 100644 board/cvitek/cv180x/cv180x_pinlist_swconfig.h
 create mode 100644 board/cvitek/cv180x/cv180x_reg.h
 create mode 100644 board/cvitek/cv180x/cv180x_reg_fmux_gpio.h
 create mode 100644 board/cvitek/cv180x/sdhci_reg.h
 create mode 100644 board/cvitek/cv181x/Kconfig
 create mode 100644 board/cvitek/cv181x/MAINTAINERS
 create mode 100644 board/cvitek/cv181x/Makefile
 create mode 100644 board/cvitek/cv181x/board.c
 create mode 100644 board/cvitek/cv181x/cv181x_pinlist_swconfig.h
 create mode 100644 board/cvitek/cv181x/cv181x_reg.h
 create mode 100644 board/cvitek/cv181x/cv181x_reg_fmux_gpio.h
 create mode 100644 board/cvitek/cv181x/sdhci_reg.h
 create mode 100644 board/cvitek/cv1822/Kconfig
 create mode 100644 board/cvitek/cv1822/MAINTAINERS
 create mode 100644 board/cvitek/cv1822/Makefile
 create mode 100644 board/cvitek/cv1822/board.c
 create mode 100644 board/cvitek/cv1822/cv1822_pinlist_swconfig.h
 create mode 100644 board/cvitek/cv1822/cv1822_reg.h
 create mode 100644 board/cvitek/cv1822/cv1822_reg_fmux_gpio.h
 create mode 100644 board/cvitek/cv1822/sdhci_reg.h
 create mode 100644 board/cvitek/cv1835/Kconfig
 create mode 100644 board/cvitek/cv1835/MAINTAINERS
 create mode 100644 board/cvitek/cv1835/Makefile
 create mode 100644 board/cvitek/cv1835/board.c
 create mode 100644 board/cvitek/cv1835/cv1835_pinlist_swconfig.h
 create mode 100644 board/cvitek/cv1835/cv1835_reg.h
 create mode 100644 board/cvitek/cv1835/cv1835_reg_fmux_gpio.h
 create mode 100644 board/cvitek/cv1835/sdhci_reg.h
 create mode 100644 cmd/cvi_sd_update.c
 create mode 100644 cmd/cvi_sd_update_spinand_v3.c
 create mode 100644 cmd/cvi_update.c
 create mode 100644 cmd/cvi_utask.c
 create mode 100644 cmd/efuse.c
 create mode 100644 cvitek.mk
 create mode 100644 drivers/adc/cvitek-adc.c
 create mode 100644 drivers/cvi_usb/Makefile
 create mode 100644 drivers/cvi_usb/utask/cv181x/cps_cvi.c
 create mode 100644 drivers/cvi_usb/utask/cv181x/cvi_udc_otg.c
 create mode 100644 drivers/cvi_usb/utask/cv181x/cvi_udc_otg_xfer_dma.c
 create mode 100644 drivers/cvi_usb/utask/cv181x/cvi_usb.c
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/big_endian.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/byteorder.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_ch9.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_drv_if.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_errno.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_private.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_stdint.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_stdio.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_stdtypes.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_string.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_udc.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_priv.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_regs.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/cvi_usb.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/debug.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/dps.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/little_endian.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/platform_def.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/swap.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/system_common.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/include/usb_tty.h
 create mode 100644 drivers/cvi_usb/utask/cv181x/usb_tty.c
 create mode 100644 drivers/cvi_usb/utask/test/README
 create mode 100755 drivers/cvi_usb/utask/test/utask_memcpy.py
 create mode 100644 drivers/mmc/cvitek/sdhci-cv180x.c
 create mode 100644 drivers/mmc/cvitek/sdhci-cv181x.c
 create mode 100644 drivers/mmc/cvitek/sdhci-cv182x.c
 create mode 100644 drivers/mmc/cvitek/sdhci-cv183x.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/Makefile
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_common.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c
 create mode 100644 drivers/net/phy/cv182xa.c
 create mode 100644 drivers/pwm/cvitek_pwm.c
 create mode 100644 drivers/spi/cvi_spif.c
 create mode 100755 drivers/spi/cvi_spif.h
 create mode 100644 drivers/video/cvitek/Kconfig
 create mode 100644 drivers/video/cvitek/Makefile
 create mode 100644 drivers/video/cvitek/cvi_disp.c
 create mode 100644 drivers/video/cvitek/cvi_i80.c
 create mode 100644 drivers/video/cvitek/cvi_lvds.c
 create mode 100644 drivers/video/cvitek/cvi_mipi.c
 create mode 100644 drivers/video/cvitek/dsi_phy.c
 create mode 100644 drivers/video/cvitek/dsi_phy.h
 create mode 100644 drivers/video/cvitek/reg.c
 create mode 100644 drivers/video/cvitek/reg.h
 create mode 100644 drivers/video/cvitek/reg_vip_sys.h
 create mode 100644 drivers/video/cvitek/scaler.c
 create mode 100644 drivers/video/cvitek/scaler.h
 create mode 100644 drivers/video/cvitek/scaler_reg.h
 create mode 100644 drivers/video/cvitek/vip_common.h
 create mode 100644 drivers/video/cvitek/vip_sys.c
 create mode 100644 include/configs/cv180x-asic.h
 create mode 100644 include/configs/cv180x-fpga.h
 create mode 100644 include/configs/cv180x-palladium.h
 create mode 100644 include/configs/cv181x-asic.h
 create mode 100644 include/configs/cv181x-fpga.h
 create mode 100644 include/configs/cv181x-palladium.h
 create mode 100644 include/configs/cv1822-asic.h
 create mode 100644 include/configs/cv1822-fpga.h
 create mode 100644 include/configs/cv1822-palladium.h
 create mode 100644 include/configs/cv1835-asic.h
 create mode 100644 include/configs/cv1835-fpga.h
 create mode 100644 include/configs/cv1835-palladium.h
 create mode 100644 include/crc.h
 create mode 100644 include/cvi_efuse.h
 create mode 100644 include/cvi_update.h
 create mode 100644 include/cvitek/cv183x_reg.h
 create mode 100644 include/cvitek/cvi_disp.h
 create mode 100644 include/cvitek/cvi_efuse.h
 create mode 100644 include/cvitek/cvi_i80.h
 create mode 100644 include/cvitek/cvi_mipi.h
 create mode 100644 include/cvitek/cvi_panels/cvi_panel_diffs.h
 create mode 100644 include/cvitek/cvi_panels/cvi_panels.h
 create mode 100644 include/cvitek/cvi_panels/dsi_3aml069lp01g.h
 create mode 100644 include/cvitek/cvi_panels/dsi_hx8394_evb.h
 create mode 100644 include/cvitek/cvi_panels/dsi_icn9707.h
 create mode 100644 include/cvitek/cvi_panels/dsi_ili9881c.h
 create mode 100644 include/cvitek/cvi_panels/dsi_ili9881d.h
 create mode 100644 include/cvitek/cvi_panels/dsi_jd9366ab.h
 create mode 100644 include/cvitek/cvi_panels/dsi_nt35521.h
 create mode 100644 include/cvitek/cvi_panels/dsi_ota7290b.h
 create mode 100644 include/cvitek/cvi_panels/dsi_ota7290b_1920.h
 create mode 100644 include/cvitek/cvi_panels/dsi_st7701.h
 create mode 100644 include/cvitek/cvi_panels/i80_st7789v.h
 create mode 100644 include/cvitek/cvi_reboot.h
 create mode 100644 include/cvitek/cvi_utask.h
 create mode 100644 include/cvitek/mmio.h
 create mode 100644 include/cvsnfc.h
 create mode 100644 include/cvsnfc_common.h
 create mode 100644 include/cvsnfc_spi_ids.h
 create mode 100644 include/dt-bindings/clock/cv180x-clock.h
 create mode 100644 include/dt-bindings/clock/cv181x-clock.h
 create mode 100644 include/dt-bindings/dma/cv180x-dmamap.h
 create mode 100644 include/dt-bindings/dma/cv181x-dmamap.h
 create mode 100644 include/dt-bindings/reset/cv180x-resets.h
 create mode 100644 include/dt-bindings/reset/cv181x-resets.h

diff --git a/Makefile b/Makefile
index 20c1aa3f5..96ce713bc 100644
--- a/Makefile
+++ b/Makefile
@@ -427,6 +427,7 @@ KBUILD_CFLAGS   := -Wall -Wstrict-prototypes \
 		   -Wno-format-security \
 		   -fno-builtin -ffreestanding $(CSTD_FLAG)
 KBUILD_CFLAGS	+= -fshort-wchar -fno-strict-aliasing
+KBUILD_CFLAGS	+= -Werror
 KBUILD_AFLAGS   := -D__ASSEMBLY__
 KBUILD_LDFLAGS  :=
 
@@ -454,6 +455,8 @@ KBUILD_AFLAGS	+= $(call cc-option,-fno-PIE)
 UBOOTRELEASE = $(shell cat include/config/uboot.release 2> /dev/null)
 UBOOTVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
 
+include cvitek.mk
+
 export VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION
 export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
 export CONFIG_SHELL HOSTCC KBUILD_HOSTCFLAGS CROSS_COMPILE AS LD CC
@@ -782,6 +785,7 @@ KBUILD_HOSTCFLAGS += $(if $(CONFIG_TOOLS_DEBUG),-g)
 UBOOTINCLUDE    := \
 	-Iinclude \
 	$(if $(KBUILD_SRC), -I$(srctree)/include) \
+	$(if $(CONFIG_TARGET_CVITEK), -I$(srctree)/include/cvitek) \
 	$(if $(CONFIG_$(SPL_)SYS_THUMB_BUILD), \
 		$(if $(CONFIG_HAS_THUMB2), \
 			$(if $(CONFIG_CPU_V7M), \
@@ -813,6 +817,7 @@ libs-y += fs/
 libs-y += net/
 libs-y += disk/
 libs-y += drivers/
+libs-y += drivers/cvi_usb/
 libs-y += drivers/dma/
 libs-y += drivers/gpio/
 libs-y += drivers/net/
diff --git a/arch/Kconfig b/arch/Kconfig
index 8f8daadcf..c366b2006 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -83,22 +83,7 @@ config RISCV
 	select SUPPORT_OF_CONTROL
 	select OF_CONTROL
 	select DM
-	imply DM_SERIAL
-	imply DM_ETH
-	imply DM_MMC
-	imply DM_SPI
-	imply DM_SPI_FLASH
-	imply BLK
-	imply CLK
-	imply MTD
 	imply TIMER
-	imply CMD_DM
-	imply SPL_DM
-	imply SPL_OF_CONTROL
-	imply SPL_LIBCOMMON_SUPPORT
-	imply SPL_LIBGENERIC_SUPPORT
-	imply SPL_SERIAL_SUPPORT
-	imply SPL_TIMER
 
 config SANDBOX
 	bool "Sandbox"
@@ -338,3 +323,6 @@ source "arch/sh/Kconfig"
 source "arch/x86/Kconfig"
 source "arch/xtensa/Kconfig"
 source "arch/riscv/Kconfig"
+
+# board/cvitek/Kconfig are shared by ARM/RISCV
+source "board/cvitek/Kconfig"
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index b5bd3284c..12470f5aa 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -517,7 +517,10 @@ config ARM64_SUPPORT_AARCH32
 
 choice
 	prompt "Target select"
-	default TARGET_HIKEY
+	default TARGET_CVITEK_ARM
+
+config TARGET_CVITEK_ARM
+	prompt "Cvitek target for ARM"
 
 config ARCH_AT91
 	bool "Atmel AT91"
@@ -2039,7 +2042,6 @@ source "arch/arm/mach-zynqmp-r5/Kconfig"
 source "arch/arm/cpu/armv7/Kconfig"
 
 source "arch/arm/cpu/armv8/Kconfig"
-
 source "arch/arm/mach-imx/Kconfig"
 
 source "arch/arm/mach-nexell/Kconfig"
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index fc16a57e6..b8ba72e5b 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0+
+dtb-$(CONFIG_TARGET_CVITEK) += $(CHIP)_$(CVIBOARD).dtb
 
 dtb-$(CONFIG_TARGET_SMARTWEB) += at91sam9260-smartweb.dtb
 dtb-$(CONFIG_TARGET_TAURUS) += at91sam9g20-taurus.dtb
@@ -497,7 +498,7 @@ dtb-$(CONFIG_MACH_SUN4I) += \
 	sun4i-a10-inet9f-rev03.dtb \
 	sun4i-a10-itead-iteaduino-plus.dtb \
 	sun4i-a10-jesurun-q5.dtb \
-	sun4i-a10-marsboard.dtb \
+	sun4i-a10-cv181xboard.dtb \
 	sun4i-a10-mini-xplus.dtb \
 	sun4i-a10-mk802.dtb \
 	sun4i-a10-mk802ii.dtb \
@@ -772,7 +773,7 @@ dtb-y += \
 	imx6q-icore-rqs.dtb \
 	imx6q-kp.dtb \
 	imx6q-logicpd.dtb \
-	imx6q-marsboard.dtb \
+	imx6q-cv181xboard.dtb \
 	imx6q-mba6a.dtb \
 	imx6q-mba6b.dtb \
 	imx6q-mccmon6.dtb\
diff --git a/arch/arm/include/asm/arch-armv8/boot0.h b/arch/arm/include/asm/arch-armv8/boot0.h
new file mode 100644
index 000000000..0c8f18a2b
--- /dev/null
+++ b/arch/arm/include/asm/arch-armv8/boot0.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CVITEK u-boot header
+ */
+
+#ifndef __BOOT0_H__
+#define __BOOT0_H__
+
+/* BOOT0 header information */
+	b boot0_time_recode
+	.word 0x33334c42  /* b'BL33' */
+	.word 0xdeadbee1  /* CKSUM */
+	.word 0xdeadbee4  /* SIZE */
+	.quad CONFIG_SYS_TEXT_BASE /* RUNADDR */
+	.word 0xdeadbee6
+	b boot0_time_recode
+/* BOOT0 header end */
+boot0_time_recode:
+	mrs x0, cntpct_el0
+	ldr x1, =BOOT0_START_TIME
+	str w0, [x1]
+	b reset
+
+	.global BOOT0_START_TIME
+BOOT0_START_TIME:
+	.word 0
+
+#endif /* __BOOT0_H__ */
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index 32532b3ca..ce85c7b5d 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -1627,7 +1627,7 @@
 #define MACH_TYPE_MX35EVB              1643
 #define MACH_TYPE_AML_M8050            1644
 #define MACH_TYPE_MX35_3DS             1645
-#define MACH_TYPE_MARS                 1646
+#define MACH_TYPE_CV181X                 1646
 #define MACH_TYPE_NEUROS_OSD2          1647
 #define MACH_TYPE_BADGER               1648
 #define MACH_TYPE_TRIZEPS4WL           1649
@@ -4840,7 +4840,7 @@
 #define MACH_TYPE_MX6S_HAWTHORNE       4901
 #define MACH_TYPE_SEAH                 4902
 #define MACH_TYPE_AM335X_EC3           4903
-#define MACH_TYPE_EMBEST_MARS          4904
+#define MACH_TYPE_EMBEST_CV181X          4904
 #define MACH_TYPE_MX6DL_VIKITOUCH      4905
 #define MACH_TYPE_IX2_NG               4906
 #define MACH_TYPE_PEKQSD               4907
diff --git a/arch/arm/include/asm/u-boot-arm.h b/arch/arm/include/asm/u-boot-arm.h
index 0b93cc48c..54be8dd1c 100644
--- a/arch/arm/include/asm/u-boot-arm.h
+++ b/arch/arm/include/asm/u-boot-arm.h
@@ -36,6 +36,7 @@ int	arch_misc_init(void);
 
 /* board/.../... */
 int	board_init(void);
+void	board_save_time_record(uintptr_t saveaddr);
 
 /* calls to c from vectors.S */
 struct pt_regs;
diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
index f60ee3a7e..9143404cd 100644
--- a/arch/arm/lib/bootm.c
+++ b/arch/arm/lib/bootm.c
@@ -125,6 +125,9 @@ static void announce_and_cleanup(int fake)
 	dm_remove_devices_flags(DM_REMOVE_ACTIVE_ALL);
 
 	cleanup_before_linux();
+
+	// Save kernel start time
+	board_save_time_record(TIME_RECORDS_FIELD_KERNEL_START);
 }
 
 static void setup_start_tag (struct bd_info *bd)
diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index ec651fe0a..57135cd45 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -6,7 +6,10 @@ config SYS_ARCH
 
 choice
 	prompt "Target select"
-	optional
+	default TARGET_CVITEK_RISCV
+
+config TARGET_CVITEK_RISCV
+	prompt "Cvitek target for RISCV"
 
 config TARGET_AX25_AE350
 	bool "Support ax25-ae350"
diff --git a/arch/riscv/config.mk b/arch/riscv/config.mk
index 1ebce5bd6..5c36c2e90 100644
--- a/arch/riscv/config.mk
+++ b/arch/riscv/config.mk
@@ -21,10 +21,12 @@ endif
 ifdef CONFIG_64BIT
 KBUILD_LDFLAGS		+= -m $(64bit-emul)
 EFI_LDS			:= elf_riscv64_efi.lds
+PLATFORM_ELFFLAGS	+= -B riscv:rv64 -O elf64-littleriscv
 endif
 
 CONFIG_STANDALONE_LOAD_ADDR ?= 0x00000000
 
+
 PLATFORM_CPPFLAGS	+= -ffixed-gp -fpic
 PLATFORM_RELFLAGS	+= -fno-common -gdwarf-2 -ffunction-sections \
 			   -fdata-sections
diff --git a/arch/riscv/cpu/generic/Makefile b/arch/riscv/cpu/generic/Makefile
index 258e4620d..3fa6a7a67 100644
--- a/arch/riscv/cpu/generic/Makefile
+++ b/arch/riscv/cpu/generic/Makefile
@@ -4,3 +4,4 @@
 
 obj-y += dram.o
 obj-y += cpu.o
+obj-y += cache.o
diff --git a/arch/riscv/cpu/generic/cache.c b/arch/riscv/cpu/generic/cache.c
new file mode 100644
index 000000000..8ebe8e2c2
--- /dev/null
+++ b/arch/riscv/cpu/generic/cache.c
@@ -0,0 +1,66 @@
+#include <linux/types.h>
+#include <cpu_func.h>
+
+#define L1_CACHE_BYTES     64
+#define ALIGN(x, a)              (((x) + (a) - 1) & ~((a) - 1))
+
+/*
+ * dcache.ipa rs1 (invalidate)
+ * | 31 - 25 | 24 - 20 | 19 - 15 | 14 - 12 | 11 - 7 | 6 - 0 |
+ *   0000001    01010      rs1       000      00000  0001011
+ *
+ * dcache.cpa rs1 (clean)
+ * | 31 - 25 | 24 - 20 | 19 - 15 | 14 - 12 | 11 - 7 | 6 - 0 |
+ *   0000001    01001      rs1       000      00000  0001011
+ *
+ * dcache.cipa rs1 (clean then invalidate)
+ * | 31 - 25 | 24 - 20 | 19 - 15 | 14 - 12 | 11 - 7 | 6 - 0 |
+ *   0000001    01011      rs1       000      00000  0001011
+ *
+ * sync.s
+ * | 31 - 25 | 24 - 20 | 19 - 15 | 14 - 12 | 11 - 7 | 6 - 0 |
+ *   0000000    11001     00000      000      00000  0001011
+ */
+#define DCACHE_IPA_A0	".long 0x02a5000b"
+#define DCACHE_CPA_A0	".long 0x0295000b"
+#define DCACHE_CIPA_A0	".long 0x02b5000b"
+
+#define SYNC_S		".long 0x0190000b"
+
+#define CACHE_OP_RANGE(OP, start, size) \
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1); \
+	for (; i < ALIGN(start + size, L1_CACHE_BYTES); i += L1_CACHE_BYTES) \
+		__asm__ __volatile__(OP); \
+	 __asm__ __volatile__(SYNC_S)
+
+void invalidate_dcache_range(unsigned long start, unsigned long end)
+{
+	CACHE_OP_RANGE(DCACHE_IPA_A0, start, end - start);
+}
+
+void flush_dcache_range(unsigned long start, unsigned long end)
+{
+	CACHE_OP_RANGE(DCACHE_CIPA_A0, start, end - start);
+}
+
+/*
+ * Once uboot execute csrsi mhcr 0x2.
+ * Will enter trap mode.
+ * Comment the implement to avoid problem first
+ */
+#if CV181X_UBOOT_USE_DCACHE_API
+void dcache_enable(void)
+{
+	asm volatile(
+		"csrs mhcr, %0;" ::"rI"(0x2)
+	);
+}
+
+void dcache_disable(void)
+{
+	flush_dcache_range(0x80000000, 0x80000000 + CONFIG_SYS_BOOTMAPSZ);
+	asm volatile(
+		"csrc mhcr, %0;" ::"rI"(0x2)
+	);
+}
+#endif
\ No newline at end of file
diff --git a/arch/riscv/cpu/start.S b/arch/riscv/cpu/start.S
index 308b0a97a..39e49aa20 100644
--- a/arch/riscv/cpu/start.S
+++ b/arch/riscv/cpu/start.S
@@ -39,6 +39,8 @@ secondary_harts_relocation_error:
 .section .text
 .globl _start
 _start:
+#include <asm/boot0.h>
+_start_real:
 #if CONFIG_IS_ENABLED(RISCV_MMODE)
 	csrr	a0, CSR_MHARTID
 #endif
diff --git a/arch/riscv/dts/Makefile b/arch/riscv/dts/Makefile
index b6e916676..9d02c4f05 100644
--- a/arch/riscv/dts/Makefile
+++ b/arch/riscv/dts/Makefile
@@ -8,6 +8,8 @@ dtb-$(CONFIG_TARGET_SIFIVE_UNLEASHED) += hifive-unleashed-a00.dtb
 dtb-$(CONFIG_TARGET_SIFIVE_UNMATCHED) += hifive-unmatched-a00.dtb
 dtb-$(CONFIG_TARGET_SIPEED_MAIX) += k210-maix-bit.dtb
 
+dtb-$(CONFIG_TARGET_CVITEK) += $(CHIP)_$(CVIBOARD).dtb
+
 targets += $(dtb-y)
 
 DTC_FLAGS += -R 4 -p 0x1000
diff --git a/arch/riscv/dts/cv1800b_wdmb_0008a_spinor.dts b/arch/riscv/dts/cv1800b_wdmb_0008a_spinor.dts
new file mode 100644
index 000000000..5314a49d9
--- /dev/null
+++ b/arch/riscv/dts/cv1800b_wdmb_0008a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&mipi_rx{
+	snsr-reset = <&portc 8 GPIO_ACTIVE_LOW>, <&portc 8 GPIO_ACTIVE_LOW>, <&portc 8 GPIO_ACTIVE_LOW>;
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv1800b_wevb_0008a_spinor.dts b/arch/riscv/dts/cv1800b_wevb_0008a_spinor.dts
new file mode 100644
index 000000000..a11b17e07
--- /dev/null
+++ b/arch/riscv/dts/cv1800b_wevb_0008a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&i2c2 {
+	status = "disabled";
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv1800c_wevb_0009a_spinor.dts b/arch/riscv/dts/cv1800c_wevb_0009a_spinor.dts
new file mode 100644
index 000000000..7f59a23a9
--- /dev/null
+++ b/arch/riscv/dts/cv1800c_wevb_0009a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&i2c1 {
+	status = "disabled";
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv1801b_wevb_0008a_spinor.dts b/arch/riscv/dts/cv1801b_wevb_0008a_spinor.dts
new file mode 100644
index 000000000..a11b17e07
--- /dev/null
+++ b/arch/riscv/dts/cv1801b_wevb_0008a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&i2c2 {
+	status = "disabled";
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv1801c_wdmb_0009a_spinor.dts b/arch/riscv/dts/cv1801c_wdmb_0009a_spinor.dts
new file mode 100644
index 000000000..489ecc71d
--- /dev/null
+++ b/arch/riscv/dts/cv1801c_wdmb_0009a_spinor.dts
@@ -0,0 +1,17 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&i2c1 {
+	status = "disabled";
+};
+&mipi_rx{
+	snsr-reset = <&portc 17 GPIO_ACTIVE_LOW>, <&portc 17 GPIO_ACTIVE_LOW>, <&portc 17 GPIO_ACTIVE_LOW>;
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv1801c_wevb_0009a_spinand.dts b/arch/riscv/dts/cv1801c_wevb_0009a_spinand.dts
new file mode 100644
index 000000000..f9ec58135
--- /dev/null
+++ b/arch/riscv/dts/cv1801c_wevb_0009a_spinand.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinand.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&i2c1 {
+	status = "disabled";
+};
+
+/ {
+
+};
diff --git a/arch/riscv/dts/cv1801c_wevb_0009a_spinor.dts b/arch/riscv/dts/cv1801c_wevb_0009a_spinor.dts
new file mode 100644
index 000000000..7f59a23a9
--- /dev/null
+++ b/arch/riscv/dts/cv1801c_wevb_0009a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&i2c1 {
+	status = "disabled";
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv180x_asic_bga.dtsi b/arch/riscv/dts/cv180x_asic_bga.dtsi
new file mode 100644
index 000000000..2bcacfb3a
--- /dev/null
+++ b/arch/riscv/dts/cv180x_asic_bga.dtsi
@@ -0,0 +1,12 @@
+&dac{
+	mute-gpio-l = <&porta 15 GPIO_ACTIVE_LOW>;
+	mute-gpio-r = <&porta 30 GPIO_ACTIVE_LOW>;
+};
+
+/ {
+	/delete-node/ i2s@04110000;
+	/delete-node/ i2s@04120000;
+	/delete-node/ sound_ext1;
+	/delete-node/ sound_ext2;
+	/delete-node/ sound_PDM;
+};
diff --git a/arch/riscv/dts/cv180x_asic_qfn.dtsi b/arch/riscv/dts/cv180x_asic_qfn.dtsi
new file mode 100644
index 000000000..46a54b3ec
--- /dev/null
+++ b/arch/riscv/dts/cv180x_asic_qfn.dtsi
@@ -0,0 +1,114 @@
+&sd {
+	no-1-8-v;
+};
+
+&mipi_rx{
+	snsr-reset = <&portc 13 GPIO_ACTIVE_LOW>, <&portc 13 GPIO_ACTIVE_LOW>, <&portc 13 GPIO_ACTIVE_LOW>;
+};
+
+&dac{
+	mute-gpio-r = <&porte 2 GPIO_ACTIVE_LOW>;
+};
+
+&spi0 {
+	status = "disabled";
+	num-cs = <1>;
+	spidev@0 {
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <1000000>;
+		reg = <0>;
+	};
+};
+
+&spi1 {
+	status = "disabled";
+	num-cs = <1>;
+	spidev@0 {
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <1000000>;
+		reg = <0>;
+	};
+};
+
+&spi2 {
+	status = "disabled";
+	num-cs = <1>;
+	spidev@0 {
+	compatible = "rohm,dh2228fv";
+		spi-max-frequency = <1000000>;
+		reg = <0>;
+	};
+};
+
+&spi3 {
+	status = "okay";
+	num-cs = <1>;
+	spidev@0 {
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <1000000>;
+		reg = <0>;
+	};
+};
+
+&i2c0 {
+	/* FMUX_GPIO_REG iic_func_sel gpio_func_sel */
+	scl-pinmux = <0x0300104c 0x4 0x3>;	// IIC0_SCL/IIC0_SCL/XGPIOA[28]
+	sda-pinmux = <0x03001050 0x4 0x3>;	// IIC0_SDA/IIC0_SDA/XGPIOA[29]
+	/* gpio port */
+	scl-gpios = <&porta 28 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&porta 29 GPIO_ACTIVE_HIGH>;
+};
+
+&i2c1 {
+	/* FMUX_GPIO_REG iic_func_sel gpio_func_sel */
+	scl-pinmux = <0x030010f4 0x4 0x3>;	// PAD_MIPIRX0N/IIC1_SCL/XGPIOC[10]
+	sda-pinmux = <0x030010f0 0x4 0x3>;	// PAD_MIPIRX1P/IIC1_SDA/XGPIOC[9]
+	/* gpio port */
+	scl-gpios = <&portc 10 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&portc 9 GPIO_ACTIVE_HIGH>;
+};
+
+&i2c2 {
+	/* FMUX_GPIO_REG iic_func_sel gpio_func_sel */
+	scl-pinmux = <0x03001108 0x4 0x3>;	// PAD_MIPI_TXP1/IIC2_SCL/XGPIOC[15]
+	sda-pinmux = <0x03001104 0x4 0x3>;	// PAD_MIPI_TXM1/IIC2_SDA/XGPIOC[14]
+	/* gpio port */
+	scl-gpios = <&portc 15 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&portc 14 GPIO_ACTIVE_HIGH>;
+};
+
+&i2c3 {
+	/* FMUX_GPIO_REG iic_func_sel gpio_func_sel */
+	scl-pinmux = <0x0300109c 0x2 0x3>;	// SD1_CMD/IIC3_SCL/PWR_GPIO[22]
+	sda-pinmux = <0x030010a0 0x2 0x3>;	// SD1_CLK/IIC3_SDA/PWR_GPIO[23]
+	/* gpio port */
+	scl-gpios = <&porte 22 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&porte 23 GPIO_ACTIVE_HIGH>;
+	status = "disabled";
+};
+
+&i2c4 {
+	/* FMUX_GPIO_REG iic_func_sel gpio_func_sel */
+	scl-pinmux = <0x030010e4 0x5 0x3>;	// PAD_MIPIRX2N/IIC4_SCL/XGPIOC[6]
+	sda-pinmux = <0x030010e8 0x5 0x3>;	// PAD_MIPIRX2P/IIC4_SDA/XGPIOC[7]
+	/* gpio port */
+	scl-gpios = <&portc 6 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&portc 7 GPIO_ACTIVE_HIGH>;
+	status = "disabled";
+};
+
+/ {
+	/delete-node/ wifi-sd@4320000;
+	/delete-node/ i2s@04110000;
+	/delete-node/ i2s@04120000;
+	/delete-node/ sound_ext1;
+	/delete-node/ sound_ext2;
+	/delete-node/ sound_PDM;
+
+	wifi_pin {
+		compatible = "cvitek,wifi-pin";
+		poweron-gpio = <&porte 2 GPIO_ACTIVE_HIGH>;
+		wakeup-gpio = <&porte 6 GPIO_ACTIVE_HIGH>;
+	};
+
+};
diff --git a/arch/riscv/dts/cv180x_asic_spinand.dtsi b/arch/riscv/dts/cv180x_asic_spinand.dtsi
new file mode 100644
index 000000000..2c3c6065c
--- /dev/null
+++ b/arch/riscv/dts/cv180x_asic_spinand.dtsi
@@ -0,0 +1,5 @@
+/ {
+	/delete-node/ cvi-spif@10000000;
+	/delete-node/ cv-emmc@4300000;
+};
+
diff --git a/arch/riscv/dts/cv180x_asic_spinor.dtsi b/arch/riscv/dts/cv180x_asic_spinor.dtsi
new file mode 100644
index 000000000..cd1254082
--- /dev/null
+++ b/arch/riscv/dts/cv180x_asic_spinor.dtsi
@@ -0,0 +1,5 @@
+/ {
+	/delete-node/ cv-emmc@4300000;
+	/delete-node/ cv-spinf@4060000;
+};
+
diff --git a/arch/riscv/dts/cv180x_base.dtsi b/arch/riscv/dts/cv180x_base.dtsi
new file mode 100644
index 000000000..923618bc3
--- /dev/null
+++ b/arch/riscv/dts/cv180x_base.dtsi
@@ -0,0 +1,881 @@
+
+/ {
+	compatible = "cvitek,cv180x";
+
+	#size-cells = <0x2>;
+	#address-cells = <0x2>;
+
+	top_misc:top_misc_ctrl@3000000 {
+		compatible = "syscon";
+		reg = <0x0 0x03000000 0x0 0x8000>;
+	};
+
+	clk_rst: clk-reset-controller {
+		#reset-cells = <1>;
+		compatible = "cvitek,clk-reset";
+		reg = <0x0 0x03002000 0x0 0x8>;
+	};
+
+	osc: oscillator {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+		clock-output-names = "osc";
+	};
+
+	clk: clock-controller {
+		compatible = "cvitek,cv180x-clk";
+		reg = <0x0 0x03002000 0x0 0x1000>;
+		clocks = <&osc>;
+		#clock-cells = <1>;
+	};
+
+	rst: reset-controller {
+		#reset-cells = <1>;
+		compatible = "cvitek,reset";
+		reg = <0x0 0x03003000 0x0 0x10>;
+	};
+
+	restart: restart-controller {
+		compatible = "cvitek,restart";
+		reg = <0x0 0x05025000 0x0 0x2000>;
+	};
+
+	tpu {
+		compatible = "cvitek,tpu";
+		reg-names = "tdma", "tiu";
+		reg = <0x0 0x0C100000 0x0 0x1000>,
+			  <0x0 0x0C101000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_TPU>, <&clk CV180X_CLK_TPU_FAB>;
+		clock-names = "clk_tpu_axi", "clk_tpu_fab";
+		resets = <&rst RST_TDMA>, <&rst RST_TPU>, <&rst RST_TPUSYS>;
+		reset-names = "res_tdma", "res_tpu", "res_tpusys";
+	};
+
+	mon {
+		compatible = "cvitek,mon";
+		reg-names = "pcmon", "ddr_ctrl", "ddr_phyd", "ddr_aximon", "ddr_top";
+		reg = <0x0 0x01040000 0x0 0x1000>,
+					<0x0 0x08004000 0x0 0x1000>,
+					<0x0 0x08006000 0x0 0x1000>,
+					<0x0 0x08008000 0x0 0x1000>,
+					<0x0 0x0800A000 0x0 0x1000>;
+	};
+
+	wiegand0 {
+		compatible = "cvitek,wiegand";
+		reg-names = "wiegand";
+		reg = <0x0 0x03030000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_WGN>, <&clk CV180X_CLK_WGN0>;
+		clock-names = "clk_wgn", "clk_wgn1";
+		resets = <&rst RST_WGN0>;
+		reset-names = "res_wgn";
+	};
+
+	wiegand1 {
+		compatible = "cvitek,wiegand";
+		reg-names = "wiegand";
+		reg = <0x0 0x03031000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_WGN>, <&clk CV180X_CLK_WGN1>;
+		clock-names = "clk_wgn", "clk_wgn1";
+		resets = <&rst RST_WGN1>;
+		reset-names = "res_wgn";
+	};
+
+	wiegand2 {
+		compatible = "cvitek,wiegand";
+		reg-names = "wiegand";
+		reg = <0x0 0x03032000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_WGN>, <&clk CV180X_CLK_WGN2>;
+		clock-names = "clk_wgn", "clk_wgn1";
+		resets = <&rst RST_WGN2>;
+		reset-names = "res_wgn";
+	};
+
+	saradc {
+		compatible = "cvitek,saradc";
+		reg-names = "top_domain_saradc", "rtc_domain_saradc";
+		reg = <0x0 0x030F0000 0x0 0x1000>, <0x0 0x0502c000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_SARADC>;
+		clock-names = "clk_saradc";
+		resets = <&rst RST_SARADC>;
+		reset-names = "res_saradc";
+	};
+
+	rtc {
+		compatible = "cvitek,rtc";
+		reg = <0x0 0x05026000 0x0 0x1000>,<0x0 0x05025000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_RTC_25M>;
+		clock-names = "clk_rtc";
+	};
+
+	cvitek-ion {
+		compatible = "cvitek,cvitek-ion";
+
+		heap_carveout@0 {
+			compatible = "cvitek,carveout";
+			memory-region = <&ion_reserved>;
+		};
+	};
+
+	sysdma_remap {
+		compatible = "cvitek,sysdma_remap";
+		reg = <0x0 0x03000154 0x0 0x10>;
+		ch-remap = <CVI_I2S0_RX CVI_I2S2_TX CVI_I2S1_RX CVI_I2S1_TX
+					CVI_SPI_NAND CVI_SPI_NAND CVI_I2S2_RX CVI_I2S3_TX>;
+		int_mux_base = <0x03000298>;
+	};
+
+	dmac: dma@0x4330000 {
+		compatible = "snps,dmac-bm";
+		reg = <0x0 0x04330000 0x0 0x1000>;
+		clock-names = "clk_sdma_axi";
+		clocks = <&clk CV180X_CLK_SDMA_AXI>;
+
+		dma-channels = /bits/ 8 <8>;
+		#dma-cells = <3>;
+		dma-requests = /bits/ 8 <16>;
+		chan_allocation_order = /bits/ 8 <0>;
+		chan_priority = /bits/ 8 <1>;
+		block_size = <1024>;
+		dma-masters = /bits/ 8 <2>;
+		data-width = <4 4>; /* bytes */
+		axi_tr_width = <4>; /* bytes */
+		block-ts = <15>;
+	};
+
+	watchdog0: cv-wd@0x3010000 {
+		compatible = "snps,dw-wdt";
+		reg = <0x0 0x03010000 0x0 0x1000>;
+		resets = <&rst RST_WDT>;
+		clocks = <&pclk>;
+	};
+
+	pwm0: pwm@3060000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3060000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_PWM>;
+		#pwm-cells = <1>;
+	};
+
+	pwm1: pwm@3061000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3061000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_PWM>;
+		#pwm-cells = <2>;
+	};
+
+	pwm2: pwm@3062000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3062000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_PWM>;
+		#pwm-cells = <3>;
+	};
+
+	pwm3: pwm@3063000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3063000 0x0 0x1000>;
+		clocks = <&clk CV180X_CLK_PWM>;
+		#pwm-cells = <4>;
+	};
+
+	pclk: pclk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+
+	spinand:cv-spinf@4060000 {
+		compatible = "cvitek,cv1835-spinf";
+		reg = <0x0 0x4060000 0x0 0x1000>;
+		reg-names = "core_mem";
+		bus-width = <4>;
+		dmas = <&dmac 4 1 1
+			&dmac 5 1 1>;
+		dma-names = "rx","tx";
+	};
+
+	spif:cvi-spif@10000000 {
+		compatible = "cvitek,cvi-spif";
+		bus-num = <0>;
+		reg = <0x0 0x10000000 0x0 0x10000000>;
+		reg-names = "spif";
+		sck-div = <3>;
+		sck_mhz = <300>;
+		spi-max-frequency = <75000000>;
+		spiflash {
+			compatible = "jedec,spi-nor";
+			spi-rx-bus-width = <4>;
+			spi-tx-bus-width = <4>;
+		};
+	};
+
+	spi0:spi0@04180000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x04180000 0x0 0x10000>;
+		clocks = <&clk CV180X_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	spi1:spi1@04190000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x04190000 0x0 0x10000>;
+		clocks = <&clk CV180X_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	spi2:spi2@041A0000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x041A0000 0x0 0x10000>;
+		clocks = <&clk CV180X_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	spi3:spi3@041B0000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x041B0000 0x0 0x10000>;
+		clocks = <&clk CV180X_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+#if 0
+		dmas = <&dmac 2 1 1
+			&dmac 3 1 1>;
+		dma-names = "rx", "tx";
+		capability = "txrx";
+#endif
+	};
+
+	uart0: serial@04140000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04140000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "okay";
+	};
+
+	uart1: serial@04150000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04150000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	uart2: serial@04160000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04160000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	uart3: serial@04170000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04170000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	uart4: serial@041C0000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x041C0000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	gpio0: gpio@03020000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03020000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		porta: gpio-controller@0 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "porta";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <32>;
+			reg = <0>;
+		};
+	};
+
+	gpio1: gpio@03021000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03021000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		portb: gpio-controller@1 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "portb";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <32>;
+			reg = <0>;
+		};
+	};
+
+	gpio2: gpio@03022000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03022000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		portc: gpio-controller@2 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "portc";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <32>;
+			reg = <0>;
+		};
+	};
+
+	gpio3: gpio@03023000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03023000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		portd: gpio-controller@3 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "portd";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <12>;
+			reg = <0>;
+		};
+	};
+
+	gpio4: gpio@05021000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x05021000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		porte: gpio-controller@4 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "porte";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <24>;
+			reg = <0>;
+		};
+	};
+
+	i2c0: i2c@04000000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV180X_CLK_I2C>;
+		reg = <0x0 0x04000000 0x0 0x1000>;
+		clock-frequency = <400000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C0>;
+		reset-names = "i2c0";
+	};
+
+	i2c1: i2c@04010000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV180X_CLK_I2C>;
+		reg = <0x0 0x04010000 0x0 0x1000>;
+		clock-frequency = <400000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C1>;
+		reset-names = "i2c1";
+	};
+
+	i2c2: i2c@04020000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV180X_CLK_I2C>;
+		reg = <0x0 0x04020000 0x0 0x1000>;
+		clock-frequency = <100000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C2>;
+		reset-names = "i2c2";
+	};
+
+	i2c3: i2c@04030000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV180X_CLK_I2C>;
+		reg = <0x0 0x04030000 0x0 0x1000>;
+		clock-frequency = <400000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C3>;
+		reset-names = "i2c3";
+	};
+
+	i2c4: i2c@04040000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV180X_CLK_I2C>;
+		reg = <0x0 0x04040000 0x0 0x1000>;
+		clock-frequency = <400000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C4>;
+		reset-names = "i2c4";
+	};
+
+	eth_csrclk: eth_csrclk {
+		clock-output-names = "eth_csrclk";
+		clock-frequency = <250000000>;
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+	};
+
+	eth_ptpclk: eth_ptpclk {
+		clock-output-names = "eth_ptpclk";
+		clock-frequency = <50000000>;
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+	};
+
+	stmmac_axi_setup: stmmac-axi-config {
+		snps,wr_osr_lmt = <1>;
+		snps,rd_osr_lmt = <2>;
+		snps,blen = <4 8 16 0 0 0 0>;
+	};
+
+	mtl_rx_setup: rx-queues-config {
+		snps,rx-queues-to-use = <1>;
+		queue0 {};
+	};
+
+	mtl_tx_setup: tx-queues-config {
+		snps,tx-queues-to-use = <1>;
+		queue0 {};
+	};
+
+	ethernet0: ethernet@4070000 {
+		compatible = "cvitek,ethernet";
+		reg = <0x0 0x04070000 0x0 0x10000>;
+		clock-names = "stmmaceth", "ptp_ref";
+		clocks = <&eth_csrclk>, <&eth_ptpclk>;
+		//phy-reset-gpios = <&porta 26 0>;
+
+		tx-fifo-depth = <8192>;
+		rx-fifo-depth = <8192>;
+		/* no hash filter and perfect filter support */
+		snps,multicast-filter-bins = <0>;
+		snps,perfect-filter-entries = <1>;
+
+		snps,txpbl = <8>;
+		snps,rxpbl = <8>;
+		snps,aal;
+
+		snps,axi-config = <&stmmac_axi_setup>;
+		snps,mtl-rx-config = <&mtl_rx_setup>;
+		snps,mtl-tx-config = <&mtl_tx_setup>;
+
+		phy-mode = "rmii";
+	};
+
+	sd:cv-sd@4310000 {
+		compatible = "cvitek,cv180x-sd";
+		reg = <0x0 0x4310000 0x0 0x1000>;
+		reg-names = "core_mem";
+		bus-width = <4>;
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		sd-uhs-sdr12;
+		sd-uhs-sdr25;
+		sd-uhs-sdr50;
+		sd-uhs-sdr104;
+		no-sdio;
+		no-mmc;
+		/*no-1-8-v;*/
+		src-frequency = <375000000>;
+		min-frequency = <400000>;
+		max-frequency = <200000000>;
+		64_addressing;
+		reset_tx_rx_phy;
+		reset-names = "sdhci";
+		pll_index = <0x6>;
+		pll_reg = <0x3002070>;
+		cvi-cd-gpios = <&porta 13 GPIO_ACTIVE_LOW>;
+	};
+
+	wifisd:wifi-sd@4320000 {
+		compatible = "cvitek,cv180x-sdio";
+		bus-width = <4>;
+		reg = <0x0 0x4320000 0x0 0x1000>;
+		reg_names = "core_mem";
+		src-frequency = <375000000>;
+		min-frequency = <400000>;
+		max-frequency = <50000000>;
+		64_addressing;
+		reset_tx_rx_phy;
+		non-removable;
+		pll_index = <0x7>;
+		pll_reg = <0x300207C>;
+		no-mmc;
+		no-sd;
+		status = "disabled";
+	};
+
+	i2s_mclk: i2s_mclk {
+		clock-output-names = "i2s_mclk";
+		clock-frequency = <24576000>;
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+	};
+
+	i2s_subsys {
+		compatible = "cvitek,i2s_tdm_subsys";
+		reg = <0x0 0x04108000 0x0 0x100>;
+		clocks = <&i2s_mclk>, <&clk CV180X_CLK_A0PLL>,
+			<&clk CV180X_CLK_SDMA_AUD0>, <&clk CV180X_CLK_SDMA_AUD1>,
+			<&clk CV180X_CLK_SDMA_AUD2>, <&clk CV180X_CLK_SDMA_AUD3>;
+		clock-names = "i2sclk", "clk_a0pll",
+			"clk_sdma_aud0", "clk_sdma_aud1",
+			"clk_sdma_aud2", "clk_sdma_aud3";
+		master_base = <0x04110000>; /* I2S1 is master, only useful while using multi I2S IPs work on same IO */
+	};
+
+	i2s0: i2s@04100000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04100000 0x0 0x2000>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <0>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 0 1 1>; /* read channel */
+		dma-names = "rx";
+		capability = "rx"; /* I2S0 connect to internal ADC as RX */
+		mclk_out = "false";
+	};
+
+	i2s1: i2s@04110000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04110000 0x0 0x2000>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <1>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 2 1 1 /* read channel */
+			&dmac 3 1 1>; /* write channel */
+		dma-names = "rx", "tx";
+		capability = "txrx";
+		mclk_out = "false";
+	};
+
+	i2s2: i2s@04120000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04120000 0x0 0x2000>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <2>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 6 1 1 /* read channel */
+			&dmac 1 1 1>; /* write channel */
+		dma-names = "rx", "tx";
+		capability = "txrx";
+		mclk_out = "false";
+
+	};
+
+	i2s3: i2s@04130000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04130000 0x0 0x2000>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <3>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 7 1 1>; /* write channel */
+		dma-names = "tx";
+		capability = "tx"; /* I2S3 connect to internal DAC as TX */
+		mclk_out = "true";
+	};
+
+	adc: adc@0300A100 {
+		compatible = "cvitek,cv182xaadc";
+		reg = <0x0 0x0300A100 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		clk_source = <0x04130000>; /* MCLK source is I2S3 */
+	};
+
+	dac: dac@0300A000 {
+		compatible = "cvitek,cv182xadac";
+		reg = <0x0 0x0300A000 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+	};
+
+	pdm: pdm@0x041D0C00 {
+		compatible = "cvitek,cv1835pdm";
+		reg = <0x0 0x041D0C00 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+	};
+
+	sound_adc {
+		compatible = "cvitek,cv182xa-adc";
+		cvi,model = "CV182XA";
+		cvi,card_name = "cv182xa_adc";
+	};
+
+	sound_dac {
+		compatible = "cvitek,cv182xa-dac";
+		cvi,model = "CV182XA";
+		cvi,card_name = "cv182xa_dac";
+	};
+
+	sound_PDM {
+		compatible = "cvitek,cv182x-pdm";
+		cvi,model = "CV182X";
+		cvi,card_name = "cv182x_internal_PDM";
+	};
+
+	wifi_pin {
+		compatible = "cvitek,wifi-pin";
+		poweron-gpio = <&porta 18 GPIO_ACTIVE_HIGH>;
+		wakeup-gpio = <&porte 7 GPIO_ACTIVE_HIGH>;
+	};
+
+	bt_pin {
+		compatible = "cvitek,bt-pin";
+		poweron-gpio = <&porte 9 GPIO_ACTIVE_HIGH>;
+	};
+
+	mipi_rx: cif {
+		compatible = "cvitek,cif";
+		reg = <0x0 0x0a0c2000 0x0 0x2000>, <0x0 0x0a0d0000 0x0 0x1000>,
+		      <0x0 0x0a0c4000 0x0 0x2000>, <0x0 0x03001c30 0x0 0x30>;
+		reg-names = "csi_mac0", "csi_wrap0", "csi_mac1", "pad_ctrl";
+		snsr-reset = <&porta 2 GPIO_ACTIVE_LOW>, <&porta 2 GPIO_ACTIVE_LOW>, <&porta 2 GPIO_ACTIVE_LOW>;
+		resets = <&rst RST_CSIPHY0>, <&rst RST_CSIPHY1>,
+			<&rst RST_CSIPHY0RST_APB>, <&rst RST_CSIPHY1RST_APB>;
+		reset-names = "phy0", "phy1", "phy-apb0", "phy-apb1";
+		clocks = <&clk CV180X_CLK_CAM0>, <&clk CV180X_CLK_CAM1>, <&clk CV180X_CLK_SRC_VIP_SYS_2>,
+			 <&clk CV180X_CLK_MIPIMPLL>, <&clk CV180X_CLK_DISPPLL>, <&clk CV180X_CLK_FPLL>;
+		clock-names = "clk_cam0", "clk_cam1", "clk_sys_2",
+			      "clk_mipimpll", "clk_disppll", "clk_fpll";
+	};
+
+	sys {
+		compatible = "cvitek,sys";
+	};
+
+	base {
+		compatible = "cvitek,base";
+		reg = <0x0 0x0a0c8000 0x0 0x20>;
+		reg-names = "vip_sys";
+	};
+
+	vi {
+		compatible = "cvitek,vi";
+		reg = <0x0 0x0a000000 0x0 0x80000>;
+		clocks = <&clk CV180X_CLK_SRC_VIP_SYS_0>, <&clk CV180X_CLK_SRC_VIP_SYS_1>,
+				<&clk CV180X_CLK_SRC_VIP_SYS_2>, <&clk CV180X_CLK_SRC_VIP_SYS_3>,
+				<&clk CV180X_CLK_AXI_VIP>, <&clk CV180X_CLK_CSI_BE_VIP>,
+				<&clk CV180X_CLK_RAW_VIP>, <&clk CV180X_CLK_ISP_TOP_VIP>,
+				<&clk CV180X_CLK_CSI_MAC0_VIP>, <&clk CV180X_CLK_CSI_MAC1_VIP>,
+				<&clk CV180X_CLK_CSI_MAC2_VIP>;
+		clock-names = "clk_sys_0", "clk_sys_1", "clk_sys_2", "clk_sys_3",
+					"clk_axi", "clk_csi_be", "clk_raw", "clk_isp_top",
+					"clk_csi_mac0", "clk_csi_mac1", "clk_csi_mac2";
+		clock-freq-vip-sys1 = <300000000>;
+	};
+
+	vpss {
+		compatible = "cvitek,vpss";
+		reg = <0x0 0x0a080000 0x0 0x10000>, <0x0 0x0a0d1000 0x0 0x100>;
+		reg-names = "sc";
+		clocks = <&clk CV180X_CLK_SRC_VIP_SYS_0>,	<&clk CV180X_CLK_SRC_VIP_SYS_1>,
+			<&clk CV180X_CLK_SRC_VIP_SYS_2>, <&clk CV180X_CLK_IMG_D_VIP>,
+			<&clk CV180X_CLK_IMG_V_VIP>, <&clk CV180X_CLK_SC_TOP_VIP>,
+			<&clk CV180X_CLK_SC_D_VIP>, <&clk CV180X_CLK_SC_V1_VIP>,
+			<&clk CV180X_CLK_SC_V2_VIP>, <&clk CV180X_CLK_SC_V3_VIP>;
+		clock-names = "clk_sys_0", "clk_sys_1",
+			"clk_sys_2", "clk_img_d",
+			"clk_img_v", "clk_sc_top",
+			"clk_sc_d", "clk_sc_v1",
+			"clk_sc_v2", "clk_sc_v3";
+		clock-freq-vip-sys1 = <300000000>;
+	};
+
+	dwa {
+		compatible = "cvitek,dwa";
+		reg = <0x0 0x0a0c0000 0x0 0x1000>;
+		reg-names = "dwa";
+		clocks = <&clk CV180X_CLK_SRC_VIP_SYS_0>, <&clk CV180X_CLK_SRC_VIP_SYS_1>,
+			<&clk CV180X_CLK_SRC_VIP_SYS_2>, <&clk CV180X_CLK_SRC_VIP_SYS_3>,
+			<&clk CV180X_CLK_SRC_VIP_SYS_4>, <&clk CV180X_CLK_DWA_VIP>;
+		clock-names = "clk_sys_0", "clk_sys_1",
+			"clk_sys_2", "clk_sys_3",
+			"clk_sys_4", "clk_dwa";
+		clock-freq-vip-sys1 = <300000000>;
+	};
+
+	rgn {
+		compatible = "cvitek,rgn";
+	};
+
+	vcodec {
+		compatible = "cvitek,asic-vcodec";
+		reg = <0x0 0x0B020000 0x0 0x10000>,<0x0 0x0B010000 0x0 0x10000>,<0x0 0x0B030000 0x0 0x100>,
+		      <0x0 0x0B058000 0x0 0x100>,<0x0 0x0B050000 0x0 0x400>;
+		reg-names = "h265","h264","vc_ctrl","vc_sbm","vc_addr_remap";
+		clocks = <&clk CV180X_CLK_AXI_VIDEO_CODEC>,
+			<&clk CV180X_CLK_H264C>, <&clk CV180X_CLK_APB_H264C>,
+			<&clk CV180X_CLK_H265C>, <&clk CV180X_CLK_APB_H265C>,
+			<&clk CV180X_CLK_VC_SRC0>, <&clk CV180X_CLK_VC_SRC1>,
+			<&clk CV180X_CLK_VC_SRC2>, <&clk CV180X_CLK_CFG_REG_VC>;
+		clock-names = "clk_axi_video_codec",
+			"clk_h264c", "clk_apb_h264c",
+			"clk_h265c", "clk_apb_h265c",
+			"clk_vc_src0", "clk_vc_src1",
+			"clk_vc_src2", "clk_cfg_reg_vc";
+	};
+
+	jpu {
+		compatible = "cvitek,asic-jpeg";
+		reg = <0x0 0x0B000000 0x0 0x300>,<0x0 0x0B030000 0x0 0x100>,<0x0 0x0B058000 0x0 0x100>;
+		reg-names = "jpeg","vc_ctrl","vc_sbm";
+		clocks = <&clk CV180X_CLK_AXI_VIDEO_CODEC>,
+			<&clk CV180X_CLK_JPEG>, <&clk CV180X_CLK_APB_JPEG>,
+			<&clk CV180X_CLK_VC_SRC0>, <&clk CV180X_CLK_VC_SRC1>,
+			<&clk CV180X_CLK_VC_SRC2>, <&clk CV180X_CLK_CFG_REG_VC>;
+		clock-names = "clk_axi_video_codec",
+			"clk_jpeg", "clk_apb_jpeg",
+			"clk_vc_src0", "clk_vc_src1",
+			"clk_vc_src2", "clk_cfg_reg_vc";
+		resets = <&rst RST_JPEG>;
+		reset-names = "jpeg";
+	};
+
+	cvi_vc_drv {
+		compatible = "cvitek,cvi_vc_drv";
+		reg = <0x0 0x0B030000 0x0 0x100>,<0x0 0x0B058000 0x0 0x100>,<0x0 0x0B050000 0x0 0x400>;
+		reg-names = "vc_ctrl","vc_sbm","vc_addr_remap";
+	};
+
+	rtos_cmdqu {
+		compatible = "cvitek,rtos_cmdqu";
+		reg = <0x0 0x01900000 0x0 0x1000>;
+		reg-names = "mailbox";
+	};
+
+	usb: usb@04340000 {
+		compatible = "cvitek,cv182x-usb";
+		reg = <0x0 0x04340000 0x0 0x10000>,
+			<0x0 0x03006000 0x0 0x58>;	//USB 2.0 PHY
+		dr_mode = "otg";
+		g-use-dma;
+		g-rx-fifo-size = <536>;
+		g-np-tx-fifo-size = <32>;
+		g-tx-fifo-size = <768 512 512 384 128 128>;
+		clocks = <&clk CV180X_CLK_AXI4_USB>,
+				<&clk CV180X_CLK_APB_USB>,
+				<&clk CV180X_CLK_125M_USB>,
+				<&clk CV180X_CLK_33K_USB>,
+				<&clk CV180X_CLK_12M_USB>;
+		clock-names = "clk_axi", "clk_apb", "clk_125m", "clk_33k", "clk_12m";
+		vbus-gpio = <&portb 6 0>;
+		status = "okay";
+	};
+
+	thermal:thermal@030E0000 {
+		compatible = "cvitek,cv180x-thermal";
+		reg = <0x0 0x030E0000 0x0 0x10000>;
+		clocks = <&clk CV180X_CLK_TEMPSEN>;
+		clock-names = "clk_tempsen";
+		reset-names = "tempsen";
+		#thermal-sensor-cells = <1>;
+	};
+
+#if 0
+	cv182x_cooling:cv182x_cooling {
+		clocks = <&clk CV180X_CLK_A53>, <&clk CV180X_CLK_TPU>;
+		clock-names = "clk_a53", "clk_tpu_axi";
+		dev-freqs = <1000000000 750000000>,
+			<500000000 375000000>,
+			<500000000 100000000>;
+		compatible = "cvitek,cv182x-cooling";
+		#cooling-cells = <2>;
+	};
+#endif
+
+	thermal-zones {
+		soc_thermal_0: soc_thermal_0 {
+			polling-delay-passive = <1000>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+			thermal-sensors = <&thermal 0>;
+
+			trips {
+				soc_thermal_trip_0: soc_thermal_trip_0 {
+					temperature = <100000>; /* millicelsius */
+					hysteresis = <5000>; /* millicelsius */
+					type = "passive";
+				};
+
+				soc_thermal_trip_1: soc_thermal_trip_1 {
+					temperature = <110000>; /* millicelsius */
+					hysteresis = <5000>; /* millicelsius */
+					type = "passive";
+				};
+
+				soc_thermal_crtical_0: soc_thermal_crtical_0 {
+					temperature = <130000>; /* millicelsius */
+					hysteresis = <0>; /* millicelsius */
+					type = "critical";
+				};
+			};
+		};
+	};
+
+#if 0
+	cvipctrl: pinctrl@3001000 {
+		compatible = "cvitek,pinctrl-cv182x";
+		reg = <0 0x03001000 0 0x1000>;
+	};
+#endif
+
+	cviaudio_core {
+		compatible = "cvitek,audio";
+	};
+
+	audio_clock: audio_clock {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+#if 0
+		clock-frequency = <12288000>;
+#else
+		clock-frequency = <24576000>;
+#endif
+		};
+
+
+	aliases {
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		serial0 = &uart0;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+};
+
diff --git a/arch/riscv/dts/cv180x_base_riscv.dtsi b/arch/riscv/dts/cv180x_base_riscv.dtsi
new file mode 100644
index 000000000..ca87a1a85
--- /dev/null
+++ b/arch/riscv/dts/cv180x_base_riscv.dtsi
@@ -0,0 +1,374 @@
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/cv180x-resets.h>
+#include <dt-bindings/clock/cv180x-clock.h>
+#include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/dma/cv180x-dmamap.h>
+#include "cvi_board_memmap.h"
+
+/*
+ * OpenSBI will add below subnode into reserved memory automatically
+ * mmode_resv0@80000000 {
+ *     reg = <0x00 0x80000000 0x00 0x20000>;
+ *     phandle = <0x0d>;
+ * };
+ * Skip below to avoid lmb region reseved conflict in uboot.
+ *
+ */
+#ifndef __UBOOT__
+/memreserve/	CVIMMAP_MONITOR_ADDR CVIMMAP_OPENSBI_SIZE; // OpenSBI
+#endif
+
+#include "cv180x_base.dtsi"
+
+/ {
+	model = "Cvitek. CV180X ASIC. C906.";
+
+	#size-cells = <0x2>;
+	#address-cells = <0x2>;
+
+	c906_cpus:cpus {
+		#address-cells = <0x01>;
+		#size-cells = <0x00>;
+		timebase-frequency = <25000000>;
+
+		cpu-map {
+
+			cluster0 {
+
+				core0 {
+					cpu = <0x01>;
+				};
+			};
+		};
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x00>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdvcsu";
+			mmu-type = "riscv,sv39";
+			clock-frequency = <25000000>;
+
+			cpu0_intc: interrupt-controller {
+				#interrupt-cells = <0x01>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+			};
+		};
+	};
+
+	soc {
+		#address-cells = <0x02>;
+		#size-cells = <0x02>;
+		compatible = "simple-bus";
+		ranges;
+
+		plic0: interrupt-controller@70000000 {
+			riscv,ndev = <101>;
+			riscv,max-priority = <0x07>;
+			reg-names = "control";
+			reg = <0x00 0x70000000 0x00 0x4000000>;
+			interrupts-extended = <&cpu0_intc 0xffffffff &cpu0_intc 0x09>;
+			interrupt-controller;
+			compatible = "riscv,plic0";
+			#interrupt-cells = <0x02>;
+			#address-cells = <0x00>;
+		};
+
+		clint@74000000 {
+			interrupts-extended = <&cpu0_intc 0x03 &cpu0_intc 0x07>;
+			reg = <0x00 0x74000000 0x00 0x10000>;
+			compatible = "riscv,clint0";
+			clint,has-no-64bit-mmio;
+		};
+
+	};
+
+
+	cv180x_cooling:cv180x_cooling {
+		clocks = <&clk CV180X_CLK_C906_0>, <&clk CV180X_CLK_TPU>;
+		clock-names = "clk_cpu", "clk_tpu_axi";
+		dev-freqs = <850000000 500000000>,
+			<425000000 375000000>,
+			<425000000 300000000>;
+		compatible = "cvitek,cv180x-cooling";
+		#cooling-cells = <2>;
+	};
+
+	tpu {
+		interrupts = <75 IRQ_TYPE_LEVEL_HIGH>,
+				<76 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "tiu_irq", "tdma_irq";
+		interrupt-parent = <&plic0>;
+	};
+
+	mon {
+		interrupts = <93 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "mon_irq";
+		interrupt-parent = <&plic0>;
+	};
+
+	wiegand0 {
+		interrupts = <64 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	wiegand1 {
+		interrupts = <65 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	wiegand2 {
+		interrupts = <66 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	saradc {
+		interrupts = <100 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&plic0>;
+	};
+
+	rtc {
+		interrupts = <17 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	sysdma_remap {
+		int_mux = <0x7FC00>; /* enable bit [10..18] for CPU1(906B) */
+	};
+
+	dmac: dma@0x4330000 {
+		interrupts = <29 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	watchdog0: cv-wd@0x3010000 {
+		interrupts = <58 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	spinand:cv-spinf@4060000 {
+		interrupts = <39 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	spif:cvi-spif@10000000 {
+		interrupts = <95 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	spi0:spi0@04180000 {
+		interrupts = <54 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	spi1:spi1@04190000 {
+		interrupts = <55 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	spi2:spi2@041A0000 {
+		interrupts = <56 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	spi3:spi3@041B0000 {
+		interrupts = <57 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	uart0: serial@04140000 {
+		interrupts = <44 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	uart1: serial@04150000 {
+		interrupts = <45 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	uart2: serial@04160000 {
+		interrupts = <46 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	uart3: serial@04170000 {
+		interrupts = <47 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	uart4: serial@041C0000 {
+		interrupts = <48 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	gpio0: gpio@03020000 {
+		porta: gpio-controller@0 {
+			interrupt-controller;
+			interrupts = <60 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&plic0>;
+		};
+	};
+
+	gpio1: gpio@03021000 {
+		portb: gpio-controller@1 {
+			interrupt-controller;
+			interrupts = <61 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&plic0>;
+		};
+	};
+
+	gpio2: gpio@03022000 {
+		portc: gpio-controller@2 {
+			interrupt-controller;
+			interrupts = <62 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&plic0>;
+		};
+	};
+
+	gpio3: gpio@03023000 {
+		portd: gpio-controller@3 {
+			interrupt-controller;
+			interrupts = <63 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&plic0>;
+		};
+	};
+
+	gpio4: gpio@05021000 {
+		porte: gpio-controller@4 {
+			interrupt-controller;
+			interrupts = <70 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&plic0>;
+		};
+	};
+
+	i2c0: i2c@04000000 {
+		interrupts = <49 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2c1: i2c@04010000 {
+		interrupts = <50 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2c2: i2c@04020000 {
+		interrupts = <51 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2c3: i2c@04030000 {
+		interrupts = <52 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2c4: i2c@04040000 {
+		interrupts = <53 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	ethernet0: ethernet@4070000 {
+		interrupt-names = "macirq";
+		interrupts = <31 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+#if 0
+    emmc:cv-emmc@4300000 {
+		interrupts = <34 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+#endif
+	sd:cv-sd@4310000 {
+		interrupts = <36 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2s0: i2s@04100000 {
+		interrupts = <40 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2s1: i2s@04110000 {
+		interrupts = <41 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2s2: i2s@04120000 {
+		interrupts = <42 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	i2s3: i2s@04130000 {
+		interrupts = <43 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	vi {
+		interrupts = <24 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+		interrupt-names = "isp";
+	};
+
+	vcodec {
+		interrupts = <22 IRQ_TYPE_LEVEL_HIGH>,
+			     <21 IRQ_TYPE_LEVEL_HIGH>,
+			     <23 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "h265","h264","sbm";
+		interrupt-parent = <&plic0>;
+	};
+
+	jpu {
+		interrupts = <20 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "jpeg";
+		interrupt-parent = <&plic0>;
+	};
+
+	rtos_cmdqu {
+		interrupts = <101 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "mailbox";
+		interrupt-parent = <&plic0>;
+	};
+
+	wifisd:wifi-sd@4320000 {
+		interrupts = <38 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	mipi_rx: cif {
+		interrupts = <26 IRQ_TYPE_LEVEL_HIGH>,
+			     <27 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "csi0", "csi1";
+		interrupt-parent = <&plic0>;
+	};
+#if 0
+	ive {
+		interrupt-names = "ive_irq";
+		interrupt-parent = <&plic0>;
+		interrupts = <97 IRQ_TYPE_LEVEL_HIGH>;
+	};
+#endif
+	vpss {
+		interrupts = <25 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "sc";
+		interrupt-parent = <&plic0>;
+	};
+
+	dwa {
+		interrupts = <28 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "dwa";
+		interrupt-parent = <&plic0>;
+	};
+
+	usb: usb@04340000 {
+		interrupts = <30 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&plic0>;
+	};
+
+	thermal:thermal@030E0000 {
+		interrupts = <16 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "tempsen";
+		interrupt-parent = <&plic0>;
+	};
+
+};
diff --git a/arch/riscv/dts/cv180x_default_memmap.dtsi b/arch/riscv/dts/cv180x_default_memmap.dtsi
new file mode 100644
index 000000000..93ab84007
--- /dev/null
+++ b/arch/riscv/dts/cv180x_default_memmap.dtsi
@@ -0,0 +1,26 @@
+/ {
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00 CVIMMAP_KERNEL_MEMORY_ADDR 0x00 CVIMMAP_KERNEL_MEMORY_SIZE>;
+	};
+
+
+	fast_image {
+		compatible = "cvitek,rtos_image";
+		reg-names = "rtos_region";
+		reg = <0x0 CVIMMAP_FREERTOS_ADDR 0x0 CVIMMAP_FREERTOS_SIZE>;
+		ion-size = <CVIMMAP_FREERTOS_RESERVED_ION_SIZE>;	//reserved ion size for freertos
+	};
+
+	reserved-memory {
+		#size-cells = <0x2>;
+		#address-cells = <0x2>;
+		ranges;
+
+		ion_reserved: ion {
+			compatible = "ion-region";
+			alloc-ranges = <0x0 CVIMMAP_ION_ADDR 0 CVIMMAP_ION_SIZE>;
+			size = <0x0 CVIMMAP_ION_SIZE>;
+		};
+	};
+};
diff --git a/arch/riscv/dts/cv180x_fpga.dts b/arch/riscv/dts/cv180x_fpga.dts
new file mode 100644
index 000000000..19b42bf59
--- /dev/null
+++ b/arch/riscv/dts/cv180x_fpga.dts
@@ -0,0 +1,16 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_bga.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+/ {
+
+};
+
+&sd {
+	no-1-8-v;
+	src-frequency = <25000000>;
+	min-frequency = <400000>;
+	max-frequency = <12000000>;
+};
diff --git a/arch/riscv/dts/cv180x_palladium.dts b/arch/riscv/dts/cv180x_palladium.dts
new file mode 100644
index 000000000..46e712f74
--- /dev/null
+++ b/arch/riscv/dts/cv180x_palladium.dts
@@ -0,0 +1,22 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_bga.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+/ {
+
+};
+
+&c906_cpus {
+	timebase-frequency = <1000000000>;
+
+	cpu@0 {
+		clock-frequency = <850000000>;
+	};
+};
+
+&uart0 {
+	clock-frequency = <307200>;
+	current-speed = <19200>;
+};
diff --git a/arch/riscv/dts/cv180zb_wdmb_0008a_spinor.dts b/arch/riscv/dts/cv180zb_wdmb_0008a_spinor.dts
new file mode 100644
index 000000000..5314a49d9
--- /dev/null
+++ b/arch/riscv/dts/cv180zb_wdmb_0008a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&mipi_rx{
+	snsr-reset = <&portc 8 GPIO_ACTIVE_LOW>, <&portc 8 GPIO_ACTIVE_LOW>, <&portc 8 GPIO_ACTIVE_LOW>;
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/dts/cv180zb_wevb_0008a_spinor.dts b/arch/riscv/dts/cv180zb_wevb_0008a_spinor.dts
new file mode 100644
index 000000000..5314a49d9
--- /dev/null
+++ b/arch/riscv/dts/cv180zb_wevb_0008a_spinor.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+#include "cv180x_base_riscv.dtsi"
+#include "cv180x_asic_qfn.dtsi"
+#include "cv180x_asic_spinor.dtsi"
+#include "cv180x_default_memmap.dtsi"
+
+&mipi_rx{
+	snsr-reset = <&portc 8 GPIO_ACTIVE_LOW>, <&portc 8 GPIO_ACTIVE_LOW>, <&portc 8 GPIO_ACTIVE_LOW>;
+};
+
+/ {
+
+};
+
diff --git a/arch/riscv/include/asm/boot0.h b/arch/riscv/include/asm/boot0.h
new file mode 100644
index 000000000..71876eedd
--- /dev/null
+++ b/arch/riscv/include/asm/boot0.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * CVITEK u-boot header
+ */
+
+#ifndef __BOOT0_H__
+#define __BOOT0_H__
+
+/* BOOT0 header information */
+	j boot0_time_recode
+	.balign 4
+	.word 0x33334c42  /* b'BL33' */
+	.word 0xdeadbeea  /* CKSUM */
+	.word 0xdeadbeeb  /* SIZE */
+	.quad CONFIG_SYS_TEXT_BASE /* RUNADDR */
+	.word 0xdeadbeec
+	.balign 4
+	j boot0_time_recode
+	.balign 4
+/* BOOT0 header end */
+boot0_time_recode:
+	csrr x1, time
+	la x2, BOOT0_START_TIME
+	sw x1, 0(x2)
+	j _start_real
+
+	.global BOOT0_START_TIME
+BOOT0_START_TIME:
+	.word 0
+
+#endif /* __BOOT0_H__ */
diff --git a/arch/riscv/include/asm/cache.h b/arch/riscv/include/asm/cache.h
index 874963d73..5060e249b 100644
--- a/arch/riscv/include/asm/cache.h
+++ b/arch/riscv/include/asm/cache.h
@@ -9,7 +9,8 @@
 
 /* cache */
 void cache_flush(void);
-
+void invalidate_dcache_range(unsigned long start, unsigned long end);
+void flush_dcache_range(unsigned long start, unsigned long end);
 /*
  * The current upper bound for RISCV L1 data cache line sizes is 32 bytes.
  * We use that value for aligning DMA buffers unless the board config has
diff --git a/arch/riscv/include/asm/io.h b/arch/riscv/include/asm/io.h
index acf5a9644..3540773c4 100644
--- a/arch/riscv/include/asm/io.h
+++ b/arch/riscv/include/asm/io.h
@@ -44,15 +44,15 @@ static inline phys_addr_t map_to_sysmem(const void *ptr)
  * read/writes.  We define __arch_*[bl] here, and leave __arch_*w
  * to the architecture specific code.
  */
-#define __arch_getb(a)			(*(unsigned char *)(a))
-#define __arch_getw(a)			(*(unsigned short *)(a))
-#define __arch_getl(a)			(*(unsigned int *)(a))
-#define __arch_getq(a)			(*(unsigned long long *)(a))
-
-#define __arch_putb(v, a)		(*(unsigned char *)(a) = (v))
-#define __arch_putw(v, a)		(*(unsigned short *)(a) = (v))
-#define __arch_putl(v, a)		(*(unsigned int *)(a) = (v))
-#define __arch_putq(v, a)		(*(unsigned long long *)(a) = (v))
+#define __arch_getb(a)			(*(volatile unsigned char *)(a))
+#define __arch_getw(a)			(*(volatile unsigned short *)(a))
+#define __arch_getl(a)			(*(volatile unsigned int *)(a))
+#define __arch_getq(a)			(*(volatile unsigned long long *)(a))
+
+#define __arch_putb(v, a)		(*(volatile unsigned char *)(a) = (v))
+#define __arch_putw(v, a)		(*(volatile unsigned short *)(a) = (v))
+#define __arch_putl(v, a)		(*(volatile unsigned int *)(a) = (v))
+#define __arch_putq(v, a)		(*(volatile unsigned long long *)(a) = (v))
 
 #define __raw_writeb(v, a)		__arch_putb(v, a)
 #define __raw_writew(v, a)		__arch_putw(v, a)
diff --git a/arch/riscv/include/asm/u-boot-riscv.h b/arch/riscv/include/asm/u-boot-riscv.h
index 543a1688d..f222bea40 100644
--- a/arch/riscv/include/asm/u-boot-riscv.h
+++ b/arch/riscv/include/asm/u-boot-riscv.h
@@ -16,6 +16,7 @@ int cleanup_before_linux(void);
 
 /* board/.../... */
 int board_init(void);
+void board_save_time_record(uintptr_t saveaddr);
 void board_quiesce_devices(void);
 int riscv_board_reserved_mem_fixup(void *fdt);
 int riscv_fdt_copy_resv_mem_node(const void *src_fdt, void *dest_fdt);
diff --git a/arch/riscv/lib/bootm.c b/arch/riscv/lib/bootm.c
index 8dd182054..a3fa860f0 100644
--- a/arch/riscv/lib/bootm.c
+++ b/arch/riscv/lib/bootm.c
@@ -60,6 +60,9 @@ static void announce_and_cleanup(int fake)
 	dm_remove_devices_flags(DM_REMOVE_ACTIVE_ALL);
 
 	cleanup_before_linux();
+
+	// Save kernel start time
+	board_save_time_record(TIME_RECORDS_FIELD_KERNEL_START);
 }
 
 static void boot_prep_linux(bootm_headers_t *images)
@@ -135,3 +138,16 @@ int do_bootm_vxworks(int flag, int argc, char *const argv[],
 {
 	return do_bootm_linux(flag, argc, argv, images);
 }
+
+static ulong get_sp(void)
+{
+	ulong ret;
+
+	asm("mv %0, sp" : "=r"(ret) : );
+	return ret;
+}
+
+void arch_lmb_reserve(struct lmb *lmb)
+{
+	arch_lmb_reserve_generic(lmb, get_sp(), gd->ram_top, 4096);
+}
diff --git a/arch/riscv/lib/reset.c b/arch/riscv/lib/reset.c
index 8779c619c..a1da9fb4e 100644
--- a/arch/riscv/lib/reset.c
+++ b/arch/riscv/lib/reset.c
@@ -7,12 +7,13 @@
 #include <command.h>
 #include <hang.h>
 
+extern void cv_system_reset(void);
+
 int do_reset(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
 	printf("resetting ...\n");
 
-	printf("reset not supported yet\n");
-	hang();
+	cv_system_reset();
 
 	return 0;
 }
diff --git a/board/cvitek/Kconfig b/board/cvitek/Kconfig
new file mode 100644
index 000000000..f1ca1ce3b
--- /dev/null
+++ b/board/cvitek/Kconfig
@@ -0,0 +1,35 @@
+if TARGET_CVITEK_ARM || TARGET_CVITEK_RISCV
+
+config TARGET_CVITEK
+	def_bool n
+	select ARM64 if TARGET_CVITEK_ARM
+	select GENERIC_RISCV if TARGET_CVITEK_RISCV
+	select ENABLE_ARM_SOC_BOOT0_HOOK if TARGET_CVITEK_ARM
+
+choice
+	prompt "Cvitek target"
+
+config TARGET_CVITEK_CV1835
+	bool "Support CVITEK CV1835"
+	select TARGET_CVITEK
+
+config TARGET_CVITEK_CV1822
+	bool "Support CVITEK CV1822"
+	select TARGET_CVITEK
+
+config TARGET_CVITEK_CV181X
+	bool "Support CVITEK CV181X"
+	select TARGET_CVITEK
+
+config TARGET_CVITEK_CV180X
+	bool "Support CVITEK CV180X"
+	select TARGET_CVITEK
+
+endchoice
+
+source "board/cvitek/cv1835/Kconfig"
+source "board/cvitek/cv1822/Kconfig"
+source "board/cvitek/cv181x/Kconfig"
+source "board/cvitek/cv180x/Kconfig"
+
+endif
diff --git a/board/cvitek/cv180x/Kconfig b/board/cvitek/cv180x/Kconfig
new file mode 100644
index 000000000..9a30bbc01
--- /dev/null
+++ b/board/cvitek/cv180x/Kconfig
@@ -0,0 +1,76 @@
+if TARGET_CVITEK_CV180X
+
+choice
+	prompt "Cvitek CV180X verification platform type select"
+	help
+	  Select the board version of the shc board.
+
+config TARGET_CVITEK_CV180X_ASIC
+	bool "ASIC"
+	help
+	  This enables support for Cvitek's CV180X SoC on ASIC platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV180X_PALLADIUM
+	bool "Palladium"
+	help
+	  This enables support for Cvitek's CV180X SoC on PALLADIUM platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV180X_FPGA
+	bool "FPGA"
+	help
+	  This enables support for Cvitek's CV180X SoC on FPGA platform.
+
+	  If unsure, say N.
+
+endchoice
+
+config SYS_BOARD
+	default "cv180x"
+
+config SYS_VENDOR
+	default "cvitek"
+
+config SYS_CPU
+	default "generic"
+
+config SYS_CONFIG_NAME
+	default "cv180x-asic" if TARGET_CVITEK_CV180X_ASIC
+	default "cv180x-palladium" if TARGET_CVITEK_CV180X_PALLADIUM
+	default "cv180x-fpga" if TARGET_CVITEK_CV180X_FPGA
+
+config CVITEK_SPI_FLASH
+    bool
+	prompt "Support CVITEK SPINOR"
+    select SPI_FLASH
+	select DM
+	select DM_SPI
+	select DM_SPI_FLASH
+	select SPI_MEM
+	select CMD_SF
+    select CVI_SPIF
+    select ENV_IS_IN_SPI_FLASH
+
+config ENV_SIZE
+    default 0x10000 if ENV_IS_IN_SPI_FLASH
+    default 0x20000 if ENV_IS_IN_MMC
+	default 0x20000 if ENV_IS_IN_NAND
+
+config ENV_SECT_SIZE
+	default 0x10000 if ENV_IS_IN_SPI_FLASH
+	default 0x40000 if ENV_IS_IN_MMC
+	default 0x20000 if ENV_IS_IN_NAND
+
+config ENV_OFFSET
+    default 0x3A0000 if ENV_IS_IN_SPI_FLASH
+    default 0x880000 if ENV_IS_IN_MMC
+	default 0xae0000 if ENV_IS_IN_NAND
+
+config ENV_OFFSET_REDUND
+    default 0x3B0000 if ENV_IS_IN_SPI_FLASH
+	default 0xb00000 if ENV_IS_IN_NAND
+
+endif
diff --git a/board/cvitek/cv180x/Makefile b/board/cvitek/cv180x/Makefile
new file mode 100644
index 000000000..da8bfb2ae
--- /dev/null
+++ b/board/cvitek/cv180x/Makefile
@@ -0,0 +1,2 @@
+
+obj-y	:= board.o
diff --git a/board/cvitek/cv180x/board.c b/board/cvitek/cv180x/board.c
new file mode 100644
index 000000000..fc70cace5
--- /dev/null
+++ b/board/cvitek/cv180x/board.c
@@ -0,0 +1,304 @@
+/*
+ * (C) Copyright 2013
+ * David Feng <fenghua@phytium.com.cn>
+ * Sharma Bhupesh <bhupesh.sharma@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#if defined(__aarch64__)
+#include <asm/armv8/mmu.h>
+#endif
+#include <usb/dwc2_udc.h>
+#include <usb.h>
+#include "cv180x_reg.h"
+#include "mmio.h"
+#include "cv180x_reg_fmux_gpio.h"
+#include "cv180x_pinlist_swconfig.h"
+#include <linux/delay.h>
+#include <bootstage.h>
+
+#if defined(__riscv)
+#include <asm/csr.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+#define SD1_SDIO_PAD
+
+#if defined(CV1801C_WEVB_0009A_SPINOR) ||	\
+	defined(CV1800C_WEVB_0009A_SPINOR) ||	\
+	defined(CV1801C_WEVB_0009A_SPINAND)
+#define CV180X_QFN_88_PIN
+#elif defined(CV1801C_WDMB_0009A_SPINOR)
+#define CV180X_QFN_88_PIN_38
+#else
+#define CV180X_QFN_68_PIN
+#endif
+
+#if defined(__aarch64__)
+static struct mm_region cv180x_mem_map[] = {
+	{
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		.virt = PHYS_SDRAM_1,
+		.phys = PHYS_SDRAM_1,
+		.size = PHYS_SDRAM_1_SIZE,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = cv180x_mem_map;
+#endif
+
+// #define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) printf ("%s\n", PIN_NAME ##_ ##FUNC_NAME);
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + FMUX_GPIO_FUNCSEL_##PIN_NAME, \
+			FMUX_GPIO_FUNCSEL_##PIN_NAME##_MASK << FMUX_GPIO_FUNCSEL_##PIN_NAME##_OFFSET, \
+			PIN_NAME##__##FUNC_NAME)
+
+void pinmux_config(int io_type)
+{
+		switch (io_type) {
+		case PINMUX_UART0:
+			PINMUX_CONFIG(UART0_RX, UART0_RX);
+			PINMUX_CONFIG(UART0_TX, UART0_TX);
+		break;
+		case PINMUX_SDIO0:
+			PINMUX_CONFIG(SD0_CD, SDIO0_CD);
+			PINMUX_CONFIG(SD0_PWR_EN, SDIO0_PWR_EN);
+			PINMUX_CONFIG(SD0_CMD, SDIO0_CMD);
+			PINMUX_CONFIG(SD0_CLK, SDIO0_CLK);
+			PINMUX_CONFIG(SD0_D0, SDIO0_D_0);
+			PINMUX_CONFIG(SD0_D1, SDIO0_D_1);
+			PINMUX_CONFIG(SD0_D2, SDIO0_D_2);
+			PINMUX_CONFIG(SD0_D3, SDIO0_D_3);
+			break;
+
+		case PINMUX_SPI0:
+			PINMUX_CONFIG(SD0_CMD, SPI0_SDO);
+			PINMUX_CONFIG(SD0_CLK, SPI0_SCK);
+			PINMUX_CONFIG(SD0_D0, SPI0_SDI);
+			PINMUX_CONFIG(SD0_D3, SPI0_CS_X);
+			break;
+
+		case PINMUX_SPI2:
+			PINMUX_CONFIG(SD1_CMD, SPI2_SDO);
+			PINMUX_CONFIG(SD1_CLK, SPI2_SCK);
+			PINMUX_CONFIG(SD1_D0, SPI2_SDI);
+			PINMUX_CONFIG(SD1_D3, SPI2_CS_X);
+			break;
+
+		case PINMUX_SDIO1:
+#if defined(SD1_SDIO_PAD)
+			/*
+			 * Name            Address            SD1  MIPI
+			 * reg_sd1_phy_sel REG_0x300_0294[10] 0x0  0x1
+			 */
+			mmio_write_32(TOP_BASE + 0x294,
+				      (mmio_read_32(TOP_BASE + 0x294) & 0xFFFFFBFF));
+			PINMUX_CONFIG(SD1_CMD, PWR_SD1_CMD);
+			PINMUX_CONFIG(SD1_CLK, PWR_SD1_CLK);
+			PINMUX_CONFIG(SD1_D0, PWR_SD1_D0);
+			PINMUX_CONFIG(SD1_D1, PWR_SD1_D1);
+			PINMUX_CONFIG(SD1_D2, PWR_SD1_D2);
+			PINMUX_CONFIG(SD1_D3, PWR_SD1_D3);
+#endif
+			break;
+		case PINMUX_SPI_NOR:
+			PINMUX_CONFIG(SPINOR_HOLD_X, SPINOR_HOLD_X);
+			PINMUX_CONFIG(SPINOR_SCK, SPINOR_SCK);
+			PINMUX_CONFIG(SPINOR_MOSI, SPINOR_MOSI);
+			PINMUX_CONFIG(SPINOR_WP_X, SPINOR_WP_X);
+			PINMUX_CONFIG(SPINOR_MISO, SPINOR_MISO);
+			PINMUX_CONFIG(SPINOR_CS_X, SPINOR_CS_X);
+		break;
+		case PINMUX_SPI_NAND:
+			PINMUX_CONFIG(SPINOR_HOLD_X, SPINAND_HOLD);
+			PINMUX_CONFIG(SPINOR_SCK, SPINAND_CLK);
+			PINMUX_CONFIG(SPINOR_MOSI, SPINAND_MOSI);
+			PINMUX_CONFIG(SPINOR_WP_X, SPINAND_WP);
+			PINMUX_CONFIG(SPINOR_MISO, SPINAND_MISO);
+			PINMUX_CONFIG(SPINOR_CS_X, SPINAND_CS);
+		break;
+		case PINMUX_USB:
+#if defined(CV180X_QFN_88_PIN)
+			PINMUX_CONFIG(PWR_GPIO0, PWR_GPIO_0);
+			PINMUX_CONFIG(PWR_GPIO1, PWR_GPIO_1);
+			PINMUX_CONFIG(ADC1, XGPIOB_3);
+			PINMUX_CONFIG(USB_VBUS_DET, USB_VBUS_DET);
+#elif defined(CV180X_QFN_88_PIN_38)
+			PINMUX_CONFIG(ADC1, XGPIOB_3);
+			PINMUX_CONFIG(USB_VBUS_DET, USB_VBUS_DET);
+#elif defined(CV180X_QFN_68_PIN)
+			PINMUX_CONFIG(SD1_GPIO0, PWR_GPIO_25);
+			PINMUX_CONFIG(SD1_GPIO1, PWR_GPIO_26);
+			PINMUX_CONFIG(ADC1, XGPIOB_3);
+			PINMUX_CONFIG(USB_VBUS_DET, USB_VBUS_DET);
+#endif
+		break;
+		default:
+			break;
+	}
+}
+
+#include "../cvi_board_init.c"
+
+#if defined(CONFIG_PHY_CVITEK_CV182XA)
+static void cv182xa_ephy_id_init(void)
+{
+	// set rg_ephy_apb_rw_sel 0x0804@[0]=1/APB by using APB interface
+	mmio_write_32(0x03009804, 0x0001);
+
+	// Release 0x0800[0]=0/shutdown
+	mmio_write_32(0x03009800, 0x0900);
+
+	// Release 0x0800[2]=1/dig_rst_n, Let mii_reg can be accessabile
+	mmio_write_32(0x03009800, 0x0904);
+
+	// PHY_ID
+	mmio_write_32(0x03009008, 0x0043);
+	mmio_write_32(0x0300900c, 0x5649);
+
+	// switch to MDIO control by ETH_MAC
+	mmio_write_32(0x03009804, 0x0000);
+}
+#endif
+
+int board_init(void)
+{
+	extern uint32_t BOOT0_START_TIME;
+	uint16_t start_time = DIV_ROUND_UP(BOOT0_START_TIME, SYS_COUNTER_FREQ_IN_SECOND / 1000);
+
+	// Save uboot start time. time is from boot0.h
+	mmio_write_16(TIME_RECORDS_FIELD_UBOOT_START, start_time);
+
+#if defined(CONFIG_PHY_CVITEK_CV182XA) /* config cvitek cr181x/cr180x eth internal phy on ASIC board */
+	cv182xa_ephy_id_init();
+#endif
+
+#if defined(CONFIG_NAND_SUPPORT)
+	pinmux_config(PINMUX_SPI_NAND);
+#elif defined(CONFIG_SPI_FLASH)
+	pinmux_config(PINMUX_SPI_NOR);
+#endif
+	// pinmux_config(PINMUX_SDIO1);
+	pinmux_config(PINMUX_USB);
+	//pinmux_config(PINMUX_SPI0);
+	//pinmux_config(PINMUX_SPI2);
+	cvi_board_init();
+
+	return 0;
+}
+
+#if defined(__aarch64__)
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+#endif
+
+#ifdef CV_SYS_OFF
+static void cv_system_off(void)
+{
+	mmio_write_32(REG_RTC_BASE + RTC_EN_SHDN_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_SHDN_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_CTRL0, 0xFFFF0800 | (0x1 << 0));
+
+	while (1)
+		;
+}
+#endif
+
+void cv_system_reset(void)
+{
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_CTRL0, 0xFFFF0800 | (0x1 << 4));
+
+	while (1)
+		;
+}
+
+/*
+ * Board specific reset that is system reset.
+ */
+void reset_cpu(void)
+{
+	cv_system_reset();
+}
+
+#ifdef CONFIG_USB_GADGET_DWC2_OTG
+struct dwc2_plat_otg_data cv182x_otg_data = {
+	.regs_otg = USB_BASE,
+	.usb_gusbcfg    = 0x40081400,
+	.rx_fifo_sz     = 512,
+	.np_tx_fifo_sz  = 512,
+	.tx_fifo_sz     = 512,
+};
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	uint32_t value;
+
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) & (~BIT_TOP_SOFT_RST_USB);
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+	udelay(50);
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) | BIT_TOP_SOFT_RST_USB;
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+
+	/* Set USB phy configuration */
+	value = mmio_read_32(REG_TOP_USB_PHY_CTRL);
+	mmio_write_32(REG_TOP_USB_PHY_CTRL, value | BIT_TOP_USB_PHY_CTRL_EXTVBUS
+					| USB_PHY_ID_OVERRIDE_ENABLE
+					| USB_PHY_ID_VALUE);
+
+	/* Enable ECO RXF */
+	mmio_write_32(REG_TOP_USB_ECO, mmio_read_32(REG_TOP_USB_ECO) | BIT_TOP_USB_ECO_RX_FLUSH);
+
+	printf("cvi_usb_hw_init done\n");
+
+	return dwc2_udc_probe(&cv182x_otg_data);
+}
+#endif
+
+void board_save_time_record(uintptr_t saveaddr)
+{
+	uint64_t boot_us = 0;
+#if defined(__aarch64__)
+	boot_us = timer_get_boot_us();
+#elif defined(__riscv)
+	// Read from CSR_TIME directly. RISC-V timers is initialized later.
+	boot_us = csr_read(CSR_TIME) / (SYS_COUNTER_FREQ_IN_SECOND / 1000000);
+#else
+#error "Unknown ARCH"
+#endif
+
+	mmio_write_16(saveaddr, DIV_ROUND_UP(boot_us, 1000));
+}
diff --git a/board/cvitek/cv180x/cv180x_pinlist_swconfig.h b/board/cvitek/cv180x/cv180x_pinlist_swconfig.h
new file mode 100644
index 000000000..5afcd9ea3
--- /dev/null
+++ b/board/cvitek/cv180x/cv180x_pinlist_swconfig.h
@@ -0,0 +1,407 @@
+//##==============================================================================
+//##=== This script is generate by genswconfig.pl from .\00_cv180x_Pinlist_20220315.xls
+//##=== Generate Time stamp is : 2022-03-17 14:04:49
+//##==============================================================================
+
+#ifndef __CV180X_PINLIST_SWCONFIG_H__
+#define __CV180X_PINLIST_SWCONFIG_H__
+
+#define SD0_CLK__SDIO0_CLK 0
+#define SD0_CLK__IIC1_SDA 1
+#define SD0_CLK__SPI0_SCK 2
+#define SD0_CLK__XGPIOA_7 3
+#define SD0_CLK__PWM_15 5
+#define SD0_CLK__EPHY_LNK_LED 6
+#define SD0_CLK__DBG_0 7
+#define SD0_CMD__SDIO0_CMD 0
+#define SD0_CMD__IIC1_SCL 1
+#define SD0_CMD__SPI0_SDO 2
+#define SD0_CMD__XGPIOA_8 3
+#define SD0_CMD__PWM_14 5
+#define SD0_CMD__EPHY_SPD_LED 6
+#define SD0_CMD__DBG_1 7
+#define SD0_D0__SDIO0_D_0 0
+#define SD0_D0__CAM_MCLK1 1
+#define SD0_D0__SPI0_SDI 2
+#define SD0_D0__XGPIOA_9 3
+#define SD0_D0__UART3_TX 4
+#define SD0_D0__PWM_13 5
+#define SD0_D0__WG0_D0 6
+#define SD0_D0__DBG_2 7
+#define SD0_D1__SDIO0_D_1 0
+#define SD0_D1__IIC1_SDA 1
+#define SD0_D1__AUX0 2
+#define SD0_D1__XGPIOA_10 3
+#define SD0_D1__UART1_TX 4
+#define SD0_D1__PWM_12 5
+#define SD0_D1__WG0_D1 6
+#define SD0_D1__DBG_3 7
+#define SD0_D2__SDIO0_D_2 0
+#define SD0_D2__IIC1_SCL 1
+#define SD0_D2__AUX1 2
+#define SD0_D2__XGPIOA_11 3
+#define SD0_D2__UART1_RX 4
+#define SD0_D2__PWM_11 5
+#define SD0_D2__WG1_D0 6
+#define SD0_D2__DBG_4 7
+#define SD0_D3__SDIO0_D_3 0
+#define SD0_D3__CAM_MCLK0 1
+#define SD0_D3__SPI0_CS_X 2
+#define SD0_D3__XGPIOA_12 3
+#define SD0_D3__UART3_RX 4
+#define SD0_D3__PWM_10 5
+#define SD0_D3__WG1_D1 6
+#define SD0_D3__DBG_5 7
+#define SD0_CD__SDIO0_CD 0
+#define SD0_CD__XGPIOA_13 3
+#define SD0_PWR_EN__SDIO0_PWR_EN 0
+#define SD0_PWR_EN__XGPIOA_14 3
+#define SPK_EN__XGPIOA_15 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__CAM_MCLK1 1
+#define UART0_TX__PWM_4 2
+#define UART0_TX__XGPIOA_16 3
+#define UART0_TX__UART1_TX 4
+#define UART0_TX__AUX1 5
+#define UART0_TX__JTAG_TMS 6
+#define UART0_TX__DBG_6 7
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__CAM_MCLK0 1
+#define UART0_RX__PWM_5 2
+#define UART0_RX__XGPIOA_17 3
+#define UART0_RX__UART1_RX 4
+#define UART0_RX__AUX0 5
+#define UART0_RX__JTAG_TCK 6
+#define UART0_RX__DBG_7 7
+#define SPINOR_HOLD_X__SPINOR_HOLD_X 1
+#define SPINOR_HOLD_X__SPINAND_HOLD 2
+#define SPINOR_HOLD_X__XGPIOA_26 3
+#define SPINOR_SCK__SPINOR_SCK 1
+#define SPINOR_SCK__SPINAND_CLK 2
+#define SPINOR_SCK__XGPIOA_22 3
+#define SPINOR_MOSI__SPINOR_MOSI 1
+#define SPINOR_MOSI__SPINAND_MOSI 2
+#define SPINOR_MOSI__XGPIOA_25 3
+#define SPINOR_WP_X__SPINOR_WP_X 1
+#define SPINOR_WP_X__SPINAND_WP 2
+#define SPINOR_WP_X__XGPIOA_27 3
+#define SPINOR_MISO__SPINOR_MISO 1
+#define SPINOR_MISO__SPINAND_MISO 2
+#define SPINOR_MISO__XGPIOA_23 3
+#define SPINOR_CS_X__SPINOR_CS_X 1
+#define SPINOR_CS_X__SPINAND_CS 2
+#define SPINOR_CS_X__XGPIOA_24 3
+#define JTAG_CPU_TMS__JTAG_TMS 0
+#define JTAG_CPU_TMS__CAM_MCLK0 1
+#define JTAG_CPU_TMS__PWM_7 2
+#define JTAG_CPU_TMS__XGPIOA_19 3
+#define JTAG_CPU_TMS__UART1_RTS 4
+#define JTAG_CPU_TMS__AUX0 5
+#define JTAG_CPU_TMS__UART1_TX 6
+#define JTAG_CPU_TCK__JTAG_TCK 0
+#define JTAG_CPU_TCK__CAM_MCLK1 1
+#define JTAG_CPU_TCK__PWM_6 2
+#define JTAG_CPU_TCK__XGPIOA_18 3
+#define JTAG_CPU_TCK__UART1_CTS 4
+#define JTAG_CPU_TCK__AUX1 5
+#define JTAG_CPU_TCK__UART1_RX 6
+#define IIC0_SCL__CV_SCL0__CR_4WTDI 0
+#define IIC0_SDA__CV_SDA0__CR_4WTDO 0
+#define IIC0_SCL__JTAG_TDI 0
+#define IIC0_SCL__UART1_TX 1
+#define IIC0_SCL__UART2_TX 2
+#define IIC0_SCL__XGPIOA_28 3
+#define IIC0_SCL__IIC0_SCL 4
+#define IIC0_SCL__WG0_D0 5
+#define IIC0_SCL__DBG_10 7
+#define IIC0_SDA__JTAG_TDO 0
+#define IIC0_SDA__UART1_RX 1
+#define IIC0_SDA__UART2_RX 2
+#define IIC0_SDA__XGPIOA_29 3
+#define IIC0_SDA__IIC0_SDA 4
+#define IIC0_SDA__WG0_D1 5
+#define IIC0_SDA__WG1_D0 6
+#define IIC0_SDA__DBG_11 7
+#define AUX0__AUX0 0
+#define AUX0__XGPIOA_30 3
+#define AUX0__IIS1_MCLK 4
+#define AUX0__WG1_D1 6
+#define AUX0__DBG_12 7
+#define GPIO_ZQ__PWR_GPIO_24 3
+#define GPIO_ZQ__PWM_2 4
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_RSTN__PWR_RSTN 0
+#define PWR_SEQ1__PWR_SEQ1 0
+#define PWR_SEQ1__PWR_GPIO_3 3
+#define PWR_SEQ2__PWR_SEQ2 0
+#define PWR_SEQ2__PWR_GPIO_4 3
+#define PTEST__PWR_PTEST 0
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__PWR_IR0 1
+#define PWR_WAKEUP0__PWR_UART0_TX 2
+#define PWR_WAKEUP0__PWR_GPIO_6 3
+#define PWR_WAKEUP0__UART1_TX 4
+#define PWR_WAKEUP0__IIC4_SCL 5
+#define PWR_WAKEUP0__EPHY_LNK_LED 6
+#define PWR_WAKEUP0__WG2_D0 7
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__PWR_GPIO_8 3
+#define PWR_BUTTON1__UART1_RX 4
+#define PWR_BUTTON1__IIC4_SDA 5
+#define PWR_BUTTON1__EPHY_SPD_LED 6
+#define PWR_BUTTON1__WG2_D1 7
+#define XTAL_XIN__PWR_XTAL_CLKIN 0
+#define PWR_GPIO0__PWR_GPIO_0 0
+#define PWR_GPIO0__UART2_TX 1
+#define PWR_GPIO0__PWR_UART0_RX 2
+#define PWR_GPIO0__PWM_8 4
+#define PWR_GPIO1__PWR_GPIO_1 0
+#define PWR_GPIO1__UART2_RX 1
+#define PWR_GPIO1__EPHY_LNK_LED 3
+#define PWR_GPIO1__PWM_9 4
+#define PWR_GPIO1__PWR_IIC_SCL 5
+#define PWR_GPIO1__IIC2_SCL 6
+#define PWR_GPIO1__IIC0_SDA 7
+#define PWR_GPIO2__PWR_GPIO_2 0
+#define PWR_GPIO2__PWR_SECTICK 2
+#define PWR_GPIO2__EPHY_SPD_LED 3
+#define PWR_GPIO2__PWM_10 4
+#define PWR_GPIO2__PWR_IIC_SDA 5
+#define PWR_GPIO2__IIC2_SDA 6
+#define PWR_GPIO2__IIC0_SCL 7
+#define SD1_GPIO1__UART4_TX 1
+#define SD1_GPIO1__PWR_GPIO_26 3
+#define SD1_GPIO1__PWM_10 7
+#define SD1_GPIO0__UART4_RX 1
+#define SD1_GPIO0__PWR_GPIO_25 3
+#define SD1_GPIO0__PWM_11 7
+#define SD1_D3__PWR_SD1_D3 0
+#define SD1_D3__SPI2_CS_X 1
+#define SD1_D3__IIC1_SCL 2
+#define SD1_D3__PWR_GPIO_18 3
+#define SD1_D3__CAM_MCLK0 4
+#define SD1_D3__UART3_CTS 5
+#define SD1_D3__PWR_SPINOR1_CS_X 6
+#define SD1_D3__PWM_4 7
+#define SD1_D2__PWR_SD1_D2 0
+#define SD1_D2__IIC1_SCL 1
+#define SD1_D2__UART2_TX 2
+#define SD1_D2__PWR_GPIO_19 3
+#define SD1_D2__CAM_MCLK0 4
+#define SD1_D2__UART3_TX 5
+#define SD1_D2__PWR_SPINOR1_HOLD_X 6
+#define SD1_D2__PWM_5 7
+#define SD1_D1__PWR_SD1_D1 0
+#define SD1_D1__IIC1_SDA 1
+#define SD1_D1__UART2_RX 2
+#define SD1_D1__PWR_GPIO_20 3
+#define SD1_D1__CAM_MCLK1 4
+#define SD1_D1__UART3_RX 5
+#define SD1_D1__PWR_SPINOR1_WP_X 6
+#define SD1_D1__PWM_6 7
+#define SD1_D0__PWR_SD1_D0 0
+#define SD1_D0__SPI2_SDI 1
+#define SD1_D0__IIC1_SDA 2
+#define SD1_D0__PWR_GPIO_21 3
+#define SD1_D0__CAM_MCLK1 4
+#define SD1_D0__UART3_RTS 5
+#define SD1_D0__PWR_SPINOR1_MISO 6
+#define SD1_D0__PWM_7 7
+#define SD1_CMD__PWR_SD1_CMD 0
+#define SD1_CMD__SPI2_SDO 1
+#define SD1_CMD__IIC3_SCL 2
+#define SD1_CMD__PWR_GPIO_22 3
+#define SD1_CMD__CAM_VS0 4
+#define SD1_CMD__EPHY_LNK_LED 5
+#define SD1_CMD__PWR_SPINOR1_MOSI 6
+#define SD1_CMD__PWM_8 7
+#define SD1_CLK__PWR_SD1_CLK 0
+#define SD1_CLK__SPI2_SCK 1
+#define SD1_CLK__IIC3_SDA 2
+#define SD1_CLK__PWR_GPIO_23 3
+#define SD1_CLK__CAM_HS0 4
+#define SD1_CLK__EPHY_SPD_LED 5
+#define SD1_CLK__PWR_SPINOR1_SCK 6
+#define SD1_CLK__PWM_9 7
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_0 3
+#define ADC1__XGPIOB_3 3
+#define ADC1__KEY_COL2 4
+#define ADC1__PWM_3 6
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_6 3
+#define USB_VBUS_DET__CAM_MCLK0 4
+#define USB_VBUS_DET__CAM_MCLK1 5
+#define USB_VBUS_DET__PWM_4 6
+#define MUX_SPI1_MISO__UART3_RTS 1
+#define MUX_SPI1_MISO__IIC1_SDA 2
+#define MUX_SPI1_MISO__XGPIOB_8 3
+#define MUX_SPI1_MISO__PWM_9 4
+#define MUX_SPI1_MISO__KEY_COL1 5
+#define MUX_SPI1_MISO__SPI1_SDI 6
+#define MUX_SPI1_MISO__DBG_14 7
+#define MUX_SPI1_MOSI__UART3_RX 1
+#define MUX_SPI1_MOSI__IIC1_SCL 2
+#define MUX_SPI1_MOSI__XGPIOB_7 3
+#define MUX_SPI1_MOSI__PWM_8 4
+#define MUX_SPI1_MOSI__KEY_COL0 5
+#define MUX_SPI1_MOSI__SPI1_SDO 6
+#define MUX_SPI1_MOSI__DBG_13 7
+#define MUX_SPI1_CS__UART3_CTS 1
+#define MUX_SPI1_CS__CAM_MCLK0 2
+#define MUX_SPI1_CS__XGPIOB_10 3
+#define MUX_SPI1_CS__PWM_11 4
+#define MUX_SPI1_CS__KEY_ROW3 5
+#define MUX_SPI1_CS__SPI1_CS_X 6
+#define MUX_SPI1_CS__DBG_16 7
+#define MUX_SPI1_SCK__UART3_TX 1
+#define MUX_SPI1_SCK__CAM_MCLK1 2
+#define MUX_SPI1_SCK__XGPIOB_9 3
+#define MUX_SPI1_SCK__PWM_10 4
+#define MUX_SPI1_SCK__KEY_ROW2 5
+#define MUX_SPI1_SCK__SPI1_SCK 6
+#define MUX_SPI1_SCK__DBG_15 7
+#define PAD_ETH_TXP__UART3_RX 1
+#define PAD_ETH_TXP__IIC1_SCL 2
+#define PAD_ETH_TXP__XGPIOB_25 3
+#define PAD_ETH_TXP__PWM_13 4
+#define PAD_ETH_TXP__CAM_MCLK0 5
+#define PAD_ETH_TXP__SPI1_SDO 6
+#define PAD_ETH_TXP__IIS2_LRCK 7
+#define PAD_ETH_TXM__UART3_RTS 1
+#define PAD_ETH_TXM__IIC1_SDA 2
+#define PAD_ETH_TXM__XGPIOB_24 3
+#define PAD_ETH_TXM__PWM_12 4
+#define PAD_ETH_TXM__CAM_MCLK1 5
+#define PAD_ETH_TXM__SPI1_SDI 6
+#define PAD_ETH_TXM__IIS2_BCLK 7
+#define PAD_ETH_RXP__UART3_TX 1
+#define PAD_ETH_RXP__CAM_MCLK1 2
+#define PAD_ETH_RXP__XGPIOB_27 3
+#define PAD_ETH_RXP__PWM_15 4
+#define PAD_ETH_RXP__CAM_HS0 5
+#define PAD_ETH_RXP__SPI1_SCK 6
+#define PAD_ETH_RXP__IIS2_DO 7
+#define PAD_ETH_RXM__UART3_CTS 1
+#define PAD_ETH_RXM__CAM_MCLK0 2
+#define PAD_ETH_RXM__XGPIOB_26 3
+#define PAD_ETH_RXM__PWM_14 4
+#define PAD_ETH_RXM__CAM_VS0 5
+#define PAD_ETH_RXM__SPI1_CS_X 6
+#define PAD_ETH_RXM__IIS2_DI 7
+#define GPIO_RTX__VI0_D_15 1
+#define GPIO_RTX__XGPIOB_23 3
+#define GPIO_RTX__PWM_1 4
+#define GPIO_RTX__CAM_MCLK0 5
+#define GPIO_RTX__IIS2_MCLK 7
+#define PAD_MIPIRX4N__VI0_CLK 1
+#define PAD_MIPIRX4N__IIC0_SCL 2
+#define PAD_MIPIRX4N__XGPIOC_2 3
+#define PAD_MIPIRX4N__IIC1_SDA 4
+#define PAD_MIPIRX4N__CAM_MCLK0 5
+#define PAD_MIPIRX4N__KEY_ROW0 6
+#define PAD_MIPIRX4N__MUX_SPI1_SCK 7
+#define PAD_MIPIRX4P__VI0_D_0 1
+#define PAD_MIPIRX4P__IIC0_SDA 2
+#define PAD_MIPIRX4P__XGPIOC_3 3
+#define PAD_MIPIRX4P__IIC1_SCL 4
+#define PAD_MIPIRX4P__CAM_MCLK1 5
+#define PAD_MIPIRX4P__KEY_ROW1 6
+#define PAD_MIPIRX4P__MUX_SPI1_CS 7
+#define PAD_MIPIRX3N__VI0_D_1 1
+#define PAD_MIPIRX3N__XGPIOC_4 3
+#define PAD_MIPIRX3N__CAM_MCLK0 4
+#define PAD_MIPIRX3N__MUX_SPI1_MISO 7
+#define PAD_MIPIRX3P__VI0_D_2 1
+#define PAD_MIPIRX3P__XGPIOC_5 3
+#define PAD_MIPIRX3P__MUX_SPI1_MOSI 7
+#define PAD_MIPIRX2N__VI0_D_3 1
+#define PAD_MIPIRX2N__XGPIOC_6 3
+#define PAD_MIPIRX2N__IIC4_SCL 5
+#define PAD_MIPIRX2N__DBG_6 7
+#define PAD_MIPIRX2P__VI0_D_4 1
+#define PAD_MIPIRX2P__XGPIOC_7 3
+#define PAD_MIPIRX2P__IIC4_SDA 5
+#define PAD_MIPIRX2P__DBG_7 7
+#define PAD_MIPIRX1N__VI0_D_5 1
+#define PAD_MIPIRX1N__XGPIOC_8 3
+#define PAD_MIPIRX1N__KEY_ROW3 6
+#define PAD_MIPIRX1N__DBG_8 7
+#define PAD_MIPIRX1P__VI0_D_6 1
+#define PAD_MIPIRX1P__XGPIOC_9 3
+#define PAD_MIPIRX1P__IIC1_SDA 4
+#define PAD_MIPIRX1P__KEY_ROW2 6
+#define PAD_MIPIRX1P__DBG_9 7
+#define PAD_MIPIRX0N__VI0_D_7 1
+#define PAD_MIPIRX0N__XGPIOC_10 3
+#define PAD_MIPIRX0N__IIC1_SCL 4
+#define PAD_MIPIRX0N__CAM_MCLK1 5
+#define PAD_MIPIRX0N__DBG_10 7
+#define PAD_MIPIRX0P__VI0_D_8 1
+#define PAD_MIPIRX0P__XGPIOC_11 3
+#define PAD_MIPIRX0P__CAM_MCLK0 4
+#define PAD_MIPIRX0P__DBG_11 7
+#define PAD_MIPI_TXM2__VI0_D_13 1
+#define PAD_MIPI_TXM2__IIC0_SDA 2
+#define PAD_MIPI_TXM2__XGPIOC_16 3
+#define PAD_MIPI_TXM2__IIC1_SDA 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__SPI0_SCK 6
+#define PAD_MIPI_TXP2__VI0_D_14 1
+#define PAD_MIPI_TXP2__IIC0_SCL 2
+#define PAD_MIPI_TXP2__XGPIOC_17 3
+#define PAD_MIPI_TXP2__IIC1_SCL 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__SPI0_CS_X 6
+#define PAD_MIPI_TXP2__IIS1_MCLK 7
+#define PAD_MIPI_TXM1__SPI3_SDO 0
+#define PAD_MIPI_TXM1__VI0_D_11 1
+#define PAD_MIPI_TXM1__IIS1_LRCK 2
+#define PAD_MIPI_TXM1__XGPIOC_14 3
+#define PAD_MIPI_TXM1__IIC2_SDA 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__SPI0_SDO 6
+#define PAD_MIPI_TXM1__DBG_14 7
+#define PAD_MIPI_TXP1__SPI3_SDI 0
+#define PAD_MIPI_TXP1__VI0_D_12 1
+#define PAD_MIPI_TXP1__IIS1_DO 2
+#define PAD_MIPI_TXP1__XGPIOC_15 3
+#define PAD_MIPI_TXP1__IIC2_SCL 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__SPI0_SDI 6
+#define PAD_MIPI_TXP1__DBG_15 7
+#define PAD_MIPI_TXM0__SPI3_SCK 0
+#define PAD_MIPI_TXM0__VI0_D_9 1
+#define PAD_MIPI_TXM0__IIS1_DI 2
+#define PAD_MIPI_TXM0__XGPIOC_12 3
+#define PAD_MIPI_TXM0__CAM_MCLK1 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__CAM_VS0 6
+#define PAD_MIPI_TXM0__DBG_12 7
+#define PAD_MIPI_TXP0__SPI3_CS_X 0
+#define PAD_MIPI_TXP0__VI0_D_10 1
+#define PAD_MIPI_TXP0__IIS1_BCLK 2
+#define PAD_MIPI_TXP0__XGPIOC_13 3
+#define PAD_MIPI_TXP0__CAM_MCLK0 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__CAM_HS0 6
+#define PAD_MIPI_TXP0__DBG_13 7
+#define PKG_TYPE0__PKG_TYPE0 0
+#define PKG_TYPE1__PKG_TYPE1 0
+#define PKG_TYPE2__PKG_TYPE2 0
+#define PAD_AUD_AINL_MIC__XGPIOC_23 3
+#define PAD_AUD_AINL_MIC__IIS1_BCLK 4
+#define PAD_AUD_AINL_MIC__IIS2_BCLK 5
+#define PAD_AUD_AINR_MIC__XGPIOC_22 3
+#define PAD_AUD_AINR_MIC__IIS1_DO 4
+#define PAD_AUD_AINR_MIC__IIS2_DI 5
+#define PAD_AUD_AINR_MIC__IIS1_DI 6
+#define PAD_AUD_AOUTL__XGPIOC_25 3
+#define PAD_AUD_AOUTL__IIS1_LRCK 4
+#define PAD_AUD_AOUTL__IIS2_LRCK 5
+#define PAD_AUD_AOUTR__XGPIOC_24 3
+#define PAD_AUD_AOUTR__IIS1_DI 4
+#define PAD_AUD_AOUTR__IIS2_DO 5
+#define PAD_AUD_AOUTR__IIS1_DO 6
+
+#endif /* __CV180X_PINLIST_SWCONFIG_H__ */
diff --git a/board/cvitek/cv180x/cv180x_reg.h b/board/cvitek/cv180x/cv180x_reg.h
new file mode 100644
index 000000000..b6fe5599a
--- /dev/null
+++ b/board/cvitek/cv180x/cv180x_reg.h
@@ -0,0 +1,186 @@
+#ifndef __CV180X_REG_H__
+#define __CV180X_REG_H__
+
+#define TOP_BASE        0x03000000
+#define PINMUX_BASE     (TOP_BASE + 0x1000)
+#define WATCHDOG_BASE   (TOP_BASE + 0x00010000)
+#define RTC_BASE   0x05026000
+
+/*
+ * RTC info registers
+ */
+#define RTC_INFO0 (RTC_BASE + 0x1C)
+
+/*
+ * General purpose registers
+ */
+#define GP_REG0 (TOP_BASE + 0x80)
+#define GP_REG1 (TOP_BASE + 0x84)
+#define GP_REG2 (TOP_BASE + 0x88
+#define GP_REG3 (TOP_BASE + 0x8C)
+#define GP_REG4 (TOP_BASE + 0x90)
+#define GP_REG5 (TOP_BASE + 0x94)
+#define GP_REG6 (TOP_BASE + 0x98)
+#define GP_REG7 (TOP_BASE + 0x9C)
+#define GP_REG8 (TOP_BASE + 0xA0)
+#define GP_REG9 (TOP_BASE + 0xA4)
+#define GP_REG10 (TOP_BASE + 0xA8)
+
+/*
+ * Pinmux definitions
+ */
+#define PINMUX_UART0    0
+#define PINMUX_UART1    1
+#define PINMUX_UART2    2
+#define PINMUX_UART3    3
+#define PINMUX_UART3_2  4
+#define PINMUX_I2C0     5
+#define PINMUX_I2C1     6
+#define PINMUX_I2C2     7
+#define PINMUX_I2C3     8
+#define PINMUX_I2C4     9
+#define PINMUX_I2C4_2   10
+#define PINMUX_SPI0     11
+#define PINMUX_SPI1     12
+#define PINMUX_SPI2     13
+#define PINMUX_SPI2_2   14
+#define PINMUX_SPI3     15
+#define PINMUX_SPI3_2   16
+#define PINMUX_I2S0     17
+#define PINMUX_I2S1     18
+#define PINMUX_I2S2     19
+#define PINMUX_I2S3     20
+#define PINMUX_USBID    21
+#define PINMUX_SDIO0    22
+#define PINMUX_SDIO1    23
+#define PINMUX_ND       24
+#define PINMUX_EMMC     25
+#define PINMUX_SPI_NOR  26
+#define PINMUX_SPI_NAND 27
+#define PINMUX_CAM0     28
+#define PINMUX_CAM1     29
+#define PINMUX_PCM0     30
+#define PINMUX_PCM1     31
+#define PINMUX_CSI0     32
+#define PINMUX_CSI1     33
+#define PINMUX_CSI2     34
+#define PINMUX_DSI      35
+#define PINMUX_VI0      36
+#define PINMUX_VO       37
+#define PINMUX_RMII1    38
+#define PINMUX_EPHY_LED 39
+#define PINMUX_I80      40
+#define PINMUX_LVDS     41
+#define PINMUX_USB     42
+
+#define PINMUX_USB_VBUS_DET     (PINMUX_BASE + 0x108)
+
+#define REG_TOP_USB_ECO			(TOP_BASE + 0xB4)
+#define BIT_TOP_USB_ECO_RX_FLUSH	0x80
+/* rst */
+#define REG_TOP_SOFT_RST        0x3000
+#define BIT_TOP_SOFT_RST_USB    BIT(11)
+#define BIT_TOP_SOFT_RST_SDIO   BIT(14)
+#define BIT_TOP_SOFT_RST_NAND   BIT(12)
+
+#define REG_TOP_USB_CTRSTS	(TOP_BASE + 0x38)
+
+#define REG_TOP_CONF_INFO		(TOP_BASE + 0x4)
+#define BIT_TOP_CONF_INFO_VBUS		BIT(9)
+#define REG_TOP_USB_PHY_CTRL		(TOP_BASE + 0x48)
+#define BIT_TOP_USB_PHY_CTRL_EXTVBUS	BIT(0)
+#define USB_PHY_ID_OVERRIDE_ENABLE	BIT(6)
+#define USB_PHY_ID_VALUE		BIT(7)
+#define REG_TOP_DDR_ADDR_MODE		(TOP_BASE + 0x64)
+
+/* irq */
+#define IRQ_LEVEL   0
+#define IRQ_EDGE    3
+
+/* usb */
+#define USB_BASE            0x04340000
+
+/* ethernet phy */
+#define ETH_PHY_BASE        0x03009000
+#define ETH_PHY_INIT_MASK   0xFFFFFFF9
+#define ETH_PHY_SHUTDOWN    BIT(1)
+#define ETH_PHY_POWERUP     0xFFFFFFFD
+#define ETH_PHY_RESET       0xFFFFFFFB
+#define ETH_PHY_RESET_N     BIT(2)
+#define ETH_PHY_LED_LOW_ACTIVE  BIT(3)
+
+/* watchdog */
+#define CONFIG_DW_WDT_BASE WATCHDOG_BASE
+#define CONFIG_DW_WDT_CLOCK_KHZ	25000
+
+#define DW_WDT_CR	0x00
+#define DW_WDT_TORR	0x04
+#define DW_WDT_CRR	0x0C
+
+#define DW_WDT_CR_EN_OFFSET	0x00
+#define DW_WDT_CR_RMOD_OFFSET	0x01
+#define DW_WDT_CR_RMOD_VAL	0x00
+#define DW_WDT_CRR_RESTART_VAL	0x76
+
+/* SDIO Wifi */
+#define WIFI_CHIP_EN_BGA    BIT(18)
+#define WIFI_CHIP_EN_QFN    BIT(2)
+
+/* RTC */
+#define RTC_SYS_BASE		0x05000000
+#define RTC_MACRO_BASE		(RTC_SYS_BASE + 0x00026400)
+#define RTC_MACRO_DA_SOC_READY		0x8C
+#define RTC_MACRO_RO_T		0xA8
+#define RTC_CORE_SRAM_BASE	(RTC_SYS_BASE + 0x00026800)
+#define RTC_CORE_SRAM_SIZE	0x0800 // 2KB
+
+#define REG_RTC_CTRL_BASE	(RTC_SYS_BASE + 0x00025000)
+#define RTC_CTRL0_UNLOCKKEY	0x4
+#define RTC_CTRL0		0x8
+#define RTC_CTRL0_STATUS0		0xC
+#define RTCSYS_RST_CTRL	0x18
+
+#define REG_RTC_BASE		(RTC_SYS_BASE + 0x00026000)
+#define RTC_EN_PWR_WAKEUP	0xBC
+#define RTC_EN_SHDN_REQ	0xC0
+#define RTC_EN_PWR_CYC_REQ	0xC8
+#define RTC_EN_WARM_RST_REQ	0xCC
+#define RTC_EN_WDT_RST_REQ	0xE0
+#define RTC_EN_SUSPEND_REQ	0xE4
+#define RTC_PG_REG		0xF0
+#define RTC_ST_ON_REASON	0xF8
+
+#define REG_RTC_ST_ON_REASON	(REG_RTC_BASE + RTC_ST_ON_REASON)
+
+#define RTCSYS_F32KLESS_BASE		(RTC_SYS_BASE + 0x0002A000)
+
+#define RTC_INTERNAL_32K	0
+#define RTC_EXTERNAL_32K	1
+
+/* eFuse  */
+#define EFUSE_BASE (TOP_BASE + 0x00050000)
+
+/* AXI SRAM */
+#define AXI_SRAM_BASE 0x0E000000
+#define AXI_SRAM_SIZE 0x40
+
+#define EFUSE_SW_INFO_ADDR (AXI_SRAM_BASE)
+#define EFUSE_SW_INFO_SIZE 4
+
+#define BOOT_SOURCE_FLAG_ADDR (EFUSE_SW_INFO_ADDR + EFUSE_SW_INFO_SIZE)
+#define BOOT_SOURCE_FLAG_SIZE 4
+#define MAGIC_NUM_USB_DL 0x4D474E31 // MGN1
+#define MAGIC_NUM_SD_DL 0x4D474E32 // MGN2
+
+#define BOOT_LOG_LEN_ADDR (BOOT_SOURCE_FLAG_ADDR + BOOT_SOURCE_FLAG_SIZE) // 0x0E000008
+#define BOOT_LOG_LEN_SIZE 4
+
+#define TIME_RECORDS_ADDR (AXI_SRAM_BASE + 0x10) // 0x0E000010
+
+/* from fsbl/plat/cv180x/include/platform_def.h struct _time_records { ... } */
+#define TIME_RECORDS_FIELD_UBOOT_START (TIME_RECORDS_ADDR + 0x10)
+#define TIME_RECORDS_FIELD_BOOTCMD_START (TIME_RECORDS_ADDR + 0x12)
+#define TIME_RECORDS_FIELD_DECOMPRESS_KERNEL_START (TIME_RECORDS_ADDR + 0x14)
+#define TIME_RECORDS_FIELD_KERNEL_START (TIME_RECORDS_ADDR + 0x16)
+
+#endif /* __CV180X_REG_H__ */
diff --git a/board/cvitek/cv180x/cv180x_reg_fmux_gpio.h b/board/cvitek/cv180x/cv180x_reg_fmux_gpio.h
new file mode 100644
index 000000000..a07236fba
--- /dev/null
+++ b/board/cvitek/cv180x/cv180x_reg_fmux_gpio.h
@@ -0,0 +1,337 @@
+// $Module: fmux_gpio $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: ghost $
+// $Date: Thu, 17 Mar 2022 04:53:31 PM $
+//
+
+//GEN REG ADDR/OFFSET/MASK
+
+#ifndef __CV180X_REG_FMUX_GPIO_H__
+#define __CV180X_REG_FMUX_GPIO_H__
+
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CLK  0x0
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CMD  0x4
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D0  0x8
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D1  0xc
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D2  0x10
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D3  0x14
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CD  0x18
+#define  FMUX_GPIO_REG_IOCTRL_SD0_PWR_EN  0x1c
+#define  FMUX_GPIO_REG_IOCTRL_SPK_EN  0x20
+#define  FMUX_GPIO_REG_IOCTRL_UART0_TX  0x24
+#define  FMUX_GPIO_REG_IOCTRL_UART0_RX  0x28
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_HOLD_X  0x2c
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_SCK  0x30
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_MOSI  0x34
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_WP_X  0x38
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_MISO  0x3c
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_CS_X  0x40
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TMS  0x44
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TCK  0x48
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SCL  0x4c
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SDA  0x50
+#define  FMUX_GPIO_REG_IOCTRL_AUX0  0x54
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_ZQ  0x58
+#define  FMUX_GPIO_REG_IOCTRL_PWR_VBAT_DET  0x5c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_RSTN  0x60
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ1  0x64
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ2  0x68
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP0  0x6c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_BUTTON1  0x70
+#define  FMUX_GPIO_REG_IOCTRL_XTAL_XIN  0x74
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO0  0x78
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO1  0x7c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO2  0x80
+#define  FMUX_GPIO_REG_IOCTRL_SD1_GPIO1  0x84
+#define  FMUX_GPIO_REG_IOCTRL_SD1_GPIO0  0x88
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D3  0x8c
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D2  0x90
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D1  0x94
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D0  0x98
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CMD  0x9c
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CLK  0xa0
+#define  FMUX_GPIO_REG_IOCTRL_PWM0_BUCK  0xa4
+#define  FMUX_GPIO_REG_IOCTRL_ADC1  0xa8
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_DET  0xac
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MISO  0xb0
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MOSI  0xb4
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_CS  0xb8
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_SCK  0xbc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXP  0xc0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXM  0xc4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXP  0xc8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXM  0xcc
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_RTX  0xd0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4N  0xd4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4P  0xd8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3N  0xdc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3P  0xe0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2N  0xe4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2P  0xe8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1N  0xec
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1P  0xf0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0N  0xf4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0P  0xf8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM2  0xfc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP2  0x100
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM1  0x104
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP1  0x108
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM0  0x10c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP0  0x110
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE0  0x114
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE1  0x118
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE2  0x11c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINL_MIC  0x120
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINR_MIC  0x124
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTL  0x128
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTR  0x12c
+#define  FMUX_GPIO_REG_DEVMATRIX_UART0_IP_SEL  0x1d4
+#define  FMUX_GPIO_REG_DEVMATRIX_UART1_IP_SEL  0x1d8
+#define  FMUX_GPIO_REG_DEVMATRIX_UART2_IP_SEL  0x1dc
+#define  FMUX_GPIO_REG_DEVMATRIX_UART3_IP_SEL  0x1e0
+#define  FMUX_GPIO_REG_DEVMATRIX_UART4_IP_SEL  0x1e4
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK   0x0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD   0x4
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D0   0x8
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D1   0xc
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D2   0x10
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D3   0x14
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CD   0x18
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN   0x1c
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPK_EN   0x20
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_TX   0x24
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_RX   0x28
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_HOLD_X   0x2c
+#define  FMUX_GPIO_FUNCSEL_SPINOR_HOLD_X_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_HOLD_X_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_SCK   0x30
+#define  FMUX_GPIO_FUNCSEL_SPINOR_SCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_SCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MOSI   0x34
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MOSI_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MOSI_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_WP_X   0x38
+#define  FMUX_GPIO_FUNCSEL_SPINOR_WP_X_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_WP_X_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MISO   0x3c
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MISO_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MISO_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_CS_X   0x40
+#define  FMUX_GPIO_FUNCSEL_SPINOR_CS_X_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_CS_X_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS   0x44
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK   0x48
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL   0x4c
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA   0x50
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_AUX0   0x54
+#define  FMUX_GPIO_FUNCSEL_AUX0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_AUX0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ   0x58
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET   0x5c
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN   0x60
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1   0x64
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2   0x68
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0   0x6c
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1   0x70
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN   0x74
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0   0x78
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1   0x7c
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2   0x80
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO1   0x84
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO0   0x88
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D3   0x8c
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D2   0x90
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D1   0x94
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D0   0x98
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD   0x9c
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK   0xa0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK   0xa4
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC1   0xa8
+#define  FMUX_GPIO_FUNCSEL_ADC1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET   0xac
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO   0xb0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI   0xb4
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS   0xb8
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK   0xbc
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP   0xc0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM   0xc4
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP   0xc8
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM   0xcc
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX   0xd0
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N   0xd4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P   0xd8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N   0xdc
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P   0xe0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N   0xe4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P   0xe8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N   0xec
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P   0xf0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N   0xf4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P   0xf8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2   0xfc
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2   0x100
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1   0x104
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1   0x108
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0   0x10c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0   0x110
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0   0x114
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1   0x118
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2   0x11c
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC   0x120
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC   0x124
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL   0x128
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR   0x12c
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_MASK   0x7
+#define  FMUX_GPIO_MUX_UART0_IP_SEL   0x1d4
+#define  FMUX_GPIO_MUX_UART0_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART0_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART1_IP_SEL   0x1d8
+#define  FMUX_GPIO_MUX_UART1_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART1_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART2_IP_SEL   0x1dc
+#define  FMUX_GPIO_MUX_UART2_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART2_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART3_IP_SEL   0x1e0
+#define  FMUX_GPIO_MUX_UART3_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART3_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART4_IP_SEL   0x1e4
+#define  FMUX_GPIO_MUX_UART4_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART4_IP_SEL_MASK   0x7
+
+#endif /* __CV180X_REG_FMUX_GPIO_H__ */
diff --git a/board/cvitek/cv180x/sdhci_reg.h b/board/cvitek/cv180x/sdhci_reg.h
new file mode 100644
index 000000000..e0bbc2cf9
--- /dev/null
+++ b/board/cvitek/cv180x/sdhci_reg.h
@@ -0,0 +1,130 @@
+#ifndef _SDHCI_REG_H
+#define _SDHCI_REG_H
+#include "cv180x_reg.h"
+#define REG_TOP_SD_PWRSW_CTRL (0x1F4)
+
+#define REG_SDIO0_PAD_MASK (0xFFFFFFF3)
+#define REG_SDIO0_PAD_SHIFT (2)
+
+#define REG_SDIO0_PAD_CLR_MASK (0xC)
+#define REG_SDIO0_CD_PAD_REG (PINMUX_BASE + 0x900)
+#define REG_SDIO0_CD_PAD_VALUE (1)
+#define REG_SDIO0_CD_PAD_RESET (1)
+
+#define REG_SDIO0_PWR_EN_PAD_REG (PINMUX_BASE + 0x904)
+#define REG_SDIO0_PWR_EN_PAD_VALUE (2)
+#define REG_SDIO0_PWR_EN_PAD_RESET (2)
+
+#define REG_SDIO0_CLK_PAD_REG (PINMUX_BASE + 0xA00)
+#define REG_SDIO0_CLK_PAD_VALUE (2)
+#define REG_SDIO0_CLK_PAD_RESET (2)
+
+#define REG_SDIO0_CMD_PAD_REG (PINMUX_BASE + 0xA04)
+#define REG_SDIO0_CMD_PAD_VALUE (1)
+#define REG_SDIO0_CMD_PAD_RESET (2)
+
+#define REG_SDIO0_DAT0_PAD_REG (PINMUX_BASE + 0xA08)
+#define REG_SDIO0_DAT0_PAD_VALUE (1)
+#define REG_SDIO0_DAT0_PAD_RESET (2)
+
+#define REG_SDIO0_DAT1_PAD_REG (PINMUX_BASE + 0xA0C)
+#define REG_SDIO0_DAT1_PAD_VALUE (1)
+#define REG_SDIO0_DAT1_PAD_RESET (2)
+
+#define REG_SDIO0_DAT2_PAD_REG (PINMUX_BASE + 0xA10)
+#define REG_SDIO0_DAT2_PAD_VALUE (1)
+#define REG_SDIO0_DAT2_PAD_RESET (2)
+
+#define REG_SDIO0_DAT3_PAD_REG (PINMUX_BASE + 0xA14)
+#define REG_SDIO0_DAT3_PAD_VALUE (1)
+#define REG_SDIO0_DAT3_PAD_RESET (2)
+
+#define PAD_SDIO0_CD_REG (PINMUX_BASE + 0x18)
+#define PAD_SDIO0_PWR_EN_REG (PINMUX_BASE + 0x1C)
+#define PAD_SDIO0_CLK_REG (PINMUX_BASE + 0x0)
+#define PAD_SDIO0_CMD_REG (PINMUX_BASE + 0x4)
+#define PAD_SDIO0_D0_REG (PINMUX_BASE + 0x8)
+#define PAD_SDIO0_D1_REG (PINMUX_BASE + 0xC)
+#define PAD_SDIO0_D2_REG (PINMUX_BASE + 0x10)
+#define PAD_SDIO0_D3_REG (PINMUX_BASE + 0x14)
+
+#define REG_SDIO1_PAD_MASK (0xFFFFFFF3)
+#define REG_SDIO1_PAD_SHIFT (2)
+
+#define SDIO1_PAD_BASE 0x05027000
+#define REG_SDIO1_PAD_CLR_MASK (0xC)
+#define REG_SDIO1_CLK_PAD_REG (SDIO1_PAD_BASE + 0x06C)
+#define REG_SDIO1_CLK_PAD_VALUE (2)
+
+#define REG_SDIO1_CMD_PAD_REG (SDIO1_PAD_BASE + 0x068)
+#define REG_SDIO1_CMD_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT0_PAD_REG (SDIO1_PAD_BASE + 0x064)
+#define REG_SDIO1_DAT0_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT2_PAD_REG (SDIO1_PAD_BASE + 0x05C)
+#define REG_SDIO1_DAT2_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT1_PAD_REG (SDIO1_PAD_BASE + 0x060)
+#define REG_SDIO1_DAT1_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT3_PAD_REG (SDIO1_PAD_BASE + 0x058)
+#define REG_SDIO1_DAT3_PAD_VALUE (1)
+
+#define REG_EMMC_PAD_CLR_MASK (0xC)
+#define REG_EMMC_PAD_SHIFT (2)
+
+#define REG_EMMC_RSTN_PAD_REG (PINMUX_BASE + 0x914)
+#define REG_EMMC_RSTN_PAD_VALUE (1)
+
+#define REG_EMMC_CLK_PAD_REG (PINMUX_BASE + 0x91c)
+#define REG_EMMC_CLK_PAD_VALUE (2)
+
+#define REG_EMMC_CMD_PAD_REG (PINMUX_BASE + 0x928)
+#define REG_EMMC_CMD_PAD_VALUE (1)
+
+#define REG_EMMC_DAT0_PAD_REG (PINMUX_BASE + 0x920)
+#define REG_EMMC_DAT0_PAD_VALUE (1)
+
+#define REG_EMMC_DAT1_PAD_REG (PINMUX_BASE + 0x92C)
+#define REG_EMMC_DAT1_PAD_VALUE (1)
+
+#define REG_EMMC_DAT2_PAD_REG (PINMUX_BASE + 0x918)
+#define REG_EMMC_DAT2_PAD_VALUE (1)
+
+#define REG_EMMC_DAT3_PAD_REG (PINMUX_BASE + 0x924)
+#define REG_EMMC_DAT3_PAD_VALUE (1)
+
+#define CVI_SDHCI_VENDOR_OFFSET 0x200
+#define CVI_SDHCI_PHY_TX_RX_DLY	(CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_PHY_DS_DLY	(CVI_SDHCI_VENDOR_OFFSET + 0x44)
+#define CVI_SDHCI_PHY_DLY_STS	(CVI_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_SDHCI_PHY_CONFIG	(CVI_SDHCI_VENDOR_OFFSET + 0x4C)
+
+#define CVI_SDHCI_BIT_CLK_FREE_EN 2
+#define CVI_SDHCI_CLK_FREE_EN_VALUE 0
+#define CVI_SDHCI_CLK_FREE_EN_MASK 0xFFFFFFFB
+#define CVI_SDHCI_VENDOR_MSHC_CTRL_R (CVI_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_SDHCI_PHY_RX_DLY_SHIFT 16
+// Bit 16~22
+#define CVI_SDHCI_PHY_RX_DLY_MASK 0x7F0000
+#define CVI_SDHCI_PHY_TX_RX_DLY (CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_PHY_RX_SRC_BIT_1 24
+#define CVI_SDHCI_PHY_RX_SRC_BIT_2 25
+
+#define SDHCI_PHY_CONFIG                                                       \
+	(CVI_SDHCI_VENDOR_OFFSET +                                             \
+	 0x4C) // P_VERDOR_SPECIFIC_AREA + 0x4c0x24c( PHY_TX_BPS )
+#define REG_TX_BPS_SEL_MASK 0xFFFFFFFE
+#define REG_TX_BPS_SEL_CLR_MASK (0x1) // 0x24c  PHY_TX_BPS
+#define REG_TX_BPS_SEL_SHIFT (0) // 0x24c  PHY_TX_BPS
+#define REG_TX_BPS_SEL_BYPASS (1) // 0x24c PHY_TX_BPS inv
+
+#define MMC_MAX_CLOCK (375000000)
+#define MMC_MAX_CLOCK_DIV_VALUE (0x40009)
+#define CLOCK_BYPASS_SELECT_REGISTER (0x3002030)
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#endif
diff --git a/board/cvitek/cv181x/Kconfig b/board/cvitek/cv181x/Kconfig
new file mode 100644
index 000000000..64722d032
--- /dev/null
+++ b/board/cvitek/cv181x/Kconfig
@@ -0,0 +1,73 @@
+if TARGET_CVITEK_CV181X
+
+choice
+	prompt "Cvitek CV181X verification platform type select"
+
+config TARGET_CVITEK_CV181X_ASIC
+	bool "ASIC"
+	help
+	  This enables support for Cvitek's CV181X SoC on ASIC platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV181X_PALLADIUM
+	bool "Palladium"
+	help
+	  This enables support for Cvitek's CV181X SoC on PALLADIUM platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV181X_FPGA
+	bool "FPGA"
+	help
+	  This enables support for Cvitek's CV181X SoC on FPGA platform.
+
+	  If unsure, say N.
+
+endchoice
+
+config SYS_BOARD
+	default "cv181x"
+
+config SYS_VENDOR
+	default "cvitek"
+
+config SYS_CPU
+	default "generic"
+
+config SYS_CONFIG_NAME
+	default "cv181x-asic" if TARGET_CVITEK_CV181X_ASIC
+	default "cv181x-palladium" if TARGET_CVITEK_CV181X_PALLADIUM
+	default "cv181x-fpga" if TARGET_CVITEK_CV181X_FPGA
+
+config CVITEK_SPI_FLASH
+    bool
+	prompt "Support CVITEK SPINOR"
+    select SPI_FLASH
+	select DM
+	select DM_SPI
+	select DM_SPI_FLASH
+	select SPI_MEM
+	select CMD_SF
+    select CVI_SPIF
+
+config ENV_SIZE
+    default 0x10000 if ENV_IS_IN_SPI_FLASH
+    default 0x20000 if ENV_IS_IN_MMC
+	default 0x20000 if ENV_IS_IN_NAND
+
+config ENV_SECT_SIZE
+	default 0x10000 if ENV_IS_IN_SPI_FLASH
+	default 0x40000 if ENV_IS_IN_MMC
+	default 0x20000 if ENV_IS_IN_NAND
+
+config ENV_OFFSET
+    default 0x3A0000 if ENV_IS_IN_SPI_FLASH
+    default 0x880000 if ENV_IS_IN_MMC
+	default 0xae0000 if ENV_IS_IN_NAND
+
+config ENV_OFFSET_REDUND
+    default 0x3B0000 if ENV_IS_IN_SPI_FLASH
+	default 0xb00000 if ENV_IS_IN_NAND
+
+endif
diff --git a/board/cvitek/cv181x/MAINTAINERS b/board/cvitek/cv181x/MAINTAINERS
new file mode 100644
index 000000000..f8fabe2e8
--- /dev/null
+++ b/board/cvitek/cv181x/MAINTAINERS
@@ -0,0 +1,4 @@
+CV1822 BOARD
+M:	Myles Tsai <myles.tsai@wisecore.com.tw>
+S:	Maintained
+F:	board/armltd/vexpress64/
diff --git a/board/cvitek/cv181x/Makefile b/board/cvitek/cv181x/Makefile
new file mode 100644
index 000000000..da8bfb2ae
--- /dev/null
+++ b/board/cvitek/cv181x/Makefile
@@ -0,0 +1,2 @@
+
+obj-y	:= board.o
diff --git a/board/cvitek/cv181x/board.c b/board/cvitek/cv181x/board.c
new file mode 100644
index 000000000..886b23eee
--- /dev/null
+++ b/board/cvitek/cv181x/board.c
@@ -0,0 +1,286 @@
+/*
+ * (C) Copyright 2013
+ * David Feng <fenghua@phytium.com.cn>
+ * Sharma Bhupesh <bhupesh.sharma@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#if defined(__aarch64__)
+#include <asm/armv8/mmu.h>
+#endif
+#include <usb/dwc2_udc.h>
+#include <usb.h>
+#include "cv181x_reg.h"
+#include "mmio.h"
+#include "cv181x_reg_fmux_gpio.h"
+#include "cv181x_pinlist_swconfig.h"
+#include <linux/delay.h>
+#include <bootstage.h>
+
+#if defined(__riscv)
+#include <asm/csr.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+#define SD1_SDIO_PAD
+
+#if defined(__aarch64__)
+static struct mm_region cv181x_mem_map[] = {
+	{
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		.virt = PHYS_SDRAM_1,
+		.phys = PHYS_SDRAM_1,
+		.size = PHYS_SDRAM_1_SIZE,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = cv181x_mem_map;
+#endif
+
+// #define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) printf ("%s\n", PIN_NAME ##_ ##FUNC_NAME);
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + FMUX_GPIO_FUNCSEL_##PIN_NAME, \
+			FMUX_GPIO_FUNCSEL_##PIN_NAME##_MASK << FMUX_GPIO_FUNCSEL_##PIN_NAME##_OFFSET, \
+			PIN_NAME##__##FUNC_NAME)
+
+void pinmux_config(int io_type)
+{
+		switch (io_type) {
+		case PINMUX_UART0:
+			PINMUX_CONFIG(UART0_RX, UART0_RX);
+			PINMUX_CONFIG(UART0_TX, UART0_TX);
+		break;
+		case PINMUX_SDIO0:
+			PINMUX_CONFIG(SD0_CD, SDIO0_CD);
+			PINMUX_CONFIG(SD0_PWR_EN, SDIO0_PWR_EN);
+			PINMUX_CONFIG(SD0_CMD, SDIO0_CMD);
+			PINMUX_CONFIG(SD0_CLK, SDIO0_CLK);
+			PINMUX_CONFIG(SD0_D0, SDIO0_D_0);
+			PINMUX_CONFIG(SD0_D1, SDIO0_D_1);
+			PINMUX_CONFIG(SD0_D2, SDIO0_D_2);
+			PINMUX_CONFIG(SD0_D3, SDIO0_D_3);
+			break;
+		case PINMUX_SDIO1:
+#if defined(SD1_SDIO_PAD)
+			/*
+			 * Name            Address            SD1  MIPI
+			 * reg_sd1_phy_sel REG_0x300_0294[10] 0x0  0x1
+			 */
+			mmio_write_32(TOP_BASE + 0x294,
+				      (mmio_read_32(TOP_BASE + 0x294) & 0xFFFFFBFF));
+			PINMUX_CONFIG(SD1_CMD, PWR_SD1_CMD_VO36);
+			PINMUX_CONFIG(SD1_CLK, PWR_SD1_CLK_VO37);
+			PINMUX_CONFIG(SD1_D0, PWR_SD1_D0_VO35);
+			PINMUX_CONFIG(SD1_D1, PWR_SD1_D1_VO34);
+			PINMUX_CONFIG(SD1_D2, PWR_SD1_D2_VO33);
+			PINMUX_CONFIG(SD1_D3, PWR_SD1_D3_VO32);
+#elif defined(SD1_MIPI_PAD)
+			/*
+			 * Name            Address            SD1  MIPI
+			 * reg_sd1_phy_sel REG_0x300_0294[10] 0x0  0x1
+			 */
+			mmio_write_32(TOP_BASE + 0x294,
+				      (mmio_read_32(TOP_BASE + 0x294) & 0xFFFFFBFF) | BIT(10));
+			PINMUX_CONFIG(PAD_MIPI_TXM4, SD1_CLK);
+			PINMUX_CONFIG(PAD_MIPI_TXP4, SD1_CMD);
+			PINMUX_CONFIG(PAD_MIPI_TXM3, SD1_D0);
+			PINMUX_CONFIG(PAD_MIPI_TXP3, SD1_D1);
+			PINMUX_CONFIG(PAD_MIPI_TXM2, SD1_D2);
+			PINMUX_CONFIG(PAD_MIPI_TXP2, SD1_D3);
+#endif
+			break;
+		case PINMUX_EMMC:
+			PINMUX_CONFIG(EMMC_CLK, EMMC_CLK);
+			PINMUX_CONFIG(EMMC_RSTN, EMMC_RSTN);
+			PINMUX_CONFIG(EMMC_CMD, EMMC_CMD);
+			PINMUX_CONFIG(EMMC_DAT1, EMMC_DAT_1);
+			PINMUX_CONFIG(EMMC_DAT0, EMMC_DAT_0);
+			PINMUX_CONFIG(EMMC_DAT2, EMMC_DAT_2);
+			PINMUX_CONFIG(EMMC_DAT3, EMMC_DAT_3);
+			break;
+		case PINMUX_SPI_NAND:
+			PINMUX_CONFIG(EMMC_DAT2, SPINAND_HOLD);
+			PINMUX_CONFIG(EMMC_CLK, SPINAND_CLK);
+			PINMUX_CONFIG(EMMC_DAT0, SPINAND_MOSI);
+			PINMUX_CONFIG(EMMC_DAT3, SPINAND_WP);
+			PINMUX_CONFIG(EMMC_CMD, SPINAND_MISO);
+			PINMUX_CONFIG(EMMC_DAT1, SPINAND_CS);
+		break;
+		default:
+			break;
+	}
+}
+
+#include "../cvi_board_init.c"
+
+#if defined(CONFIG_PHY_CVITEK_CV182XA) /* config cvitek cv182xa eth internal phy on ASIC board */
+static void cv182xa_ephy_id_init(void)
+{
+	// set rg_ephy_apb_rw_sel 0x0804@[0]=1/APB by using APB interface
+	mmio_write_32(0x03009804, 0x0001);
+
+	// Release 0x0800[0]=0/shutdown
+	mmio_write_32(0x03009800, 0x0900);
+
+	// Release 0x0800[2]=1/dig_rst_n, Let mii_reg can be accessabile
+	mmio_write_32(0x03009800, 0x0904);
+
+	// PHY_ID
+	mmio_write_32(0x03009008, 0x0043);
+	mmio_write_32(0x0300900c, 0x5649);
+
+	// switch to MDIO control by ETH_MAC
+	mmio_write_32(0x03009804, 0x0000);
+}
+#endif
+
+void cpu_pwr_ctrl(void)
+{
+#if defined(CONFIG_RISCV)
+	mmio_write_32(0x01901008, 0x30001);// cortexa53_pwr_iso_en
+#elif defined(CONFIG_ARM)
+	mmio_write_32(0x01901004, 0x30001);// c906_top_pwr_iso_en
+#endif
+}
+
+int board_init(void)
+{
+	extern volatile uint32_t BOOT0_START_TIME;
+	uint16_t start_time = DIV_ROUND_UP(BOOT0_START_TIME, SYS_COUNTER_FREQ_IN_SECOND / 1000);
+
+	// Save uboot start time. time is from boot0.h
+	mmio_write_16(TIME_RECORDS_FIELD_UBOOT_START, start_time);
+
+	cpu_pwr_ctrl();
+
+#if defined(CONFIG_PHY_CVITEK_CV182XA) /* config cvitek cv182xa eth internal phy on ASIC board */
+	cv182xa_ephy_id_init();
+#endif
+
+#if defined(CONFIG_NAND_SUPPORT)
+	pinmux_config(PINMUX_SPI_NAND);
+#elif defined(CONFIG_SPI_FLASH)
+	pinmux_config(PINMUX_SPI_NOR);
+#elif defined(CONFIG_EMMC_SUPPORT)
+	pinmux_config(PINMUX_EMMC);
+#endif
+	pinmux_config(PINMUX_SDIO1);
+	cvi_board_init();
+	return 0;
+}
+
+#if defined(__aarch64__)
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+#endif
+
+#ifdef CV_SYS_OFF
+static void cv_system_off(void)
+{
+	mmio_write_32(REG_RTC_BASE + RTC_EN_SHDN_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_SHDN_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_CTRL0, 0xFFFF0800 | (0x1 << 0));
+
+	while (1)
+		;
+}
+#endif
+
+void cv_system_reset(void)
+{
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_CTRL0, 0xFFFF0800 | (0x1 << 4));
+
+	while (1)
+		;
+}
+
+/*
+ * Board specific reset that is system reset.
+ */
+void reset_cpu(void)
+{
+	cv_system_reset();
+}
+
+#ifdef CONFIG_USB_GADGET_DWC2_OTG
+struct dwc2_plat_otg_data cv182x_otg_data = {
+	.regs_otg = USB_BASE,
+	.usb_gusbcfg    = 0x40081400,
+	.rx_fifo_sz     = 512,
+	.np_tx_fifo_sz  = 512,
+	.tx_fifo_sz     = 512,
+};
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	uint32_t value;
+
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) & (~BIT_TOP_SOFT_RST_USB);
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+	udelay(50);
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) | BIT_TOP_SOFT_RST_USB;
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+
+	/* Set USB phy configuration */
+	value = mmio_read_32(REG_TOP_USB_PHY_CTRL);
+	mmio_write_32(REG_TOP_USB_PHY_CTRL, value | BIT_TOP_USB_PHY_CTRL_EXTVBUS
+					| USB_PHY_ID_OVERRIDE_ENABLE
+					| USB_PHY_ID_VALUE);
+
+	/* Enable ECO RXF */
+	mmio_write_32(REG_TOP_USB_ECO, mmio_read_32(REG_TOP_USB_ECO) | BIT_TOP_USB_ECO_RX_FLUSH);
+
+	printf("cvi_usb_hw_init done\n");
+
+	return dwc2_udc_probe(&cv182x_otg_data);
+}
+#endif
+
+void board_save_time_record(uintptr_t saveaddr)
+{
+	uint64_t boot_us = 0;
+#if defined(__aarch64__)
+	boot_us = timer_get_boot_us();
+#elif defined(__riscv)
+	// Read from CSR_TIME directly. RISC-V timers is initialized later.
+	boot_us = csr_read(CSR_TIME) / (SYS_COUNTER_FREQ_IN_SECOND / 1000000);
+#else
+#error "Unknown ARCH"
+#endif
+
+	mmio_write_16(saveaddr, DIV_ROUND_UP(boot_us, 1000));
+}
diff --git a/board/cvitek/cv181x/cv181x_pinlist_swconfig.h b/board/cvitek/cv181x/cv181x_pinlist_swconfig.h
new file mode 100644
index 000000000..2fe0849d2
--- /dev/null
+++ b/board/cvitek/cv181x/cv181x_pinlist_swconfig.h
@@ -0,0 +1,674 @@
+//##==============================================================================
+//##=== This script is generate by genswconfig.pl from .\00_cv181x_Pinlist_20210827.xls
+//##=== Generate Time stamp is : 2021-08-27 20:43:11
+//##==============================================================================
+
+#ifndef __CV181X_PINLIST_SWCONFIG_H__
+#define __CV181X_PINLIST_SWCONFIG_H__
+
+#define CAM_MCLK0__CAM_MCLK0 0
+#define CAM_MCLK0__AUX1 2
+#define CAM_MCLK0__XGPIOA_0 3
+#define CAM_PD0__IIS1_MCLK 1
+#define CAM_PD0__XGPIOA_1 3
+#define CAM_PD0__CAM_HS0 4
+#define CAM_RST0__XGPIOA_2 3
+#define CAM_RST0__CAM_VS0 4
+#define CAM_RST0__IIC4_SCL 6
+#define CAM_MCLK1__CAM_MCLK1 0
+#define CAM_MCLK1__AUX2 2
+#define CAM_MCLK1__XGPIOA_3 3
+#define CAM_MCLK1__CAM_HS0 4
+#define CAM_PD1__IIS1_MCLK 1
+#define CAM_PD1__XGPIOA_4 3
+#define CAM_PD1__CAM_VS0 4
+#define CAM_PD1__IIC4_SDA 6
+#define IIC3_SCL__IIC3_SCL 0
+#define IIC3_SCL__XGPIOA_5 3
+#define IIC3_SDA__IIC3_SDA 0
+#define IIC3_SDA__XGPIOA_6 3
+#define SD0_CLK__SDIO0_CLK 0
+#define SD0_CLK__IIC1_SDA 1
+#define SD0_CLK__SPI0_SCK 2
+#define SD0_CLK__XGPIOA_7 3
+#define SD0_CLK__PWM_15 5
+#define SD0_CLK__EPHY_LNK_LED 6
+#define SD0_CLK__DBG_0 7
+#define SD0_CMD__SDIO0_CMD 0
+#define SD0_CMD__IIC1_SCL 1
+#define SD0_CMD__SPI0_SDO 2
+#define SD0_CMD__XGPIOA_8 3
+#define SD0_CMD__PWM_14 5
+#define SD0_CMD__EPHY_SPD_LED 6
+#define SD0_CMD__DBG_1 7
+#define SD0_D0__SDIO0_D_0 0
+#define SD0_D0__CAM_MCLK1 1
+#define SD0_D0__SPI0_SDI 2
+#define SD0_D0__XGPIOA_9 3
+#define SD0_D0__UART3_TX 4
+#define SD0_D0__PWM_13 5
+#define SD0_D0__WG0_D0 6
+#define SD0_D0__DBG_2 7
+#define SD0_D1__SDIO0_D_1 0
+#define SD0_D1__IIC1_SDA 1
+#define SD0_D1__AUX0 2
+#define SD0_D1__XGPIOA_10 3
+#define SD0_D1__UART1_TX 4
+#define SD0_D1__PWM_12 5
+#define SD0_D1__WG0_D1 6
+#define SD0_D1__DBG_3 7
+#define SD0_D2__SDIO0_D_2 0
+#define SD0_D2__IIC1_SCL 1
+#define SD0_D2__AUX1 2
+#define SD0_D2__XGPIOA_11 3
+#define SD0_D2__UART1_RX 4
+#define SD0_D2__PWM_11 5
+#define SD0_D2__WG1_D0 6
+#define SD0_D2__DBG_4 7
+#define SD0_D3__SDIO0_D_3 0
+#define SD0_D3__CAM_MCLK0 1
+#define SD0_D3__SPI0_CS_X 2
+#define SD0_D3__XGPIOA_12 3
+#define SD0_D3__UART3_RX 4
+#define SD0_D3__PWM_10 5
+#define SD0_D3__WG1_D1 6
+#define SD0_D3__DBG_5 7
+#define SD0_CD__SDIO0_CD 0
+#define SD0_CD__XGPIOA_13 3
+#define SD0_PWR_EN__SDIO0_PWR_EN 0
+#define SD0_PWR_EN__XGPIOA_14 3
+#define SPK_EN__XGPIOA_15 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__CAM_MCLK1 1
+#define UART0_TX__PWM_4 2
+#define UART0_TX__XGPIOA_16 3
+#define UART0_TX__UART1_TX 4
+#define UART0_TX__AUX1 5
+#define UART0_TX__DBG_6 7
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__CAM_MCLK0 1
+#define UART0_RX__PWM_5 2
+#define UART0_RX__XGPIOA_17 3
+#define UART0_RX__UART1_RX 4
+#define UART0_RX__AUX0 5
+#define UART0_RX__DBG_7 7
+#define EMMC_RSTN__EMMC_RSTN 0
+#define EMMC_RSTN__XGPIOA_21 3
+#define EMMC_RSTN__AUX2 4
+#define EMMC_DAT2__EMMC_DAT_2 0
+#define EMMC_DAT2__SPINOR_HOLD_X 1
+#define EMMC_DAT2__SPINAND_HOLD 2
+#define EMMC_DAT2__XGPIOA_26 3
+#define EMMC_CLK__EMMC_CLK 0
+#define EMMC_CLK__SPINOR_SCK 1
+#define EMMC_CLK__SPINAND_CLK 2
+#define EMMC_CLK__XGPIOA_22 3
+#define EMMC_DAT0__EMMC_DAT_0 0
+#define EMMC_DAT0__SPINOR_MOSI 1
+#define EMMC_DAT0__SPINAND_MOSI 2
+#define EMMC_DAT0__XGPIOA_25 3
+#define EMMC_DAT3__EMMC_DAT_3 0
+#define EMMC_DAT3__SPINOR_WP_X 1
+#define EMMC_DAT3__SPINAND_WP 2
+#define EMMC_DAT3__XGPIOA_27 3
+#define EMMC_CMD__EMMC_CMD 0
+#define EMMC_CMD__SPINOR_MISO 1
+#define EMMC_CMD__SPINAND_MISO 2
+#define EMMC_CMD__XGPIOA_23 3
+#define EMMC_DAT1__EMMC_DAT_1 0
+#define EMMC_DAT1__SPINOR_CS_X 1
+#define EMMC_DAT1__SPINAND_CS 2
+#define EMMC_DAT1__XGPIOA_24 3
+#define JTAG_CPU_TMS__CV_2WTMS_CR_4WTMS 0
+#define JTAG_CPU_TMS__CAM_MCLK0 1
+#define JTAG_CPU_TMS__PWM_7 2
+#define JTAG_CPU_TMS__XGPIOA_19 3
+#define JTAG_CPU_TMS__UART1_RTS 4
+#define JTAG_CPU_TMS__AUX0 5
+#define JTAG_CPU_TMS__UART1_TX 6
+#define JTAG_CPU_TMS__VO_D_28 7
+#define JTAG_CPU_TCK__CV_2WTCK_CR_4WTCK 0
+#define JTAG_CPU_TCK__CAM_MCLK1 1
+#define JTAG_CPU_TCK__PWM_6 2
+#define JTAG_CPU_TCK__XGPIOA_18 3
+#define JTAG_CPU_TCK__UART1_CTS 4
+#define JTAG_CPU_TCK__AUX1 5
+#define JTAG_CPU_TCK__UART1_RX 6
+#define JTAG_CPU_TCK__VO_D_29 7
+#define JTAG_CPU_TRST__JTAG_CPU_TRST 0
+#define JTAG_CPU_TRST__XGPIOA_20 3
+#define JTAG_CPU_TRST__VO_D_30 6
+#define IIC0_SCL__CV_SCL0__CR_4WTDI 0
+#define IIC0_SCL__UART1_TX 1
+#define IIC0_SCL__UART2_TX 2
+#define IIC0_SCL__XGPIOA_28 3
+#define IIC0_SCL__WG0_D0 5
+#define IIC0_SCL__DBG_10 7
+#define IIC0_SDA__CV_SDA0__CR_4WTDO 0
+#define IIC0_SDA__UART1_RX 1
+#define IIC0_SDA__UART2_RX 2
+#define IIC0_SDA__XGPIOA_29 3
+#define IIC0_SDA__WG0_D1 5
+#define IIC0_SDA__WG1_D0 6
+#define IIC0_SDA__DBG_11 7
+#define AUX0__AUX0 0
+#define AUX0__XGPIOA_30 3
+#define AUX0__IIS1_MCLK 4
+#define AUX0__VO_D_31 5
+#define AUX0__WG1_D1 6
+#define AUX0__DBG_12 7
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_RSTN__PWR_RSTN 0
+#define PWR_SEQ1__PWR_SEQ1 0
+#define PWR_SEQ1__PWR_GPIO_3 3
+#define PWR_SEQ2__PWR_SEQ2 0
+#define PWR_SEQ2__PWR_GPIO_4 3
+#define PWR_SEQ3__PWR_SEQ3 0
+#define PWR_SEQ3__PWR_GPIO_5 3
+#define PTEST__PWR_PTEST 0
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__PWR_IR0 1
+#define PWR_WAKEUP0__PWR_UART0_TX 2
+#define PWR_WAKEUP0__PWR_GPIO_6 3
+#define PWR_WAKEUP0__UART1_TX 4
+#define PWR_WAKEUP0__IIC4_SCL 5
+#define PWR_WAKEUP0__EPHY_LNK_LED 6
+#define PWR_WAKEUP0__WG2_D0 7
+#define PWR_WAKEUP1__PWR_WAKEUP1 0
+#define PWR_WAKEUP1__PWR_IR1 1
+#define PWR_WAKEUP1__PWR_GPIO_7 3
+#define PWR_WAKEUP1__UART1_TX 4
+#define PWR_WAKEUP1__IIC4_SCL 5
+#define PWR_WAKEUP1__EPHY_LNK_LED 6
+#define PWR_WAKEUP1__WG0_D0 7
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__PWR_GPIO_8 3
+#define PWR_BUTTON1__UART1_RX 4
+#define PWR_BUTTON1__IIC4_SDA 5
+#define PWR_BUTTON1__EPHY_SPD_LED 6
+#define PWR_BUTTON1__WG2_D1 7
+#define PWR_ON__PWR_ON 0
+#define PWR_ON__PWR_GPIO_9 3
+#define PWR_ON__UART1_RX 4
+#define PWR_ON__IIC4_SDA 5
+#define PWR_ON__EPHY_SPD_LED 6
+#define PWR_ON__WG0_D1 7
+#define XTAL_XIN__PWR_XTAL_CLKIN 0
+#define PWR_GPIO0__PWR_GPIO_0 0
+#define PWR_GPIO0__UART2_TX 1
+#define PWR_GPIO0__PWR_UART0_RX 2
+#define PWR_GPIO0__PWM_8 4
+#define PWR_GPIO1__PWR_GPIO_1 0
+#define PWR_GPIO1__UART2_RX 1
+#define PWR_GPIO1__EPHY_LNK_LED 3
+#define PWR_GPIO1__PWM_9 4
+#define PWR_GPIO1__PWR_IIC_SCL 5
+#define PWR_GPIO1__IIC2_SCL 6
+#define PWR_GPIO1__CV_4WTMS_CR_SDA0 7
+#define PWR_GPIO2__PWR_GPIO_2 0
+#define PWR_GPIO2__PWR_SECTICK 2
+#define PWR_GPIO2__EPHY_SPD_LED 3
+#define PWR_GPIO2__PWM_10 4
+#define PWR_GPIO2__PWR_IIC_SDA 5
+#define PWR_GPIO2__IIC2_SDA 6
+#define PWR_GPIO2__CV_4WTCK_CR_2WTCK 7
+#define CLK32K__CLK32K 0
+#define CLK32K__AUX0 1
+#define CLK32K__CV_4WTDI_CR_SCL0 2
+#define CLK32K__PWR_GPIO_10 3
+#define CLK32K__PWM_2 4
+#define CLK32K__KEY_COL0 5
+#define CLK32K__CAM_MCLK0 6
+#define CLK32K__DBG_0 7
+#define CLK25M__CLK25M 0
+#define CLK25M__AUX1 1
+#define CLK25M__CV_4WTDO_CR_2WTMS 2
+#define CLK25M__PWR_GPIO_11 3
+#define CLK25M__PWM_3 4
+#define CLK25M__KEY_COL1 5
+#define CLK25M__CAM_MCLK1 6
+#define CLK25M__DBG_1 7
+#define IIC2_SCL__IIC2_SCL 0
+#define IIC2_SCL__PWM_14 1
+#define IIC2_SCL__PWR_GPIO_12 3
+#define IIC2_SCL__UART2_RX 4
+#define IIC2_SCL__KEY_COL2 7
+#define IIC2_SDA__IIC2_SDA 0
+#define IIC2_SDA__PWM_15 1
+#define IIC2_SDA__PWR_GPIO_13 3
+#define IIC2_SDA__UART2_TX 4
+#define IIC2_SDA__IIS1_MCLK 5
+#define IIC2_SDA__IIS2_MCLK 6
+#define IIC2_SDA__KEY_COL3 7
+#define UART2_TX__UART2_TX 0
+#define UART2_TX__PWM_11 1
+#define UART2_TX__PWR_UART1_TX 2
+#define UART2_TX__PWR_GPIO_14 3
+#define UART2_TX__KEY_ROW3 4
+#define UART2_TX__UART4_TX 5
+#define UART2_TX__IIS2_BCLK 6
+#define UART2_TX__WG2_D0 7
+#define UART2_RTS__UART2_RTS 0
+#define UART2_RTS__PWM_8 1
+#define UART2_RTS__PWR_GPIO_15 3
+#define UART2_RTS__KEY_ROW0 4
+#define UART2_RTS__UART4_RTS 5
+#define UART2_RTS__IIS2_DO 6
+#define UART2_RTS__WG1_D0 7
+#define UART2_RX__UART2_RX 0
+#define UART2_RX__PWM_10 1
+#define UART2_RX__PWR_UART1_RX 2
+#define UART2_RX__PWR_GPIO_16 3
+#define UART2_RX__KEY_COL3 4
+#define UART2_RX__UART4_RX 5
+#define UART2_RX__IIS2_DI 6
+#define UART2_RX__WG2_D1 7
+#define UART2_CTS__UART2_CTS 0
+#define UART2_CTS__PWM_9 1
+#define UART2_CTS__PWR_GPIO_17 3
+#define UART2_CTS__KEY_ROW1 4
+#define UART2_CTS__UART4_CTS 5
+#define UART2_CTS__IIS2_LRCK 6
+#define UART2_CTS__WG1_D1 7
+#define SD1_D3__PWR_SD1_D3_VO32 0
+#define SD1_D3__SPI2_CS_X 1
+#define SD1_D3__IIC1_SCL 2
+#define SD1_D3__PWR_GPIO_18 3
+#define SD1_D3__CAM_MCLK0 4
+#define SD1_D3__UART3_CTS 5
+#define SD1_D3__PWR_SPINOR1_CS_X 6
+#define SD1_D3__PWM_4 7
+#define SD1_D2__PWR_SD1_D2_VO33 0
+#define SD1_D2__IIC1_SCL 1
+#define SD1_D2__UART2_TX 2
+#define SD1_D2__PWR_GPIO_19 3
+#define SD1_D2__CAM_MCLK0 4
+#define SD1_D2__UART3_TX 5
+#define SD1_D2__PWR_SPINOR1_HOLD_X 6
+#define SD1_D2__PWM_5 7
+#define SD1_D1__PWR_SD1_D1_VO34 0
+#define SD1_D1__IIC1_SDA 1
+#define SD1_D1__UART2_RX 2
+#define SD1_D1__PWR_GPIO_20 3
+#define SD1_D1__CAM_MCLK1 4
+#define SD1_D1__UART3_RX 5
+#define SD1_D1__PWR_SPINOR1_WP_X 6
+#define SD1_D1__PWM_6 7
+#define SD1_D0__PWR_SD1_D0_VO35 0
+#define SD1_D0__SPI2_SDI 1
+#define SD1_D0__IIC1_SDA 2
+#define SD1_D0__PWR_GPIO_21 3
+#define SD1_D0__CAM_MCLK1 4
+#define SD1_D0__UART3_RTS 5
+#define SD1_D0__PWR_SPINOR1_MISO 6
+#define SD1_D0__PWM_7 7
+#define SD1_CMD__PWR_SD1_CMD_VO36 0
+#define SD1_CMD__SPI2_SDO 1
+#define SD1_CMD__IIC3_SCL 2
+#define SD1_CMD__PWR_GPIO_22 3
+#define SD1_CMD__CAM_VS0 4
+#define SD1_CMD__EPHY_LNK_LED 5
+#define SD1_CMD__PWR_SPINOR1_MOSI 6
+#define SD1_CMD__PWM_8 7
+#define SD1_CLK__PWR_SD1_CLK_VO37 0
+#define SD1_CLK__SPI2_SCK 1
+#define SD1_CLK__IIC3_SDA 2
+#define SD1_CLK__PWR_GPIO_23 3
+#define SD1_CLK__CAM_HS0 4
+#define SD1_CLK__EPHY_SPD_LED 5
+#define SD1_CLK__PWR_SPINOR1_SCK 6
+#define SD1_CLK__PWM_9 7
+#define RSTN__RSTN 0
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_0 3
+#define ADC3__CAM_MCLK0 1
+#define ADC3__IIC4_SCL 2
+#define ADC3__XGPIOB_1 3
+#define ADC3__PWM_12 4
+#define ADC3__EPHY_LNK_LED 5
+#define ADC3__WG2_D0 6
+#define ADC3__UART3_TX 7
+#define ADC2__CAM_MCLK1 1
+#define ADC2__IIC4_SDA 2
+#define ADC2__XGPIOB_2 3
+#define ADC2__PWM_13 4
+#define ADC2__EPHY_SPD_LED 5
+#define ADC2__WG2_D1 6
+#define ADC2__UART3_RX 7
+#define ADC1__XGPIOB_3 3
+#define ADC1__KEY_COL2 4
+#define USB_ID__USB_ID 0
+#define USB_ID__XGPIOB_4 3
+#define USB_VBUS_EN__USB_VBUS_EN 0
+#define USB_VBUS_EN__XGPIOB_5 3
+#define PKG_TYPE0__PKG_TYPE0 0
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_6 3
+#define USB_VBUS_DET__CAM_MCLK0 4
+#define USB_VBUS_DET__CAM_MCLK1 5
+#define PKG_TYPE1__PKG_TYPE1 0
+#define PKG_TYPE2__PKG_TYPE2 0
+#define MUX_SPI1_MISO__UART3_RTS 1
+#define MUX_SPI1_MISO__IIC1_SDA 2
+#define MUX_SPI1_MISO__XGPIOB_8 3
+#define MUX_SPI1_MISO__PWM_9 4
+#define MUX_SPI1_MISO__KEY_COL1 5
+#define MUX_SPI1_MISO__SPI1_SDI 6
+#define MUX_SPI1_MISO__DBG_14 7
+#define MUX_SPI1_MOSI__UART3_RX 1
+#define MUX_SPI1_MOSI__IIC1_SCL 2
+#define MUX_SPI1_MOSI__XGPIOB_7 3
+#define MUX_SPI1_MOSI__PWM_8 4
+#define MUX_SPI1_MOSI__KEY_COL0 5
+#define MUX_SPI1_MOSI__SPI1_SDO 6
+#define MUX_SPI1_MOSI__DBG_13 7
+#define MUX_SPI1_CS__UART3_CTS 1
+#define MUX_SPI1_CS__CAM_MCLK0 2
+#define MUX_SPI1_CS__XGPIOB_10 3
+#define MUX_SPI1_CS__PWM_11 4
+#define MUX_SPI1_CS__KEY_ROW3 5
+#define MUX_SPI1_CS__SPI1_CS_X 6
+#define MUX_SPI1_CS__DBG_16 7
+#define MUX_SPI1_SCK__UART3_TX 1
+#define MUX_SPI1_SCK__CAM_MCLK1 2
+#define MUX_SPI1_SCK__XGPIOB_9 3
+#define MUX_SPI1_SCK__PWM_10 4
+#define MUX_SPI1_SCK__KEY_ROW2 5
+#define MUX_SPI1_SCK__SPI1_SCK 6
+#define MUX_SPI1_SCK__DBG_15 7
+#define PAD_ETH_TXP__UART3_RX 1
+#define PAD_ETH_TXP__IIC1_SCL 2
+#define PAD_ETH_TXP__XGPIOB_25 3
+#define PAD_ETH_TXP__PWM_13 4
+#define PAD_ETH_TXP__CAM_MCLK0 5
+#define PAD_ETH_TXP__SPI1_SDO 6
+#define PAD_ETH_TXP__IIS2_LRCK 7
+#define PAD_ETH_TXM__UART3_RTS 1
+#define PAD_ETH_TXM__IIC1_SDA 2
+#define PAD_ETH_TXM__XGPIOB_24 3
+#define PAD_ETH_TXM__PWM_12 4
+#define PAD_ETH_TXM__CAM_MCLK1 5
+#define PAD_ETH_TXM__SPI1_SDI 6
+#define PAD_ETH_TXM__IIS2_BCLK 7
+#define PAD_ETH_RXP__UART3_TX 1
+#define PAD_ETH_RXP__CAM_MCLK1 2
+#define PAD_ETH_RXP__XGPIOB_27 3
+#define PAD_ETH_RXP__PWM_15 4
+#define PAD_ETH_RXP__CAM_HS0 5
+#define PAD_ETH_RXP__SPI1_SCK 6
+#define PAD_ETH_RXP__IIS2_DO 7
+#define PAD_ETH_RXM__UART3_CTS 1
+#define PAD_ETH_RXM__CAM_MCLK0 2
+#define PAD_ETH_RXM__XGPIOB_26 3
+#define PAD_ETH_RXM__PWM_14 4
+#define PAD_ETH_RXM__CAM_VS0 5
+#define PAD_ETH_RXM__SPI1_CS_X 6
+#define PAD_ETH_RXM__IIS2_DI 7
+#define VIVO_D10__PWM_1 0
+#define VIVO_D10__VI1_D_10 1
+#define VIVO_D10__VO_D_23 2
+#define VIVO_D10__XGPIOB_11 3
+#define VIVO_D10__RMII0_IRQ 4
+#define VIVO_D10__CAM_MCLK0 5
+#define VIVO_D10__IIC1_SDA 6
+#define VIVO_D10__UART2_TX 7
+#define VIVO_D9__PWM_2 0
+#define VIVO_D9__VI1_D_9 1
+#define VIVO_D9__VO_D_22 2
+#define VIVO_D9__XGPIOB_12 3
+#define VIVO_D9__CAM_MCLK1 5
+#define VIVO_D9__IIC1_SCL 6
+#define VIVO_D9__UART2_RX 7
+#define VIVO_D8__PWM_3 0
+#define VIVO_D8__VI1_D_8 1
+#define VIVO_D8__VO_D_21 2
+#define VIVO_D8__XGPIOB_13 3
+#define VIVO_D8__RMII0_MDIO 4
+#define VIVO_D8__SPI3_SDO 5
+#define VIVO_D8__IIC2_SCL 6
+#define VIVO_D8__CAM_VS0 7
+#define VIVO_D7__VI2_D_7 0
+#define VIVO_D7__VI1_D_7 1
+#define VIVO_D7__VO_D_20 2
+#define VIVO_D7__XGPIOB_14 3
+#define VIVO_D7__RMII0_RXD1 4
+#define VIVO_D7__SPI3_SDI 5
+#define VIVO_D7__IIC2_SDA 6
+#define VIVO_D7__CAM_HS0 7
+#define VIVO_D6__VI2_D_6 0
+#define VIVO_D6__VI1_D_6 1
+#define VIVO_D6__VO_D_19 2
+#define VIVO_D6__XGPIOB_15 3
+#define VIVO_D6__RMII0_REFCLKI 4
+#define VIVO_D6__SPI3_SCK 5
+#define VIVO_D6__UART2_TX 6
+#define VIVO_D6__CAM_VS0 7
+#define VIVO_D5__VI2_D_5 0
+#define VIVO_D5__VI1_D_5 1
+#define VIVO_D5__VO_D_18 2
+#define VIVO_D5__XGPIOB_16 3
+#define VIVO_D5__RMII0_RXD0 4
+#define VIVO_D5__SPI3_CS_X 5
+#define VIVO_D5__UART2_RX 6
+#define VIVO_D5__CAM_HS0 7
+#define VIVO_D4__VI2_D_4 0
+#define VIVO_D4__VI1_D_4 1
+#define VIVO_D4__VO_D_17 2
+#define VIVO_D4__XGPIOB_17 3
+#define VIVO_D4__RMII0_MDC 4
+#define VIVO_D4__IIC1_SDA 5
+#define VIVO_D4__UART2_CTS 6
+#define VIVO_D4__CAM_VS0 7
+#define VIVO_D3__VI2_D_3 0
+#define VIVO_D3__VI1_D_3 1
+#define VIVO_D3__VO_D_16 2
+#define VIVO_D3__XGPIOB_18 3
+#define VIVO_D3__RMII0_TXD0 4
+#define VIVO_D3__IIC1_SCL 5
+#define VIVO_D3__UART2_RTS 6
+#define VIVO_D3__CAM_HS0 7
+#define VIVO_D2__VI2_D_2 0
+#define VIVO_D2__VI1_D_2 1
+#define VIVO_D2__VO_D_15 2
+#define VIVO_D2__XGPIOB_19 3
+#define VIVO_D2__RMII0_TXD1 4
+#define VIVO_D2__CAM_MCLK1 5
+#define VIVO_D2__PWM_2 6
+#define VIVO_D2__UART2_TX 7
+#define VIVO_D1__VI2_D_1 0
+#define VIVO_D1__VI1_D_1 1
+#define VIVO_D1__VO_D_14 2
+#define VIVO_D1__XGPIOB_20 3
+#define VIVO_D1__RMII0_RXDV 4
+#define VIVO_D1__IIC3_SDA 5
+#define VIVO_D1__PWM_3 6
+#define VIVO_D1__IIC4_SCL 7
+#define VIVO_D0__VI2_D_0 0
+#define VIVO_D0__VI1_D_0 1
+#define VIVO_D0__VO_D_13 2
+#define VIVO_D0__XGPIOB_21 3
+#define VIVO_D0__RMII0_TXCLK 4
+#define VIVO_D0__IIC3_SCL 5
+#define VIVO_D0__WG1_D0 6
+#define VIVO_D0__IIC4_SDA 7
+#define VIVO_CLK__VI2_CLK 0
+#define VIVO_CLK__VI1_CLK 1
+#define VIVO_CLK__VO_CLK1 2
+#define VIVO_CLK__XGPIOB_22 3
+#define VIVO_CLK__RMII0_TXEN 4
+#define VIVO_CLK__CAM_MCLK0 5
+#define VIVO_CLK__WG1_D1 6
+#define VIVO_CLK__UART2_RX 7
+#define PAD_MIPIRX5N__VI1_D_11 1
+#define PAD_MIPIRX5N__VO_D_12 2
+#define PAD_MIPIRX5N__XGPIOC_0 3
+#define PAD_MIPIRX5N__CAM_MCLK0 5
+#define PAD_MIPIRX5N__WG0_D0 6
+#define PAD_MIPIRX5N__DBG_0 7
+#define PAD_MIPIRX5P__VI1_D_12 1
+#define PAD_MIPIRX5P__VO_D_11 2
+#define PAD_MIPIRX5P__XGPIOC_1 3
+#define PAD_MIPIRX5P__IIS1_MCLK 4
+#define PAD_MIPIRX5P__CAM_MCLK1 5
+#define PAD_MIPIRX5P__WG0_D1 6
+#define PAD_MIPIRX5P__DBG_1 7
+#define PAD_MIPIRX4N__CV_4WTDI_CR_SCL0 0
+#define PAD_MIPIRX4N__VI0_CLK 1
+#define PAD_MIPIRX4N__VI1_D_13 2
+#define PAD_MIPIRX4N__XGPIOC_2 3
+#define PAD_MIPIRX4N__IIC1_SDA 4
+#define PAD_MIPIRX4N__CAM_MCLK0 5
+#define PAD_MIPIRX4N__KEY_ROW0 6
+#define PAD_MIPIRX4N__MUX_SPI1_SCK 7
+#define PAD_MIPIRX4P__CV_4WTMS_CR_SDA0 0
+#define PAD_MIPIRX4P__VI0_D_0 1
+#define PAD_MIPIRX4P__VI1_D_14 2
+#define PAD_MIPIRX4P__XGPIOC_3 3
+#define PAD_MIPIRX4P__IIC1_SCL 4
+#define PAD_MIPIRX4P__CAM_MCLK1 5
+#define PAD_MIPIRX4P__KEY_ROW1 6
+#define PAD_MIPIRX4P__MUX_SPI1_CS 7
+#define PAD_MIPIRX3N__CV_4WTDO_CR_2WTMS 0
+#define PAD_MIPIRX3N__VI0_D_1 1
+#define PAD_MIPIRX3N__VI1_D_15 2
+#define PAD_MIPIRX3N__XGPIOC_4 3
+#define PAD_MIPIRX3N__CAM_MCLK0 4
+#define PAD_MIPIRX3N__MUX_SPI1_MISO 7
+#define PAD_MIPIRX3P__CV_4WTCK_CR_2WTCK 0
+#define PAD_MIPIRX3P__VI0_D_2 1
+#define PAD_MIPIRX3P__VI1_D_16 2
+#define PAD_MIPIRX3P__XGPIOC_5 3
+#define PAD_MIPIRX3P__MUX_SPI1_MOSI 7
+#define PAD_MIPIRX2N__VI0_D_3 1
+#define PAD_MIPIRX2N__VO_D_10 2
+#define PAD_MIPIRX2N__XGPIOC_6 3
+#define PAD_MIPIRX2N__VI1_D_17 4
+#define PAD_MIPIRX2N__IIC4_SCL 5
+#define PAD_MIPIRX2N__DBG_6 7
+#define PAD_MIPIRX2P__VI0_D_4 1
+#define PAD_MIPIRX2P__VO_D_9 2
+#define PAD_MIPIRX2P__XGPIOC_7 3
+#define PAD_MIPIRX2P__VI1_D_18 4
+#define PAD_MIPIRX2P__IIC4_SDA 5
+#define PAD_MIPIRX2P__DBG_7 7
+#define PAD_MIPIRX1N__VI0_D_5 1
+#define PAD_MIPIRX1N__VO_D_8 2
+#define PAD_MIPIRX1N__XGPIOC_8 3
+#define PAD_MIPIRX1N__KEY_ROW3 6
+#define PAD_MIPIRX1N__DBG_8 7
+#define PAD_MIPIRX1P__VI0_D_6 1
+#define PAD_MIPIRX1P__VO_D_7 2
+#define PAD_MIPIRX1P__XGPIOC_9 3
+#define PAD_MIPIRX1P__IIC1_SDA 4
+#define PAD_MIPIRX1P__KEY_ROW2 6
+#define PAD_MIPIRX1P__DBG_9 7
+#define PAD_MIPIRX0N__VI0_D_7 1
+#define PAD_MIPIRX0N__VO_D_6 2
+#define PAD_MIPIRX0N__XGPIOC_10 3
+#define PAD_MIPIRX0N__IIC1_SCL 4
+#define PAD_MIPIRX0N__CAM_MCLK1 5
+#define PAD_MIPIRX0N__DBG_10 7
+#define PAD_MIPIRX0P__VI0_D_8 1
+#define PAD_MIPIRX0P__VO_D_5 2
+#define PAD_MIPIRX0P__XGPIOC_11 3
+#define PAD_MIPIRX0P__CAM_MCLK0 4
+#define PAD_MIPIRX0P__DBG_11 7
+#define PAD_MIPI_TXM4__VI0_D_15 0
+#define PAD_MIPI_TXM4__SD1_CLK 1
+#define PAD_MIPI_TXM4__VO_D_24 2
+#define PAD_MIPI_TXM4__XGPIOC_18 3
+#define PAD_MIPI_TXM4__CAM_MCLK1 4
+#define PAD_MIPI_TXM4__PWM_12 5
+#define PAD_MIPI_TXM4__IIC1_SDA 6
+#define PAD_MIPI_TXM4__DBG_18 7
+#define PAD_MIPI_TXP4__VI0_D_16 0
+#define PAD_MIPI_TXP4__SD1_CMD 1
+#define PAD_MIPI_TXP4__VO_D_25 2
+#define PAD_MIPI_TXP4__XGPIOC_19 3
+#define PAD_MIPI_TXP4__CAM_MCLK0 4
+#define PAD_MIPI_TXP4__PWM_13 5
+#define PAD_MIPI_TXP4__IIC1_SCL 6
+#define PAD_MIPI_TXP4__DBG_19 7
+#define PAD_MIPI_TXM3__VI0_D_17 0
+#define PAD_MIPI_TXM3__SD1_D0 1
+#define PAD_MIPI_TXM3__VO_D_26 2
+#define PAD_MIPI_TXM3__XGPIOC_20 3
+#define PAD_MIPI_TXM3__IIC2_SDA 4
+#define PAD_MIPI_TXM3__PWM_14 5
+#define PAD_MIPI_TXM3__IIC1_SDA 6
+#define PAD_MIPI_TXM3__CAM_VS0 7
+#define PAD_MIPI_TXP3__VI0_D_18 0
+#define PAD_MIPI_TXP3__SD1_D1 1
+#define PAD_MIPI_TXP3__VO_D_27 2
+#define PAD_MIPI_TXP3__XGPIOC_21 3
+#define PAD_MIPI_TXP3__IIC2_SCL 4
+#define PAD_MIPI_TXP3__PWM_15 5
+#define PAD_MIPI_TXP3__IIC1_SCL 6
+#define PAD_MIPI_TXP3__CAM_HS0 7
+#define PAD_MIPI_TXM2__CV_4WTMS_CR_SDA0 0
+#define PAD_MIPI_TXM2__VI0_D_13 1
+#define PAD_MIPI_TXM2__VO_D_0 2
+#define PAD_MIPI_TXM2__XGPIOC_16 3
+#define PAD_MIPI_TXM2__IIC1_SDA 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__SPI0_SCK 6
+#define PAD_MIPI_TXM2__SD1_D2 7
+#define PAD_MIPI_TXP2__CV_4WTDI_CR_SCL0 0
+#define PAD_MIPI_TXP2__VI0_D_14 1
+#define PAD_MIPI_TXP2__VO_CLK0 2
+#define PAD_MIPI_TXP2__XGPIOC_17 3
+#define PAD_MIPI_TXP2__IIC1_SCL 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__SPI0_CS_X 6
+#define PAD_MIPI_TXP2__SD1_D3 7
+#define PAD_MIPI_TXM1__CV_4WTDO_CR_2WTMS 0
+#define PAD_MIPI_TXM1__VI0_D_11 1
+#define PAD_MIPI_TXM1__VO_D_2 2
+#define PAD_MIPI_TXM1__XGPIOC_14 3
+#define PAD_MIPI_TXM1__IIC2_SDA 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__SPI0_SDO 6
+#define PAD_MIPI_TXM1__DBG_14 7
+#define PAD_MIPI_TXP1__CV_4WTCK_CR_2WTCK 0
+#define PAD_MIPI_TXP1__VI0_D_12 1
+#define PAD_MIPI_TXP1__VO_D_1 2
+#define PAD_MIPI_TXP1__XGPIOC_15 3
+#define PAD_MIPI_TXP1__IIC2_SCL 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__SPI0_SDI 6
+#define PAD_MIPI_TXP1__DBG_15 7
+#define PAD_MIPI_TXM0__VI0_D_9 1
+#define PAD_MIPI_TXM0__VO_D_4 2
+#define PAD_MIPI_TXM0__XGPIOC_12 3
+#define PAD_MIPI_TXM0__CAM_MCLK1 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__CAM_VS0 6
+#define PAD_MIPI_TXM0__DBG_12 7
+#define PAD_MIPI_TXP0__VI0_D_10 1
+#define PAD_MIPI_TXP0__VO_D_3 2
+#define PAD_MIPI_TXP0__XGPIOC_13 3
+#define PAD_MIPI_TXP0__CAM_MCLK0 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__CAM_HS0 6
+#define PAD_MIPI_TXP0__DBG_13 7
+#define PAD_AUD_AINL_MIC__XGPIOC_23 3
+#define PAD_AUD_AINL_MIC__IIS1_BCLK 4
+#define PAD_AUD_AINL_MIC__IIS2_BCLK 5
+#define PAD_AUD_AINR_MIC__XGPIOC_22 3
+#define PAD_AUD_AINR_MIC__IIS1_DO 4
+#define PAD_AUD_AINR_MIC__IIS2_DI 5
+#define PAD_AUD_AINR_MIC__IIS1_DI 6
+#define PAD_AUD_AOUTL__XGPIOC_25 3
+#define PAD_AUD_AOUTL__IIS1_LRCK 4
+#define PAD_AUD_AOUTL__IIS2_LRCK 5
+#define PAD_AUD_AOUTR__XGPIOC_24 3
+#define PAD_AUD_AOUTR__IIS1_DI 4
+#define PAD_AUD_AOUTR__IIS2_DO 5
+#define PAD_AUD_AOUTR__IIS1_DO 6
+#define GPIO_RTX__XGPIOB_23 3
+#define GPIO_RTX__PWM_1 4
+#define GPIO_RTX__CAM_MCLK0 5
+#define GPIO_ZQ__PWR_GPIO_24 3
+#define GPIO_ZQ__PWM_2 4
+
+#endif /* __CV181X_PINLIST_SWCONFIG_H__ */
diff --git a/board/cvitek/cv181x/cv181x_reg.h b/board/cvitek/cv181x/cv181x_reg.h
new file mode 100644
index 000000000..3d257030e
--- /dev/null
+++ b/board/cvitek/cv181x/cv181x_reg.h
@@ -0,0 +1,185 @@
+#ifndef __CV181X_REG_H__
+#define __CV181X_REG_H__
+
+#define TOP_BASE        0x03000000
+#define PINMUX_BASE     (TOP_BASE + 0x1000)
+#define WATCHDOG_BASE   (TOP_BASE + 0x00010000)
+#define RTC_BASE   0x05026000
+
+/*
+ * RTC info registers
+ */
+#define RTC_INFO0 (RTC_BASE + 0x1C)
+
+/*
+ * General purpose registers
+ */
+#define GP_REG0 (TOP_BASE + 0x80)
+#define GP_REG1 (TOP_BASE + 0x84)
+#define GP_REG2 (TOP_BASE + 0x88
+#define GP_REG3 (TOP_BASE + 0x8C)
+#define GP_REG4 (TOP_BASE + 0x90)
+#define GP_REG5 (TOP_BASE + 0x94)
+#define GP_REG6 (TOP_BASE + 0x98)
+#define GP_REG7 (TOP_BASE + 0x9C)
+#define GP_REG8 (TOP_BASE + 0xA0)
+#define GP_REG9 (TOP_BASE + 0xA4)
+#define GP_REG10 (TOP_BASE + 0xA8)
+
+/*
+ * Pinmux definitions
+ */
+#define PINMUX_UART0    0
+#define PINMUX_UART1    1
+#define PINMUX_UART2    2
+#define PINMUX_UART3    3
+#define PINMUX_UART3_2  4
+#define PINMUX_I2C0     5
+#define PINMUX_I2C1     6
+#define PINMUX_I2C2     7
+#define PINMUX_I2C3     8
+#define PINMUX_I2C4     9
+#define PINMUX_I2C4_2   10
+#define PINMUX_SPI0     11
+#define PINMUX_SPI1     12
+#define PINMUX_SPI2     13
+#define PINMUX_SPI2_2   14
+#define PINMUX_SPI3     15
+#define PINMUX_SPI3_2   16
+#define PINMUX_I2S0     17
+#define PINMUX_I2S1     18
+#define PINMUX_I2S2     19
+#define PINMUX_I2S3     20
+#define PINMUX_USBID    21
+#define PINMUX_SDIO0    22
+#define PINMUX_SDIO1    23
+#define PINMUX_ND       24
+#define PINMUX_EMMC     25
+#define PINMUX_SPI_NOR  26
+#define PINMUX_SPI_NAND 27
+#define PINMUX_CAM0     28
+#define PINMUX_CAM1     29
+#define PINMUX_PCM0     30
+#define PINMUX_PCM1     31
+#define PINMUX_CSI0     32
+#define PINMUX_CSI1     33
+#define PINMUX_CSI2     34
+#define PINMUX_DSI      35
+#define PINMUX_VI0      36
+#define PINMUX_VO       37
+#define PINMUX_RMII1    38
+#define PINMUX_EPHY_LED 39
+#define PINMUX_I80      40
+#define PINMUX_LVDS     41
+
+#define PINMUX_USB_VBUS_DET     (PINMUX_BASE + 0x108)
+
+#define REG_TOP_USB_ECO			(TOP_BASE + 0xB4)
+#define BIT_TOP_USB_ECO_RX_FLUSH	0x80
+/* rst */
+#define REG_TOP_SOFT_RST        0x3000
+#define BIT_TOP_SOFT_RST_USB    BIT(11)
+#define BIT_TOP_SOFT_RST_SDIO   BIT(14)
+#define BIT_TOP_SOFT_RST_NAND   BIT(12)
+
+#define REG_TOP_USB_CTRSTS	(TOP_BASE + 0x38)
+
+#define REG_TOP_CONF_INFO		(TOP_BASE + 0x4)
+#define BIT_TOP_CONF_INFO_VBUS		BIT(9)
+#define REG_TOP_USB_PHY_CTRL		(TOP_BASE + 0x48)
+#define BIT_TOP_USB_PHY_CTRL_EXTVBUS	BIT(0)
+#define USB_PHY_ID_OVERRIDE_ENABLE	BIT(6)
+#define USB_PHY_ID_VALUE		BIT(7)
+#define REG_TOP_DDR_ADDR_MODE		(TOP_BASE + 0x64)
+
+/* irq */
+#define IRQ_LEVEL   0
+#define IRQ_EDGE    3
+
+/* usb */
+#define USB_BASE            0x04340000
+
+/* ethernet phy */
+#define ETH_PHY_BASE        0x03009000
+#define ETH_PHY_INIT_MASK   0xFFFFFFF9
+#define ETH_PHY_SHUTDOWN    BIT(1)
+#define ETH_PHY_POWERUP     0xFFFFFFFD
+#define ETH_PHY_RESET       0xFFFFFFFB
+#define ETH_PHY_RESET_N     BIT(2)
+#define ETH_PHY_LED_LOW_ACTIVE  BIT(3)
+
+/* watchdog */
+#define CONFIG_DW_WDT_BASE WATCHDOG_BASE
+#define CONFIG_DW_WDT_CLOCK_KHZ	25000
+
+#define DW_WDT_CR	0x00
+#define DW_WDT_TORR	0x04
+#define DW_WDT_CRR	0x0C
+
+#define DW_WDT_CR_EN_OFFSET	0x00
+#define DW_WDT_CR_RMOD_OFFSET	0x01
+#define DW_WDT_CR_RMOD_VAL	0x00
+#define DW_WDT_CRR_RESTART_VAL	0x76
+
+/* SDIO Wifi */
+#define WIFI_CHIP_EN_BGA    BIT(18)
+#define WIFI_CHIP_EN_QFN    BIT(2)
+
+/* RTC */
+#define RTC_SYS_BASE		0x05000000
+#define RTC_MACRO_BASE		(RTC_SYS_BASE + 0x00026400)
+#define RTC_MACRO_DA_SOC_READY		0x8C
+#define RTC_MACRO_RO_T		0xA8
+#define RTC_CORE_SRAM_BASE	(RTC_SYS_BASE + 0x00026800)
+#define RTC_CORE_SRAM_SIZE	0x0800 // 2KB
+
+#define REG_RTC_CTRL_BASE	(RTC_SYS_BASE + 0x00025000)
+#define RTC_CTRL0_UNLOCKKEY	0x4
+#define RTC_CTRL0		0x8
+#define RTC_CTRL0_STATUS0		0xC
+#define RTCSYS_RST_CTRL	0x18
+
+#define REG_RTC_BASE		(RTC_SYS_BASE + 0x00026000)
+#define RTC_EN_PWR_WAKEUP	0xBC
+#define RTC_EN_SHDN_REQ	0xC0
+#define RTC_EN_PWR_CYC_REQ	0xC8
+#define RTC_EN_WARM_RST_REQ	0xCC
+#define RTC_EN_WDT_RST_REQ	0xE0
+#define RTC_EN_SUSPEND_REQ	0xE4
+#define RTC_PG_REG		0xF0
+#define RTC_ST_ON_REASON	0xF8
+
+#define REG_RTC_ST_ON_REASON	(REG_RTC_BASE + RTC_ST_ON_REASON)
+
+#define RTCSYS_F32KLESS_BASE		(RTC_SYS_BASE + 0x0002A000)
+
+#define RTC_INTERNAL_32K	0
+#define RTC_EXTERNAL_32K	1
+
+/* eFuse  */
+#define EFUSE_BASE (TOP_BASE + 0x00050000)
+
+/* AXI SRAM */
+#define AXI_SRAM_BASE 0x0E000000
+#define AXI_SRAM_SIZE 0x40
+
+#define EFUSE_SW_INFO_ADDR (AXI_SRAM_BASE)
+#define EFUSE_SW_INFO_SIZE 4
+
+#define BOOT_SOURCE_FLAG_ADDR (EFUSE_SW_INFO_ADDR + EFUSE_SW_INFO_SIZE)
+#define BOOT_SOURCE_FLAG_SIZE 4
+#define MAGIC_NUM_USB_DL 0x4D474E31 // MGN1
+#define MAGIC_NUM_SD_DL 0x4D474E32 // MGN2
+
+#define BOOT_LOG_LEN_ADDR (BOOT_SOURCE_FLAG_ADDR + BOOT_SOURCE_FLAG_SIZE) // 0x0E000008
+#define BOOT_LOG_LEN_SIZE 4
+
+#define TIME_RECORDS_ADDR (AXI_SRAM_BASE + 0x10) // 0x0E000010
+
+/* from fsbl/plat/cv181x/include/platform_def.h struct _time_records { ... } */
+#define TIME_RECORDS_FIELD_UBOOT_START (TIME_RECORDS_ADDR + 0x10)
+#define TIME_RECORDS_FIELD_BOOTCMD_START (TIME_RECORDS_ADDR + 0x12)
+#define TIME_RECORDS_FIELD_DECOMPRESS_KERNEL_START (TIME_RECORDS_ADDR + 0x14)
+#define TIME_RECORDS_FIELD_KERNEL_START (TIME_RECORDS_ADDR + 0x16)
+
+#endif /* __CV181X_REG_H__ */
diff --git a/board/cvitek/cv181x/cv181x_reg_fmux_gpio.h b/board/cvitek/cv181x/cv181x_reg_fmux_gpio.h
new file mode 100644
index 000000000..96042d70b
--- /dev/null
+++ b/board/cvitek/cv181x/cv181x_reg_fmux_gpio.h
@@ -0,0 +1,481 @@
+// $Module: fmux_gpio $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: ghost $
+// $Date: Fri, 27 Aug 2021 08:47:09 PM $
+//
+
+//GEN REG ADDR/OFFSET/MASK
+
+#ifndef __CV181X_REG_FMUX_GPIO_H__
+#define __CV181X_REG_FMUX_GPIO_H__
+
+#define  FMUX_GPIO_REG_IOCTRL_CAM_MCLK0  0x0
+#define  FMUX_GPIO_REG_IOCTRL_CAM_PD0  0x4
+#define  FMUX_GPIO_REG_IOCTRL_CAM_RST0  0x8
+#define  FMUX_GPIO_REG_IOCTRL_CAM_MCLK1  0xc
+#define  FMUX_GPIO_REG_IOCTRL_CAM_PD1  0x10
+#define  FMUX_GPIO_REG_IOCTRL_IIC3_SCL  0x14
+#define  FMUX_GPIO_REG_IOCTRL_IIC3_SDA  0x18
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CLK  0x1c
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CMD  0x20
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D0  0x24
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D1  0x28
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D2  0x2c
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D3  0x30
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CD  0x34
+#define  FMUX_GPIO_REG_IOCTRL_SD0_PWR_EN  0x38
+#define  FMUX_GPIO_REG_IOCTRL_SPK_EN  0x3c
+#define  FMUX_GPIO_REG_IOCTRL_UART0_TX  0x40
+#define  FMUX_GPIO_REG_IOCTRL_UART0_RX  0x44
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_RSTN  0x48
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT2  0x4c
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_CLK  0x50
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT0  0x54
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT3  0x58
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_CMD  0x5c
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT1  0x60
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TMS  0x64
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TCK  0x68
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TRST  0x6c
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SCL  0x70
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SDA  0x74
+#define  FMUX_GPIO_REG_IOCTRL_AUX0  0x78
+#define  FMUX_GPIO_REG_IOCTRL_PWR_VBAT_DET  0x7c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_RSTN  0x80
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ1  0x84
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ2  0x88
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ3  0x8c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP0  0x90
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP1  0x94
+#define  FMUX_GPIO_REG_IOCTRL_PWR_BUTTON1  0x98
+#define  FMUX_GPIO_REG_IOCTRL_PWR_ON  0x9c
+#define  FMUX_GPIO_REG_IOCTRL_XTAL_XIN  0xa0
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO0  0xa4
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO1  0xa8
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO2  0xac
+#define  FMUX_GPIO_REG_IOCTRL_CLK32K  0xb0
+#define  FMUX_GPIO_REG_IOCTRL_CLK25M  0xb4
+#define  FMUX_GPIO_REG_IOCTRL_IIC2_SCL  0xb8
+#define  FMUX_GPIO_REG_IOCTRL_IIC2_SDA  0xbc
+#define  FMUX_GPIO_REG_IOCTRL_UART2_TX  0xc0
+#define  FMUX_GPIO_REG_IOCTRL_UART2_RTS  0xc4
+#define  FMUX_GPIO_REG_IOCTRL_UART2_RX  0xc8
+#define  FMUX_GPIO_REG_IOCTRL_UART2_CTS  0xcc
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D3  0xd0
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D2  0xd4
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D1  0xd8
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D0  0xdc
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CMD  0xe0
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CLK  0xe4
+#define  FMUX_GPIO_REG_IOCTRL_RSTN  0xe8
+#define  FMUX_GPIO_REG_IOCTRL_PWM0_BUCK  0xec
+#define  FMUX_GPIO_REG_IOCTRL_ADC3  0xf0
+#define  FMUX_GPIO_REG_IOCTRL_ADC2  0xf4
+#define  FMUX_GPIO_REG_IOCTRL_ADC1  0xf8
+#define  FMUX_GPIO_REG_IOCTRL_USB_ID  0xfc
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_EN  0x100
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE0  0x104
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_DET  0x108
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE1  0x10c
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE2  0x110
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MISO  0x114
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MOSI  0x118
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_CS  0x11c
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_SCK  0x120
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXP  0x124
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXM  0x128
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXP  0x12c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXM  0x130
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D10  0x134
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D9  0x138
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D8  0x13c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D7  0x140
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D6  0x144
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D5  0x148
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D4  0x14c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D3  0x150
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D2  0x154
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D1  0x158
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D0  0x15c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_CLK  0x160
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX5N  0x164
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX5P  0x168
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4N  0x16c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4P  0x170
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3N  0x174
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3P  0x178
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2N  0x17c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2P  0x180
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1N  0x184
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1P  0x188
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0N  0x18c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0P  0x190
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM4  0x194
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP4  0x198
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM3  0x19c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP3  0x1a0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM2  0x1a4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP2  0x1a8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM1  0x1ac
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP1  0x1b0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM0  0x1b4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP0  0x1b8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINL_MIC  0x1bc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINR_MIC  0x1c0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTL  0x1c4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTR  0x1c8
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_RTX  0x1cc
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_ZQ  0x1d0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0   0x0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0   0x4
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0   0x8
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1   0xc
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1   0x10
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL   0x14
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA   0x18
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK   0x1c
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD   0x20
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D0   0x24
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D1   0x28
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D2   0x2c
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D3   0x30
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CD   0x34
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN   0x38
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPK_EN   0x3c
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_TX   0x40
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_RX   0x44
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN   0x48
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2   0x4c
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK   0x50
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0   0x54
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3   0x58
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD   0x5c
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1   0x60
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS   0x64
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK   0x68
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST   0x6c
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL   0x70
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA   0x74
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_AUX0   0x78
+#define  FMUX_GPIO_FUNCSEL_AUX0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_AUX0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET   0x7c
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN   0x80
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1   0x84
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2   0x88
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3   0x8c
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0   0x90
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1   0x94
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1   0x98
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_ON   0x9c
+#define  FMUX_GPIO_FUNCSEL_PWR_ON_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_ON_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN   0xa0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0   0xa4
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1   0xa8
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2   0xac
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CLK32K   0xb0
+#define  FMUX_GPIO_FUNCSEL_CLK32K_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CLK32K_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CLK25M   0xb4
+#define  FMUX_GPIO_FUNCSEL_CLK25M_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CLK25M_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL   0xb8
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA   0xbc
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_TX   0xc0
+#define  FMUX_GPIO_FUNCSEL_UART2_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS   0xc4
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_RX   0xc8
+#define  FMUX_GPIO_FUNCSEL_UART2_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS   0xcc
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D3   0xd0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D2   0xd4
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D1   0xd8
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D0   0xdc
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD   0xe0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK   0xe4
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_RSTN   0xe8
+#define  FMUX_GPIO_FUNCSEL_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK   0xec
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC3   0xf0
+#define  FMUX_GPIO_FUNCSEL_ADC3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC2   0xf4
+#define  FMUX_GPIO_FUNCSEL_ADC2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC1   0xf8
+#define  FMUX_GPIO_FUNCSEL_ADC1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_ID   0xfc
+#define  FMUX_GPIO_FUNCSEL_USB_ID_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_ID_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN   0x100
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0   0x104
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET   0x108
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1   0x10c
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2   0x110
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO   0x114
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI   0x118
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS   0x11c
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK   0x120
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP   0x124
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM   0x128
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP   0x12c
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM   0x130
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10   0x134
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9   0x138
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8   0x13c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7   0x140
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6   0x144
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5   0x148
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4   0x14c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3   0x150
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2   0x154
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1   0x158
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0   0x15c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK   0x160
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N   0x164
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P   0x168
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N   0x16c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P   0x170
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N   0x174
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P   0x178
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N   0x17c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P   0x180
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N   0x184
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P   0x188
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N   0x18c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P   0x190
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4   0x194
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4   0x198
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3   0x19c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3   0x1a0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2   0x1a4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2   0x1a8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1   0x1ac
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1   0x1b0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0   0x1b4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0   0x1b8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC   0x1bc
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC   0x1c0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL   0x1c4
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR   0x1c8
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX   0x1cc
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ   0x1d0
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_MASK   0x7
+
+#endif /* __CV181X_REG_FMUX_GPIO_H__ */
diff --git a/board/cvitek/cv181x/sdhci_reg.h b/board/cvitek/cv181x/sdhci_reg.h
new file mode 100644
index 000000000..ec4ad5451
--- /dev/null
+++ b/board/cvitek/cv181x/sdhci_reg.h
@@ -0,0 +1,130 @@
+#ifndef _SDHCI_REG_H
+#define _SDHCI_REG_H
+#include "cv181x_reg.h"
+#define REG_TOP_SD_PWRSW_CTRL (0x1F4)
+
+#define REG_SDIO0_PAD_MASK (0xFFFFFFF3)
+#define REG_SDIO0_PAD_SHIFT (2)
+
+#define REG_SDIO0_PAD_CLR_MASK (0xC)
+#define REG_SDIO0_CD_PAD_REG (PINMUX_BASE + 0x900)
+#define REG_SDIO0_CD_PAD_VALUE (1)
+#define REG_SDIO0_CD_PAD_RESET (1)
+
+#define REG_SDIO0_PWR_EN_PAD_REG (PINMUX_BASE + 0x904)
+#define REG_SDIO0_PWR_EN_PAD_VALUE (2)
+#define REG_SDIO0_PWR_EN_PAD_RESET (2)
+
+#define REG_SDIO0_CLK_PAD_REG (PINMUX_BASE + 0xA00)
+#define REG_SDIO0_CLK_PAD_VALUE (2)
+#define REG_SDIO0_CLK_PAD_RESET (2)
+
+#define REG_SDIO0_CMD_PAD_REG (PINMUX_BASE + 0xA04)
+#define REG_SDIO0_CMD_PAD_VALUE (1)
+#define REG_SDIO0_CMD_PAD_RESET (2)
+
+#define REG_SDIO0_DAT0_PAD_REG (PINMUX_BASE + 0xA08)
+#define REG_SDIO0_DAT0_PAD_VALUE (1)
+#define REG_SDIO0_DAT0_PAD_RESET (2)
+
+#define REG_SDIO0_DAT1_PAD_REG (PINMUX_BASE + 0xA0C)
+#define REG_SDIO0_DAT1_PAD_VALUE (1)
+#define REG_SDIO0_DAT1_PAD_RESET (2)
+
+#define REG_SDIO0_DAT2_PAD_REG (PINMUX_BASE + 0xA10)
+#define REG_SDIO0_DAT2_PAD_VALUE (1)
+#define REG_SDIO0_DAT2_PAD_RESET (2)
+
+#define REG_SDIO0_DAT3_PAD_REG (PINMUX_BASE + 0xA14)
+#define REG_SDIO0_DAT3_PAD_VALUE (1)
+#define REG_SDIO0_DAT3_PAD_RESET (2)
+
+#define PAD_SDIO0_CD_REG (PINMUX_BASE + 0x34)
+#define PAD_SDIO0_PWR_EN_REG (PINMUX_BASE + 0x38)
+#define PAD_SDIO0_CLK_REG (PINMUX_BASE + 0x1C)
+#define PAD_SDIO0_CMD_REG (PINMUX_BASE + 0x20)
+#define PAD_SDIO0_D0_REG (PINMUX_BASE + 0x24)
+#define PAD_SDIO0_D1_REG (PINMUX_BASE + 0x28)
+#define PAD_SDIO0_D2_REG (PINMUX_BASE + 0x2C)
+#define PAD_SDIO0_D3_REG (PINMUX_BASE + 0x30)
+
+#define REG_SDIO1_PAD_MASK (0xFFFFFFF3)
+#define REG_SDIO1_PAD_SHIFT (2)
+
+#define SDIO1_PAD_BASE 0x05027000
+#define REG_SDIO1_PAD_CLR_MASK (0xC)
+#define REG_SDIO1_CLK_PAD_REG (SDIO1_PAD_BASE + 0x06C)
+#define REG_SDIO1_CLK_PAD_VALUE (2)
+
+#define REG_SDIO1_CMD_PAD_REG (SDIO1_PAD_BASE + 0x068)
+#define REG_SDIO1_CMD_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT0_PAD_REG (SDIO1_PAD_BASE + 0x064)
+#define REG_SDIO1_DAT0_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT2_PAD_REG (SDIO1_PAD_BASE + 0x05C)
+#define REG_SDIO1_DAT2_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT1_PAD_REG (SDIO1_PAD_BASE + 0x060)
+#define REG_SDIO1_DAT1_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT3_PAD_REG (SDIO1_PAD_BASE + 0x058)
+#define REG_SDIO1_DAT3_PAD_VALUE (1)
+
+#define REG_EMMC_PAD_CLR_MASK (0xC)
+#define REG_EMMC_PAD_SHIFT (2)
+
+#define REG_EMMC_RSTN_PAD_REG (PINMUX_BASE + 0x914)
+#define REG_EMMC_RSTN_PAD_VALUE (1)
+
+#define REG_EMMC_CLK_PAD_REG (PINMUX_BASE + 0x91c)
+#define REG_EMMC_CLK_PAD_VALUE (2)
+
+#define REG_EMMC_CMD_PAD_REG (PINMUX_BASE + 0x928)
+#define REG_EMMC_CMD_PAD_VALUE (1)
+
+#define REG_EMMC_DAT0_PAD_REG (PINMUX_BASE + 0x920)
+#define REG_EMMC_DAT0_PAD_VALUE (1)
+
+#define REG_EMMC_DAT1_PAD_REG (PINMUX_BASE + 0x92C)
+#define REG_EMMC_DAT1_PAD_VALUE (1)
+
+#define REG_EMMC_DAT2_PAD_REG (PINMUX_BASE + 0x918)
+#define REG_EMMC_DAT2_PAD_VALUE (1)
+
+#define REG_EMMC_DAT3_PAD_REG (PINMUX_BASE + 0x924)
+#define REG_EMMC_DAT3_PAD_VALUE (1)
+
+#define CVI_SDHCI_VENDOR_OFFSET 0x200
+#define CVI_SDHCI_PHY_TX_RX_DLY	(CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_PHY_DS_DLY	(CVI_SDHCI_VENDOR_OFFSET + 0x44)
+#define CVI_SDHCI_PHY_DLY_STS	(CVI_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_SDHCI_PHY_CONFIG	(CVI_SDHCI_VENDOR_OFFSET + 0x4C)
+
+#define CVI_SDHCI_BIT_CLK_FREE_EN 2
+#define CVI_SDHCI_CLK_FREE_EN_VALUE 0
+#define CVI_SDHCI_CLK_FREE_EN_MASK 0xFFFFFFFB
+#define CVI_SDHCI_VENDOR_MSHC_CTRL_R (CVI_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_SDHCI_PHY_RX_DLY_SHIFT 16
+// Bit 16~22
+#define CVI_SDHCI_PHY_RX_DLY_MASK 0x7F0000
+#define CVI_SDHCI_PHY_TX_RX_DLY (CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_PHY_RX_SRC_BIT_1 24
+#define CVI_SDHCI_PHY_RX_SRC_BIT_2 25
+
+#define SDHCI_PHY_CONFIG                                                       \
+	(CVI_SDHCI_VENDOR_OFFSET +                                             \
+	 0x4C) // P_VERDOR_SPECIFIC_AREA + 0x4c0x24c( PHY_TX_BPS )
+#define REG_TX_BPS_SEL_MASK 0xFFFFFFFE
+#define REG_TX_BPS_SEL_CLR_MASK (0x1) // 0x24c  PHY_TX_BPS
+#define REG_TX_BPS_SEL_SHIFT (0) // 0x24c  PHY_TX_BPS
+#define REG_TX_BPS_SEL_BYPASS (1) // 0x24c PHY_TX_BPS inv
+
+#define MMC_MAX_CLOCK (375000000)
+#define MMC_MAX_CLOCK_DIV_VALUE (0x40009)
+#define CLOCK_BYPASS_SELECT_REGISTER (0x3002030)
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#endif
diff --git a/board/cvitek/cv1822/Kconfig b/board/cvitek/cv1822/Kconfig
new file mode 100644
index 000000000..528693877
--- /dev/null
+++ b/board/cvitek/cv1822/Kconfig
@@ -0,0 +1,44 @@
+if TARGET_CVITEK_CV1822
+
+choice
+	prompt "Cvitek CV1822 verification platform type select"
+
+config TARGET_CVITEK_CV1822_ASIC
+	bool "ASIC"
+	help
+	  This enables support for Cvitek's CV1822 SoC on ASIC platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV1822_PALLADIUM
+	bool "Palladium"
+	help
+	  This enables support for Cvitek's CV1822 SoC on PALLADIUM platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV1822_FPGA
+	bool "FPGA"
+	help
+	  This enables support for Cvitek's CV1822 SoC on FPGA platform.
+
+	  If unsure, say N.
+
+endchoice
+
+config SYS_BOARD
+	default "cv1822"
+
+config SYS_VENDOR
+	default "cvitek"
+
+config SYS_CONFIG_NAME
+	default "cv1822-asic" if TARGET_CVITEK_CV1822_ASIC
+	default "cv1822-palladium" if TARGET_CVITEK_CV1822_PALLADIUM
+	default "cv1822-fpga" if TARGET_CVITEK_CV1822_FPGA
+
+config SYS_BOOTMAPSZ
+	hex "Maximum size of memory mapped"
+	default "0x8000000"
+
+endif
diff --git a/board/cvitek/cv1822/MAINTAINERS b/board/cvitek/cv1822/MAINTAINERS
new file mode 100644
index 000000000..f8fabe2e8
--- /dev/null
+++ b/board/cvitek/cv1822/MAINTAINERS
@@ -0,0 +1,4 @@
+CV1822 BOARD
+M:	Myles Tsai <myles.tsai@wisecore.com.tw>
+S:	Maintained
+F:	board/armltd/vexpress64/
diff --git a/board/cvitek/cv1822/Makefile b/board/cvitek/cv1822/Makefile
new file mode 100644
index 000000000..da8bfb2ae
--- /dev/null
+++ b/board/cvitek/cv1822/Makefile
@@ -0,0 +1,2 @@
+
+obj-y	:= board.o
diff --git a/board/cvitek/cv1822/board.c b/board/cvitek/cv1822/board.c
new file mode 100644
index 000000000..d2d014385
--- /dev/null
+++ b/board/cvitek/cv1822/board.c
@@ -0,0 +1,418 @@
+/*
+ * (C) Copyright 2013
+ * David Feng <fenghua@phytium.com.cn>
+ * Sharma Bhupesh <bhupesh.sharma@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <dm/platform_data/serial_pl01x.h>
+#include <asm/armv8/mmu.h>
+#include <mmio.h>
+#include <usb/dwc2_udc.h>
+#include <usb.h>
+#include "cv1822_reg.h"
+#include "cvi_reboot.h"
+#include "cv1822_reg_fmux_gpio.h"
+#include "cv1822_pinlist_swconfig.h"
+#include <linux/delay.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_PL011_SERIAL
+static const struct pl01x_serial_platdata serial_platdata = {
+	.base = V2M_UART0,
+	.type = TYPE_PL011,
+	.clock = CONFIG_PL011_CLOCK,
+};
+
+U_BOOT_DEVICE(vexpress_serials) = {
+	.name = "serial_pl01x",
+	.platdata = &serial_platdata,
+};
+#endif
+
+static struct mm_region vexpress64_mem_map[] = {
+	{
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		.virt = PHYS_SDRAM_1,
+		.phys = PHYS_SDRAM_1,
+		.size = PHYS_SDRAM_1_SIZE,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+#ifdef BM_UPDATE_FW_START_ADDR
+	}, {
+		.virt = BM_UPDATE_FW_START_ADDR,
+		.phys = BM_UPDATE_FW_START_ADDR,
+		/*
+		 * this area is for bmtest under uboot. -- added by Xun Li
+		 * [0x110000000, 0x190000000] size = 2G
+		 */
+		.size = BM_UPDATE_FW_SIZE,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+#else
+	}, {
+		/*
+		 * be aware we'll need 256MB more other than PHYS_SDRAM_1_SIZE for the fake flash area
+		 * of itb file during ram boot, and MMC's DMA buffer (BM_UPDATE_ALIGNED_BUFFER).
+		 * so either cover it here or in video's region.
+		 * also be carefull with BM_SPIF_BUFFER_ADDR and BM_UPDATE_FW_START_ADDR...
+		 */
+		.virt = PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE,
+		.phys = PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE,
+		.size = 0x10000000,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+#endif
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = vexpress64_mem_map;
+
+// #define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) printf ("%s\n", PIN_NAME ##_ ##FUNC_NAME);
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + fmux_gpio_funcsel_##PIN_NAME, \
+			fmux_gpio_funcsel_##PIN_NAME##_MASK << fmux_gpio_funcsel_##PIN_NAME##_OFFSET, \
+			PIN_NAME##__##FUNC_NAME)
+
+static void pinmux_config(int io_type)
+{
+		switch (io_type) {
+		case PINMUX_UART0:
+			PINMUX_CONFIG(UART0_RX, UART0_RX);
+			PINMUX_CONFIG(UART0_TX, UART0_TX);
+		break;
+		case PINMUX_I2S1:
+			PINMUX_CONFIG(PAD_AUD_AOUTR, IIS1_DI);
+			PINMUX_CONFIG(AUX0, IIS1_MCLK);
+			PINMUX_CONFIG(PAD_AUD_AINR_MIC, IIS1_DO);
+			PINMUX_CONFIG(PAD_AUD_AINL_MIC, IIS1_BCLK);
+			PINMUX_CONFIG(PAD_AUD_AOUTL, IIS1_LRCK);
+		break;
+		case PINMUX_I2S2:
+			PINMUX_CONFIG(UART2_RX, IIS2_DI);
+			PINMUX_CONFIG(IIC2_SDA, IIS2_MCLK);
+			PINMUX_CONFIG(UART2_RTS, IIS2_DO);
+			PINMUX_CONFIG(UART2_TX, IIS2_BCLK);
+			PINMUX_CONFIG(UART2_CTS, IIS2_LRCK);
+		break;
+		case PINMUX_EMMC:
+			PINMUX_CONFIG(EMMC_RSTN, EMMC_RSTN);
+			PINMUX_CONFIG(EMMC_DAT2, EMMC_DAT_2);
+			PINMUX_CONFIG(EMMC_CLK, EMMC_CLK);
+			PINMUX_CONFIG(EMMC_DAT0, EMMC_DAT_0);
+			PINMUX_CONFIG(EMMC_DAT3, EMMC_DAT_3);
+			PINMUX_CONFIG(EMMC_CMD, EMMC_CMD);
+			PINMUX_CONFIG(EMMC_DAT1, EMMC_DAT_1);
+		break;
+		case PINMUX_SPI_NOR:
+			PINMUX_CONFIG(EMMC_CLK, SPINOR_SCK);
+			PINMUX_CONFIG(EMMC_CMD, SPINOR_MISO);
+			PINMUX_CONFIG(EMMC_DAT1, SPINOR_CS_X);
+			PINMUX_CONFIG(EMMC_DAT0, SPINOR_MOSI);
+			PINMUX_CONFIG(EMMC_DAT2, SPINOR_HOLD_X);
+			PINMUX_CONFIG(EMMC_DAT3, SPINOR_WP_X);
+		break;
+		case PINMUX_SPI_NAND:
+			PINMUX_CONFIG(EMMC_DAT2, SPINAND_HOLD);
+			PINMUX_CONFIG(EMMC_CLK, SPINAND_CLK);
+			PINMUX_CONFIG(EMMC_DAT0, SPINAND_MOSI);
+			PINMUX_CONFIG(EMMC_DAT3, SPINAND_WP);
+			PINMUX_CONFIG(EMMC_CMD, SPINAND_MISO);
+			PINMUX_CONFIG(EMMC_DAT1, SPINAND_CS);
+		break;
+		case PINMUX_SDIO1:
+			PINMUX_CONFIG(SD1_CMD, PWR_SD1_CMD);
+			PINMUX_CONFIG(SD1_CLK, PWR_SD1_CLK);
+			PINMUX_CONFIG(SD1_D0, PWR_SD1_D0);
+			PINMUX_CONFIG(SD1_D1, PWR_SD1_D1);
+			PINMUX_CONFIG(SD1_D2, PWR_SD1_D2);
+			PINMUX_CONFIG(SD1_D3, PWR_SD1_D3);
+		break;
+		case PINMUX_DSI:
+#if (defined(CV1822_WDMB_0004A_SPINAND) || defined(CV1822_WDMB_0004B_SPINAND))
+			// no panel
+#elif (defined(CV1822_WEVB_0005B_SPINAND) || defined(CV1822_WEVB_0005B_64MB_SPINAND))
+			PINMUX_CONFIG(PAD_MIPI_TXM0, XGPIOC_12);
+			PINMUX_CONFIG(PAD_MIPI_TXP0, XGPIOC_13);
+			PINMUX_CONFIG(PAD_MIPI_TXM1, XGPIOC_14);
+			PINMUX_CONFIG(PAD_MIPI_TXP1, XGPIOC_15);
+			PINMUX_CONFIG(PAD_MIPI_TXM2, XGPIOC_16);
+			PINMUX_CONFIG(PAD_MIPI_TXP2, XGPIOC_17);
+#else
+			PINMUX_CONFIG(PAD_MIPI_TXM0, XGPIOC_12);
+			PINMUX_CONFIG(PAD_MIPI_TXP0, XGPIOC_13);
+			PINMUX_CONFIG(PAD_MIPI_TXM1, XGPIOC_14);
+			PINMUX_CONFIG(PAD_MIPI_TXP1, XGPIOC_15);
+			PINMUX_CONFIG(PAD_MIPI_TXM2, XGPIOC_16);
+			PINMUX_CONFIG(PAD_MIPI_TXP2, XGPIOC_17);
+			PINMUX_CONFIG(PAD_MIPI_TXM3, XGPIOC_20);
+			PINMUX_CONFIG(PAD_MIPI_TXP3, XGPIOC_21);
+			PINMUX_CONFIG(PAD_MIPI_TXM4, XGPIOC_18);
+			PINMUX_CONFIG(PAD_MIPI_TXP4, XGPIOC_19);
+#endif
+		break;
+		default:
+		break;
+	}
+}
+
+void config_pinmux_for_low_power(void)
+{
+#if 0
+	// Board-dependent settings
+	mmio_write_32(0x03001090, 0x03);	// Set PWR_WAKEUP0 to GPIO
+	mmio_write_32(0x03001094, 0x03);	// Set PWR_WAKEUP1 to GPIO
+	mmio_write_32(0x0300109C, 0x03);	// Set PWR_ON to GPIO
+	mmio_write_32(0x030010B0, 0x03);	// Set CLK32K to GPIO
+	mmio_write_32(0x030010B4, 0x03);	// Set CLK25M to GPIO
+
+	mmio_write_32(0x05027008, 0x40);	// PWR_SEQ1: remove PD
+	mmio_write_32(0x0502700C, 0x40);	// PWR_SEQ2: remove PD
+	mmio_write_32(0x05027010, 0x40);	// PWR_SEQ3: remove PD
+
+	mmio_write_32(0x05027018, 0x40);	// PWR_WAKEUP0: remove PD, on board PU VDDIO_RTC
+	mmio_write_32(0x0502701C, 0x40);	// PWR_WAKEUP1: remove PD, on board PU VDDIO_RTC
+	mmio_write_32(0x05027024, 0x40);	// PWR_ON: remove PD
+	mmio_write_32(0x05027034, 0x40);	// PWR_GPIO[2]: remove PD, on board PU VDDIO_WIFI
+	mmio_write_32(0x05027038, 0x40);	// CLK32K: remove PD, on board PU VDDIO_RTC
+	mmio_write_32(0x0502703C, 0x40);	// CLK25M: remove PD, on board PU VDDIO_RTC
+	mmio_write_32(0x05027040, 0x40);	// IIC2_SCL: remove PD, on board PU VDDIO_WIFI
+	mmio_write_32(0x05027044, 0x40);	// IIC2_SDA: remove PD, on board PU VDDIO_WIFI
+	mmio_write_32(0x0502704C, 0x40);	// UART2_RTS: remove PD, on board PU VDDIO_WIFI
+	mmio_write_32(0x05027054, 0x40);	// UART2_CTS: remove PD, on board PU VDDIO_WIFI
+
+	mmio_write_32(0x05027030, 0x44);	// PWR_GPIO[1]: pull up
+	mmio_clrbits_32(0x05021000, 0x1 << 1);	// Set PWR_GPIO[1] to input
+	mmio_clrbits_32(0x05021004, 0x1 << 1);	// Set PWR_GPIO[1] to input
+#endif
+}
+
+void enable_pwr_drop_protection(void)
+{
+	mmio_setbits_32(TOP_BASE + 0x22C, 0x3);
+}
+
+#ifdef CONFIG_CMD_CVI_SAPD
+static void config_rtc_ctrl_for_low_power(void)
+{
+	mmio_write_32(0x05025084, 0x00030003); // m51 iso_en, sd_iso_en
+	mmio_write_32(0x05025080, 0x00000003); // m51 power down , sd power up
+	mmio_write_32(0x05025084, 0x00030002); // m51 iso en and sd iso dis
+	mmio_write_32(0x05025098, 0x000009A6); // sd sram power up
+	mmio_write_32(0x05025034, 0x06450036); // sd clock en
+	//info("Drc_lp\n");
+}
+#endif
+
+#include "../cvi_board_init.c"
+
+// #define CV182X_RTC_EXTERNAL_32K
+int board_init(void)
+{
+#if defined(CONFIG_TARGET_CVITEK_CV1822_ASIC) /* config eth internal phy on ASIC board */
+	unsigned int val;
+
+	val = readl(0x03009000) & ETH_PHY_INIT_MASK;
+	writel((val | ETH_PHY_SHUTDOWN) & ETH_PHY_RESET, 0x03009000);
+	mdelay(1);
+	writel(val & ETH_PHY_POWERUP & ETH_PHY_RESET, 0x03009000);
+	mdelay(20);
+	writel((val & ETH_PHY_POWERUP) | ETH_PHY_RESET_N, 0x03009000);
+	mdelay(1);
+#endif
+
+/* Set ethernet clock resource */
+#if defined(CONFIG_TARGET_CVITEK_CV1835_FPGA)
+	writel(0x000000C0, 0x03000034); /* Set eth0 RGMII, eth1 RMII clk resource and interface type*/
+#elif defined(CONFIG_TARGET_CVITEK_CV1835_ASIC)
+	writel(0x00000004, 0x03000034); /* Set eth0 RMII, eth1 RGMII clk resource and interface type*/
+#elif defined(CONFIG_TARGET_CVITEK_CV1835_PALLADIUM)
+	writel(0x00000004, 0x03000034); /* Set eth0 RMII, eth1 RGMII clk resource and interface type*/
+#endif
+
+#ifdef CONFIG_CMD_CVI_SAPD
+	mmio_write_32(RTC_INFO0, CVI_SAPD_FLAG);
+	config_rtc_ctrl_for_low_power();
+#endif
+
+	enable_pwr_drop_protection();
+
+#if defined(CONFIG_NAND_SUPPORT)
+	pinmux_config(PINMUX_SPI_NAND);
+#elif defined(CONFIG_SPI_FLASH)
+	pinmux_config(PINMUX_SPI_NOR);
+#elif defined(CONFIG_EMMC_SUPPORT)
+	pinmux_config(PINMUX_EMMC);
+#endif
+
+#ifdef CONFIG_DISPLAY_CVITEK_MIPI
+	pinmux_config(PINMUX_DSI);
+#endif
+
+#if defined(CV1822_WDMB_0002A_SPINAND)
+	PINMUX_CONFIG(JTAG_CPU_TCK, XGPIOA_18); //IIC2_SHDN
+	PINMUX_CONFIG(JTAG_CPU_TMS, XGPIOA_19);//AMP_MUTE
+#elif (defined(CV1822_WEVB_0005B_SPINAND) || defined(CV1822_WEVB_0005B_64MB_SPINAND))
+	PINMUX_CONFIG(SPK_EN, XGPIOA_15);
+	PINMUX_CONFIG(JTAG_CPU_TCK, XGPIOA_18);
+	PINMUX_CONFIG(JTAG_CPU_TMS, XGPIOA_19);//AMP_MUTE
+#elif defined(CV1822_WDMB_0001A_SPINAND)
+	PINMUX_CONFIG(UART1_RX, UART1_RX); //UART_RX,TX,CTS
+	PINMUX_CONFIG(UART1_TX, UART1_TX);
+	PINMUX_CONFIG(UART1_CTS, UART1_CTS);
+#endif
+
+#if defined(CONFIG_MMC_SDHCI_CVITEK_WIFI)
+	pinmux_config(PINMUX_SDIO1);
+#else
+	/* If not support wifi, then switch pinmux to enable LED */
+	PINMUX_CONFIG(SD1_CMD, EPHY_LNK_LED);
+	PINMUX_CONFIG(SD1_CLK, EPHY_SPD_LED);
+#endif
+
+#if (defined(CV1822_WDMB_0004A_SPINAND) || defined(CV1822_WDMB_0004B_SPINAND))
+	PINMUX_CONFIG(PAD_MIPI_TXP0, CAM_MCLK0);
+	PINMUX_CONFIG(PAD_MIPI_TXM0, XGPIOC_12);
+	PINMUX_CONFIG(IIC2_SCL, PWR_GPIO_12);
+	PINMUX_CONFIG(IIC2_SDA, PWR_GPIO_13);
+	PINMUX_CONFIG(PAD_MIPI_TXP1, IIC2_SCL);
+	PINMUX_CONFIG(PAD_MIPI_TXM1, IIC2_SDA);
+	PINMUX_CONFIG(PAD_MIPI_TXP2, XGPIOC_17);
+#elif (defined(CV1821_WEVB_0005B_SPINAND) ||	\
+	defined(CV1822_WEVB_0005B_128MB_SPINAND) ||	\
+	defined(CV1822_WEVB_0005B_64MB_SPINAND) ||	\
+	defined(CV1822_WEVB_0005B_SPINAND)) || \
+	defined(CV1822_WEVB_0005B_SPINOR) || \
+	defined(CV1821_WEVB_0005B_SPINOR) || \
+	defined(CV1821_WEVB_0005B_64MB_SPINOR) || \
+	defined(CV1820_WEVB_0005B_SPINOR)
+	PINMUX_CONFIG(PAD_MIPI_TXP0, XGPIOC_13);
+	PINMUX_CONFIG(PAD_MIPI_TXM0, CAM_MCLK1);
+	PINMUX_CONFIG(IIC2_SCL, PWR_GPIO_12);
+	PINMUX_CONFIG(IIC2_SDA, PWR_GPIO_13);
+	PINMUX_CONFIG(PAD_MIPI_TXP1, IIC2_SCL);
+	PINMUX_CONFIG(PAD_MIPI_TXM1, IIC2_SDA);
+#elif defined(CV1822_WDMB_0004C_SPINAND)
+	PINMUX_CONFIG(SD1_CMD, PWR_GPIO_22); //PANEL RESET
+	PINMUX_CONFIG(SD1_D0, IIC1_SDA); //IIC1 SDA
+	PINMUX_CONFIG(SD1_D3, IIC1_SCL); //IIC1 SCL
+	PINMUX_CONFIG(SD1_D2, CAM_MCLK0); //MCLK
+	PINMUX_CONFIG(SD1_D1, PWR_GPIO_20); //CAM RESET
+	PINMUX_CONFIG(SD1_CLK, PWR_GPIO_23); //PWDN
+#else
+	PINMUX_CONFIG(IIC2_SCL, IIC2_SCL); //IIC2
+	PINMUX_CONFIG(IIC2_SDA, IIC2_SDA);
+#endif
+
+#if 0
+#ifdef CONFIG_PWM_CVITEK
+	PINMUX_CONFIG(IIC2_SCL, PWM_14);//PWM_14
+	PINMUX_CONFIG(IIC2_SDA, PWM_15);//PWM_15
+	PINMUX_CONFIG(PWM0_BUCK, PWM_0);//PWM_0
+#endif
+#endif
+
+	cvi_board_init();
+
+	config_pinmux_for_low_power();
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+void software_root_reset(void)
+{
+	// clear spinand sv vec in case stuck at next boot.
+	mmio_setbits_32(CLKGEN_BASE, BIT(4)); // Enable clk_tpu
+	memset((void *)BM_IO_BUF_BASE, 0x0, BM_IO_BUF_SIZE); //8KB
+
+	mmio_write_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ, 0x01);
+	while (mmio_read_32(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != 0x01)
+		;
+	mmio_write_32(REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY, 0xAB18);
+	mmio_setbits_32(REG_RTC_CTRL_BASE + RTC_CTRL0, 0xFFFF0800 | (0x1 << 4));
+	while (1)
+		;
+}
+void reset_cpu(void)
+{
+}
+
+/*
+ * Board specific ethernet initialization routine.
+ */
+#if 0
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_SMC91111
+	rc = smc91111_initialize(0, CONFIG_SMC91111_BASE);
+#endif
+#ifdef CONFIG_SMC911X
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+	return rc;
+}
+#endif
+#ifdef CONFIG_USB_GADGET_DWC2_OTG
+struct dwc2_plat_otg_data cv182x_otg_data = {
+	.regs_otg = USB_BASE,
+	.usb_gusbcfg    = 0x40081400,
+	.rx_fifo_sz     = 512,
+	.np_tx_fifo_sz  = 512,
+	.tx_fifo_sz     = 512,
+};
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	uint32_t value;
+
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) & (~BIT_TOP_SOFT_RST_USB);
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+	udelay(50);
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) | BIT_TOP_SOFT_RST_USB;
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+
+	/* Set USB phy configuration */
+	value = mmio_read_32(REG_TOP_USB_PHY_CTRL);
+	mmio_write_32(REG_TOP_USB_PHY_CTRL, value | BIT_TOP_USB_PHY_CTRL_EXTVBUS
+					| USB_PHY_ID_OVERRIDE_ENABLE
+					| USB_PHY_ID_VALUE);
+
+	/* Enable ECO RXF */
+	mmio_write_32(REG_TOP_USB_ECO, mmio_read_32(REG_TOP_USB_ECO) | BIT_TOP_USB_ECO_RX_FLUSH);
+
+	printf("cvi_usb_hw_init done\n");
+
+	return dwc2_udc_probe(&cv182x_otg_data);
+}
+#endif
diff --git a/board/cvitek/cv1822/cv1822_pinlist_swconfig.h b/board/cvitek/cv1822/cv1822_pinlist_swconfig.h
new file mode 100644
index 000000000..ec3c60437
--- /dev/null
+++ b/board/cvitek/cv1822/cv1822_pinlist_swconfig.h
@@ -0,0 +1,614 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cv18322_pinlist_swconfig.h
+ * Description:
+ */
+
+#ifndef __CV1822_PINLIST_SWCONFIG_H__
+#define __CV1822_PINLIST_SWCONFIG_H__
+
+//##==============================================================================
+//##=== This script is generate by genswconfig.pl from .\00_Mercury_Pinlist_20200819_SPEPHY.xls
+//##=== Generate Time stamp is : 2020-08-20 11:01:40
+//##==============================================================================
+
+#define CAM_MCLK0__CAM_MCLK0 0
+#define CAM_MCLK0__AUX1 2
+#define CAM_MCLK0__XGPIOA_0 3
+#define CAM_PD0__IIS1_MCLK 1
+#define CAM_PD0__XGPIOA_1 3
+#define CAM_RST0__XGPIOA_2 3
+#define CAM_RST0__IIC4_SCL 6
+#define CAM_MCLK1__CAM_MCLK1 0
+#define CAM_MCLK1__AUX2 2
+#define CAM_MCLK1__XGPIOA_3 3
+#define CAM_PD1__IIS1_MCLK 1
+#define CAM_PD1__XGPIOA_4 3
+#define CAM_PD1__IIC4_SDA 6
+#define IIC3_SCL__IIC3_SCL 0
+#define IIC3_SCL__XGPIOA_5 3
+#define IIC3_SDA__IIC3_SDA 0
+#define IIC3_SDA__XGPIOA_6 3
+#define SD0_CLK__SDIO0_CLK 0
+#define SD0_CLK__IIC1_SDA 1
+#define SD0_CLK__SPI0_SCK 2
+#define SD0_CLK__XGPIOA_7 3
+#define SD0_CLK__PWM_15 5
+#define SD0_CLK__EPHY_LNK_LED 6
+#define SD0_CLK__DBG_0 7
+#define SD0_CMD__SDIO0_CMD 0
+#define SD0_CMD__IIC1_SCL 1
+#define SD0_CMD__SPI0_SDO 2
+#define SD0_CMD__XGPIOA_8 3
+#define SD0_CMD__PWM_14 5
+#define SD0_CMD__EPHY_SPD_LED 6
+#define SD0_CMD__DBG_1 7
+#define SD0_D0__SDIO0_D_0 0
+#define SD0_D0__CAM_MCLK1 1
+#define SD0_D0__SPI0_SDI 2
+#define SD0_D0__XGPIOA_9 3
+#define SD0_D0__UART3_TX 4
+#define SD0_D0__PWM_13 5
+#define SD0_D0__WG0_D0 6
+#define SD0_D0__DBG_2 7
+#define SD0_D1__SDIO0_D_1 0
+#define SD0_D1__IIC1_SDA 1
+#define SD0_D1__AUX0 2
+#define SD0_D1__XGPIOA_10 3
+#define SD0_D1__UART1_TX 4
+#define SD0_D1__PWM_12 5
+#define SD0_D1__WG0_D1 6
+#define SD0_D1__DBG_3 7
+#define SD0_D2__SDIO0_D_2 0
+#define SD0_D2__IIC1_SCL 1
+#define SD0_D2__AUX1 2
+#define SD0_D2__XGPIOA_11 3
+#define SD0_D2__UART1_RX 4
+#define SD0_D2__PWM_11 5
+#define SD0_D2__WG1_D0 6
+#define SD0_D2__DBG_4 7
+#define SD0_D3__SDIO0_D_3 0
+#define SD0_D3__CAM_MCLK0 1
+#define SD0_D3__SPI0_CS_X 2
+#define SD0_D3__XGPIOA_12 3
+#define SD0_D3__UART3_RX 4
+#define SD0_D3__PWM_10 5
+#define SD0_D3__WG1_D1 6
+#define SD0_D3__DBG_5 7
+#define SD0_CD__SDIO0_CD 0
+#define SD0_CD__XGPIOA_13 3
+#define SD0_PWR_EN__SDIO0_PWR_EN 0
+#define SD0_PWR_EN__XGPIOA_14 3
+#define SPK_EN__XGPIOA_15 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__CAM_MCLK1 1
+#define UART0_TX__PWM_4 2
+#define UART0_TX__XGPIOA_16 3
+#define UART0_TX__UART1_TX 4
+#define UART0_TX__AUX1 5
+#define UART0_TX__DBG_6 7
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__CAM_MCLK0 1
+#define UART0_RX__PWM_5 2
+#define UART0_RX__XGPIOA_17 3
+#define UART0_RX__UART1_RX 4
+#define UART0_RX__AUX0 5
+#define UART0_RX__DBG_7 7
+#define EMMC_RSTN__EMMC_RSTN 0
+#define EMMC_RSTN__XGPIOA_21 3
+#define EMMC_RSTN__AUX2 4
+#define EMMC_DAT2__EMMC_DAT_2 0
+#define EMMC_DAT2__SPINOR_HOLD_X 1
+#define EMMC_DAT2__SPINAND_HOLD 2
+#define EMMC_DAT2__XGPIOA_26 3
+#define EMMC_CLK__EMMC_CLK 0
+#define EMMC_CLK__SPINOR_SCK 1
+#define EMMC_CLK__SPINAND_CLK 2
+#define EMMC_CLK__XGPIOA_22 3
+#define EMMC_DAT0__EMMC_DAT_0 0
+#define EMMC_DAT0__SPINOR_MOSI 1
+#define EMMC_DAT0__SPINAND_MOSI 2
+#define EMMC_DAT0__XGPIOA_25 3
+#define EMMC_DAT3__EMMC_DAT_3 0
+#define EMMC_DAT3__SPINOR_WP_X 1
+#define EMMC_DAT3__SPINAND_WP 2
+#define EMMC_DAT3__XGPIOA_27 3
+#define EMMC_CMD__EMMC_CMD 0
+#define EMMC_CMD__SPINOR_MISO 1
+#define EMMC_CMD__SPINAND_MISO 2
+#define EMMC_CMD__XGPIOA_23 3
+#define EMMC_DAT1__EMMC_DAT_1 0
+#define EMMC_DAT1__SPINOR_CS_X 1
+#define EMMC_DAT1__SPINAND_CS 2
+#define EMMC_DAT1__XGPIOA_24 3
+#define JTAG_CPU_TMS__JTAG_CPU_TMS 0
+#define JTAG_CPU_TMS__CAM_MCLK0 1
+#define JTAG_CPU_TMS__PWM_7 2
+#define JTAG_CPU_TMS__XGPIOA_19 3
+#define JTAG_CPU_TMS__UART1_RTS 4
+#define JTAG_CPU_TMS__AUX0 5
+#define JTAG_CPU_TMS__UART1_TX 6
+#define JTAG_CPU_TMS__DBG_9 7
+#define JTAG_CPU_TCK__JTAG_CPU_TCK 0
+#define JTAG_CPU_TCK__CAM_MCLK1 1
+#define JTAG_CPU_TCK__PWM_6 2
+#define JTAG_CPU_TCK__XGPIOA_18 3
+#define JTAG_CPU_TCK__UART1_CTS 4
+#define JTAG_CPU_TCK__AUX1 5
+#define JTAG_CPU_TCK__UART1_RX 6
+#define JTAG_CPU_TCK__DBG_8 7
+#define JTAG_CPU_TRST__JTAG_CPU_TRST 0
+#define JTAG_CPU_TRST__XGPIOA_20 3
+#define IIC0_SCL__IIC0_SCL 0
+#define IIC0_SCL__UART1_TX 1
+#define IIC0_SCL__UART2_TX 2
+#define IIC0_SCL__XGPIOA_28 3
+#define IIC0_SCL__WG0_D0 5
+#define IIC0_SCL__DBG_10 7
+#define IIC0_SDA__IIC0_SDA 0
+#define IIC0_SDA__UART1_RX 1
+#define IIC0_SDA__UART2_RX 2
+#define IIC0_SDA__XGPIOA_29 3
+#define IIC0_SDA__WG0_D1 5
+#define IIC0_SDA__WG1_D0 6
+#define IIC0_SDA__DBG_11 7
+#define AUX0__AUX0 0
+#define AUX0__XGPIOA_30 3
+#define AUX0__IIS1_MCLK 4
+#define AUX0__WG1_D1 6
+#define AUX0__DBG_12 7
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_RSTN__PWR_RSTN 0
+#define PWR_SEQ1__PWR_SEQ1 0
+#define PWR_SEQ1__PWR_GPIO_3 3
+#define PWR_SEQ2__PWR_SEQ2 0
+#define PWR_SEQ2__PWR_GPIO_4 3
+#define PWR_SEQ3__PWR_SEQ3 0
+#define PWR_SEQ3__PWR_GPIO_5 3
+#define PTEST__PWR_PTEST 0
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__PWR_UART0_TX 2
+#define PWR_WAKEUP0__PWR_GPIO_6 3
+#define PWR_WAKEUP0__UART1_TX 4
+#define PWR_WAKEUP0__IIC4_SCL 5
+#define PWR_WAKEUP0__EPHY_LNK_LED 6
+#define PWR_WAKEUP0__WG2_D0 7
+#define PWR_WAKEUP1__PWR_WAKEUP1 0
+#define PWR_WAKEUP1__PWR_GPIO_7 3
+#define PWR_WAKEUP1__UART1_TX 4
+#define PWR_WAKEUP1__IIC4_SCL 5
+#define PWR_WAKEUP1__EPHY_LNK_LED 6
+#define PWR_WAKEUP1__WG0_D0 7
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__PWR_GPIO_8 3
+#define PWR_BUTTON1__UART1_RX 4
+#define PWR_BUTTON1__IIC4_SDA 5
+#define PWR_BUTTON1__EPHY_SPD_LED 6
+#define PWR_BUTTON1__WG2_D1 7
+#define PWR_ON__PWR_ON 0
+#define PWR_ON__PWR_GPIO_9 3
+#define PWR_ON__UART1_RX 4
+#define PWR_ON__IIC4_SDA 5
+#define PWR_ON__EPHY_SPD_LED 6
+#define PWR_ON__WG0_D1 7
+#define XTAL_XIN__PWR_XTAL_CLKIN 0
+#define PWR_GPIO0__PWR_GPIO_0 0
+#define PWR_GPIO0__UART2_TX 1
+#define PWR_GPIO0__PWR_UART0_RX 2
+#define PWR_GPIO0__PWM_8 4
+#define PWR_GPIO1__PWR_GPIO_1 0
+#define PWR_GPIO1__UART2_RX 1
+#define PWR_GPIO1__EPHY_LNK_LED 3
+#define PWR_GPIO1__PWM_9 4
+#define PWR_GPIO1__PWR_IIC_SCL 5
+#define PWR_GPIO1__IIC2_SCL 6
+#define PWR_GPIO1__PWR_MCU_JTAG_TMS 7
+#define PWR_GPIO2__PWR_GPIO_2 0
+#define PWR_GPIO2__PWR_SECTICK 2
+#define PWR_GPIO2__EPHY_SPD_LED 3
+#define PWR_GPIO2__PWM_10 4
+#define PWR_GPIO2__PWR_IIC_SDA 5
+#define PWR_GPIO2__IIC2_SDA 6
+#define PWR_GPIO2__PWR_MCU_JTAG_TCK 7
+#define CLK32K__CLK32K 0
+#define CLK32K__AUX0 1
+#define CLK32K__PWR_MCU_JTAG_TDI 2
+#define CLK32K__PWR_GPIO_10 3
+#define CLK32K__PWM_2 4
+#define CLK32K__KEY_COL0 5
+#define CLK32K__CAM_MCLK0 6
+#define CLK32K__DBG_0 7
+#define CLK25M__CLK25M 0
+#define CLK25M__AUX1 1
+#define CLK25M__PWR_MCU_JTAG_TDO 2
+#define CLK25M__PWR_GPIO_11 3
+#define CLK25M__PWM_3 4
+#define CLK25M__KEY_COL1 5
+#define CLK25M__CAM_MCLK1 6
+#define CLK25M__DBG_1 7
+#define IIC2_SCL__IIC2_SCL 0
+#define IIC2_SCL__PWM_14 1
+#define IIC2_SCL__PWR_GPIO_12 3
+#define IIC2_SCL__UART2_RX 4
+#define IIC2_SCL__KEY_COL2 7
+#define IIC2_SDA__IIC2_SDA 0
+#define IIC2_SDA__PWM_15 1
+#define IIC2_SDA__PWR_GPIO_13 3
+#define IIC2_SDA__UART2_TX 4
+#define IIC2_SDA__IIS1_MCLK 5
+#define IIC2_SDA__IIS2_MCLK 6
+#define IIC2_SDA__KEY_COL3 7
+#define UART2_TX__UART2_TX 0
+#define UART2_TX__PWM_11 1
+#define UART2_TX__PWR_UART1_TX 2
+#define UART2_TX__PWR_GPIO_14 3
+#define UART2_TX__KEY_ROW3 4
+#define UART2_TX__UART4_TX 5
+#define UART2_TX__IIS2_BCLK 6
+#define UART2_TX__WG2_D0 7
+#define UART2_RTS__UART2_RTS 0
+#define UART2_RTS__PWM_8 1
+#define UART2_RTS__PWR_GPIO_15 3
+#define UART2_RTS__KEY_ROW0 4
+#define UART2_RTS__UART4_RTS 5
+#define UART2_RTS__IIS2_DO 6
+#define UART2_RTS__WG1_D0 7
+#define UART2_RX__UART2_RX 0
+#define UART2_RX__PWM_10 1
+#define UART2_RX__PWR_UART1_RX 2
+#define UART2_RX__PWR_GPIO_16 3
+#define UART2_RX__KEY_COL3 4
+#define UART2_RX__UART4_RX 5
+#define UART2_RX__IIS2_DI 6
+#define UART2_RX__WG2_D1 7
+#define UART2_CTS__UART2_CTS 0
+#define UART2_CTS__PWM_9 1
+#define UART2_CTS__PWR_GPIO_17 3
+#define UART2_CTS__KEY_ROW1 4
+#define UART2_CTS__UART4_CTS 5
+#define UART2_CTS__IIS2_LRCK 6
+#define UART2_CTS__WG1_D1 7
+#define SD1_D3__PWR_SD1_D3 0
+#define SD1_D3__SPI2_CS_X 1
+#define SD1_D3__IIC1_SCL 2
+#define SD1_D3__PWR_GPIO_18 3
+#define SD1_D3__CAM_MCLK0 4
+#define SD1_D3__UART3_CTS 5
+#define SD1_D3__PWR_SPINOR1_CS_X 6
+#define SD1_D3__PWM_4 7
+#define SD1_D2__PWR_SD1_D2 0
+#define SD1_D2__IIC1_SCL 1
+#define SD1_D2__UART2_TX 2
+#define SD1_D2__PWR_GPIO_19 3
+#define SD1_D2__CAM_MCLK0 4
+#define SD1_D2__UART3_TX 5
+#define SD1_D2__PWR_SPINOR1_HOLD_X 6
+#define SD1_D2__PWM_5 7
+#define SD1_D1__PWR_SD1_D1 0
+#define SD1_D1__IIC1_SDA 1
+#define SD1_D1__UART2_RX 2
+#define SD1_D1__PWR_GPIO_20 3
+#define SD1_D1__CAM_MCLK1 4
+#define SD1_D1__UART3_RX 5
+#define SD1_D1__PWR_SPINOR1_WP_X 6
+#define SD1_D1__PWM_6 7
+#define SD1_D0__PWR_SD1_D0 0
+#define SD1_D0__SPI2_SDI 1
+#define SD1_D0__IIC1_SDA 2
+#define SD1_D0__PWR_GPIO_21 3
+#define SD1_D0__CAM_MCLK1 4
+#define SD1_D0__UART3_RTS 5
+#define SD1_D0__PWR_SPINOR1_MISO 6
+#define SD1_D0__PWM_7 7
+#define SD1_CMD__PWR_SD1_CMD 0
+#define SD1_CMD__SPI2_SDO 1
+#define SD1_CMD__IIC3_SCL 2
+#define SD1_CMD__PWR_GPIO_22 3
+#define SD1_CMD__EPHY_LNK_LED 5
+#define SD1_CMD__PWR_SPINOR1_MOSI 6
+#define SD1_CMD__PWM_8 7
+#define SD1_CLK__PWR_SD1_CLK 0
+#define SD1_CLK__SPI2_SCK 1
+#define SD1_CLK__IIC3_SDA 2
+#define SD1_CLK__PWR_GPIO_23 3
+#define SD1_CLK__EPHY_SPD_LED 5
+#define SD1_CLK__PWR_SPINOR1_SCK 6
+#define SD1_CLK__PWM_9 7
+#define RSTN__RSTN 0
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_0 3
+#define ADC3__CAM_MCLK0 1
+#define ADC3__IIC4_SCL 2
+#define ADC3__XGPIOB_1 3
+#define ADC3__PWM_12 4
+#define ADC3__EPHY_LNK_LED 5
+#define ADC3__WG2_D0 6
+#define ADC3__UART3_TX 7
+#define ADC2__CAM_MCLK1 1
+#define ADC2__IIC4_SDA 2
+#define ADC2__XGPIOB_2 3
+#define ADC2__PWM_13 4
+#define ADC2__EPHY_SPD_LED 5
+#define ADC2__WG2_D1 6
+#define ADC2__UART3_RX 7
+#define ADC1__XGPIOB_3 3
+#define ADC1__KEY_COL2 4
+#define USB_ID__USB_ID 0
+#define USB_ID__XGPIOB_4 3
+#define USB_VBUS_EN__USB_VBUS_EN 0
+#define USB_VBUS_EN__XGPIOB_5 3
+#define PKG_TYPE0__PKG_TYPE0 0
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_6 3
+#define USB_VBUS_DET__CAM_MCLK0 4
+#define USB_VBUS_DET__CAM_MCLK1 5
+#define PKG_TYPE1__PKG_TYPE1 0
+#define PKG_TYPE2__PKG_TYPE2 0
+#define SPI1_MISO__UART3_RTS 1
+#define SPI1_MISO__IIC1_SDA 2
+#define SPI1_MISO__XGPIOB_8 3
+#define SPI1_MISO__PWM_9 4
+#define SPI1_MISO__KEY_COL1 5
+#define SPI1_MISO__SPI1_SDI 6
+#define SPI1_MISO__DBG_14 7
+#define SPI1_MOSI__UART3_RX 1
+#define SPI1_MOSI__IIC1_SCL 2
+#define SPI1_MOSI__XGPIOB_7 3
+#define SPI1_MOSI__PWM_8 4
+#define SPI1_MOSI__KEY_COL0 5
+#define SPI1_MOSI__SPI1_SDO 6
+#define SPI1_MOSI__DBG_13 7
+#define SPI1_CS__UART3_CTS 1
+#define SPI1_CS__CAM_MCLK0 2
+#define SPI1_CS__XGPIOB_10 3
+#define SPI1_CS__PWM_11 4
+#define SPI1_CS__KEY_ROW3 5
+#define SPI1_CS__SPI1_CS_X 6
+#define SPI1_CS__DBG_16 7
+#define SPI1_SCK__UART3_TX 1
+#define SPI1_SCK__CAM_MCLK1 2
+#define SPI1_SCK__XGPIOB_9 3
+#define SPI1_SCK__PWM_10 4
+#define SPI1_SCK__KEY_ROW2 5
+#define SPI1_SCK__SPI1_SCK 6
+#define SPI1_SCK__DBG_15 7
+#define VIVO_D10__PWM_1 0
+#define VIVO_D10__VI1_D_10 1
+#define VIVO_D10__VO_D_23 2
+#define VIVO_D10__XGPIOB_11 3
+#define VIVO_D10__RMII0_IRQ 4
+#define VIVO_D10__CAM_MCLK0 5
+#define VIVO_D10__IIC1_SDA 6
+#define VIVO_D10__UART2_TX 7
+#define VIVO_D9__PWM_2 0
+#define VIVO_D9__VI1_D_9 1
+#define VIVO_D9__VO_D_22 2
+#define VIVO_D9__XGPIOB_12 3
+#define VIVO_D9__CAM_MCLK1 5
+#define VIVO_D9__IIC1_SCL 6
+#define VIVO_D9__UART2_RX 7
+#define VIVO_D8__PWM_3 0
+#define VIVO_D8__VI1_D_8 1
+#define VIVO_D8__VO_D_21 2
+#define VIVO_D8__XGPIOB_13 3
+#define VIVO_D8__RMII0_MDIO 4
+#define VIVO_D8__SPI3_SDO 5
+#define VIVO_D8__IIC2_SCL 6
+#define VIVO_D8__DBG_17 7
+#define VIVO_D7__VI2_D_7 0
+#define VIVO_D7__VI1_D_7 1
+#define VIVO_D7__VO_D_20 2
+#define VIVO_D7__XGPIOB_14 3
+#define VIVO_D7__RMII0_RXD1 4
+#define VIVO_D7__SPI3_SDI 5
+#define VIVO_D7__IIC2_SDA 6
+#define VIVO_D7__DBG_18 7
+#define VIVO_D6__VI2_D_6 0
+#define VIVO_D6__VI1_D_6 1
+#define VIVO_D6__VO_D_19 2
+#define VIVO_D6__XGPIOB_15 3
+#define VIVO_D6__RMII0_REFCLKI 4
+#define VIVO_D6__SPI3_SCK 5
+#define VIVO_D6__UART2_TX 6
+#define VIVO_D6__DBG_19 7
+#define VIVO_D5__VI2_D_5 0
+#define VIVO_D5__VI1_D_5 1
+#define VIVO_D5__VO_D_18 2
+#define VIVO_D5__XGPIOB_16 3
+#define VIVO_D5__RMII0_RXD0 4
+#define VIVO_D5__SPI3_CS_X 5
+#define VIVO_D5__UART2_RX 6
+#define VIVO_D5__DBG_20 7
+#define VIVO_D4__VI2_D_4 0
+#define VIVO_D4__VI1_D_4 1
+#define VIVO_D4__VO_D_17 2
+#define VIVO_D4__XGPIOB_17 3
+#define VIVO_D4__RMII0_MDC 4
+#define VIVO_D4__IIC1_SDA 5
+#define VIVO_D4__UART2_CTS 6
+#define VIVO_D4__DBG_21 7
+#define VIVO_D3__VI2_D_3 0
+#define VIVO_D3__VI1_D_3 1
+#define VIVO_D3__VO_D_16 2
+#define VIVO_D3__XGPIOB_18 3
+#define VIVO_D3__RMII0_TXD0 4
+#define VIVO_D3__IIC1_SCL 5
+#define VIVO_D3__UART2_RTS 6
+#define VIVO_D3__DBG_22 7
+#define VIVO_D2__VI2_D_2 0
+#define VIVO_D2__VI1_D_2 1
+#define VIVO_D2__VO_D_15 2
+#define VIVO_D2__XGPIOB_19 3
+#define VIVO_D2__RMII0_TXD1 4
+#define VIVO_D2__CAM_MCLK1 5
+#define VIVO_D2__PWM_2 6
+#define VIVO_D2__UART2_TX 7
+#define VIVO_D1__VI2_D_1 0
+#define VIVO_D1__VI1_D_1 1
+#define VIVO_D1__VO_D_14 2
+#define VIVO_D1__XGPIOB_20 3
+#define VIVO_D1__RMII0_RXDV 4
+#define VIVO_D1__IIC3_SDA 5
+#define VIVO_D1__PWM_3 6
+#define VIVO_D1__IIC4_SCL 7
+#define VIVO_D0__VI2_D_0 0
+#define VIVO_D0__VI1_D_0 1
+#define VIVO_D0__VO_D_13 2
+#define VIVO_D0__XGPIOB_21 3
+#define VIVO_D0__RMII0_TXCLK 4
+#define VIVO_D0__IIC3_SCL 5
+#define VIVO_D0__WG1_D0 6
+#define VIVO_D0__IIC4_SDA 7
+#define VIVO_CLK__VI2_CLK 0
+#define VIVO_CLK__VI1_CLK 1
+#define VIVO_CLK__VO_CLK1 2
+#define VIVO_CLK__XGPIOB_22 3
+#define VIVO_CLK__RMII0_TXEN 4
+#define VIVO_CLK__CAM_MCLK0 5
+#define VIVO_CLK__WG1_D1 6
+#define VIVO_CLK__UART2_RX 7
+#define PAD_MIPIRX5N__VI1_D_11 1
+#define PAD_MIPIRX5N__VO_D_12 2
+#define PAD_MIPIRX5N__XGPIOC_0 3
+#define PAD_MIPIRX5N__CAM_MCLK0 5
+#define PAD_MIPIRX5N__WG0_D0 6
+#define PAD_MIPIRX5N__DBG_0 7
+#define PAD_MIPIRX5P__VI1_D_12 1
+#define PAD_MIPIRX5P__VO_D_11 2
+#define PAD_MIPIRX5P__XGPIOC_1 3
+#define PAD_MIPIRX5P__IIS1_MCLK 4
+#define PAD_MIPIRX5P__CAM_MCLK1 5
+#define PAD_MIPIRX5P__WG0_D1 6
+#define PAD_MIPIRX5P__DBG_1 7
+#define PAD_MIPIRX4N__VI0_CLK 1
+#define PAD_MIPIRX4N__VI1_D_13 2
+#define PAD_MIPIRX4N__XGPIOC_2 3
+#define PAD_MIPIRX4N__IIC1_SDA 4
+#define PAD_MIPIRX4N__CAM_MCLK0 5
+#define PAD_MIPIRX4N__KEY_ROW0 6
+#define PAD_MIPIRX4N__MUX_SPI1_SCK 7
+#define PAD_MIPIRX4P__VI0_D_0 1
+#define PAD_MIPIRX4P__VI1_D_14 2
+#define PAD_MIPIRX4P__XGPIOC_3 3
+#define PAD_MIPIRX4P__IIC1_SCL 4
+#define PAD_MIPIRX4P__CAM_MCLK1 5
+#define PAD_MIPIRX4P__KEY_ROW1 6
+#define PAD_MIPIRX4P__MUX_SPI1_CS 7
+#define PAD_MIPIRX3N__VI0_D_1 1
+#define PAD_MIPIRX3N__VI1_D_15 2
+#define PAD_MIPIRX3N__XGPIOC_4 3
+#define PAD_MIPIRX3N__CAM_MCLK0 4
+#define PAD_MIPIRX3N__MUX_SPI1_MISO 7
+#define PAD_MIPIRX3P__VI0_D_2 1
+#define PAD_MIPIRX3P__VI1_D_16 2
+#define PAD_MIPIRX3P__XGPIOC_5 3
+#define PAD_MIPIRX3P__MUX_SPI1_MOSI 7
+#define PAD_MIPIRX2N__VI0_D_3 1
+#define PAD_MIPIRX2N__VO_D_10 2
+#define PAD_MIPIRX2N__XGPIOC_6 3
+#define PAD_MIPIRX2N__VI1_D_17 4
+#define PAD_MIPIRX2N__IIC4_SCL 5
+#define PAD_MIPIRX2N__DBG_6 7
+#define PAD_MIPIRX2P__VI0_D_4 1
+#define PAD_MIPIRX2P__VO_D_9 2
+#define PAD_MIPIRX2P__XGPIOC_7 3
+#define PAD_MIPIRX2P__VI1_D_18 4
+#define PAD_MIPIRX2P__IIC4_SDA 5
+#define PAD_MIPIRX2P__DBG_7 7
+#define PAD_MIPIRX1N__VI0_D_5 1
+#define PAD_MIPIRX1N__VO_D_8 2
+#define PAD_MIPIRX1N__XGPIOC_8 3
+#define PAD_MIPIRX1N__KEY_ROW3 6
+#define PAD_MIPIRX1N__DBG_8 7
+#define PAD_MIPIRX1P__VI0_D_6 1
+#define PAD_MIPIRX1P__VO_D_7 2
+#define PAD_MIPIRX1P__XGPIOC_9 3
+#define PAD_MIPIRX1P__IIC1_SDA 4
+#define PAD_MIPIRX1P__KEY_ROW2 6
+#define PAD_MIPIRX1P__DBG_9 7
+#define PAD_MIPIRX0N__VI0_D_7 1
+#define PAD_MIPIRX0N__VO_D_6 2
+#define PAD_MIPIRX0N__XGPIOC_10 3
+#define PAD_MIPIRX0N__IIC1_SCL 4
+#define PAD_MIPIRX0N__CAM_MCLK1 5
+#define PAD_MIPIRX0N__DBG_10 7
+#define PAD_MIPIRX0P__VI0_D_8 1
+#define PAD_MIPIRX0P__VO_D_5 2
+#define PAD_MIPIRX0P__XGPIOC_11 3
+#define PAD_MIPIRX0P__CAM_MCLK0 4
+#define PAD_MIPIRX0P__DBG_11 7
+#define PAD_MIPI_TXM4__VO_D_24 2
+#define PAD_MIPI_TXM4__XGPIOC_18 3
+#define PAD_MIPI_TXM4__CAM_MCLK1 4
+#define PAD_MIPI_TXM4__PWM_12 5
+#define PAD_MIPI_TXM4__IIC1_SDA 6
+#define PAD_MIPI_TXM4__DBG_18 7
+#define PAD_MIPI_TXP4__VO_D_25 2
+#define PAD_MIPI_TXP4__XGPIOC_19 3
+#define PAD_MIPI_TXP4__CAM_MCLK0 4
+#define PAD_MIPI_TXP4__PWM_13 5
+#define PAD_MIPI_TXP4__IIC1_SCL 6
+#define PAD_MIPI_TXP4__DBG_19 7
+#define PAD_MIPI_TXM3__VO_D_26 2
+#define PAD_MIPI_TXM3__XGPIOC_20 3
+#define PAD_MIPI_TXM3__IIC2_SDA 4
+#define PAD_MIPI_TXM3__PWM_14 5
+#define PAD_MIPI_TXM3__IIC1_SDA 6
+#define PAD_MIPI_TXM3__DBG_20 7
+#define PAD_MIPI_TXP3__VO_D_27 2
+#define PAD_MIPI_TXP3__XGPIOC_21 3
+#define PAD_MIPI_TXP3__IIC2_SCL 4
+#define PAD_MIPI_TXP3__PWM_15 5
+#define PAD_MIPI_TXP3__IIC1_SCL 6
+#define PAD_MIPI_TXP3__DBG_21 7
+#define PAD_MIPI_TXM2__VI0_D_13 1
+#define PAD_MIPI_TXM2__VO_D_0 2
+#define PAD_MIPI_TXM2__XGPIOC_16 3
+#define PAD_MIPI_TXM2__IIC1_SDA 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__SPI0_SCK 6
+#define PAD_MIPI_TXM2__DBG_16 7
+#define PAD_MIPI_TXP2__VI0_D_14 1
+#define PAD_MIPI_TXP2__VO_CLK0 2
+#define PAD_MIPI_TXP2__XGPIOC_17 3
+#define PAD_MIPI_TXP2__IIC1_SCL 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__SPI0_CS_X 6
+#define PAD_MIPI_TXP2__DBG_17 7
+#define PAD_MIPI_TXM1__VI0_D_11 1
+#define PAD_MIPI_TXM1__VO_D_2 2
+#define PAD_MIPI_TXM1__XGPIOC_14 3
+#define PAD_MIPI_TXM1__IIC2_SDA 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__SPI0_SDO 6
+#define PAD_MIPI_TXM1__DBG_14 7
+#define PAD_MIPI_TXP1__VI0_D_12 1
+#define PAD_MIPI_TXP1__VO_D_1 2
+#define PAD_MIPI_TXP1__XGPIOC_15 3
+#define PAD_MIPI_TXP1__IIC2_SCL 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__SPI0_SDI 6
+#define PAD_MIPI_TXP1__DBG_15 7
+#define PAD_MIPI_TXM0__VI0_D_9 1
+#define PAD_MIPI_TXM0__VO_D_4 2
+#define PAD_MIPI_TXM0__XGPIOC_12 3
+#define PAD_MIPI_TXM0__CAM_MCLK1 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__DBG_12 7
+#define PAD_MIPI_TXP0__VI0_D_10 1
+#define PAD_MIPI_TXP0__VO_D_3 2
+#define PAD_MIPI_TXP0__XGPIOC_13 3
+#define PAD_MIPI_TXP0__CAM_MCLK0 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__DBG_13 7
+#define PAD_AUD_AINL_MIC__XGPIOC_23 3
+#define PAD_AUD_AINL_MIC__IIS1_BCLK 4
+#define PAD_AUD_AINR_MIC__XGPIOC_22 3
+#define PAD_AUD_AINR_MIC__IIS1_DO 4
+#define PAD_AUD_AOUTL__XGPIOC_25 3
+#define PAD_AUD_AOUTL__IIS1_LRCK 4
+#define PAD_AUD_AOUTR__XGPIOC_24 3
+#define PAD_AUD_AOUTR__IIS1_DI 4
+
+#endif /* __CV1822_PINLIST_SWCONFIG_H__ */
diff --git a/board/cvitek/cv1822/cv1822_reg.h b/board/cvitek/cv1822/cv1822_reg.h
new file mode 100644
index 000000000..5e3999696
--- /dev/null
+++ b/board/cvitek/cv1822/cv1822_reg.h
@@ -0,0 +1,160 @@
+#ifndef __CV1822_REG_H
+#define __CV1822_REG_H
+
+#define TOP_BASE 0x03000000
+#define PINMUX_BASE (TOP_BASE + 0x1000)
+#define CLKGEN_BASE (TOP_BASE + 0x2000)
+#define WATCHDOG_BASE (TOP_BASE + 0x00010000)
+#define RTC_BASE 0x05026000
+
+#define BM_IO_BUF_BASE 0x0C000000
+#define BM_IO_BUF_SIZE 0x2000
+
+/*
+* RTC info registers
+*/
+#define RTC_INFO0 (RTC_BASE + 0x1C)
+
+/*
+* General purpose registers
+*/
+#define GP_REG0 (TOP_BASE + 0x80)
+#define GP_REG1 (TOP_BASE + 0x84)
+#define GP_REG2 (TOP_BASE + 0x88
+#define GP_REG3 (TOP_BASE + 0x8C)
+#define GP_REG4 (TOP_BASE + 0x90)
+#define GP_REG5 (TOP_BASE + 0x94)
+#define GP_REG6 (TOP_BASE + 0x98)
+#define GP_REG7 (TOP_BASE + 0x9C)
+#define GP_REG8 (TOP_BASE + 0xA0)
+#define GP_REG9 (TOP_BASE + 0xA4)
+#define GP_REG10 (TOP_BASE + 0xA8)
+
+/*
+* Pinmux definitions
+*/
+#define PINMUX_UART0 0
+#define PINMUX_UART1 1
+#define PINMUX_UART2 2
+#define PINMUX_UART3 3
+#define PINMUX_UART3_2 4
+#define PINMUX_I2C0 5
+#define PINMUX_I2C1 6
+#define PINMUX_I2C2 7
+#define PINMUX_I2C3 8
+#define PINMUX_I2C4 9
+#define PINMUX_I2C4_2 10
+#define PINMUX_SPI0 11
+#define PINMUX_SPI1 12
+#define PINMUX_SPI2 13
+#define PINMUX_SPI2_2 14
+#define PINMUX_SPI3 15
+#define PINMUX_SPI3_2 16
+#define PINMUX_I2S0 17
+#define PINMUX_I2S1 18
+#define PINMUX_I2S2 19
+#define PINMUX_I2S3 20
+#define PINMUX_USBID 21
+#define PINMUX_SDIO0 22
+#define PINMUX_SDIO1 23
+#define PINMUX_ND 24
+#define PINMUX_EMMC 25
+#define PINMUX_SPI_NOR 26
+#define PINMUX_SPI_NAND 27
+#define PINMUX_CAM0 28
+#define PINMUX_CAM1 29
+#define PINMUX_PCM0 30
+#define PINMUX_PCM1 31
+#define PINMUX_CSI0 32
+#define PINMUX_CSI1 33
+#define PINMUX_CSI2 34
+#define PINMUX_DSI 35
+#define PINMUX_VI0 36
+#define PINMUX_VO 37
+#define PINMUX_RMII1 38
+#define PINMUX_EPHY_LED 39
+#define PINMUX_I80 40
+#define PINMUX_LVDS 41
+
+#define REG_TOP_USB_ECO (TOP_BASE + 0xB4)
+#define BIT_TOP_USB_ECO_RX_FLUSH 0x80
+/* rst */
+#define REG_TOP_SOFT_RST 0x3000
+#define BIT_TOP_SOFT_RST_USB BIT(11)
+#define BIT_TOP_SOFT_RST_SDIO BIT(14)
+#define BIT_TOP_SOFT_RST_NAND BIT(12)
+
+#define REG_TOP_USB_CTRSTS (TOP_BASE + 0x38)
+
+#define REG_TOP_CONF_INFO (TOP_BASE + 0x4)
+#define BIT_TOP_CONF_INFO_VBUS BIT(9)
+#define REG_TOP_USB_PHY_CTRL (TOP_BASE + 0x48)
+#define BIT_TOP_USB_PHY_CTRL_EXTVBUS BIT(0)
+#define USB_PHY_ID_OVERRIDE_ENABLE BIT(6)
+#define USB_PHY_ID_VALUE BIT(7)
+#define REG_TOP_DDR_ADDR_MODE (TOP_BASE + 0x64)
+
+/* irq */
+#define IRQ_LEVEL 0
+#define IRQ_EDGE 3
+
+/* usb */
+#define USB_BASE 0x04340000
+
+/* ethernet phy */
+#define ETH_PHY_BASE 0x03009000
+#define ETH_PHY_INIT_MASK 0xFFFFFFF9
+#define ETH_PHY_SHUTDOWN BIT(1)
+#define ETH_PHY_POWERUP 0xFFFFFFFD
+#define ETH_PHY_RESET 0xFFFFFFFB
+#define ETH_PHY_RESET_N BIT(2)
+#define ETH_PHY_LED_LOW_ACTIVE BIT(3)
+
+/* watchdog */
+#define DW_WDT_CR 0x00
+#define DW_WDT_TORR 0x04
+#define DW_WDT_CRR 0x0C
+
+#define DW_WDT_CR_EN_OFFSET 0x00
+#define DW_WDT_CR_RMOD_OFFSET 0x01
+#define DW_WDT_CR_RMOD_VAL 0x00
+#define DW_WDT_CRR_RESTART_VAL 0x76
+
+/* SDIO Wifi */
+#define WIFI_CHIP_EN_BGA BIT(18)
+#define WIFI_CHIP_EN_QFN BIT(2)
+
+/* RTC */
+#define RTC_SYS_BASE 0x05000000
+#define RTC_MACRO_BASE (RTC_SYS_BASE + 0x00026400)
+#define RTC_MACRO_DA_SOC_READY 0x8C
+#define RTC_MACRO_RO_T 0xA8
+#define RTC_CORE_SRAM_BASE (RTC_SYS_BASE + 0x00026800)
+#define RTC_CORE_SRAM_SIZE 0x0800 // 2KB
+
+#define REG_RTC_CTRL_BASE (RTC_SYS_BASE + 0x00025000)
+#define RTC_CTRL0_UNLOCKKEY 0x4
+#define RTC_CTRL0 0x8
+#define RTC_CTRL0_STATUS0 0xC
+#define RTCSYS_RST_CTRL 0x18
+
+#define REG_RTC_BASE (RTC_SYS_BASE + 0x00026000)
+#define RTC_EN_PWR_WAKEUP 0xBC
+#define RTC_EN_SHDN_REQ 0xC0
+#define RTC_EN_PWR_CYC_REQ 0xC8
+#define RTC_EN_WARM_RST_REQ 0xCC
+#define RTC_EN_WDT_RST_REQ 0xE0
+#define RTC_EN_SUSPEND_REQ 0xE4
+#define RTC_PG_REG 0xF0
+#define RTC_ST_ON_REASON 0xF8
+
+#define REG_RTC_ST_ON_REASON (REG_RTC_BASE + RTC_ST_ON_REASON)
+
+#define RTCSYS_F32KLESS_BASE (RTC_SYS_BASE + 0x0002A000)
+
+#define RTC_INTERNAL_32K 0
+#define RTC_EXTERNAL_32K 1
+#define CONFIG_DW_WDT_BASE WATCHDOG_BASE
+#define CONFIG_DW_WDT_CLOCK_KHZ 25000
+
+#endif /* __CV1822_REG_H */
diff --git a/board/cvitek/cv1822/cv1822_reg_fmux_gpio.h b/board/cvitek/cv1822/cv1822_reg_fmux_gpio.h
new file mode 100644
index 000000000..c37c240bc
--- /dev/null
+++ b/board/cvitek/cv1822/cv1822_reg_fmux_gpio.h
@@ -0,0 +1,457 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cv1822_reg_fmux_gpio.h
+ * Description:
+ */
+
+#ifndef __CV1822_REG_FMUX_GPIO_H__
+#define __CV1822_REG_FMUX_GPIO_H__
+
+//GEN REG ADDR/OFFSET/MASK
+#define  fmux_gpio_REG_IOCTRL_CAM_MCLK0  0x0
+#define  fmux_gpio_REG_IOCTRL_CAM_PD0  0x4
+#define  fmux_gpio_REG_IOCTRL_CAM_RST0  0x8
+#define  fmux_gpio_REG_IOCTRL_CAM_MCLK1  0xc
+#define  fmux_gpio_REG_IOCTRL_CAM_PD1  0x10
+#define  fmux_gpio_REG_IOCTRL_IIC3_SCL  0x14
+#define  fmux_gpio_REG_IOCTRL_IIC3_SDA  0x18
+#define  fmux_gpio_REG_IOCTRL_SD0_CLK  0x1c
+#define  fmux_gpio_REG_IOCTRL_SD0_CMD  0x20
+#define  fmux_gpio_REG_IOCTRL_SD0_D0  0x24
+#define  fmux_gpio_REG_IOCTRL_SD0_D1  0x28
+#define  fmux_gpio_REG_IOCTRL_SD0_D2  0x2c
+#define  fmux_gpio_REG_IOCTRL_SD0_D3  0x30
+#define  fmux_gpio_REG_IOCTRL_SD0_CD  0x34
+#define  fmux_gpio_REG_IOCTRL_SD0_PWR_EN  0x38
+#define  fmux_gpio_REG_IOCTRL_SPK_EN  0x3c
+#define  fmux_gpio_REG_IOCTRL_UART0_TX  0x40
+#define  fmux_gpio_REG_IOCTRL_UART0_RX  0x44
+#define  fmux_gpio_REG_IOCTRL_EMMC_RSTN  0x48
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT2  0x4c
+#define  fmux_gpio_REG_IOCTRL_EMMC_CLK  0x50
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT0  0x54
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT3  0x58
+#define  fmux_gpio_REG_IOCTRL_EMMC_CMD  0x5c
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT1  0x60
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TMS  0x64
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TCK  0x68
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TRST  0x6c
+#define  fmux_gpio_REG_IOCTRL_IIC0_SCL  0x70
+#define  fmux_gpio_REG_IOCTRL_IIC0_SDA  0x74
+#define  fmux_gpio_REG_IOCTRL_AUX0  0x78
+#define  fmux_gpio_REG_IOCTRL_PWR_VBAT_DET  0x7c
+#define  fmux_gpio_REG_IOCTRL_PWR_RSTN  0x80
+#define  fmux_gpio_REG_IOCTRL_PWR_SEQ1  0x84
+#define  fmux_gpio_REG_IOCTRL_PWR_SEQ2  0x88
+#define  fmux_gpio_REG_IOCTRL_PWR_SEQ3  0x8c
+#define  fmux_gpio_REG_IOCTRL_PWR_WAKEUP0  0x90
+#define  fmux_gpio_REG_IOCTRL_PWR_WAKEUP1  0x94
+#define  fmux_gpio_REG_IOCTRL_PWR_BUTTON1  0x98
+#define  fmux_gpio_REG_IOCTRL_PWR_ON  0x9c
+#define  fmux_gpio_REG_IOCTRL_XTAL_XIN  0xa0
+#define  fmux_gpio_REG_IOCTRL_PWR_GPIO0  0xa4
+#define  fmux_gpio_REG_IOCTRL_PWR_GPIO1  0xa8
+#define  fmux_gpio_REG_IOCTRL_PWR_GPIO2  0xac
+#define  fmux_gpio_REG_IOCTRL_CLK32K  0xb0
+#define  fmux_gpio_REG_IOCTRL_CLK25M  0xb4
+#define  fmux_gpio_REG_IOCTRL_IIC2_SCL  0xb8
+#define  fmux_gpio_REG_IOCTRL_IIC2_SDA  0xbc
+#define  fmux_gpio_REG_IOCTRL_UART2_TX  0xc0
+#define  fmux_gpio_REG_IOCTRL_UART2_RTS  0xc4
+#define  fmux_gpio_REG_IOCTRL_UART2_RX  0xc8
+#define  fmux_gpio_REG_IOCTRL_UART2_CTS  0xcc
+#define  fmux_gpio_REG_IOCTRL_SD1_D3  0xd0
+#define  fmux_gpio_REG_IOCTRL_SD1_D2  0xd4
+#define  fmux_gpio_REG_IOCTRL_SD1_D1  0xd8
+#define  fmux_gpio_REG_IOCTRL_SD1_D0  0xdc
+#define  fmux_gpio_REG_IOCTRL_SD1_CMD  0xe0
+#define  fmux_gpio_REG_IOCTRL_SD1_CLK  0xe4
+#define  fmux_gpio_REG_IOCTRL_RSTN  0xe8
+#define  fmux_gpio_REG_IOCTRL_PWM0_BUCK  0xec
+#define  fmux_gpio_REG_IOCTRL_ADC3  0xf0
+#define  fmux_gpio_REG_IOCTRL_ADC2  0xf4
+#define  fmux_gpio_REG_IOCTRL_ADC1  0xf8
+#define  fmux_gpio_REG_IOCTRL_USB_ID  0xfc
+#define  fmux_gpio_REG_IOCTRL_USB_VBUS_EN  0x100
+#define  fmux_gpio_REG_IOCTRL_PKG_TYPE0  0x104
+#define  fmux_gpio_REG_IOCTRL_USB_VBUS_DET  0x108
+#define  fmux_gpio_REG_IOCTRL_PKG_TYPE1  0x10c
+#define  fmux_gpio_REG_IOCTRL_PKG_TYPE2  0x110
+#define  fmux_gpio_REG_IOCTRL_SPI1_MISO  0x114
+#define  fmux_gpio_REG_IOCTRL_SPI1_MOSI  0x118
+#define  fmux_gpio_REG_IOCTRL_SPI1_CS  0x11c
+#define  fmux_gpio_REG_IOCTRL_SPI1_SCK  0x120
+#define  fmux_gpio_REG_IOCTRL_VIVO_D10  0x124
+#define  fmux_gpio_REG_IOCTRL_VIVO_D9  0x128
+#define  fmux_gpio_REG_IOCTRL_VIVO_D8  0x12c
+#define  fmux_gpio_REG_IOCTRL_VIVO_D7  0x130
+#define  fmux_gpio_REG_IOCTRL_VIVO_D6  0x134
+#define  fmux_gpio_REG_IOCTRL_VIVO_D5  0x138
+#define  fmux_gpio_REG_IOCTRL_VIVO_D4  0x13c
+#define  fmux_gpio_REG_IOCTRL_VIVO_D3  0x140
+#define  fmux_gpio_REG_IOCTRL_VIVO_D2  0x144
+#define  fmux_gpio_REG_IOCTRL_VIVO_D1  0x148
+#define  fmux_gpio_REG_IOCTRL_VIVO_D0  0x14c
+#define  fmux_gpio_REG_IOCTRL_VIVO_CLK  0x150
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX5N  0x154
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX5P  0x158
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX4N  0x15c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX4P  0x160
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX3N  0x164
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX3P  0x168
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX2N  0x16c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX2P  0x170
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX1N  0x174
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX1P  0x178
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX0N  0x17c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPIRX0P  0x180
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM4  0x184
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP4  0x188
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM3  0x18c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP3  0x190
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM2  0x194
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP2  0x198
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM1  0x19c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP1  0x1a0
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM0  0x1a4
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP0  0x1a8
+#define  fmux_gpio_REG_IOCTRL_PAD_AUD_AINL_MIC  0x1ac
+#define  fmux_gpio_REG_IOCTRL_PAD_AUD_AINR_MIC  0x1b0
+#define  fmux_gpio_REG_IOCTRL_PAD_AUD_AOUTL  0x1b4
+#define  fmux_gpio_REG_IOCTRL_PAD_AUD_AOUTR  0x1b8
+#define  fmux_gpio_funcsel_CAM_MCLK0   0x0
+#define  fmux_gpio_funcsel_CAM_MCLK0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_MCLK0_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_PD0   0x4
+#define  fmux_gpio_funcsel_CAM_PD0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_PD0_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_RST0   0x8
+#define  fmux_gpio_funcsel_CAM_RST0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_RST0_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_MCLK1   0xc
+#define  fmux_gpio_funcsel_CAM_MCLK1_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_MCLK1_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_PD1   0x10
+#define  fmux_gpio_funcsel_CAM_PD1_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_PD1_MASK   0x7
+#define  fmux_gpio_funcsel_IIC3_SCL   0x14
+#define  fmux_gpio_funcsel_IIC3_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC3_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC3_SDA   0x18
+#define  fmux_gpio_funcsel_IIC3_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC3_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_CLK   0x1c
+#define  fmux_gpio_funcsel_SD0_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_CMD   0x20
+#define  fmux_gpio_funcsel_SD0_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_D0   0x24
+#define  fmux_gpio_funcsel_SD0_D0_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_D0_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_D1   0x28
+#define  fmux_gpio_funcsel_SD0_D1_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_D1_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_D2   0x2c
+#define  fmux_gpio_funcsel_SD0_D2_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_D2_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_D3   0x30
+#define  fmux_gpio_funcsel_SD0_D3_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_D3_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_CD   0x34
+#define  fmux_gpio_funcsel_SD0_CD_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_CD_MASK   0x7
+#define  fmux_gpio_funcsel_SD0_PWR_EN   0x38
+#define  fmux_gpio_funcsel_SD0_PWR_EN_OFFSET 0
+#define  fmux_gpio_funcsel_SD0_PWR_EN_MASK   0x7
+#define  fmux_gpio_funcsel_SPK_EN   0x3c
+#define  fmux_gpio_funcsel_SPK_EN_OFFSET 0
+#define  fmux_gpio_funcsel_SPK_EN_MASK   0x7
+#define  fmux_gpio_funcsel_UART0_TX   0x40
+#define  fmux_gpio_funcsel_UART0_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART0_TX_MASK   0x7
+#define  fmux_gpio_funcsel_UART0_RX   0x44
+#define  fmux_gpio_funcsel_UART0_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART0_RX_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_RSTN   0x48
+#define  fmux_gpio_funcsel_EMMC_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT2   0x4c
+#define  fmux_gpio_funcsel_EMMC_DAT2_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT2_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_CLK   0x50
+#define  fmux_gpio_funcsel_EMMC_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT0   0x54
+#define  fmux_gpio_funcsel_EMMC_DAT0_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT0_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT3   0x58
+#define  fmux_gpio_funcsel_EMMC_DAT3_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT3_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_CMD   0x5c
+#define  fmux_gpio_funcsel_EMMC_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT1   0x60
+#define  fmux_gpio_funcsel_EMMC_DAT1_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT1_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS   0x64
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK   0x68
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST   0x6c
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST_MASK   0x7
+#define  fmux_gpio_funcsel_IIC0_SCL   0x70
+#define  fmux_gpio_funcsel_IIC0_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC0_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC0_SDA   0x74
+#define  fmux_gpio_funcsel_IIC0_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC0_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_AUX0   0x78
+#define  fmux_gpio_funcsel_AUX0_OFFSET 0
+#define  fmux_gpio_funcsel_AUX0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_VBAT_DET   0x7c
+#define  fmux_gpio_funcsel_PWR_VBAT_DET_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_VBAT_DET_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_RSTN   0x80
+#define  fmux_gpio_funcsel_PWR_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_SEQ1   0x84
+#define  fmux_gpio_funcsel_PWR_SEQ1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_SEQ1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_SEQ2   0x88
+#define  fmux_gpio_funcsel_PWR_SEQ2_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_SEQ2_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_SEQ3   0x8c
+#define  fmux_gpio_funcsel_PWR_SEQ3_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_SEQ3_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_WAKEUP0   0x90
+#define  fmux_gpio_funcsel_PWR_WAKEUP0_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_WAKEUP0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_WAKEUP1   0x94
+#define  fmux_gpio_funcsel_PWR_WAKEUP1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_WAKEUP1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_BUTTON1   0x98
+#define  fmux_gpio_funcsel_PWR_BUTTON1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_BUTTON1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_ON   0x9c
+#define  fmux_gpio_funcsel_PWR_ON_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_ON_MASK   0x7
+#define  fmux_gpio_funcsel_XTAL_XIN   0xa0
+#define  fmux_gpio_funcsel_XTAL_XIN_OFFSET 0
+#define  fmux_gpio_funcsel_XTAL_XIN_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_GPIO0   0xa4
+#define  fmux_gpio_funcsel_PWR_GPIO0_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_GPIO0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_GPIO1   0xa8
+#define  fmux_gpio_funcsel_PWR_GPIO1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_GPIO1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_GPIO2   0xac
+#define  fmux_gpio_funcsel_PWR_GPIO2_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_GPIO2_MASK   0x7
+#define  fmux_gpio_funcsel_CLK32K   0xb0
+#define  fmux_gpio_funcsel_CLK32K_OFFSET 0
+#define  fmux_gpio_funcsel_CLK32K_MASK   0x7
+#define  fmux_gpio_funcsel_CLK25M   0xb4
+#define  fmux_gpio_funcsel_CLK25M_OFFSET 0
+#define  fmux_gpio_funcsel_CLK25M_MASK   0x7
+#define  fmux_gpio_funcsel_IIC2_SCL   0xb8
+#define  fmux_gpio_funcsel_IIC2_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC2_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC2_SDA   0xbc
+#define  fmux_gpio_funcsel_IIC2_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC2_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_TX   0xc0
+#define  fmux_gpio_funcsel_UART2_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_TX_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_RTS   0xc4
+#define  fmux_gpio_funcsel_UART2_RTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_RTS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_RX   0xc8
+#define  fmux_gpio_funcsel_UART2_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_RX_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_CTS   0xcc
+#define  fmux_gpio_funcsel_UART2_CTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_CTS_MASK   0x7
+#define  fmux_gpio_funcsel_SD1_D3   0xd0
+#define  fmux_gpio_funcsel_SD1_D3_OFFSET 0
+#define  fmux_gpio_funcsel_SD1_D3_MASK   0x7
+#define  fmux_gpio_funcsel_SD1_D2   0xd4
+#define  fmux_gpio_funcsel_SD1_D2_OFFSET 0
+#define  fmux_gpio_funcsel_SD1_D2_MASK   0x7
+#define  fmux_gpio_funcsel_SD1_D1   0xd8
+#define  fmux_gpio_funcsel_SD1_D1_OFFSET 0
+#define  fmux_gpio_funcsel_SD1_D1_MASK   0x7
+#define  fmux_gpio_funcsel_SD1_D0   0xdc
+#define  fmux_gpio_funcsel_SD1_D0_OFFSET 0
+#define  fmux_gpio_funcsel_SD1_D0_MASK   0x7
+#define  fmux_gpio_funcsel_SD1_CMD   0xe0
+#define  fmux_gpio_funcsel_SD1_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_SD1_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_SD1_CLK   0xe4
+#define  fmux_gpio_funcsel_SD1_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_SD1_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_RSTN   0xe8
+#define  fmux_gpio_funcsel_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_PWM0_BUCK   0xec
+#define  fmux_gpio_funcsel_PWM0_BUCK_OFFSET 0
+#define  fmux_gpio_funcsel_PWM0_BUCK_MASK   0x7
+#define  fmux_gpio_funcsel_ADC3   0xf0
+#define  fmux_gpio_funcsel_ADC3_OFFSET 0
+#define  fmux_gpio_funcsel_ADC3_MASK   0x7
+#define  fmux_gpio_funcsel_ADC2   0xf4
+#define  fmux_gpio_funcsel_ADC2_OFFSET 0
+#define  fmux_gpio_funcsel_ADC2_MASK   0x7
+#define  fmux_gpio_funcsel_ADC1   0xf8
+#define  fmux_gpio_funcsel_ADC1_OFFSET 0
+#define  fmux_gpio_funcsel_ADC1_MASK   0x7
+#define  fmux_gpio_funcsel_USB_ID   0xfc
+#define  fmux_gpio_funcsel_USB_ID_OFFSET 0
+#define  fmux_gpio_funcsel_USB_ID_MASK   0x7
+#define  fmux_gpio_funcsel_USB_VBUS_EN   0x100
+#define  fmux_gpio_funcsel_USB_VBUS_EN_OFFSET 0
+#define  fmux_gpio_funcsel_USB_VBUS_EN_MASK   0x7
+#define  fmux_gpio_funcsel_PKG_TYPE0   0x104
+#define  fmux_gpio_funcsel_PKG_TYPE0_OFFSET 0
+#define  fmux_gpio_funcsel_PKG_TYPE0_MASK   0x7
+#define  fmux_gpio_funcsel_USB_VBUS_DET   0x108
+#define  fmux_gpio_funcsel_USB_VBUS_DET_OFFSET 0
+#define  fmux_gpio_funcsel_USB_VBUS_DET_MASK   0x7
+#define  fmux_gpio_funcsel_PKG_TYPE1   0x10c
+#define  fmux_gpio_funcsel_PKG_TYPE1_OFFSET 0
+#define  fmux_gpio_funcsel_PKG_TYPE1_MASK   0x7
+#define  fmux_gpio_funcsel_PKG_TYPE2   0x110
+#define  fmux_gpio_funcsel_PKG_TYPE2_OFFSET 0
+#define  fmux_gpio_funcsel_PKG_TYPE2_MASK   0x7
+#define  fmux_gpio_funcsel_SPI1_MISO   0x114
+#define  fmux_gpio_funcsel_SPI1_MISO_OFFSET 0
+#define  fmux_gpio_funcsel_SPI1_MISO_MASK   0x7
+#define  fmux_gpio_funcsel_SPI1_MOSI   0x118
+#define  fmux_gpio_funcsel_SPI1_MOSI_OFFSET 0
+#define  fmux_gpio_funcsel_SPI1_MOSI_MASK   0x7
+#define  fmux_gpio_funcsel_SPI1_CS   0x11c
+#define  fmux_gpio_funcsel_SPI1_CS_OFFSET 0
+#define  fmux_gpio_funcsel_SPI1_CS_MASK   0x7
+#define  fmux_gpio_funcsel_SPI1_SCK   0x120
+#define  fmux_gpio_funcsel_SPI1_SCK_OFFSET 0
+#define  fmux_gpio_funcsel_SPI1_SCK_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D10   0x124
+#define  fmux_gpio_funcsel_VIVO_D10_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D10_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D9   0x128
+#define  fmux_gpio_funcsel_VIVO_D9_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D9_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D8   0x12c
+#define  fmux_gpio_funcsel_VIVO_D8_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D8_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D7   0x130
+#define  fmux_gpio_funcsel_VIVO_D7_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D7_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D6   0x134
+#define  fmux_gpio_funcsel_VIVO_D6_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D6_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D5   0x138
+#define  fmux_gpio_funcsel_VIVO_D5_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D5_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D4   0x13c
+#define  fmux_gpio_funcsel_VIVO_D4_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D4_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D3   0x140
+#define  fmux_gpio_funcsel_VIVO_D3_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D3_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D2   0x144
+#define  fmux_gpio_funcsel_VIVO_D2_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D2_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D1   0x148
+#define  fmux_gpio_funcsel_VIVO_D1_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D1_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_D0   0x14c
+#define  fmux_gpio_funcsel_VIVO_D0_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_D0_MASK   0x7
+#define  fmux_gpio_funcsel_VIVO_CLK   0x150
+#define  fmux_gpio_funcsel_VIVO_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_VIVO_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX5N   0x154
+#define  fmux_gpio_funcsel_PAD_MIPIRX5N_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX5N_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX5P   0x158
+#define  fmux_gpio_funcsel_PAD_MIPIRX5P_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX5P_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX4N   0x15c
+#define  fmux_gpio_funcsel_PAD_MIPIRX4N_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX4N_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX4P   0x160
+#define  fmux_gpio_funcsel_PAD_MIPIRX4P_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX4P_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX3N   0x164
+#define  fmux_gpio_funcsel_PAD_MIPIRX3N_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX3N_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX3P   0x168
+#define  fmux_gpio_funcsel_PAD_MIPIRX3P_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX3P_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX2N   0x16c
+#define  fmux_gpio_funcsel_PAD_MIPIRX2N_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX2N_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX2P   0x170
+#define  fmux_gpio_funcsel_PAD_MIPIRX2P_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX2P_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX1N   0x174
+#define  fmux_gpio_funcsel_PAD_MIPIRX1N_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX1N_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX1P   0x178
+#define  fmux_gpio_funcsel_PAD_MIPIRX1P_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX1P_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX0N   0x17c
+#define  fmux_gpio_funcsel_PAD_MIPIRX0N_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX0N_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPIRX0P   0x180
+#define  fmux_gpio_funcsel_PAD_MIPIRX0P_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPIRX0P_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4   0x184
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4   0x188
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3   0x18c
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3   0x190
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2   0x194
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2   0x198
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1   0x19c
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1   0x1a0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0   0x1a4
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0   0x1a8
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_AUD_AINL_MIC   0x1ac
+#define  fmux_gpio_funcsel_PAD_AUD_AINL_MIC_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_AUD_AINL_MIC_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_AUD_AINR_MIC   0x1b0
+#define  fmux_gpio_funcsel_PAD_AUD_AINR_MIC_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_AUD_AINR_MIC_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_AUD_AOUTL   0x1b4
+#define  fmux_gpio_funcsel_PAD_AUD_AOUTL_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_AUD_AOUTL_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_AUD_AOUTR   0x1b8
+#define  fmux_gpio_funcsel_PAD_AUD_AOUTR_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_AUD_AOUTR_MASK   0x7
+
+#endif /* __CV1822_REG_FMUX_GPIO_H__ */
diff --git a/board/cvitek/cv1822/sdhci_reg.h b/board/cvitek/cv1822/sdhci_reg.h
new file mode 100644
index 000000000..d493875d2
--- /dev/null
+++ b/board/cvitek/cv1822/sdhci_reg.h
@@ -0,0 +1,130 @@
+#ifndef _SDHCI_REG_H
+#define _SDHCI_REG_H
+#include "cv1822_reg.h"
+#define REG_TOP_SD_PWRSW_CTRL (0x1F4)
+
+#define REG_SDIO0_PAD_MASK (0xFFFFFFF3)
+#define REG_SDIO0_PAD_SHIFT (2)
+
+#define REG_SDIO0_PAD_CLR_MASK (0xC)
+#define REG_SDIO0_CD_PAD_REG (PINMUX_BASE + 0x900)
+#define REG_SDIO0_CD_PAD_VALUE (1)
+#define REG_SDIO0_CD_PAD_RESET (1)
+
+#define REG_SDIO0_PWR_EN_PAD_REG (PINMUX_BASE + 0x904)
+#define REG_SDIO0_PWR_EN_PAD_VALUE (2)
+#define REG_SDIO0_PWR_EN_PAD_RESET (2)
+
+#define REG_SDIO0_CLK_PAD_REG (PINMUX_BASE + 0xA00)
+#define REG_SDIO0_CLK_PAD_VALUE (2)
+#define REG_SDIO0_CLK_PAD_RESET (2)
+
+#define REG_SDIO0_CMD_PAD_REG (PINMUX_BASE + 0xA04)
+#define REG_SDIO0_CMD_PAD_VALUE (1)
+#define REG_SDIO0_CMD_PAD_RESET (2)
+
+#define REG_SDIO0_DAT0_PAD_REG (PINMUX_BASE + 0xA08)
+#define REG_SDIO0_DAT0_PAD_VALUE (1)
+#define REG_SDIO0_DAT0_PAD_RESET (2)
+
+#define REG_SDIO0_DAT1_PAD_REG (PINMUX_BASE + 0xA0C)
+#define REG_SDIO0_DAT1_PAD_VALUE (1)
+#define REG_SDIO0_DAT1_PAD_RESET (2)
+
+#define REG_SDIO0_DAT2_PAD_REG (PINMUX_BASE + 0xA10)
+#define REG_SDIO0_DAT2_PAD_VALUE (1)
+#define REG_SDIO0_DAT2_PAD_RESET (2)
+
+#define REG_SDIO0_DAT3_PAD_REG (PINMUX_BASE + 0xA14)
+#define REG_SDIO0_DAT3_PAD_VALUE (1)
+#define REG_SDIO0_DAT3_PAD_RESET (2)
+
+#define PAD_SDIO0_CD_REG (PINMUX_BASE + 0x34)
+#define PAD_SDIO0_PWR_EN_REG (PINMUX_BASE + 0x38)
+#define PAD_SDIO0_CLK_REG (PINMUX_BASE + 0x1C)
+#define PAD_SDIO0_CMD_REG (PINMUX_BASE + 0x20)
+#define PAD_SDIO0_D0_REG (PINMUX_BASE + 0x24)
+#define PAD_SDIO0_D1_REG (PINMUX_BASE + 0x28)
+#define PAD_SDIO0_D2_REG (PINMUX_BASE + 0x2C)
+#define PAD_SDIO0_D3_REG (PINMUX_BASE + 0x30)
+
+#define REG_SDIO1_PAD_MASK (0xFFFFFFF3)
+#define REG_SDIO1_PAD_SHIFT (2)
+
+#define SDIO1_PAD_BASE 0x05027000
+#define REG_SDIO1_PAD_CLR_MASK (0xC)
+#define REG_SDIO1_CLK_PAD_REG (SDIO1_PAD_BASE + 0x06C)
+#define REG_SDIO1_CLK_PAD_VALUE (2)
+
+#define REG_SDIO1_CMD_PAD_REG (SDIO1_PAD_BASE + 0x068)
+#define REG_SDIO1_CMD_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT0_PAD_REG (SDIO1_PAD_BASE + 0x064)
+#define REG_SDIO1_DAT0_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT2_PAD_REG (SDIO1_PAD_BASE + 0x05C)
+#define REG_SDIO1_DAT2_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT1_PAD_REG (SDIO1_PAD_BASE + 0x060)
+#define REG_SDIO1_DAT1_PAD_VALUE (1)
+
+#define REG_SDIO1_DAT3_PAD_REG (SDIO1_PAD_BASE + 0x058)
+#define REG_SDIO1_DAT3_PAD_VALUE (1)
+
+#define REG_EMMC_PAD_CLR_MASK (0xC)
+#define REG_EMMC_PAD_SHIFT (2)
+
+#define REG_EMMC_RSTN_PAD_REG (PINMUX_BASE + 0x914)
+#define REG_EMMC_RSTN_PAD_VALUE (1)
+
+#define REG_EMMC_CLK_PAD_REG (PINMUX_BASE + 0x91c)
+#define REG_EMMC_CLK_PAD_VALUE (2)
+
+#define REG_EMMC_CMD_PAD_REG (PINMUX_BASE + 0x928)
+#define REG_EMMC_CMD_PAD_VALUE (1)
+
+#define REG_EMMC_DAT0_PAD_REG (PINMUX_BASE + 0x920)
+#define REG_EMMC_DAT0_PAD_VALUE (1)
+
+#define REG_EMMC_DAT1_PAD_REG (PINMUX_BASE + 0x92C)
+#define REG_EMMC_DAT1_PAD_VALUE (1)
+
+#define REG_EMMC_DAT2_PAD_REG (PINMUX_BASE + 0x918)
+#define REG_EMMC_DAT2_PAD_VALUE (1)
+
+#define REG_EMMC_DAT3_PAD_REG (PINMUX_BASE + 0x924)
+#define REG_EMMC_DAT3_PAD_VALUE (1)
+
+#define CVI_SDHCI_VENDOR_OFFSET 0x200
+#define CVI_SDHCI_PHY_TX_RX_DLY	(CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_PHY_DS_DLY	(CVI_SDHCI_VENDOR_OFFSET + 0x44)
+#define CVI_SDHCI_PHY_DLY_STS	(CVI_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_SDHCI_PHY_CONFIG	(CVI_SDHCI_VENDOR_OFFSET + 0x4C)
+
+#define CVI_SDHCI_BIT_CLK_FREE_EN 2
+#define CVI_SDHCI_CLK_FREE_EN_VALUE 0
+#define CVI_SDHCI_CLK_FREE_EN_MASK 0xFFFFFFFB
+#define CVI_SDHCI_VENDOR_MSHC_CTRL_R (CVI_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_SDHCI_PHY_RX_DLY_SHIFT 16
+// Bit 16~22
+#define CVI_SDHCI_PHY_RX_DLY_MASK 0x7F0000
+#define CVI_SDHCI_PHY_TX_RX_DLY (CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_PHY_RX_SRC_BIT_1 24
+#define CVI_SDHCI_PHY_RX_SRC_BIT_2 25
+
+#define SDHCI_PHY_CONFIG                                                       \
+	(CVI_SDHCI_VENDOR_OFFSET +                                             \
+	 0x4C) // P_VERDOR_SPECIFIC_AREA + 0x4c0x24c( PHY_TX_BPS )
+#define REG_TX_BPS_SEL_MASK 0xFFFFFFFE
+#define REG_TX_BPS_SEL_CLR_MASK (0x1) // 0x24c  PHY_TX_BPS
+#define REG_TX_BPS_SEL_SHIFT (0) // 0x24c  PHY_TX_BPS
+#define REG_TX_BPS_SEL_BYPASS (1) // 0x24c PHY_TX_BPS inv
+
+#define MMC_MAX_CLOCK (375000000)
+#define MMC_MAX_CLOCK_DIV_VALUE (0x40009)
+#define CLOCK_BYPASS_SELECT_REGISTER (0x3002030)
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#endif
diff --git a/board/cvitek/cv1835/Kconfig b/board/cvitek/cv1835/Kconfig
new file mode 100644
index 000000000..e3df3cc2f
--- /dev/null
+++ b/board/cvitek/cv1835/Kconfig
@@ -0,0 +1,44 @@
+if TARGET_CVITEK_CV1835
+
+choice
+	prompt "Cvitek CV1835 verification platform type select"
+
+config TARGET_CVITEK_CV1835_ASIC
+	bool "ASIC"
+	help
+	  This enables support for Cvitek's CV1835 SoC on ASIC platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV1835_PALLADIUM
+	bool "Palladium"
+	help
+	  This enables support for Cvitek's CV1835 SoC on PALLADIUM platform.
+
+	  If unsure, say N.
+
+config TARGET_CVITEK_CV1835_FPGA
+	bool "FPGA"
+	help
+	  This enables support for Cvitek's CV1835 SoC on FPGA platform.
+
+	  If unsure, say N.
+
+endchoice
+
+config SYS_BOARD
+	default "cv1835"
+
+config SYS_VENDOR
+	default "cvitek"
+
+config SYS_CONFIG_NAME
+	default "cv1835-asic" if TARGET_CVITEK_CV1835_ASIC
+	default "cv1835-palladium" if TARGET_CVITEK_CV1835_PALLADIUM
+	default "cv1835-fpga" if TARGET_CVITEK_CV1835_FPGA
+
+config SYS_BOOTMAPSZ
+	hex "Maximum size of memory mapped"
+	default "0x10000000"
+
+endif
diff --git a/board/cvitek/cv1835/MAINTAINERS b/board/cvitek/cv1835/MAINTAINERS
new file mode 100644
index 000000000..35d04985a
--- /dev/null
+++ b/board/cvitek/cv1835/MAINTAINERS
@@ -0,0 +1,4 @@
+CV1835 BOARD
+M:	Myles Tsai <myles.tsai@wisecore.com.tw>
+S:	Maintained
+F:	board/armltd/vexpress64/
diff --git a/board/cvitek/cv1835/Makefile b/board/cvitek/cv1835/Makefile
new file mode 100644
index 000000000..da8bfb2ae
--- /dev/null
+++ b/board/cvitek/cv1835/Makefile
@@ -0,0 +1,2 @@
+
+obj-y	:= board.o
diff --git a/board/cvitek/cv1835/board.c b/board/cvitek/cv1835/board.c
new file mode 100644
index 000000000..932d6f8c8
--- /dev/null
+++ b/board/cvitek/cv1835/board.c
@@ -0,0 +1,492 @@
+/*
+ * (C) Copyright 2013
+ * David Feng <fenghua@phytium.com.cn>
+ * Sharma Bhupesh <bhupesh.sharma@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <dm/platform_data/serial_pl01x.h>
+#include <asm/armv8/mmu.h>
+#include <asm/arch-armv8/mmio.h>
+#include "cv1835_reg.h"
+#include "cv1835_reg_fmux_gpio.h"
+#include "cv1835_pinlist_swconfig.h"
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_PL011_SERIAL
+static const struct pl01x_serial_platdata serial_platdata = {
+	.base = V2M_UART0,
+	.type = TYPE_PL011,
+	.clock = CONFIG_PL011_CLOCK,
+};
+
+U_BOOT_DEVICE(vexpress_serials) = {
+	.name = "serial_pl01x",
+	.platdata = &serial_platdata,
+};
+#endif
+
+static struct mm_region vexpress64_mem_map[] = {
+	{
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		.virt = PHYS_SDRAM_1,
+		.phys = PHYS_SDRAM_1,
+		.size = PHYS_SDRAM_1_SIZE,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+#ifdef BM_UPDATE_FW_START_ADDR
+	}, {
+		.virt = BM_UPDATE_FW_START_ADDR,
+		.phys = BM_UPDATE_FW_START_ADDR,
+		/*
+		 * this area is for bmtest under uboot. -- added by Xun Li
+		 * [0x110000000, 0x190000000] size = 2G
+		 */
+		.size = BM_UPDATE_FW_SIZE,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+#else
+	}, {
+		/*
+		 * be aware we'll need 256MB more other than PHYS_SDRAM_1_SIZE for the fake flash area
+		 * of itb file during ram boot, and MMC's DMA buffer (BM_UPDATE_ALIGNED_BUFFER).
+		 * so either cover it here or in video's region.
+		 * also be carefull with BM_SPIF_BUFFER_ADDR and BM_UPDATE_FW_START_ADDR...
+		 */
+		.virt = PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE,
+		.phys = PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE,
+		.size = 0x10000000,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+#endif
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = vexpress64_mem_map;
+
+static void pinmux_config(int io_type)
+{
+		switch (io_type) {
+		case PINMUX_UART0:
+			PINMUX_CONFIG(UART0_RX, UART0_RX);
+			PINMUX_CONFIG(UART0_TX, UART0_TX);
+		break;
+		case PINMUX_UART1:
+			PINMUX_CONFIG(UART1_RX, UART1_RX);
+			PINMUX_CONFIG(UART1_TX, UART1_TX);
+		break;
+		case PINMUX_UART2:
+			PINMUX_CONFIG(UART2_RX, UART2_RX);
+			PINMUX_CONFIG(UART2_TX, UART2_TX);
+		break;
+		case PINMUX_UART3:
+			PINMUX_CONFIG(PWM2, UART3_RX);
+			PINMUX_CONFIG(PWM3, UART3_TX);
+		break;
+		case PINMUX_I2C0:
+			PINMUX_CONFIG(IIC0_SCL, IIC0_SCL);
+			PINMUX_CONFIG(IIC0_SDA, IIC0_SDA);
+		break;
+		case PINMUX_I2C1:
+			PINMUX_CONFIG(IIC1_SCL, IIC1_SCL);
+			PINMUX_CONFIG(IIC1_SDA, IIC1_SDA);
+		break;
+		case PINMUX_I2C2:
+			PINMUX_CONFIG(IIC2_SCL, IIC2_SCL);
+			PINMUX_CONFIG(IIC2_SDA, IIC2_SDA);
+		break;
+		case PINMUX_I2C3:
+			PINMUX_CONFIG(IIC3_SCL, IIC3_SCL);
+			PINMUX_CONFIG(IIC3_SDA, IIC3_SDA);
+		break;
+		case PINMUX_SPI0:
+			PINMUX_CONFIG(SPI0_SCK, SPI0_SCK);
+			PINMUX_CONFIG(SPI0_CS_X, SPI0_CS_X);
+			PINMUX_CONFIG(SPI0_SDI, SPI0_SDI);
+			PINMUX_CONFIG(SPI0_SDO, SPI0_SDO);
+		break;
+		case PINMUX_SPI1:
+			PINMUX_CONFIG(XGPIO_A_25, SPI1_SCK);
+			PINMUX_CONFIG(XGPIO_A_29, SPI1_CS_X);
+			PINMUX_CONFIG(XGPIO_A_23, SPI1_SDI);
+			PINMUX_CONFIG(XGPIO_A_24, SPI1_SDO);
+		break;
+		case PINMUX_SPI2:
+			PINMUX_CONFIG(IIC3_SCL, SPI2_SCK);
+			PINMUX_CONFIG(IIC3_SDA, SPI2_CS_X);
+			PINMUX_CONFIG(IIC0_SCL, SPI2_SDI);
+			PINMUX_CONFIG(IIC0_SDA, SPI2_SDO);
+		break;
+		case PINMUX_SPI3:
+			printf("fix me: PINMUX_SPI3\n");
+		break;
+		case PINMUX_I2S1:
+			PINMUX_CONFIG(UART1_RTS, IIS1_DI);
+			PINMUX_CONFIG(UART2_RTS, IIS1_MCLK);
+			PINMUX_CONFIG(UART1_CTS, IIS1_DO);
+			PINMUX_CONFIG(UART1_TX, IIS1_BCLK);
+			PINMUX_CONFIG(UART1_RX, IIS1_LRCK);
+		break;
+		case PINMUX_I2S2:
+			PINMUX_CONFIG(XGPIO_A_20, IIS2_DI);
+			PINMUX_CONFIG(EMMC_RSTN, IIS2_MCLK);
+			PINMUX_CONFIG(XGPIO_A_21, IIS2_DO);
+			PINMUX_CONFIG(XGPIO_A_26, IIS2_BCLK);
+			PINMUX_CONFIG(XGPIO_A_22, IIS2_LRCK);
+		break;
+		case PINMUX_SDIO0:
+			PINMUX_CONFIG(SDIO0_CD, SDIO0_CD);
+			PINMUX_CONFIG(SDIO0_PWR_EN, SDIO0_PWR_EN);
+			PINMUX_CONFIG(SDIO0_CMD, SDIO0_CMD);
+			PINMUX_CONFIG(SDIO0_CLK, SDIO0_CLK);
+			PINMUX_CONFIG(SDIO0_D0, SDIO0_D_0);
+			PINMUX_CONFIG(SDIO0_D1, SDIO0_D_1);
+			PINMUX_CONFIG(SDIO0_D2, SDIO0_D_2);
+			PINMUX_CONFIG(SDIO0_D3, SDIO0_D_3);
+		break;
+		case PINMUX_SDIO1:
+			PINMUX_CONFIG(XGPIO_A_24, SDIO1_CMD);
+			PINMUX_CONFIG(XGPIO_A_25, SDIO1_CLK);
+			PINMUX_CONFIG(XGPIO_A_23, SDIO1_D_0);
+			PINMUX_CONFIG(XGPIO_A_28, SDIO1_D_1);
+			PINMUX_CONFIG(XGPIO_A_27, SDIO1_D_2);
+			PINMUX_CONFIG(XGPIO_A_29, SDIO1_D_3);
+			PINMUX_CONFIG(XGPIO_A_22, XGPIOA_22);
+		break;
+		case PINMUX_EMMC:
+			PINMUX_CONFIG(EMMC_CLK, EMMC_CLK);
+			PINMUX_CONFIG(EMMC_RSTN, EMMC_RSTN);
+			PINMUX_CONFIG(EMMC_CMD, EMMC_CMD);
+			PINMUX_CONFIG(EMMC_DAT1, EMMC_DAT_1);
+			PINMUX_CONFIG(EMMC_DAT0, EMMC_DAT_0);
+			PINMUX_CONFIG(EMMC_DAT2, EMMC_DAT_2);
+			PINMUX_CONFIG(EMMC_DAT3, EMMC_DAT_3);
+		break;
+		case PINMUX_SPI_NOR:
+			PINMUX_CONFIG(EMMC_CLK, SPINOR_SCK);
+			PINMUX_CONFIG(EMMC_CMD, SPINOR_SDI);
+			PINMUX_CONFIG(EMMC_DAT1, SPINOR_CS_X);
+			PINMUX_CONFIG(EMMC_DAT0, SPINOR_SDO);
+			PINMUX_CONFIG(EMMC_DAT2, SPINOR_HOLD_X);
+			PINMUX_CONFIG(EMMC_DAT3, SPINOR_WP_X);
+		break;
+		case PINMUX_SPI_NAND:
+			PINMUX_CONFIG(EMMC_CLK, SPINAND_CLK);
+			PINMUX_CONFIG(EMMC_CMD, SPINAND_DI);
+			PINMUX_CONFIG(EMMC_DAT1, SPINAND_CS);
+			PINMUX_CONFIG(EMMC_DAT0, SPINAND_DO);
+			PINMUX_CONFIG(EMMC_DAT2, SPINAND_HOLD);
+			PINMUX_CONFIG(EMMC_DAT3, SPINAND_WP);
+		break;
+		case PINMUX_CAM0:
+			PINMUX_CONFIG(CAM_PD0, CAM_MCLK1);
+			PINMUX_CONFIG(CAM_MCLK0, CAM_MCLK0);
+		break;
+		case PINMUX_VI0:
+			printf("fix me: PINMUX_VI0\n");
+		break;
+		case PINMUX_VO:
+			printf("fix me: PINMUX_VO\n");
+		break;
+		case PINMUX_DSI:
+			PINMUX_CONFIG(PWM1, XGPIOB_4);
+			PINMUX_CONFIG(PWM2, XGPIOB_3);
+			PINMUX_CONFIG(PWM3, XGPIOB_5);
+
+			PINMUX_CONFIG(PAD_MIPI_TXM4, MIPI_TXM4);
+			PINMUX_CONFIG(PAD_MIPI_TXP4, MIPI_TXP4);
+			PINMUX_CONFIG(PAD_MIPI_TXM3, MIPI_TXM3);
+			PINMUX_CONFIG(PAD_MIPI_TXP3, MIPI_TXP3);
+			PINMUX_CONFIG(PAD_MIPI_TXM2, MIPI_TXM2);
+			PINMUX_CONFIG(PAD_MIPI_TXP2, MIPI_TXP2);
+			PINMUX_CONFIG(PAD_MIPI_TXM1, MIPI_TXM1);
+			PINMUX_CONFIG(PAD_MIPI_TXP1, MIPI_TXP1);
+			PINMUX_CONFIG(PAD_MIPI_TXM0, MIPI_TXM0);
+			PINMUX_CONFIG(PAD_MIPI_TXP0, MIPI_TXP0);
+			break;
+		case PINMUX_RMII1:
+			PINMUX_CONFIG(SPI0_SDI, RMII1_TXD3);
+			PINMUX_CONFIG(SPI0_SDO, RMII1_RXD3);
+			PINMUX_CONFIG(SPI0_SCK, RMII1_TXD2);
+			PINMUX_CONFIG(SPI0_CS_X, RMII1_RXD2);
+			PINMUX_CONFIG(IIC2_SCL, RMII1_MDIO);
+			PINMUX_CONFIG(IIC1_SCL, RMII1_RXD1);
+			PINMUX_CONFIG(IIC1_SDA, RMII1_REFCLKI);
+			PINMUX_CONFIG(UART2_TX, RMII1_RXD0);
+			PINMUX_CONFIG(IIC2_SDA, RMII1_MDC);
+			PINMUX_CONFIG(UART1_RTS, RMII1_TXD0);
+			PINMUX_CONFIG(UART2_RTS, RMII1_TXD1);
+			PINMUX_CONFIG(UART2_RX, RMII1_RXDV);
+			PINMUX_CONFIG(UART1_TX, RMII1_TXCLK);
+			PINMUX_CONFIG(UART1_CTS, XGPIOB_20);
+			PINMUX_CONFIG(UART2_CTS, RMII1_TXEN);
+			break;
+		case PINMUX_EPHY_LED:
+			PINMUX_CONFIG(XGPIO_A_26, EPHY_LNK_LED);
+			PINMUX_CONFIG(XGPIO_A_22, EPHY_SPD_LED);
+			break;
+		case PINMUX_I80:
+			PINMUX_CONFIG(VO_DATA1, VO_DATA_1);
+			PINMUX_CONFIG(VO_DATA0, VO_DATA_0);
+			PINMUX_CONFIG(PAD_MIPI_TXM4, VO_DATA_10);
+			PINMUX_CONFIG(PAD_MIPI_TXP4, VO_DATA_9);
+			PINMUX_CONFIG(PAD_MIPI_TXM3, VO_DATA_8);
+			PINMUX_CONFIG(PAD_MIPI_TXP3, VO_DATA_7);
+			PINMUX_CONFIG(PAD_MIPI_TXM2, VO_DATA_6);
+			PINMUX_CONFIG(PAD_MIPI_TXP2, VO_DATA_5);
+			PINMUX_CONFIG(PAD_MIPI_TXM1, VO_DATA_4);
+			PINMUX_CONFIG(PAD_MIPI_TXP1, VO_DATA_3);
+			PINMUX_CONFIG(PAD_MIPI_TXM0, VO_DATA_2);
+			PINMUX_CONFIG(PAD_MIPI_TXP0, VO_CLK);
+			break;
+		default:
+		break;
+	}
+}
+
+#define _reg_read(addr) readl((void __iomem *)addr)
+#define _reg_write(addr, data) writel(data, (void __iomem *)addr)
+
+static void cvsnfc_setup_internal_clk(void)
+{
+/*
+ * Set clk_spi_nand to 150Mhz
+ * write(0x3002088) = read(0x3002088)|0x10
+ * write(0x3002088) = 0x000A0019
+ * write(0x3002088) = 0x000A0009
+ */
+	#define TOP_CLK_REG_BASE		0x3002000
+	#define REG_SPI_NAND_CLK_SETTING	(TOP_CLK_REG_BASE + 0x88)
+	_reg_write(REG_SPI_NAND_CLK_SETTING, _reg_read(REG_SPI_NAND_CLK_SETTING) | 0x10);
+	mdelay(1);
+	_reg_write(REG_SPI_NAND_CLK_SETTING, 0x000A0019);
+	mdelay(1);
+	_reg_write(REG_SPI_NAND_CLK_SETTING, 0x000A0009);
+}
+
+#include "../cvi_board_init.c"
+
+int board_init(void)
+{
+#if defined(CONFIG_TARGET_CVITEK_CV1835_ASIC) /* config eth internal phy on ASIC board */
+	unsigned int val;
+
+	//writel(0x00000000, 0x03002030);
+	//writel(0x00000000, 0x03002034);
+
+	val = readl(0x03009000) & ETH_PHY_INIT_MASK;
+	writel((val | ETH_PHY_SHUTDOWN) & ETH_PHY_RESET, 0x03009000);
+	mdelay(1);
+	writel(val & ETH_PHY_POWERUP & ETH_PHY_RESET, 0x03009000);
+	mdelay(20);
+	writel((val & ETH_PHY_POWERUP) | ETH_PHY_RESET_N, 0x03009000);
+	mdelay(1);
+
+	val = readl(0x03009000);
+	writel(readl(0x03009000) | ETH_PHY_LED_LOW_ACTIVE, 0x03009000);
+
+#endif
+
+/* Set ethernet clock resource */
+#if defined(CONFIG_TARGET_CVITEK_CV1835_FPGA)
+	writel(0x000000C1, 0x03000034); /* Set eth0 RGMII, eth1 RMII clk resource and interface type*/
+#elif defined(CONFIG_TARGET_CVITEK_CV1835_ASIC)
+	writel(0x0000001C, 0x03000034); /* Set eth0 RMII, eth1 RGMII clk resource and interface type*/
+
+	writel(0x00000020, 0x03001940);	 /* set TX driving strength of ASIC EVB RGMII interface */
+	writel(0x00000020, 0x03001918);
+	writel(0x00000020, 0x03001934);
+	writel(0x00000020, 0x03001938);
+	writel(0x00000020, 0x0300194c);
+	writel(0x00000020, 0x03001910);
+
+	writel(0x00000020, 0x03001928);	 /* Remove RX pull down */
+	writel(0x00000020, 0x0300193c);
+	writel(0x00000020, 0x0300192c);
+	writel(0x00000020, 0x03001924);
+	writel(0x00000020, 0x0300191c);
+	writel(0x00000020, 0x03001914);
+
+	writel(0x01070000, 0x030001CC); /* RGMII TX/RX delayline select config */
+
+
+#elif defined(CONFIG_TARGET_CVITEK_CV1835_PALLADIUM)
+	writel(0x0000001C, 0x03000034); /* Set eth0 RMII, eth1 RGMII clk resource and interface type*/
+#endif
+#if defined(CONFIG_NAND_SUPPORT)
+	pinmux_config(PINMUX_SPI_NAND); // TODO, use gpio to decide storage pinmux
+#elif defined(CONFIG_SPI_FLASH)
+	pinmux_config(PINMUX_SPI_NOR);
+#elif defined(CONFIG_EMMC_SUPPORT)
+	pinmux_config(PINMUX_EMMC);
+#endif
+
+#ifdef CONFIG_DISPLAY_CVITEK_MIPI
+	pinmux_config(PINMUX_DSI);
+#elif defined(CONFIG_DISPLAY_CVITEK_I80)
+	pinmux_config(PINMUX_I80);
+#endif
+
+#if defined(CV1835_WDMB_0001A_SPINAND)
+	PINMUX_CONFIG(UART1_RX, UART1_RX); //UART_RX,TX,CTS
+	PINMUX_CONFIG(UART1_TX, UART1_TX);
+	PINMUX_CONFIG(UART1_CTS, UART1_CTS);
+#elif defined(CV1835_WDMB_0002A_SPINAND)
+	PINMUX_CONFIG(JTAG_CPU_TCK, XGPIOA_0); //IIC2_SHDN
+	PINMUX_CONFIG(IIC2_SCL, IIC2_SCL); //IIC2
+	PINMUX_CONFIG(IIC2_SDA, IIC2_SDA);
+	PINMUX_CONFIG(JTAG_CPU_TMS, XGPIOA_6);//AMP_MUTE
+#elif defined(CV1832_WDMB_0002B_SPINAND)
+	PINMUX_CONFIG(PWM3, XGPIOB_5); //LED_PWM
+	PINMUX_CONFIG(UART1_CTS, XGPIOB_20); //ALARM_OUT
+	PINMUX_CONFIG(ADC1, XGPIOB_24); //IR_IN
+	PINMUX_CONFIG(VI_DATA19, XGPIOD_2); //ALARM_IN
+	PINMUX_CONFIG(VI_DATA20, XGPIOC_31); //KEY_SET
+	PINMUX_CONFIG(VI_DATA21, XGPIOD_0); //IR_CUT1
+	PINMUX_CONFIG(VI_DATA22, XGPIOC_30); //IR_CUT2
+#elif defined(CV1835_WDMB_0003A)
+	pinmux_config(PINMUX_SDIO1);//wifi
+	PINMUX_CONFIG(ADC1, XGPIOB_24); //Light_INT
+	PINMUX_CONFIG(UART1_CTS, XGPIOB_20); //REMOVE_BUT
+	PINMUX_CONFIG(UART1_RTS, XGPIOB_16); //RELAY_C
+	PINMUX_CONFIG(JTAG_CPU_TCK, XGPIOA_0); //CAM1_PWDN
+	PINMUX_CONFIG(JTAG_CPU_TMS, XGPIOA_6); //CAM0_PWDN
+	PINMUX_CONFIG(SDIO0_D1, XGPIOA_17); //VO_IN
+	PINMUX_CONFIG(SDIO0_D2, XGPIOA_18); //NFC_IRQ
+	PINMUX_CONFIG(SPI0_SCK, SPI0_SCK); //NFC_SCK
+	PINMUX_CONFIG(SPI0_CS_X, XGPIOB_9); //NFC_CS_X
+	PINMUX_CONFIG(SPI0_SDI, SPI0_SDI); //NFC_SDI
+	PINMUX_CONFIG(SPI0_SDO, SPI0_SDO); //NFC_SDO
+	PINMUX_CONFIG(IIC1_SCL, IIC1_SCL); //RTC
+	PINMUX_CONFIG(IIC1_SDA, IIC1_SDA); //RTC
+	PINMUX_CONFIG(UART1_TX, UART1_TX); //RS485_A
+	PINMUX_CONFIG(UART1_RX, UART1_RX); //RS485_B
+	PINMUX_CONFIG(SDIO0_D3, XGPIOA_19); //RS485_RE_DE
+	PINMUX_CONFIG(XGPIO_A_26, EPHY_LNK_LED); //EPHY_SPD_LED
+	PINMUX_CONFIG(XGPIO_A_22, EPHY_SPD_LED); //EPHY_LNK_LED
+	PINMUX_CONFIG(PWM3, PWM_3); //white_led
+#elif defined(CV9520_WEVB_0002A_V02_NVR)
+#elif defined(CV9520_WDMB_0004A_V02_NVR)
+	pinmux_config(PINMUX_SDIO1);   //WIFI
+	PINMUX_CONFIG(XGPIO_A_26, EPHY_LNK_LED);  //EPHY_SPD_LED
+	PINMUX_CONFIG(XGPIO_A_22, EPHY_SPD_LED); //EPHY_LNK_LED
+	pinmux_config(PINMUX_RMII1);   //ETH1
+	PINMUX_CONFIG(USB_VBUS_DET, USB_VBUS_DET); //USB_VBUS_DET
+	PINMUX_CONFIG(PWM1, PWM_1);    //LCD Brightness PWM
+	PINMUX_CONFIG(MIPIRX0_PAD0N, XGPIOC_28); //TOUCHPAD
+	PINMUX_CONFIG(MIPIRX0_PAD0P, XGPIOC_29); //TOUCHPAD
+#elif defined(CV9520_WEVB_0002A_V02_NVR_SPINAND)
+#elif defined(CV9520_WDMB_0004A_V02_NVR_SPINAND)
+	pinmux_config(PINMUX_SDIO1);   //WIFI
+	PINMUX_CONFIG(XGPIO_A_26, EPHY_LNK_LED);  //EPHY_SPD_LED
+	PINMUX_CONFIG(XGPIO_A_22, EPHY_SPD_LED); //EPHY_LNK_LED
+	pinmux_config(PINMUX_RMII1);   //ETH1
+	PINMUX_CONFIG(USB_VBUS_DET, USB_VBUS_DET); //USB_VBUS_DET
+	PINMUX_CONFIG(PWM1, PWM_1);    //LCD Brightness PWM
+	PINMUX_CONFIG(MIPIRX0_PAD0N, XGPIOC_28); //TOUCHPAD
+	PINMUX_CONFIG(MIPIRX0_PAD0P, XGPIOC_29); //TOUCHPAD
+#elif defined(CV1835_WEVB_0002A_I80)
+	pinmux_config(PINMUX_SDIO1);
+	pinmux_config(PINMUX_I2C1);
+	pinmux_config(PINMUX_I2C2);
+	pinmux_config(PINMUX_I2C3);
+	pinmux_config(PINMUX_UART1);
+	pinmux_config(PINMUX_UART2);
+	PINMUX_CONFIG(UART2_RTS, UART2_RTS);
+	PINMUX_CONFIG(UART2_CTS, UART2_CTS);
+	PINMUX_CONFIG(VI_DATA21, UART3_RX);//uart3
+	PINMUX_CONFIG(VI_DATA22, UART3_TX);
+	PINMUX_CONFIG(UART1_CTS, UART4_RX);//uart4
+	PINMUX_CONFIG(UART1_RTS, UART4_TX);
+	PINMUX_CONFIG(SPI0_SDI, SPI0_SDI);//spi0
+	PINMUX_CONFIG(SPI0_SDO, SPI0_SDO);
+	PINMUX_CONFIG(SPI0_SCK, SPI0_SCK);
+	PINMUX_CONFIG(SPI0_CS_X, XGPIOB_9);
+	PINMUX_CONFIG(SDIO0_PWR_EN, XGPIOA_4);//gpio
+	PINMUX_CONFIG(SDIO0_CMD, XGPIOA_14);
+	PINMUX_CONFIG(SDIO0_CLK, XGPIOA_15);
+	PINMUX_CONFIG(SDIO0_D0, XGPIOA_16);
+	PINMUX_CONFIG(SDIO0_D1, XGPIOA_17);
+	PINMUX_CONFIG(SDIO0_D2, XGPIOA_18);
+	PINMUX_CONFIG(SDIO0_D3, XGPIOA_19);
+	PINMUX_CONFIG(CAM_PD0, CAM_MCLK1); //cam_pd
+	PINMUX_CONFIG(JTAG_CPU_TRST, XGPIOA_2);
+	PINMUX_CONFIG(JTAG_CPU_TMS, XGPIOA_6);
+#endif
+
+	cvsnfc_setup_internal_clk();
+
+	return cvi_board_init();
+}
+
+int dram_init(void)
+{
+	unsigned int ddr_size;
+
+	ddr_size = readl(GP_REG8);
+	gd->ram_size = ddr_size ? ddr_size : PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	unsigned int ddr_size;
+
+	ddr_size = readl(GP_REG8);
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = ddr_size ? ddr_size : PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
+
+/*
+ * Board specific reset that is system reset.
+ */
+void reset_cpu(ulong addr)
+{
+}
+
+void software_root_reset(void)
+{
+	unsigned int val;
+
+	writel(0x4, (RTC_BASE + RTC_DB_REQ_WARM_RST));
+	writel(0x1, (RTC_BASE + RTC_EN_WARM_RST_REQ));
+	writel(0xAB18, (RTCFC_BASE + RTC_CTRL0_UNLOCKKEY));
+
+	val = readl((RTCFC_BASE + RTC_CTRL0)) | 0xFFFF0000 | (0x1 << 4);
+	writel(val, (RTCFC_BASE + RTC_CTRL0));
+}
+
+/*
+ * Board specific ethernet initialization routine.
+ */
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_SMC91111
+	rc = smc91111_initialize(0, CONFIG_SMC91111_BASE);
+#endif
+#ifdef CONFIG_SMC911X
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
+#endif
+	return rc;
+}
diff --git a/board/cvitek/cv1835/cv1835_pinlist_swconfig.h b/board/cvitek/cv1835/cv1835_pinlist_swconfig.h
new file mode 100644
index 000000000..8eb044718
--- /dev/null
+++ b/board/cvitek/cv1835/cv1835_pinlist_swconfig.h
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cv1835_pinlist_swconfig.h
+ * Description:
+ */
+
+#ifndef __CV1835_PINLIST_SWCONFIG_H__
+#define __CV1835_PINLIST_SWCONFIG_H__
+
+//##==============================================================================
+//##=== Generate Time stamp is : 2019-11-27 20:20:28
+//##==============================================================================
+
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + fmux_gpio_funcsel_##PIN_NAME, \
+			fmux_gpio_funcsel_##PIN_NAME##_MASK << fmux_gpio_funcsel_##PIN_NAME##_OFFSET, \
+			PIN_NAME##__##FUNC_NAME)
+
+#define JTAG_CPU_TCK__JTAG_CPU_TCK 0
+#define JTAG_CPU_TCK__DBG_1 1
+#define JTAG_CPU_TCK__XGPIOA_0 3
+#define SDIO0_CD__SDIO0_CD 0
+#define SDIO0_CD__DBG_6 1
+#define SDIO0_CD__XGPIOA_1 3
+#define RSTN__RSTN 0
+#define JTAG_CPU_TRST__JTAG_CPU_TRST 0
+#define JTAG_CPU_TRST__DBG_0 1
+#define JTAG_CPU_TRST__XGPIOA_2 3
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__DBG_4 1
+#define UART0_RX__AUX0 2
+#define UART0_RX__XGPIOA_3 3
+#define UART0_RX__H265_UART_RX 4
+#define UART0_RX__H264_UART_RX 5
+#define SDIO0_PWR_EN__SDIO0_PWR_EN 0
+#define SDIO0_PWR_EN__DBG_5 1
+#define SDIO0_PWR_EN__XGPIOA_4 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__DBG_3 1
+#define UART0_TX__AUX1 2
+#define UART0_TX__XGPIOA_5 3
+#define UART0_TX__H265_UART_TX 4
+#define UART0_TX__H264_UART_TX 5
+#define JTAG_CPU_TMS__JTAG_CPU_TMS 0
+#define JTAG_CPU_TMS__DBG_2 1
+#define JTAG_CPU_TMS__XGPIOA_6 3
+#define JTAG_CPU_TMS__JTAG_CPU_5W_TMS 4
+#define EMMC_CLK__EMMC_CLK 0
+#define EMMC_CLK__SPINOR_SCK 1
+#define EMMC_CLK__SPINAND_CLK 2
+#define EMMC_CLK__XGPIOA_7 3
+#define EMMC_RSTN__EMMC_RSTN 0
+#define EMMC_RSTN__XGPIOA_8 3
+#define EMMC_RSTN__AUX2 4
+#define EMMC_RSTN__IIS2_MCLK 5
+#define EMMC_CMD__EMMC_CMD 0
+#define EMMC_CMD__SPINOR_SDI 1
+#define EMMC_CMD__SPINAND_DI 2
+#define EMMC_CMD__XGPIOA_9 3
+#define EMMC_DAT1__EMMC_DAT_1 0
+#define EMMC_DAT1__SPINOR_CS_X 1
+#define EMMC_DAT1__SPINAND_CS 2
+#define EMMC_DAT1__XGPIOA_10 3
+#define EMMC_DAT0__EMMC_DAT_0 0
+#define EMMC_DAT0__SPINOR_SDO 1
+#define EMMC_DAT0__SPINAND_DO 2
+#define EMMC_DAT0__XGPIOA_11 3
+#define EMMC_DAT2__EMMC_DAT_2 0
+#define EMMC_DAT2__SPINOR_HOLD_X 1
+#define EMMC_DAT2__SPINAND_HOLD 2
+#define EMMC_DAT2__XGPIOA_12 3
+#define EMMC_DAT3__EMMC_DAT_3 0
+#define EMMC_DAT3__SPINOR_WP_X 1
+#define EMMC_DAT3__SPINAND_WP 2
+#define EMMC_DAT3__XGPIOA_13 3
+#define SDIO0_CMD__SDIO0_CMD 0
+#define SDIO0_CMD__DBG_11 1
+#define SDIO0_CMD__XGPIOA_14 3
+#define SDIO0_CLK__SDIO0_CLK 0
+#define SDIO0_CLK__DBG_12 1
+#define SDIO0_CLK__XGPIOA_15 3
+#define SDIO0_D0__SDIO0_D_0 0
+#define SDIO0_D0__DBG_10 1
+#define SDIO0_D0__XGPIOA_16 3
+#define SDIO0_D1__SDIO0_D_1 0
+#define SDIO0_D1__DBG_9 1
+#define SDIO0_D1__XGPIOA_17 3
+#define SDIO0_D2__SDIO0_D_2 0
+#define SDIO0_D2__DBG_8 1
+#define SDIO0_D2__AUX0 2
+#define SDIO0_D2__XGPIOA_18 3
+#define SDIO0_D3__SDIO0_D_3 0
+#define SDIO0_D3__DBG_7 1
+#define SDIO0_D3__AUX1 2
+#define SDIO0_D3__XGPIOA_19 3
+#define XGPIO_A_20__UART1_TX 1
+#define XGPIO_A_20__UART2_TX 2
+#define XGPIO_A_20__XGPIOA_20 3
+#define XGPIO_A_20__H265_UART_TX 4
+#define XGPIO_A_20__IIS2_DI 5
+#define XGPIO_A_20__H264_UART_TX 6
+#define XGPIO_A_20__WG1_D0 7
+#define XGPIO_A_21__UART1_RX 1
+#define XGPIO_A_21__UART2_RX 2
+#define XGPIO_A_21__XGPIOA_21 3
+#define XGPIO_A_21__H265_UART_RX 4
+#define XGPIO_A_21__IIS2_DO 5
+#define XGPIO_A_21__H264_UART_RX 6
+#define XGPIO_A_21__WG1_D1 7
+#define XGPIO_A_22__UART1_CTS 1
+#define XGPIO_A_22__UART2_CTS 2
+#define XGPIO_A_22__XGPIOA_22 3
+#define XGPIO_A_22__IIS2_LRCK 5
+#define XGPIO_A_22__UART4_TX 6
+#define XGPIO_A_22__EPHY_SPD_LED 7
+#define XGPIO_A_23__SDIO1_D_0 1
+#define XGPIO_A_23__SPI1_SDI 2
+#define XGPIO_A_23__XGPIOA_23 3
+#define XGPIO_A_23__EPHY_DPX_LED 6
+#define XGPIO_A_24__SDIO1_CMD 1
+#define XGPIO_A_24__SPI1_SDO 2
+#define XGPIO_A_24__XGPIOA_24 3
+#define XGPIO_A_24__EPHY_SPD_LED 6
+#define XGPIO_A_25__SDIO1_CLK 1
+#define XGPIO_A_25__SPI1_SCK 2
+#define XGPIO_A_25__XGPIOA_25 3
+#define XGPIO_A_25__EPHY_LNK_LED 6
+#define XGPIO_A_26__UART1_RTS 1
+#define XGPIO_A_26__UART2_RTS 2
+#define XGPIO_A_26__XGPIOA_26 3
+#define XGPIO_A_26__RMII0_IRQ 4
+#define XGPIO_A_26__IIS2_BCLK 5
+#define XGPIO_A_26__UART4_RX 6
+#define XGPIO_A_26__EPHY_LNK_LED 7
+#define XGPIO_A_27__SDIO1_D_2 1
+#define XGPIO_A_27__XGPIOA_27 3
+#define XGPIO_A_27__H265_UART_TX 4
+#define XGPIO_A_27__EPHY_DPX_LED 6
+#define XGPIO_A_27__H264_UART_TX 7
+#define XGPIO_A_28__SDIO1_D_1 1
+#define XGPIO_A_28__XGPIOA_28 3
+#define XGPIO_A_28__H265_UART_RX 4
+#define XGPIO_A_28__EPHY_SPD_LED 6
+#define XGPIO_A_28__H264_UART_RX 7
+#define XGPIO_A_29__SDIO1_D_3 1
+#define XGPIO_A_29__SPI1_CS_X 2
+#define XGPIO_A_29__XGPIOA_29 3
+#define XGPIO_A_29__EPHY_LNK_LED 6
+#define RTC_MODE__RTC_MODE 0
+#define RTC_MODE__XGPIOA_30 3
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__XGPIOA_31 3
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__XGPIOB_0 3
+#define PWR_WAKEUP1__PWR_WAKEUP1 0
+#define PWR_WAKEUP1__XGPIOB_1 3
+#define PWR_BUTTON0__PWR_BUTTON0 0
+#define PWR_BUTTON0__XGPIOD_11 3
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_ON__PWR_ON 0
+#define PWR_ON__XGPIOB_2 3
+#define PTEST__PTEST 0
+#define PWM2__PWM_2 0
+#define PWM2__IIC1_SCL 1
+#define PWM2__KEY_COL2 2
+#define PWM2__XGPIOB_3 3
+#define PWM2__JTAG_CPU_5W_TDI 4
+#define PWM2__UART3_RX 5
+#define PWM2__WG2_D0 7
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_6 3
+#define PWM3__PWM_3 0
+#define PWM3__IIC1_SDA 1
+#define PWM3__KEY_COL3 2
+#define PWM3__XGPIOB_5 3
+#define PWM3__UART3_TX 5
+#define PWM3__WG2_D1 7
+#define PWM1__PWM_1 0
+#define PWM1__XGPIOB_4 3
+#define PWM1__JTAG_CPU_5W_TDO 4
+#define SPI0_SDI__SPI0_SDI 0
+#define SPI0_SDI__IIC2_SDA 1
+#define SPI0_SDI__PWM_15 2
+#define SPI0_SDI__XGPIOB_8 3
+#define SPI0_SDI__UART3_CTS 4
+#define SPI0_SDI__RMII1_TXD3 5
+#define SPI0_SDI__SPINOR1_SDI 6
+#define SPI0_SDO__SPI0_SDO 0
+#define SPI0_SDO__IIC2_SCL 1
+#define SPI0_SDO__PWM_14 2
+#define SPI0_SDO__XGPIOB_10 3
+#define SPI0_SDO__UART3_RTS 4
+#define SPI0_SDO__RMII1_RXD3 5
+#define SPI0_SDO__SPINOR1_SDO 6
+#define SPI0_SCK__SPI0_SCK 0
+#define SPI0_SCK__IIC4_SCL 1
+#define SPI0_SCK__PWM_12 2
+#define SPI0_SCK__XGPIOB_7 3
+#define SPI0_SCK__UART3_RX 4
+#define SPI0_SCK__RMII1_TXD2 5
+#define SPI0_SCK__SPINOR1_SCK 6
+#define SPI0_CS_X__SPI0_CS_X 0
+#define SPI0_CS_X__IIC4_SDA 1
+#define SPI0_CS_X__PWM_13 2
+#define SPI0_CS_X__XGPIOB_9 3
+#define SPI0_CS_X__UART3_TX 4
+#define SPI0_CS_X__RMII1_RXD2 5
+#define SPI0_CS_X__SPINOR1_CS_X 6
+#define IIC2_SCL__IIC2_SCL 0
+#define IIC2_SCL__PWM_14 1
+#define IIC2_SCL__UART2_RX 2
+#define IIC2_SCL__XGPIOB_11 3
+#define IIC2_SCL__RMII1_MDIO 4
+#define IIC1_SCL__IIC1_SCL 0
+#define IIC1_SCL__PWM_12 1
+#define IIC1_SCL__XGPIOB_12 3
+#define IIC1_SCL__RMII1_RXD1 4
+#define IIC1_SCL__SPINOR1_HOLD_X 6
+#define IIC1_SDA__IIC1_SDA 0
+#define IIC1_SDA__PWM_13 1
+#define IIC1_SDA__XGPIOB_14 3
+#define IIC1_SDA__RMII1_REFCLKI 4
+#define IIC1_SDA__SPINOR1_WP_X 6
+#define UART2_TX__UART2_TX 0
+#define UART2_TX__PWM_11 1
+#define UART2_TX__KEY_ROW3 2
+#define UART2_TX__XGPIOB_15 3
+#define UART2_TX__RMII1_RXD0 4
+#define UART2_TX__WG2_D0 7
+#define IIC2_SDA__IIC2_SDA 0
+#define IIC2_SDA__PWM_15 1
+#define IIC2_SDA__UART2_TX 2
+#define IIC2_SDA__XGPIOB_13 3
+#define IIC2_SDA__RMII1_MDC 4
+#define UART1_RTS__UART1_RTS 0
+#define UART1_RTS__PWM_7 1
+#define UART1_RTS__KEY_COL1 2
+#define UART1_RTS__XGPIOB_16 3
+#define UART1_RTS__RMII1_TXD0 4
+#define UART1_RTS__IIS1_DI 5
+#define UART1_RTS__UART4_TX 7
+#define UART2_RTS__UART2_RTS 0
+#define UART2_RTS__PWM_8 1
+#define UART2_RTS__KEY_ROW0 2
+#define UART2_RTS__XGPIOB_18 3
+#define UART2_RTS__RMII1_TXD1 4
+#define UART2_RTS__IIS1_MCLK 5
+#define UART2_RTS__WG1_D0 7
+#define UART2_RX__UART2_RX 0
+#define UART2_RX__PWM_10 1
+#define UART2_RX__KEY_COL3 2
+#define UART2_RX__XGPIOB_17 3
+#define UART2_RX__RMII1_RXDV 4
+#define UART2_RX__WG2_D1 7
+#define UART1_TX__UART1_TX 0
+#define UART1_TX__PWM_4 1
+#define UART1_TX__KEY_COL2 2
+#define UART1_TX__XGPIOB_21 3
+#define UART1_TX__RMII1_TXCLK 4
+#define UART1_TX__IIS1_BCLK 5
+#define UART1_TX__EPHY_LNK_LED 7
+#define UART1_CTS__UART1_CTS 0
+#define UART1_CTS__PWM_6 1
+#define UART1_CTS__KEY_COL0 2
+#define UART1_CTS__XGPIOB_20 3
+#define UART1_CTS__IIS1_DO 5
+#define UART1_CTS__RMII1_IRQ 6
+#define UART1_CTS__UART4_RX 7
+#define BOOT_MS__BOOT_MS 0
+#define BOOT_MS__XGPIOB_22 3
+#define UART2_CTS__UART2_CTS 0
+#define UART2_CTS__PWM_9 1
+#define UART2_CTS__KEY_ROW1 2
+#define UART2_CTS__XGPIOB_19 3
+#define UART2_CTS__RMII1_TXEN 4
+#define UART2_CTS__WG1_D1 7
+#define ADC1__XGPIOB_24 3
+#define UART1_RX__UART1_RX 0
+#define UART1_RX__PWM_5 1
+#define UART1_RX__KEY_ROW2 2
+#define UART1_RX__XGPIOB_23 3
+#define UART1_RX__IIS1_LRCK 5
+#define UART1_RX__EPHY_SPD_LED 7
+#define USB_ID__USB_ID 0
+#define USB_ID__XGPIOB_26 3
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_25 3
+#define USB_VBUS_EN__USB_VBUS_EN 0
+#define USB_VBUS_EN__XGPIOB_27 3
+#define CLK32K__CLK32K 0
+#define CLK32K__AUX0 1
+#define CLK32K__DBG_1 2
+#define CLK32K__XGPIOB_29 3
+#define CLK25M__CLK25M 0
+#define CLK25M__AUX1 1
+#define CLK25M__DBG_0 2
+#define CLK25M__XGPIOB_28 3
+#define XTAL_XIN_XI__XTAL_CLKIN 0
+#define VO_DATA1__VO_DATA_1 1
+#define VO_DATA1__XGPIOC_8 3
+#define VO_DATA1__VO_BUS_1 6
+#define VO_DATA0__VO_DATA_0 1
+#define VO_DATA0__XGPIOC_9 3
+#define VO_DATA0__VO_BUS_0 6
+#define PAD_MIPI_TXM4__MIPI_TXM4 0
+#define PAD_MIPI_TXM4__VO_DATA_10 1
+#define PAD_MIPI_TXM4__DBG_13 2
+#define PAD_MIPI_TXM4__XGPIOB_30 3
+#define PAD_MIPI_TXM4__SPI3_SCK 4
+#define PAD_MIPI_TXM4__PWM_12 5
+#define PAD_MIPI_TXM4__VO_BUS_10 6
+#define PAD_MIPI_TXP4__MIPI_TXP4 0
+#define PAD_MIPI_TXP4__VO_DATA_9 1
+#define PAD_MIPI_TXP4__DBG_14 2
+#define PAD_MIPI_TXP4__XGPIOB_31 3
+#define PAD_MIPI_TXP4__SPI3_CS_X 4
+#define PAD_MIPI_TXP4__PWM_13 5
+#define PAD_MIPI_TXP4__VO_BUS_9 6
+#define PAD_MIPI_TXM3__MIPI_TXM3 0
+#define PAD_MIPI_TXM3__VO_DATA_8 1
+#define PAD_MIPI_TXM3__DBG_15 2
+#define PAD_MIPI_TXM3__XGPIOC_0 3
+#define PAD_MIPI_TXM3__SPI3_SDO 4
+#define PAD_MIPI_TXM3__PWM_6 5
+#define PAD_MIPI_TXM3__VO_BUS_8 6
+#define PAD_MIPI_TXP3__MIPI_TXP3 0
+#define PAD_MIPI_TXP3__VO_DATA_7 1
+#define PAD_MIPI_TXP3__DBG_16 2
+#define PAD_MIPI_TXP3__XGPIOC_1 3
+#define PAD_MIPI_TXP3__SPI3_SDI 4
+#define PAD_MIPI_TXP3__PWM_7 5
+#define PAD_MIPI_TXP3__VO_BUS_7 6
+#define PAD_MIPI_TXM2__MIPI_TXM2 0
+#define PAD_MIPI_TXM2__VO_DATA_6 1
+#define PAD_MIPI_TXM2__DBG_17 2
+#define PAD_MIPI_TXM2__XGPIOC_2 3
+#define PAD_MIPI_TXM2__KEY_ROW0 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__VO_BUS_6 6
+#define PAD_MIPI_TXP2__MIPI_TXP2 0
+#define PAD_MIPI_TXP2__VO_DATA_5 1
+#define PAD_MIPI_TXP2__DBG_18 2
+#define PAD_MIPI_TXP2__XGPIOC_3 3
+#define PAD_MIPI_TXP2__KEY_ROW1 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__VO_BUS_5 6
+#define PAD_MIPI_TXM1__MIPI_TXM1 0
+#define PAD_MIPI_TXM1__VO_DATA_4 1
+#define PAD_MIPI_TXM1__DBG_19 2
+#define PAD_MIPI_TXM1__XGPIOC_4 3
+#define PAD_MIPI_TXM1__KEY_ROW2 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__VO_BUS_4 6
+#define PAD_MIPI_TXP1__MIPI_TXP1 0
+#define PAD_MIPI_TXP1__VO_DATA_3 1
+#define PAD_MIPI_TXP1__DBG_20 2
+#define PAD_MIPI_TXP1__XGPIOC_5 3
+#define PAD_MIPI_TXP1__KEY_ROW3 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__VO_BUS_3 6
+#define PAD_MIPI_TXM0__MIPI_TXM0 0
+#define PAD_MIPI_TXM0__VO_DATA_2 1
+#define PAD_MIPI_TXM0__DBG_21 2
+#define PAD_MIPI_TXM0__XGPIOC_6 3
+#define PAD_MIPI_TXM0__KEY_COL0 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__VO_BUS_2 6
+#define PAD_MIPI_TXP0__MIPI_TXP0 0
+#define PAD_MIPI_TXP0__VO_CLK 1
+#define PAD_MIPI_TXP0__DBG_22 2
+#define PAD_MIPI_TXP0__XGPIOC_7 3
+#define PAD_MIPI_TXP0__KEY_COL1 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__VO_BUS_11 6
+#define MIPIRX1_PAD0P__VI_DATA_0 1
+#define MIPIRX1_PAD0P__DBG_0 2
+#define MIPIRX1_PAD0P__XGPIOC_10 3
+#define MIPIRX1_PAD0P__VO_DATA_11 4
+#define MIPIRX1_PAD0P__VI1_DATA_8 5
+#define MIPIRX1_PAD0P__VO_BUS_12 6
+#define MIPIRX1_PAD0N__VI_DATA_1 1
+#define MIPIRX1_PAD0N__DBG_31 2
+#define MIPIRX1_PAD0N__XGPIOC_11 3
+#define MIPIRX1_PAD0N__VO_DATA_12 4
+#define MIPIRX1_PAD0N__VI1_DATA_7 5
+#define MIPIRX1_PAD0N__VO_BUS_13 6
+#define MIPIRX1_PAD1P__VI_DATA_2 1
+#define MIPIRX1_PAD1P__DBG_30 2
+#define MIPIRX1_PAD1P__XGPIOC_12 3
+#define MIPIRX1_PAD1P__VO_DATA_13 4
+#define MIPIRX1_PAD1P__VI1_DATA_6 5
+#define MIPIRX1_PAD1P__VO_BUS_14 6
+#define MIPIRX1_PAD1N__VI_DATA_3 1
+#define MIPIRX1_PAD1N__DBG_29 2
+#define MIPIRX1_PAD1N__XGPIOC_13 3
+#define MIPIRX1_PAD1N__VO_DATA_14 4
+#define MIPIRX1_PAD1N__VI1_DATA_5 5
+#define MIPIRX1_PAD1N__VO_BUS_15 6
+#define MIPIRX1_PAD2P__VI_DATA_4 1
+#define MIPIRX1_PAD2P__DBG_28 2
+#define MIPIRX1_PAD2P__XGPIOC_14 3
+#define MIPIRX1_PAD2P__VO_DATA_15 4
+#define MIPIRX1_PAD2P__VI1_DATA_4 5
+#define MIPIRX1_PAD2P__VO_BUS_16 6
+#define MIPIRX1_PAD2N__VI_DATA_5 1
+#define MIPIRX1_PAD2N__DBG_27 2
+#define MIPIRX1_PAD2N__XGPIOC_15 3
+#define MIPIRX1_PAD2N__VO_DATA_16 4
+#define MIPIRX1_PAD2N__VI1_DATA_3 5
+#define MIPIRX1_PAD2N__VO_BUS_17 6
+#define MIPIRX1_PAD3P__VI_DATA_6 1
+#define MIPIRX1_PAD3P__DBG_26 2
+#define MIPIRX1_PAD3P__XGPIOC_16 3
+#define MIPIRX1_PAD3P__VO_DATA_17 4
+#define MIPIRX1_PAD3P__VI1_DATA_2 5
+#define MIPIRX1_PAD3P__VO_BUS_18 6
+#define MIPIRX1_PAD3N__VI_DATA_7 1
+#define MIPIRX1_PAD3N__DBG_25 2
+#define MIPIRX1_PAD3N__XGPIOC_17 3
+#define MIPIRX1_PAD3N__VI1_DATA_1 5
+#define MIPIRX1_PAD4P__VI_DATA_8 1
+#define MIPIRX1_PAD4P__DBG_24 2
+#define MIPIRX1_PAD4P__XGPIOC_18 3
+#define MIPIRX1_PAD4P__VI1_DATA_0 5
+#define MIPIRX1_PAD4N__VI_DATA_9 1
+#define MIPIRX1_PAD4N__DBG_23 2
+#define MIPIRX1_PAD4N__XGPIOC_19 3
+#define MIPIRX1_PAD4N__VI1_CLK 5
+#define MIPIRX0_PAD4N__VI_DATA_10 1
+#define MIPIRX0_PAD4N__DBG_1 2
+#define MIPIRX0_PAD4N__XGPIOC_20 3
+#define MIPIRX0_PAD4N__VI1_DATA_9 5
+#define MIPIRX0_PAD4P__VI_DATA_11 1
+#define MIPIRX0_PAD4P__DBG_2 2
+#define MIPIRX0_PAD4P__XGPIOC_21 3
+#define MIPIRX0_PAD3N__VI_DATA_12 1
+#define MIPIRX0_PAD3N__DBG_4 2
+#define MIPIRX0_PAD3N__XGPIOC_23 3
+#define MIPIRX0_PAD3P__VI_CLK 1
+#define MIPIRX0_PAD3P__DBG_3 2
+#define MIPIRX0_PAD3P__XGPIOC_22 3
+#define MIPIRX0_PAD2N__VI_DATA_13 1
+#define MIPIRX0_PAD2N__DBG_5 2
+#define MIPIRX0_PAD2N__XGPIOC_24 3
+#define MIPIRX0_PAD2N__IIC4_SCL 4
+#define MIPIRX0_PAD2P__VI_DATA_14 1
+#define MIPIRX0_PAD2P__DBG_6 2
+#define MIPIRX0_PAD2P__XGPIOC_25 3
+#define MIPIRX0_PAD2P__IIC4_SDA 4
+#define MIPIRX0_PAD1N__VI_DATA_15 1
+#define MIPIRX0_PAD1N__DBG_7 2
+#define MIPIRX0_PAD1N__XGPIOC_26 3
+#define MIPIRX0_PAD1N__KEY_ROW3 4
+#define MIPIRX0_PAD1P__VI_DATA_16 1
+#define MIPIRX0_PAD1P__DBG_8 2
+#define MIPIRX0_PAD1P__XGPIOC_27 3
+#define MIPIRX0_PAD1P__KEY_ROW2 4
+#define MIPIRX0_PAD0N__VI_DATA_17 1
+#define MIPIRX0_PAD0N__DBG_9 2
+#define MIPIRX0_PAD0N__XGPIOC_28 3
+#define MIPIRX0_PAD0P__VI_DATA_18 1
+#define MIPIRX0_PAD0P__DBG_10 2
+#define MIPIRX0_PAD0P__XGPIOC_29 3
+#define VI_DATA22__VI_DATA_22 1
+#define VI_DATA22__DBG_14 2
+#define VI_DATA22__XGPIOC_30 3
+#define VI_DATA22__KEY_COL1 4
+#define VI_DATA22__UART3_TX 5
+#define VI_DATA22__H265_UART_TX 6
+#define VI_DATA22__H264_UART_TX 7
+#define VI_DATA20__VI_DATA_20 1
+#define VI_DATA20__DBG_12 2
+#define VI_DATA20__XGPIOC_31 3
+#define VI_DATA20__KEY_ROW0 4
+#define VI_DATA21__VI_DATA_21 1
+#define VI_DATA21__DBG_13 2
+#define VI_DATA21__XGPIOD_0 3
+#define VI_DATA21__KEY_COL0 4
+#define VI_DATA21__UART3_RX 5
+#define VI_DATA21__H265_UART_RX 6
+#define VI_DATA21__H264_UART_RX 7
+#define CAM_PD0__CAM_MCLK1 0
+#define CAM_PD0__AUX2 2
+#define CAM_PD0__XGPIOD_1 3
+#define VI_DATA19__VI_DATA_19 1
+#define VI_DATA19__DBG_11 2
+#define VI_DATA19__XGPIOD_2 3
+#define VI_DATA19__KEY_ROW1 4
+#define IIC0_SDA__IIC0_SDA 0
+#define IIC0_SDA__SPI2_SDO 1
+#define IIC0_SDA__XGPIOD_3 3
+#define CAM_MCLK0__CAM_MCLK0 0
+#define CAM_MCLK0__AUX3 2
+#define CAM_MCLK0__XGPIOD_4 3
+#define IIC3_SCL__IIC3_SCL 0
+#define IIC3_SCL__SPI2_SCK 1
+#define IIC3_SCL__DBG_17 2
+#define IIC3_SCL__XGPIOD_5 3
+#define IIC3_SCL__IIC4_SCL 4
+#define VI_DATA24__VI_DATA_24 1
+#define VI_DATA24__DBG_16 2
+#define VI_DATA24__XGPIOD_6 3
+#define VI_DATA24__KEY_COL3 4
+#define VI_DATA24__UART3_CTS 5
+#define CAM_RST0__XGPIOD_7 3
+#define VI_DATA23__VI_DATA_23 1
+#define VI_DATA23__DBG_15 2
+#define VI_DATA23__XGPIOD_8 3
+#define VI_DATA23__KEY_COL2 4
+#define VI_DATA23__UART3_RTS 5
+#define IIC3_SDA__IIC3_SDA 0
+#define IIC3_SDA__SPI2_CS_X 1
+#define IIC3_SDA__DBG_18 2
+#define IIC3_SDA__XGPIOD_9 3
+#define IIC3_SDA__IIC4_SDA 4
+#define IIC0_SCL__IIC0_SCL 0
+#define IIC0_SCL__SPI2_SDI 1
+#define IIC0_SCL__XGPIOD_10 3
+
+#endif /* __CV1835_PINLIST_SWCONFIG_H__ */
diff --git a/board/cvitek/cv1835/cv1835_reg.h b/board/cvitek/cv1835/cv1835_reg.h
new file mode 100644
index 000000000..9baf0b0bb
--- /dev/null
+++ b/board/cvitek/cv1835/cv1835_reg.h
@@ -0,0 +1,117 @@
+#ifndef __CV1835_REG_H
+#define __CV1835_REG_H
+
+#define TOP_BASE        0x03000000
+#define PINMUX_BASE     (TOP_BASE + 0x1000)
+#define WATCHDOG_BASE	(TOP_BASE + 0x00010000)
+
+/*
+ * Pinmux definitions
+ */
+#define PINMUX_UART0    0
+#define PINMUX_UART1    1
+#define PINMUX_UART2    2
+#define PINMUX_UART3    3
+#define PINMUX_UART3_2  4
+#define PINMUX_I2C0     5
+#define PINMUX_I2C1     6
+#define PINMUX_I2C2     7
+#define PINMUX_I2C3     8
+#define PINMUX_I2C4     9
+#define PINMUX_I2C4_2   10
+#define PINMUX_SPI0     11
+#define PINMUX_SPI1     12
+#define PINMUX_SPI2     13
+#define PINMUX_SPI2_2   14
+#define PINMUX_SPI3     15
+#define PINMUX_SPI3_2   16
+#define PINMUX_I2S0     17
+#define PINMUX_I2S1     18
+#define PINMUX_I2S2     19
+#define PINMUX_I2S3     20
+#define PINMUX_USBID    21
+#define PINMUX_SDIO0    22
+#define PINMUX_SDIO1    23
+#define PINMUX_ND       24
+#define PINMUX_EMMC     25
+#define PINMUX_SPI_NOR  26
+#define PINMUX_SPI_NAND 27
+#define PINMUX_CAM0     28
+#define PINMUX_CAM1     29
+#define PINMUX_PCM0     30
+#define PINMUX_PCM1     31
+#define PINMUX_CSI0     32
+#define PINMUX_CSI1     33
+#define PINMUX_CSI2     34
+#define PINMUX_DSI      35
+#define PINMUX_VI0      36
+#define PINMUX_VO       37
+#define PINMUX_RMII1    38
+#define PINMUX_EPHY_LED 39
+#define PINMUX_I80      40
+#define PINMUX_LVDS     41
+
+/* rst */
+#define REG_TOP_SOFT_RST        0x3000
+#define BIT_TOP_SOFT_RST_USB    BIT(11)
+#define BIT_TOP_SOFT_RST_SDIO   BIT(14)
+#define BIT_TOP_SOFT_RST_NAND   BIT(12)
+
+#define REG_TOP_USB_CTRSTS	(TOP_BASE + 0x38)
+
+#define REG_TOP_CONF_INFO		(TOP_BASE + 0x4)
+#define BIT_TOP_CONF_INFO_VBUS		BIT(9)
+#define REG_TOP_USB_PHY_CTRL		(TOP_BASE + 0x48)
+#define BIT_TOP_USB_PHY_CTRL_EXTVBUS	BIT(0)
+#define REG_TOP_DDR_ADDR_MODE		(TOP_BASE + 0x64)
+
+/* irq */
+#define IRQ_LEVEL   0
+#define IRQ_EDGE    3
+
+/* usb */
+#define USB_BASE            0x040C0000
+#define USB_HOST_BASE       0x040D0000
+#define USB_DEV_BASE        0x040E0000
+
+/* ethernet phy */
+#define ETH_PHY_BASE        0x03009000
+#define ETH_PHY_INIT_MASK   0xFFFFFFF9
+#define ETH_PHY_SHUTDOWN    BIT(1)
+#define ETH_PHY_POWERUP     0xFFFFFFFD
+#define ETH_PHY_RESET       0xFFFFFFFB
+#define ETH_PHY_RESET_N     BIT(2)
+#define ETH_PHY_LED_LOW_ACTIVE  BIT(3)
+
+/* watchdog */
+#define WDT_BASE	0x03010000
+#define DW_WDT_CR	0x00
+#define DW_WDT_TORR	0x04
+#define DW_WDT_CRR	0x0C
+
+#define DW_WDT_CR_EN_OFFSET	0x00
+#define DW_WDT_CR_RMOD_OFFSET	0x01
+#define DW_WDT_CR_RMOD_VAL	0x00
+#define DW_WDT_CRR_RESTART_VAL	0x76
+
+/* rtc */
+#define RTC_BASE	0x03005000
+#define RTC_DB_REQ_WARM_RST	0x60
+#define RTC_EN_WARM_RST_REQ	0xcc
+
+#define RTCFC_BASE	0x03004000
+#define RTC_CTRL0_UNLOCKKEY	0x4
+#define RTC_CTRL0 0x8
+
+/* rst */
+#define CV183X_SOFT_RST_REG0 0x03003000
+#define CV183X_SOFT_RST_REG1 0x03003004
+
+/* gp_reg */
+#define GP_REG2 0x03000088
+#define GP_REG3 0x0300008C
+#define GP_REG4 0x03000090
+#define GP_REG5 0x03000094
+#define GP_REG8 0x030000A0
+
+#endif /* __CV1835_REG_H */
diff --git a/board/cvitek/cv1835/cv1835_reg_fmux_gpio.h b/board/cvitek/cv1835/cv1835_reg_fmux_gpio.h
new file mode 100644
index 000000000..7a610b124
--- /dev/null
+++ b/board/cvitek/cv1835/cv1835_reg_fmux_gpio.h
@@ -0,0 +1,463 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cv1835_reg_fmux_gpio.h
+ * Description:
+ */
+
+// $Module: fmux_gpio $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: ghost $
+// $Date: Wed, 27 Nov 2019 08:24:45 PM $
+//
+
+#ifndef __CV1835_REG_FMUX_GPIO_H__
+#define __CV1835_REG_FMUX_GPIO_H__
+
+//GEN REG ADDR/OFFSET/MASK
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TCK  0x0
+#define  fmux_gpio_REG_IOCTRL_SDIO0_CD  0x4
+#define  fmux_gpio_REG_IOCTRL_RSTN  0x8
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TRST  0xc
+#define  fmux_gpio_REG_IOCTRL_UART0_RX  0x10
+#define  fmux_gpio_REG_IOCTRL_SDIO0_PWR_EN  0x14
+#define  fmux_gpio_REG_IOCTRL_UART0_TX  0x18
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TMS  0x1c
+#define  fmux_gpio_REG_IOCTRL_EMMC_CLK  0x20
+#define  fmux_gpio_REG_IOCTRL_EMMC_RSTN  0x24
+#define  fmux_gpio_REG_IOCTRL_EMMC_CMD  0x28
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT1  0x2c
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT0  0x30
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT2  0x34
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT3  0x38
+#define  fmux_gpio_REG_IOCTRL_SDIO0_CMD  0x3c
+#define  fmux_gpio_REG_IOCTRL_SDIO0_CLK  0x40
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D0  0x44
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D1  0x48
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D2  0x4c
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D3  0x50
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_20  0x54
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_21  0x58
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_22  0x5c
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_23  0x60
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_24  0x64
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_25  0x68
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_26  0x6c
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_27  0x70
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_28  0x74
+#define  fmux_gpio_REG_IOCTRL_XGPIO_A_29  0x78
+#define  fmux_gpio_REG_IOCTRL_RTC_MODE  0x7c
+#define  fmux_gpio_REG_IOCTRL_PWR_WAKEUP0  0x80
+#define  fmux_gpio_REG_IOCTRL_PWR_BUTTON1  0x84
+#define  fmux_gpio_REG_IOCTRL_PWR_WAKEUP1  0x88
+#define  fmux_gpio_REG_IOCTRL_PWR_BUTTON0  0x8c
+#define  fmux_gpio_REG_IOCTRL_PWR_VBAT_DET  0x90
+#define  fmux_gpio_REG_IOCTRL_PWR_ON  0x94
+#define  fmux_gpio_REG_IOCTRL_PWM2  0x98
+#define  fmux_gpio_REG_IOCTRL_PWM0_BUCK  0x9c
+#define  fmux_gpio_REG_IOCTRL_PWM3  0xa0
+#define  fmux_gpio_REG_IOCTRL_PWM1  0xa4
+#define  fmux_gpio_REG_IOCTRL_SPI0_SDI  0xa8
+#define  fmux_gpio_REG_IOCTRL_SPI0_SDO  0xac
+#define  fmux_gpio_REG_IOCTRL_SPI0_SCK  0xb0
+#define  fmux_gpio_REG_IOCTRL_SPI0_CS_X  0xb4
+#define  fmux_gpio_REG_IOCTRL_IIC2_SCL  0xb8
+#define  fmux_gpio_REG_IOCTRL_IIC1_SCL  0xbc
+#define  fmux_gpio_REG_IOCTRL_IIC1_SDA  0xc0
+#define  fmux_gpio_REG_IOCTRL_UART2_TX  0xc4
+#define  fmux_gpio_REG_IOCTRL_IIC2_SDA  0xc8
+#define  fmux_gpio_REG_IOCTRL_UART1_RTS  0xcc
+#define  fmux_gpio_REG_IOCTRL_UART2_RTS  0xd0
+#define  fmux_gpio_REG_IOCTRL_UART2_RX  0xd4
+#define  fmux_gpio_REG_IOCTRL_UART1_TX  0xd8
+#define  fmux_gpio_REG_IOCTRL_UART1_CTS  0xdc
+#define  fmux_gpio_REG_IOCTRL_BOOT_MS  0xe0
+#define  fmux_gpio_REG_IOCTRL_UART2_CTS  0xe4
+#define  fmux_gpio_REG_IOCTRL_ADC1  0xe8
+#define  fmux_gpio_REG_IOCTRL_UART1_RX  0xec
+#define  fmux_gpio_REG_IOCTRL_USB_ID  0xf0
+#define  fmux_gpio_REG_IOCTRL_USB_VBUS_DET  0xf4
+#define  fmux_gpio_REG_IOCTRL_USB_VBUS_EN  0xf8
+#define  fmux_gpio_REG_IOCTRL_CLK32K  0xfc
+#define  fmux_gpio_REG_IOCTRL_CLK25M  0x100
+#define  fmux_gpio_REG_IOCTRL_XTAL_XIN_XI  0x104
+#define  fmux_gpio_REG_IOCTRL_VO_DATA1  0x108
+#define  fmux_gpio_REG_IOCTRL_VO_DATA0  0x10c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM4  0x110
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP4  0x114
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM3  0x118
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP3  0x11c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM2  0x120
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP2  0x124
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM1  0x128
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP1  0x12c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM0  0x130
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP0  0x134
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD0P  0x138
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD0N  0x13c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD1P  0x140
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD1N  0x144
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD2P  0x148
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD2N  0x14c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD3P  0x150
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD3N  0x154
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD4P  0x158
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD4N  0x15c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD4N  0x160
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD4P  0x164
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD3N  0x168
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD3P  0x16c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD2N  0x170
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD2P  0x174
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD1N  0x178
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD1P  0x17c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD0N  0x180
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD0P  0x184
+#define  fmux_gpio_REG_IOCTRL_VI_DATA22  0x188
+#define  fmux_gpio_REG_IOCTRL_VI_DATA20  0x18c
+#define  fmux_gpio_REG_IOCTRL_VI_DATA21  0x190
+#define  fmux_gpio_REG_IOCTRL_CAM_PD0  0x194
+#define  fmux_gpio_REG_IOCTRL_VI_DATA19  0x198
+#define  fmux_gpio_REG_IOCTRL_IIC0_SDA  0x19c
+#define  fmux_gpio_REG_IOCTRL_CAM_MCLK0  0x1a0
+#define  fmux_gpio_REG_IOCTRL_IIC3_SCL  0x1a4
+#define  fmux_gpio_REG_IOCTRL_VI_DATA24  0x1a8
+#define  fmux_gpio_REG_IOCTRL_CAM_RST0  0x1ac
+#define  fmux_gpio_REG_IOCTRL_VI_DATA23  0x1b0
+#define  fmux_gpio_REG_IOCTRL_IIC3_SDA  0x1b4
+#define  fmux_gpio_REG_IOCTRL_IIC0_SCL  0x1b8
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK   0x0
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_CD   0x4
+#define  fmux_gpio_funcsel_SDIO0_CD_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_CD_MASK   0x7
+#define  fmux_gpio_funcsel_RSTN   0x8
+#define  fmux_gpio_funcsel_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST   0xc
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST_MASK   0x7
+#define  fmux_gpio_funcsel_UART0_RX   0x10
+#define  fmux_gpio_funcsel_UART0_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART0_RX_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_PWR_EN   0x14
+#define  fmux_gpio_funcsel_SDIO0_PWR_EN_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_PWR_EN_MASK   0x7
+#define  fmux_gpio_funcsel_UART0_TX   0x18
+#define  fmux_gpio_funcsel_UART0_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART0_TX_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS   0x1c
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_CLK   0x20
+#define  fmux_gpio_funcsel_EMMC_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_RSTN   0x24
+#define  fmux_gpio_funcsel_EMMC_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_CMD   0x28
+#define  fmux_gpio_funcsel_EMMC_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT1   0x2c
+#define  fmux_gpio_funcsel_EMMC_DAT1_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT1_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT0   0x30
+#define  fmux_gpio_funcsel_EMMC_DAT0_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT0_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT2   0x34
+#define  fmux_gpio_funcsel_EMMC_DAT2_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT2_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT3   0x38
+#define  fmux_gpio_funcsel_EMMC_DAT3_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT3_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_CMD   0x3c
+#define  fmux_gpio_funcsel_SDIO0_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_CLK   0x40
+#define  fmux_gpio_funcsel_SDIO0_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D0   0x44
+#define  fmux_gpio_funcsel_SDIO0_D0_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D0_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D1   0x48
+#define  fmux_gpio_funcsel_SDIO0_D1_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D1_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D2   0x4c
+#define  fmux_gpio_funcsel_SDIO0_D2_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D2_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D3   0x50
+#define  fmux_gpio_funcsel_SDIO0_D3_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D3_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_20   0x54
+#define  fmux_gpio_funcsel_XGPIO_A_20_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_20_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_21   0x58
+#define  fmux_gpio_funcsel_XGPIO_A_21_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_21_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_22   0x5c
+#define  fmux_gpio_funcsel_XGPIO_A_22_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_22_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_23   0x60
+#define  fmux_gpio_funcsel_XGPIO_A_23_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_23_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_24   0x64
+#define  fmux_gpio_funcsel_XGPIO_A_24_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_24_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_25   0x68
+#define  fmux_gpio_funcsel_XGPIO_A_25_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_25_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_26   0x6c
+#define  fmux_gpio_funcsel_XGPIO_A_26_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_26_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_27   0x70
+#define  fmux_gpio_funcsel_XGPIO_A_27_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_27_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_28   0x74
+#define  fmux_gpio_funcsel_XGPIO_A_28_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_28_MASK   0x7
+#define  fmux_gpio_funcsel_XGPIO_A_29   0x78
+#define  fmux_gpio_funcsel_XGPIO_A_29_OFFSET 0
+#define  fmux_gpio_funcsel_XGPIO_A_29_MASK   0x7
+#define  fmux_gpio_funcsel_RTC_MODE   0x7c
+#define  fmux_gpio_funcsel_RTC_MODE_OFFSET 0
+#define  fmux_gpio_funcsel_RTC_MODE_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_WAKEUP0   0x80
+#define  fmux_gpio_funcsel_PWR_WAKEUP0_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_WAKEUP0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_BUTTON1   0x84
+#define  fmux_gpio_funcsel_PWR_BUTTON1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_BUTTON1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_WAKEUP1   0x88
+#define  fmux_gpio_funcsel_PWR_WAKEUP1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_WAKEUP1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_BUTTON0   0x8c
+#define  fmux_gpio_funcsel_PWR_BUTTON0_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_BUTTON0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_VBAT_DET   0x90
+#define  fmux_gpio_funcsel_PWR_VBAT_DET_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_VBAT_DET_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_ON   0x94
+#define  fmux_gpio_funcsel_PWR_ON_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_ON_MASK   0x7
+#define  fmux_gpio_funcsel_PWM2   0x98
+#define  fmux_gpio_funcsel_PWM2_OFFSET 0
+#define  fmux_gpio_funcsel_PWM2_MASK   0x7
+#define  fmux_gpio_funcsel_PWM0_BUCK   0x9c
+#define  fmux_gpio_funcsel_PWM0_BUCK_OFFSET 0
+#define  fmux_gpio_funcsel_PWM0_BUCK_MASK   0x7
+#define  fmux_gpio_funcsel_PWM3   0xa0
+#define  fmux_gpio_funcsel_PWM3_OFFSET 0
+#define  fmux_gpio_funcsel_PWM3_MASK   0x7
+#define  fmux_gpio_funcsel_PWM1   0xa4
+#define  fmux_gpio_funcsel_PWM1_OFFSET 0
+#define  fmux_gpio_funcsel_PWM1_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_SDI   0xa8
+#define  fmux_gpio_funcsel_SPI0_SDI_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_SDI_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_SDO   0xac
+#define  fmux_gpio_funcsel_SPI0_SDO_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_SDO_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_SCK   0xb0
+#define  fmux_gpio_funcsel_SPI0_SCK_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_SCK_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_CS_X   0xb4
+#define  fmux_gpio_funcsel_SPI0_CS_X_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_CS_X_MASK   0x7
+#define  fmux_gpio_funcsel_IIC2_SCL   0xb8
+#define  fmux_gpio_funcsel_IIC2_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC2_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC1_SCL   0xbc
+#define  fmux_gpio_funcsel_IIC1_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC1_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC1_SDA   0xc0
+#define  fmux_gpio_funcsel_IIC1_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC1_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_TX   0xc4
+#define  fmux_gpio_funcsel_UART2_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_TX_MASK   0x7
+#define  fmux_gpio_funcsel_IIC2_SDA   0xc8
+#define  fmux_gpio_funcsel_IIC2_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC2_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_RTS   0xcc
+#define  fmux_gpio_funcsel_UART1_RTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_RTS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_RTS   0xd0
+#define  fmux_gpio_funcsel_UART2_RTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_RTS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_RX   0xd4
+#define  fmux_gpio_funcsel_UART2_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_RX_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_TX   0xd8
+#define  fmux_gpio_funcsel_UART1_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_TX_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_CTS   0xdc
+#define  fmux_gpio_funcsel_UART1_CTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_CTS_MASK   0x7
+#define  fmux_gpio_funcsel_BOOT_MS   0xe0
+#define  fmux_gpio_funcsel_BOOT_MS_OFFSET 0
+#define  fmux_gpio_funcsel_BOOT_MS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_CTS   0xe4
+#define  fmux_gpio_funcsel_UART2_CTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_CTS_MASK   0x7
+#define  fmux_gpio_funcsel_ADC1   0xe8
+#define  fmux_gpio_funcsel_ADC1_OFFSET 0
+#define  fmux_gpio_funcsel_ADC1_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_RX   0xec
+#define  fmux_gpio_funcsel_UART1_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_RX_MASK   0x7
+#define  fmux_gpio_funcsel_USB_ID   0xf0
+#define  fmux_gpio_funcsel_USB_ID_OFFSET 0
+#define  fmux_gpio_funcsel_USB_ID_MASK   0x7
+#define  fmux_gpio_funcsel_USB_VBUS_DET   0xf4
+#define  fmux_gpio_funcsel_USB_VBUS_DET_OFFSET 0
+#define  fmux_gpio_funcsel_USB_VBUS_DET_MASK   0x7
+#define  fmux_gpio_funcsel_USB_VBUS_EN   0xf8
+#define  fmux_gpio_funcsel_USB_VBUS_EN_OFFSET 0
+#define  fmux_gpio_funcsel_USB_VBUS_EN_MASK   0x7
+#define  fmux_gpio_funcsel_CLK32K   0xfc
+#define  fmux_gpio_funcsel_CLK32K_OFFSET 0
+#define  fmux_gpio_funcsel_CLK32K_MASK   0x7
+#define  fmux_gpio_funcsel_CLK25M   0x100
+#define  fmux_gpio_funcsel_CLK25M_OFFSET 0
+#define  fmux_gpio_funcsel_CLK25M_MASK   0x7
+#define  fmux_gpio_funcsel_XTAL_XIN_XI   0x104
+#define  fmux_gpio_funcsel_XTAL_XIN_XI_OFFSET 0
+#define  fmux_gpio_funcsel_XTAL_XIN_XI_MASK   0x7
+#define  fmux_gpio_funcsel_VO_DATA1   0x108
+#define  fmux_gpio_funcsel_VO_DATA1_OFFSET 0
+#define  fmux_gpio_funcsel_VO_DATA1_MASK   0x7
+#define  fmux_gpio_funcsel_VO_DATA0   0x10c
+#define  fmux_gpio_funcsel_VO_DATA0_OFFSET 0
+#define  fmux_gpio_funcsel_VO_DATA0_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4   0x110
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4   0x114
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3   0x118
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3   0x11c
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2   0x120
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2   0x124
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1   0x128
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1   0x12c
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0   0x130
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0   0x134
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0P   0x138
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0N   0x13c
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1P   0x140
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1N   0x144
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2P   0x148
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2N   0x14c
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3P   0x150
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3N   0x154
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4P   0x158
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4N   0x15c
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4N   0x160
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4P   0x164
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3N   0x168
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3P   0x16c
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2N   0x170
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2P   0x174
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1N   0x178
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1P   0x17c
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0N   0x180
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0P   0x184
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0P_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA22   0x188
+#define  fmux_gpio_funcsel_VI_DATA22_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA22_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA20   0x18c
+#define  fmux_gpio_funcsel_VI_DATA20_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA20_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA21   0x190
+#define  fmux_gpio_funcsel_VI_DATA21_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA21_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_PD0   0x194
+#define  fmux_gpio_funcsel_CAM_PD0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_PD0_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA19   0x198
+#define  fmux_gpio_funcsel_VI_DATA19_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA19_MASK   0x7
+#define  fmux_gpio_funcsel_IIC0_SDA   0x19c
+#define  fmux_gpio_funcsel_IIC0_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC0_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_MCLK0   0x1a0
+#define  fmux_gpio_funcsel_CAM_MCLK0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_MCLK0_MASK   0x7
+#define  fmux_gpio_funcsel_IIC3_SCL   0x1a4
+#define  fmux_gpio_funcsel_IIC3_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC3_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA24   0x1a8
+#define  fmux_gpio_funcsel_VI_DATA24_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA24_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_RST0   0x1ac
+#define  fmux_gpio_funcsel_CAM_RST0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_RST0_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA23   0x1b0
+#define  fmux_gpio_funcsel_VI_DATA23_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA23_MASK   0x7
+#define  fmux_gpio_funcsel_IIC3_SDA   0x1b4
+#define  fmux_gpio_funcsel_IIC3_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC3_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_IIC0_SCL   0x1b8
+#define  fmux_gpio_funcsel_IIC0_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC0_SCL_MASK   0x7
+
+#endif /* __CV1835_REG_FMUX_GPIO_H__ */
diff --git a/board/cvitek/cv1835/sdhci_reg.h b/board/cvitek/cv1835/sdhci_reg.h
new file mode 100644
index 000000000..783a23c7b
--- /dev/null
+++ b/board/cvitek/cv1835/sdhci_reg.h
@@ -0,0 +1,122 @@
+#ifndef _SDHCI_REG_H
+#define _SDHCI_REG_H
+#include "cv1835_reg.h"
+#define REG_TOP_SD_PWRSW_CTRL (0x1F4)
+
+#define REG_SDIO0_PAD_MASK		(0xFFFFFFF3)
+#define REG_SDIO0_PAD_SHIFT		(2)
+
+#define REG_SDIO0_PAD_CLR_MASK (0xC)
+#define REG_SDIO0_CD_PAD_REG		(PINMUX_BASE + 0xC04)
+#define REG_SDIO0_CD_PAD_VALUE		(1)
+#define REG_SDIO0_CD_PAD_RESET		(1)
+
+#define REG_SDIO0_CLK_PAD_REG		(PINMUX_BASE + 0xB04)
+#define REG_SDIO0_CLK_PAD_VALUE		(2)
+#define REG_SDIO0_CLK_PAD_RESET		(2)
+
+#define REG_SDIO0_CMD_PAD_REG		(PINMUX_BASE + 0xB00)
+#define REG_SDIO0_CMD_PAD_VALUE		(1)
+#define REG_SDIO0_CMD_PAD_RESET		(2)
+
+#define REG_SDIO0_DAT0_PAD_REG		(PINMUX_BASE + 0xB08)
+#define REG_SDIO0_DAT0_PAD_VALUE	(1)
+#define REG_SDIO0_DAT0_PAD_RESET	(2)
+
+#define REG_SDIO0_DAT1_PAD_REG		(PINMUX_BASE + 0xB0C)
+#define REG_SDIO0_DAT1_PAD_VALUE	(1)
+#define REG_SDIO0_DAT1_PAD_RESET	(2)
+
+#define REG_SDIO0_DAT2_PAD_REG		(PINMUX_BASE + 0xB10)
+#define REG_SDIO0_DAT2_PAD_VALUE	(1)
+#define REG_SDIO0_DAT2_PAD_RESET	(2)
+
+#define REG_SDIO0_DAT3_PAD_REG		(PINMUX_BASE + 0xB14)
+#define REG_SDIO0_DAT3_PAD_VALUE	(1)
+#define REG_SDIO0_DAT3_PAD_RESET	(2)
+
+#define PAD_SDIO0_CD_REG (PINMUX_BASE + 0x04)
+#define PAD_SDIO0_PWR_EN_REG (PINMUX_BASE + 0x14)
+#define PAD_SDIO0_CLK_REG (PINMUX_BASE + 0x40)
+#define PAD_SDIO0_CMD_REG (PINMUX_BASE + 0x3C)
+#define PAD_SDIO0_D0_REG (PINMUX_BASE + 0x44)
+#define PAD_SDIO0_D1_REG (PINMUX_BASE + 0x48)
+#define PAD_SDIO0_D2_REG (PINMUX_BASE + 0x4C)
+#define PAD_SDIO0_D3_REG (PINMUX_BASE + 0x50)
+
+#define REG_SDIO1_PAD_MASK		(0xFFFFFFF3)
+#define REG_SDIO1_PAD_SHIFT		(2)
+
+#define REG_SDIO1_PAD_CLR_MASK (0xC)
+#define REG_SDIO1_CLK_PAD_REG		(PINMUX_BASE + 0xA14)
+#define REG_SDIO1_CLK_PAD_VALUE		(2)
+
+#define REG_SDIO1_CMD_PAD_REG		(PINMUX_BASE + 0xA10)
+#define REG_SDIO1_CMD_PAD_VALUE		(1)
+
+#define REG_SDIO1_DAT0_PAD_REG		(PINMUX_BASE + 0xA0C)
+#define REG_SDIO1_DAT0_PAD_VALUE	(1)
+
+#define REG_SDIO1_DAT2_PAD_REG		(PINMUX_BASE + 0xA1C)
+#define REG_SDIO1_DAT2_PAD_VALUE	(1)
+
+#define REG_SDIO1_DAT1_PAD_REG		(PINMUX_BASE + 0xA20)
+#define REG_SDIO1_DAT1_PAD_VALUE	(1)
+
+#define REG_SDIO1_DAT3_PAD_REG		(PINMUX_BASE + 0xA24)
+#define REG_SDIO1_DAT3_PAD_VALUE	(1)
+
+#define REG_EMMC_PAD_CLR_MASK (0xC)
+#define REG_EMMC_PAD_SHIFT (2)
+
+#define REG_EMMC_RSTN_PAD_REG		(PINMUX_BASE + 0xC24)
+#define REG_EMMC_RSTN_PAD_VALUE		(1)
+
+#define REG_EMMC_CLK_PAD_REG		(PINMUX_BASE + 0xC20)
+#define REG_EMMC_CLK_PAD_VALUE		(2)
+
+#define REG_EMMC_CMD_PAD_REG		(PINMUX_BASE + 0xC28)
+#define REG_EMMC_CMD_PAD_VALUE		(1)
+
+#define REG_EMMC_DAT0_PAD_REG		(PINMUX_BASE + 0xC30)
+#define REG_EMMC_DAT0_PAD_VALUE		(1)
+
+#define REG_EMMC_DAT1_PAD_REG		(PINMUX_BASE + 0xC2C)
+#define REG_EMMC_DAT1_PAD_VALUE		(1)
+
+#define REG_EMMC_DAT2_PAD_REG		(PINMUX_BASE + 0xC34)
+#define REG_EMMC_DAT2_PAD_VALUE		(1)
+
+#define REG_EMMC_DAT3_PAD_REG		(PINMUX_BASE + 0xC38)
+#define REG_EMMC_DAT3_PAD_VALUE		(1)
+
+#define SDHCI_RX_DELAY_LINE		(SDHCI_PHY_R_OFFSET + 0x0C)
+#define REG_RX_SRC_SEL_MASK		(0xFFCFFFFF) // 0x30c reg_rx_src_sel [21:20]
+#define REG_RX_SRC_SEL_CLK_TX_INV		(0) // clk_tx_inv
+#define REG_RX_SRC_SEL_PAD_CLK			(1) // pad_clk
+#define REG_RX_SRC_SEL_RES			(2) // resvd
+#define REG_RX_SRC_SEL_CLK_TX			(3) // clk_tx
+#define REG_RX_SRC_SEL_SHIFT		(20) // 0x30c reg_rx_src_sel [21:20]
+
+#define SDHCI_TX_DELAY_LINE		(SDHCI_PHY_R_OFFSET + 0x1C)
+#define REG_TX_SRC_SEL_MASK		(0xFFFFF3FF) // 0x31c reg_tx_src_sel [11:10]
+#define REG_TX_SRC_SEL_CLK_TX_INV		(0) // clk_tx_inv
+#define REG_TX_SRC_SEL_PAD_CLK			(1) // pad_clk
+#define REG_TX_SRC_SEL_RES			(2) // resvd
+#define REG_TX_SRC_SEL_CLK_TX			(3) // clk_tx
+#define REG_TX_SRC_SEL_SHIFT		(10) // 0x31c reg_tx_src_sel [11:10]
+
+#define MMC_MAX_CLOCK		(375000000)
+#define MMC_MAX_CLOCK_DIV_VALUE	(0x40009)
+#define CLOCK_BYPASS_SELECT_REGISTER	(0x3002030)
+
+#define CVI_SDHCI_VENDOR_OFFSET		0x500
+#define CVI_SDHCI_VENDOR_MSHC_CTRL_R	(CVI_SDHCI_VENDOR_OFFSET + 0x8)
+#define CVI_SDHCI_VENDOR_EMMC_CTRL_R	(CVI_SDHCI_VENDOR_OFFSET + 0x2C)
+#define CVI_SDHCI_VENDOR_A_CTRL_R	(CVI_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_SDHCI_VENDOR_A_STAT_R	(CVI_SDHCI_VENDOR_OFFSET + 0x44)
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#endif
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 3a857b3f6..8e5aa96bb 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -2389,6 +2389,13 @@ config CMD_UBIFS
 	help
 	  UBIFS is a file system for flash devices which works on top of UBI.
 
+config CMD_CVI_UPDATE
+	bool "cvitek update command"
+	default y
+	help
+	uboot will check flag in SRAM and thendecide if it's sd,usb,usb drive or Ethernet upgrade.
+	User can run cvi_update [usb/sd/eth] for force update without check flag.
+
 config MMC_SPEED_MODE_SET
 	bool "set speed mode using mmc command"
 	depends on CMD_MMC
diff --git a/cmd/Makefile b/cmd/Makefile
index ed3669411..b75587b55 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -68,6 +68,9 @@ obj-$(CONFIG_CMD_FAT) += fat.o
 obj-$(CONFIG_CMD_FDT) += fdt.o
 obj-$(CONFIG_CMD_SQUASHFS) += sqfs.o
 obj-$(CONFIG_CMD_FLASH) += flash.o
+obj-$(CONFIG_CMD_CVI_UPDATE) += cvi_update.o
+obj-$(CONFIG_CMD_CVI_UPDATE) += cvi_utask.o
+obj-$(CONFIG_NAND_SUPPORT) += cvi_sd_update.o cvi_sd_update_spinand_v3.o
 obj-$(CONFIG_CMD_FPGA) += fpga.o
 obj-$(CONFIG_CMD_FPGAD) += fpgad.o
 obj-$(CONFIG_CMD_FS_GENERIC) += fs.o
@@ -200,6 +203,8 @@ obj-$(CONFIG_CMD_AVB) += avb.o
 # Foundries.IO SCP03
 obj-$(CONFIG_CMD_SCP03) += scp03.o
 
+obj-y += efuse.o
+
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_RISCV) += riscv/
 obj-$(CONFIG_SANDBOX) += sandbox/
diff --git a/cmd/cvi_sd_update.c b/cmd/cvi_sd_update.c
new file mode 100644
index 000000000..251bcf494
--- /dev/null
+++ b/cmd/cvi_sd_update.c
@@ -0,0 +1,68 @@
+#include <stdlib.h>
+#include <common.h>
+#include <config.h>
+#include <command.h>
+#include <cvsnfc.h>
+
+#define		BIT_WRITE_FIP_BIN	BIT(0)
+#define		BIT_WRITE_ROM_PATCH	BIT(1)
+#define		BIT_WRITE_BLD		BIT(2)
+
+#define		COMPARE_STRING_LEN	6
+
+//------------------------------------------------------------------------------
+//  data type definitions: typedef, struct or class
+//------------------------------------------------------------------------------
+#define PTR_INC(base, offset) (void *)((uint8_t *)(base) + (offset))
+
+static int do_cvi_sd_update(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *addr;
+	uint32_t component = 0;
+
+	if (argc != 4) {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	addr = (char *)simple_strtol(argv[1], NULL, 16);
+
+	if (!addr) {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	printf("addr %p\n", addr);
+
+	if (!strncmp(argv[3], "fip", COMPARE_STRING_LEN)) {
+		printf("fip.bin\n");
+		component |= BIT_WRITE_FIP_BIN;
+
+	} else if (!strncmp(argv[3], "patch", COMPARE_STRING_LEN)) {
+		printf("patch\n");
+		component |= BIT_WRITE_ROM_PATCH;
+	} else if (!strncmp(argv[3], "all", COMPARE_STRING_LEN)) {
+		printf("all\n");
+		component |= BIT_WRITE_FIP_BIN | BIT_WRITE_ROM_PATCH | BIT_WRITE_BLD;
+	} else {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	if (!strncmp(argv[2], "spinand", COMPARE_STRING_LEN)) {
+		do_cvi_update_spinand(component, addr);
+	} else {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(cvi_sd_update, 4, 0, do_cvi_sd_update,
+	   "cvi_sd_update - write images to SPI NAND\n",
+	   "cvi_sd_update addr dev_type img_type  - Print a report\n"
+	   "addr     : data memory address\n"
+	   "dev_type : spinand\n"
+	   "img_type : fip/patch/all\n"
+);
diff --git a/cmd/cvi_sd_update_spinand_v3.c b/cmd/cvi_sd_update_spinand_v3.c
new file mode 100644
index 000000000..a9ce01f70
--- /dev/null
+++ b/cmd/cvi_sd_update_spinand_v3.c
@@ -0,0 +1,981 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+#include <stdlib.h>
+#include <common.h>
+#include <config.h>
+#include <command.h>
+#include <fs.h>
+#include <part.h>
+#include <vsprintf.h>
+#include <u-boot/md5.h>
+#include <image-sparse.h>
+#include <div64.h>
+#include <linux/math64.h>
+#include <linux/log2.h>
+#include <u-boot/crc.h>
+#include <time.h>
+#include <rand.h>
+#include <env.h>
+
+#define cvi_assert(expr) do {\
+		if (!(expr)) {\
+			printf("%s:%d[%s]\n", __FILE__, __LINE__, __func__);\
+			while \
+				(1);\
+		} \
+	} while (0)
+
+#include <cvsnfc.h>
+
+//#define CVI_SD_UPDATE_DEBUG
+
+#ifdef CVI_SD_UPDATE_DEBUG
+#define DEBUG_WRITE 1
+#define DEBUG_READ  1
+#define DEBUG_ERASE 1
+#define DEBUG_CMD_FLOW 1
+#define DEBUG_DUMP_FIP 1
+#else
+#define DEBUG_WRITE 0
+#define DEBUG_READ  0
+#define DEBUG_ERASE 0
+#define DEBUG_CMD_FLOW 0
+#define DEBUG_DUMP_FIP 1
+#endif
+
+#define FORCE_ROM_USE_2K_PAGE
+#define PLAT_BM_FIP_MAX_SIZE	0xA0000    // 640KB, Fixed, don't change unless you know it
+#define PLAT_BM_FIP_MAX_CHECK_SIZE	0xA0000    // 640KB, Fixed, don't change unless you know it
+
+//------------------------------------------------------------------------------
+//  data type definitions: typedef, struct or class
+//------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------
+//  constant definitions:
+//------------------------------------------------------------------------------
+#define FIP_IMAGE_HEAD	"FIPH" /* FIP Image Header 1 */
+#define FIP_IMAGE_BODY	"FIPB" /* FIP Image body */
+
+#define FIP_MAGIC_NUMBER "CVBL01\n\0"
+
+#define SPI_NAND_VERSION (0x1823a001)
+
+/* system vector related definitions */
+#define SPI_NAND_BASE_DATA_BACKUP_COPY (2)
+
+#define MAX_BLOCK_CNT			(20)
+/* system vector relocated definitions end here */
+
+#define SPI_NAND_FIP_RSVD_BLOCK_COUNT MAX_BLOCK_CNT // Reserved blocks for FIP.
+
+#define BACKUP_FIP_START_POSITION	9
+
+#define BIT(nr)			(1UL << (nr))
+
+#define PTR_INC(base, offset) (void *)((uint8_t *)(base) + (offset))
+#define GET_PG_IDX_IN_BLK(x, y) ((x) % (y))
+#define GET_BLK_IDX(x, y) ((x) / (y))
+
+#define FIP_STOP_RECOVERY	2
+#define FIP_CHECKNUM_ERROR	1
+#define FIP_HEADER_NO_ISSUE	0
+#define FIP_PAGE_ERROR	1
+#define FIP_PAGE_NO_ISSUE	0
+#define FIP_NO_AVAILABLE_BLOCK 1
+
+struct _spi_nand_info_t {
+	uint32_t version;
+	uint32_t id;
+	uint32_t page_size;
+
+	uint32_t spare_size;
+	uint32_t block_size;
+	uint32_t pages_per_block;
+
+	uint32_t fip_block_cnt;
+	uint8_t pages_per_block_shift;
+	uint8_t badblock_pos;
+	uint8_t dummy_data1[2];
+	uint32_t flags;
+	uint8_t ecc_en_feature_offset;
+	uint8_t ecc_en_mask;
+	uint8_t ecc_status_offset;
+	uint8_t ecc_status_mask;
+	uint8_t ecc_status_shift;
+	uint8_t ecc_status_uncorr_val;
+	uint8_t dummy_data2[2];
+	uint32_t erase_count; // erase count for sys base block
+	uint8_t sck_l;
+	uint8_t sck_h;
+	uint16_t max_freq;
+	uint32_t sample_param;
+	uint8_t xtal_switch;
+	uint8_t dummy_data3[71];
+};
+
+#define FIP_BK_TAG_SIZE	4
+/* the header should start with FIH1, FIB1+sequence number */
+struct block_header_t {
+	uint8_t tag[FIP_BK_TAG_SIZE];
+	uint32_t bk_cnt_or_seq; /* for first block, it is block count. Otherwise, it is sequence number */
+	uint32_t checknum; /* the check number to make sure all fip header and body are consistent */
+	uint32_t dummy;
+};
+
+struct _fip_param1_t {
+	uint64_t magic1;
+	uint32_t magic2;
+	uint32_t param_cksum;
+	struct _spi_nand_info_t nand_info;
+};
+
+struct _fip_info_t {
+	uint8_t bk_position[SPI_NAND_FIP_RSVD_BLOCK_COUNT / 2];
+	uint32_t checknum[SPI_NAND_FIP_RSVD_BLOCK_COUNT / 2];
+	uint8_t total_count;
+	uint16_t current_bk_mask;
+};
+
+struct _spi_nand_info_t *g_spi_nand_info;
+struct _fip_param1_t *g_fip_param;
+struct _spi_nand_info_t spinand_info;
+static char spi_nand_defect_bk_list[(MAX_BLOCK_CNT / 8) + 1];
+static char spi_nand_bk_usage_list[(MAX_BLOCK_CNT / 8) + 1];
+
+static uint8_t spi_nand_g_param_init = 0xff;
+uint8_t *pg_buf;
+uint32_t g_virgin_start;
+
+//int spi_nand_flush_vec(void);
+//void spi_nand_dump_vec(void);
+
+static inline u32 DESC_CONV(char *x)
+{
+	return ((((((x[0] << 8) | x[1]) << 8) | x[2]) << 8) | x[3]);
+}
+
+static inline u32 CHECK_MASK_BIT(void *_mask, u32 bit)
+{
+	u32 w = bit / 8;
+	u32 off = bit % 8;
+
+	return ((u8 *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, u32 bit)
+{
+	u32 byte = bit / 8;
+	u32 offset = bit % 8;
+	((u8 *)_mask)[byte] |= (1 << offset);
+}
+
+static void get_spi_nand_info(void)
+{
+	struct cvsnfc_host *host = cvsnfc_get_host();
+
+	spinand_info.version = SPI_NAND_VERSION;
+	spinand_info.id = host->nand_chip_info->id[0]
+					| host->nand_chip_info->id[1] << 8
+					| host->nand_chip_info->id[2] << 16;
+	spinand_info.page_size = host->nand_chip_info->pagesize;
+
+	spinand_info.spare_size = host->nand_chip_info->oobsize;
+	spinand_info.block_size = host->nand_chip_info->erasesize;
+
+	spinand_info.pages_per_block = (host->nand_chip_info->erasesize /
+				       host->nand_chip_info->pagesize);
+
+	spinand_info.badblock_pos = host->nand_chip_info->badblock_pos;
+
+	spinand_info.fip_block_cnt = SPI_NAND_FIP_RSVD_BLOCK_COUNT;
+
+	spinand_info.pages_per_block_shift = ilog2(spinand_info.pages_per_block);
+
+	spinand_info.flags = host->nand_chip_info->flags;
+
+	if (DEBUG_WRITE) {
+		printf("NAND_DEBUG: %s NAND id=0x%x, page size=%d, page per block=%d, block_size=%d, fip_block_cnt=%d\n",
+		       __func__,
+	       spinand_info.id,
+	       spinand_info.page_size,
+	       spinand_info.pages_per_block,
+	       spinand_info.block_size,
+	       spinand_info.fip_block_cnt);
+	}
+
+	// TODO: get ecc info form nand_chip_info
+	spinand_info.ecc_en_feature_offset = host->nand_chip_info->ecc_en_feature_offset;
+	spinand_info.ecc_en_mask = host->nand_chip_info->ecc_en_mask;
+	spinand_info.ecc_status_offset = host->nand_chip_info->ecc_status_offset;
+	spinand_info.ecc_status_mask = host->nand_chip_info->ecc_status_mask;
+	spinand_info.ecc_status_shift = host->nand_chip_info->ecc_status_shift;
+	spinand_info.ecc_status_uncorr_val = host->nand_chip_info->ecc_status_uncorr_val;
+	spinand_info.sck_l = host->nand_chip_info->sck_l;
+	spinand_info.sck_h = host->nand_chip_info->sck_h;
+	spinand_info.max_freq = host->nand_chip_info->max_freq;
+	spinand_info.sample_param = host->nand_chip_info->sample_param;
+	spinand_info.xtal_switch = host->nand_chip_info->xtal_switch;
+
+	if (DEBUG_WRITE) {
+		printf("NAND_DEBUG: %s, ecc_en_feature_offset = 0x%x, ecc_status_offset = 0x%x\n", __func__,
+		       spinand_info.ecc_en_feature_offset, spinand_info.ecc_status_offset);
+
+		printf("NAND_DEBUG: %s, sck_l = 0x%x, sck_h = 0x%x, max_freq = %d, sample_param=0x%x\n", __func__,
+		       spinand_info.sck_l, spinand_info.sck_h, spinand_info.max_freq, spinand_info.sample_param);
+
+		printf("NAND_DEBUG: %s, xtal_switch = %d\n", __func__, spinand_info.xtal_switch);
+	}
+}
+
+static void spi_nand_global_param_init(void)
+{
+	struct _spi_nand_info_t *info = &spinand_info;
+
+	if (spi_nand_g_param_init == 1) /* global parameters is initialized */
+		return;
+
+	g_fip_param = (struct _fip_param1_t *)malloc(sizeof(struct _fip_param1_t));
+	memset(g_fip_param, 0, sizeof(struct _fip_param1_t));
+
+	g_spi_nand_info = &g_fip_param->nand_info;
+
+	get_spi_nand_info();
+
+	pg_buf = (uint8_t *)malloc(info->page_size + info->spare_size);
+
+	spi_nand_g_param_init = 1;
+
+}
+
+/*
+ * Erase all block and scan defect block
+ */
+static int spi_nand_scan_defect(void)
+{
+	int status;
+	struct _spi_nand_info_t *info = &spinand_info;
+	struct cvsnfc_host *host = cvsnfc_get_host();
+
+	u32 ttl_pg_sz = info->page_size + info->spare_size;
+
+	printf("Scan and erase first %d blocks\n", info->fip_block_cnt);
+//	printf("%s info =%p, page_size %d, block size=%d, spare_size=%d\n", __func__, info,
+//		info->page_size, info->block_size, info->spare_size);
+
+	memset(spi_nand_defect_bk_list, 0, (MAX_BLOCK_CNT / 8) + 1);
+	memset(spi_nand_bk_usage_list, 0, (MAX_BLOCK_CNT / 8) + 1);
+
+	for (u32 blk_id = 0; blk_id < info->fip_block_cnt; blk_id++) {
+		uint32_t pg = blk_id << info->pages_per_block_shift;
+
+		host->addr_value[1] = pg;
+		cvsnfc_send_cmd_erase(host);
+
+		memset(pg_buf, 0xff, ttl_pg_sz);
+
+		status = cvsnfc_read_page_raw(host->mtd, host->chip, pg_buf, 0, pg);
+
+		if (status) {
+			printf("read status %d, ", status);
+			cvi_assert(0);
+		}
+
+		u8 *mark = (u8 *)pg_buf;
+		/* Should we check spare data at 800H of this page instead of byte 0 */
+		//printf("NAND_DEBUG: block[%d] spare byte[0] at 0x800 = %x\n", blk_id, *(mark + info->page_size));
+
+		if ((*mark != 0xff) || (*(mark + info->page_size) != 0xff)) {
+			printf("\n\nFound bad block %d, ", blk_id);
+			//printf("bad ");
+			//printf(" mark : 0x%x\n\n", *mark);
+			//bbt_dump_buf("data:", pg_buf, 16);
+			SET_MASK_BIT(spi_nand_defect_bk_list, blk_id);
+		}
+	}
+
+	return 0;
+}
+
+static int spi_nand_blk_allocator(int fip_idx)
+{
+	struct _spi_nand_info_t *info = &spinand_info;
+	int blk_idx;
+	u8 start_blk = 0;
+
+	if (fip_idx == 1) {
+		start_blk = BACKUP_FIP_START_POSITION;
+
+		for (blk_idx = start_blk; blk_idx < info->fip_block_cnt; blk_idx++)
+			if ((CHECK_MASK_BIT(spi_nand_defect_bk_list, blk_idx) == 0) &&
+			    (CHECK_MASK_BIT(spi_nand_bk_usage_list, blk_idx) == 0))
+				break;
+		if (blk_idx >= info->fip_block_cnt) {
+			printf("no available block can be allocated for fip[1]\n");
+			return -FIP_NO_AVAILABLE_BLOCK;
+		}
+	} else {
+		for (blk_idx = start_blk; blk_idx < BACKUP_FIP_START_POSITION; blk_idx++)
+			if ((CHECK_MASK_BIT(spi_nand_defect_bk_list, blk_idx) == 0) &&
+			    (CHECK_MASK_BIT(spi_nand_bk_usage_list, blk_idx) == 0))
+				break;
+		if (blk_idx >= BACKUP_FIP_START_POSITION) {
+			printf("no available block can be allocated for fip[0]\n");
+			return -FIP_NO_AVAILABLE_BLOCK;
+		}
+	}
+
+	SET_MASK_BIT(spi_nand_bk_usage_list, blk_idx);
+
+	return blk_idx;
+}
+
+int check_fip_checknum(struct _fip_info_t *fip_info)
+{
+	int i;
+
+	if (fip_info->total_count != 0xff) {
+		for (i = 1; i < fip_info->total_count; i++) {
+			if (fip_info->checknum[0] == fip_info->checknum[i])
+				continue; /* checknum is consistent with fip header */
+			else
+				return 1; /* checknum is not consistent, it means fip is corrupted */
+		}
+		return 0; /* all checknums are consistence */
+	}
+
+	return 1; /* no valid total_count, it means fip is corrupted */
+}
+
+int fip_reallocate_and_recovery(struct _fip_info_t *fip, int fip_idx, int bk_idx)
+{
+	struct _spi_nand_info_t *info = &spinand_info;
+	struct cvsnfc_host *host = cvsnfc_get_host();
+	int status;
+	void *temp_buf;
+	uint8_t bk_shift;
+	int bk_page_id;
+	int target_page_id;
+	int blk_id;
+
+	bk_shift = info->pages_per_block_shift;
+
+	temp_buf = (uint8_t *)malloc(info->page_size);
+
+	/* erase original block first */
+	host->addr_value[1] = (fip + fip_idx)->bk_position[bk_idx] << bk_shift;
+	cvsnfc_send_cmd_erase(host);
+
+retry:
+	blk_id = spi_nand_blk_allocator(fip_idx);
+
+	if (blk_id < 0)
+		return -1;
+
+	(fip + fip_idx)->bk_position[bk_idx] = blk_id;
+
+	for (int pg_idx = 0; pg_idx < info->pages_per_block; pg_idx++) {
+		if (fip_idx == 0) {
+			bk_page_id = ((fip + 1)->bk_position[bk_idx] << info->pages_per_block_shift) + pg_idx;
+			target_page_id = (fip->bk_position[bk_idx] << info->pages_per_block_shift) + pg_idx;
+		} else {
+			bk_page_id = (fip->bk_position[bk_idx] << info->pages_per_block_shift) + pg_idx;
+			target_page_id = ((fip + 1)->bk_position[bk_idx] << info->pages_per_block_shift) + pg_idx;
+		}
+
+		status = cvsnfc_read_page(host->mtd, host->chip, (void *)pg_buf,
+					  info->page_size, bk_page_id);
+
+		if (status < 0) {
+			printf("%s, ECC UNCORR detect on backup bk %d page %d, stop recovery\n", __func__,
+			       (fip + fip_idx)->bk_position[bk_idx], pg_idx);
+			goto retry;
+		}
+
+		cvsnfc_write_page(host->mtd, host->chip, (void *)pg_buf, 0,
+				  target_page_id);
+
+		status = cvsnfc_read_page(host->mtd, host->chip, (void *)temp_buf, info->page_size,
+					  target_page_id);
+
+		if (status < 0) {
+			printf("%s, ECC UNCORR detect on bk %d page %d after recovery\n", __func__,
+			       (fip + fip_idx)->bk_position[bk_idx], pg_idx);
+		}
+
+		if (memcmp(temp_buf, pg_buf, info->page_size)) {
+			printf("%s, fip 0 read back compare error at bk %d!\n", __func__,
+			       (fip + fip_idx)->bk_position[bk_idx]);
+		}
+
+	}
+
+	free(temp_buf);
+	return 0;
+}
+
+int fip_block_recover(struct _fip_info_t *fip, int bk_idx, int backup_fip, int target_fip)
+{
+	struct cvsnfc_host *host = cvsnfc_get_host();
+	struct _spi_nand_info_t *info = &spinand_info;
+	int status;
+	void *temp_buf;
+	int backup_page_id;
+	int target_page_id;
+
+	temp_buf = (uint8_t *)malloc(info->page_size);
+	for (int pg_idx = 0; pg_idx < info->pages_per_block; pg_idx++) {
+
+		backup_page_id = ((fip + backup_fip)->bk_position[bk_idx] << info->pages_per_block_shift) + pg_idx;
+		target_page_id = ((fip + target_fip)->bk_position[bk_idx] << info->pages_per_block_shift) + pg_idx;
+
+		status = cvsnfc_read_page(host->mtd, host->chip, (void *)pg_buf,
+					  info->page_size, backup_page_id);
+
+		if (status < 0) {
+			printf("%s, ECC UNCORR detect on backup bk %d page %d, stop recovery\n",
+			       __func__, (fip + backup_fip)->bk_position[bk_idx], pg_idx);
+			goto recover_fail;
+		}
+
+		cvsnfc_write_page(host->mtd, host->chip, (void *)pg_buf, 0,
+				  target_page_id);
+
+		status = cvsnfc_read_page(host->mtd, host->chip, (void *)temp_buf, info->page_size,
+					  target_page_id);
+
+		if (status < 0) {
+			printf("%s, ECC UNCORR detect on bk %d page %d after recovery\n",
+			       __func__, (fip + target_fip)->bk_position[bk_idx], pg_idx);
+			if (fip_reallocate_and_recovery(fip, target_fip, bk_idx) < 0)
+				goto recover_fail;
+		}
+
+		if (memcmp(temp_buf, pg_buf, info->page_size)) {
+			printf("%s, fip 0 read back compare error at bk %d!\n", __func__,
+			       fip->bk_position[bk_idx]);
+			if (fip_reallocate_and_recovery(fip, target_fip, bk_idx) < 0)
+				goto recover_fail;
+		}
+	}
+
+	free(temp_buf);
+	return FIP_PAGE_NO_ISSUE;
+
+recover_fail:
+	free(temp_buf);
+	return FIP_STOP_RECOVERY;
+}
+
+int fip_check_checknum_and_recovery(struct _fip_info_t *fip)
+{
+	struct cvsnfc_host *host = cvsnfc_get_host();
+	struct _spi_nand_info_t *info = &spinand_info;
+	int status;
+	int bk_id;
+
+	if (check_fip_checknum(fip) && !check_fip_checknum(fip + 1)) {
+		/* checknums within fip_info[0] are not consistnece, but fip_info[1] is OK. recovery fip0 from fip1 */
+		if (fip->current_bk_mask != (fip + 1)->current_bk_mask) {
+			for (int i = 0; i < (fip + 1)->total_count; i++) {
+				if (!((fip->current_bk_mask >> i) & 0x1)) {
+					printf("fip[0] bk idx %d is corrupted, recover from fip[1]\n", i);
+
+					bk_id = spi_nand_blk_allocator(0);
+					fip->bk_position[i] = bk_id;
+					host->addr_value[1] = fip->bk_position[i] << info->pages_per_block_shift;
+					cvsnfc_send_cmd_erase(host);
+					status = fip_block_recover(fip, i, 1, 0);
+					if (status)
+						return status;
+				}
+			}
+
+			fip->total_count = (fip + 1)->total_count;
+			fip->current_bk_mask = (fip + 1)->current_bk_mask;
+		} else {
+			printf("Checknums of fip[0] are not consistence\n");
+
+			for (int i = 0; i < fip->total_count; i++) {
+				/* Erase original blocks first */
+				host->addr_value[1] = fip->bk_position[i] << info->pages_per_block_shift;
+				cvsnfc_send_cmd_erase(host);
+
+				/* Read pages from backup fip then write to target pages */
+
+				status = fip_block_recover(fip, i, 1, 0);
+				if (status)
+					return status;
+			}
+		}
+	} else if (!check_fip_checknum(fip) && check_fip_checknum(fip + 1)) {
+		/* checknums within fip_info[1] are not consistnece, but fip_info[0] is OK. recovery fip1 from fip0 */
+		if (fip->current_bk_mask != (fip + 1)->current_bk_mask) {
+			for (int i = 0; i < fip->total_count; i++) {
+				if (!(((fip + 1)->current_bk_mask >> i) & 0x1)) {
+					printf("fip[1] bk idx %d is corrupted, recover from fip[0]\n", i);
+
+					bk_id = spi_nand_blk_allocator(1);
+					(fip + 1)->bk_position[i] = bk_id;
+					host->addr_value[1] = (fip + 1)->bk_position[i] << info->pages_per_block_shift;
+					cvsnfc_send_cmd_erase(host);
+					status = fip_block_recover(fip, i, 0, 1);
+					if (status)
+						return status;
+				}
+			}
+			(fip + 1)->total_count = fip->total_count;
+			(fip + 1)->current_bk_mask = fip->current_bk_mask;
+		} else {
+			printf("Checknums of fip[1] are not consistence\n");
+
+			for (int i = 0; i < (fip + 1)->total_count; i++) {
+				/* Erase original blocks first */
+				host->addr_value[1] = (fip + 1)->bk_position[i] << info->pages_per_block_shift;
+				cvsnfc_send_cmd_erase(host);
+
+				/* Read pages from backup fip then write to target pages */
+				status = fip_block_recover(fip, i, 0, 1);
+				if (status)
+					return status;
+			}
+		}
+	} else if (check_fip_checknum(fip) && check_fip_checknum(fip + 1)) {
+		printf("Both fip[0] and fip[1] are corrupted, please do re-download again!!\n");
+		return FIP_STOP_RECOVERY;
+	} else if (fip->checknum[0] != (fip + 1)->checknum[0]) {
+		/* checknums of fip0 and fip1 are not the same, it means fip download is not complete*/
+		/* recovery fip0 from fip1 */
+		printf("Checknum of fip[0] is not the same with fip[1]\n");
+		for (int i = 0; i < (fip + 1)->total_count; i++) {
+
+			/* Erase original blocks first */
+			host->addr_value[1] = fip->bk_position[i] << info->pages_per_block_shift;
+			cvsnfc_send_cmd_erase(host);
+
+			/* Read pages from backup fip then write to target pages */
+			status = fip_block_recover(fip, i, 1, 0);
+			if (status)
+				return status;
+		}
+
+		fip->total_count = (fip + 1)->total_count;
+		fip->current_bk_mask = (fip + 1)->current_bk_mask;
+	} else {
+		printf("All Header check PASS\n");
+		return FIP_HEADER_NO_ISSUE;
+	}
+
+	return FIP_CHECKNUM_ERROR;
+}
+
+int fip_check_page_and_recovery(struct _fip_info_t *fip)
+{
+	struct _spi_nand_info_t *info = &spinand_info;
+	struct cvsnfc_host *host = cvsnfc_get_host();
+	int status;
+	uint8_t	erase_and_recover = 0;
+	uint8_t fip_idx = 0;
+	uint8_t bk_shift;
+
+	bk_shift = info->pages_per_block_shift;
+
+	for (fip_idx = 0; fip_idx < SPI_NAND_BASE_DATA_BACKUP_COPY; fip_idx++) {
+
+		for (int i = 0; i < fip->total_count; i++) {
+			for (int pg_idx = 0; pg_idx < info->pages_per_block; pg_idx++) {
+				int page_id;
+
+				page_id = ((fip + fip_idx)->bk_position[i] << bk_shift) + pg_idx;
+				status = cvsnfc_read_page(host->mtd, host->chip, (void *)pg_buf,
+							  info->page_size, page_id);
+
+				if (status < 0) {
+					printf("ECC UNCORR detect on bk %d page %d\n",
+					       (fip + fip_idx)->bk_position[i], pg_idx);
+					erase_and_recover = 1;
+					break; /* need to erase a whole block and then re-write again */
+				}
+			}
+
+			if (erase_and_recover == 1) {
+				printf("Recover bk %d due to page error\n", (fip + fip_idx)->bk_position[i]);
+				host->addr_value[1] = (fip + fip_idx)->bk_position[i] << bk_shift;
+				cvsnfc_send_cmd_erase(host);
+				if (fip_idx == 0)
+					status = fip_block_recover(fip, i, 1, 0);
+				else
+					status = fip_block_recover(fip, i, 0, 1);
+
+				if (status)
+					return status;
+
+				erase_and_recover = 0;
+			}
+		}
+	}
+
+	printf("All Page check PASS\n");
+	return 0;
+}
+
+/*
+ * This function is entry point of normal bootup of u-boot
+ * check each block status and recovery it if ECC ERROR occur
+ */
+int check_and_update_fip_bin(void)
+{
+	struct _spi_nand_info_t *info;
+	struct cvsnfc_host *host = cvsnfc_get_host();
+	u32 blk_id = 0;
+	struct _fip_info_t fip_info[SPI_NAND_BASE_DATA_BACKUP_COPY];
+	struct block_header_t *bk_header;
+	u32 pg_sz, bk_sz;
+	int status;
+	u8	fip_header_count = 0;
+	u32 boot_src;
+
+	spi_nand_global_param_init();
+
+	info = &spinand_info;
+
+	pg_sz = info->page_size;
+	bk_sz = info->block_size;
+
+	memset(pg_buf, 0, sizeof(pg_sz));
+	memset(&fip_info, 0xff, sizeof(struct _fip_info_t) * SPI_NAND_BASE_DATA_BACKUP_COPY);
+	for (int i = 0; i < SPI_NAND_BASE_DATA_BACKUP_COPY; i++) {
+		fip_info[i].current_bk_mask = 0x0;
+	}
+	memset(spi_nand_defect_bk_list, 0, (MAX_BLOCK_CNT / 8) + 1);
+	memset(spi_nand_bk_usage_list, 0, (MAX_BLOCK_CNT / 8) + 1);
+
+	for (blk_id = 0; blk_id < SPI_NAND_FIP_RSVD_BLOCK_COUNT; blk_id++) {
+
+		status = cvsnfc_read_page(host->mtd, host->chip, (void *)pg_buf, pg_sz,
+					  (blk_id << info->pages_per_block_shift) + 0);
+		/* Read first page of each block */
+
+		if (status < 0) {
+			printf("%s, find ECC UNCORR on bk %d\n", __func__, blk_id);
+			SET_MASK_BIT(spi_nand_defect_bk_list, blk_id);
+			continue;
+		}
+
+		bk_header = (struct block_header_t *)pg_buf;
+
+		if (!memcmp(bk_header->tag, FIP_IMAGE_HEAD, FIP_BK_TAG_SIZE)) {
+			fip_header_count++;
+			if (fip_header_count == 1 && blk_id >= BACKUP_FIP_START_POSITION)
+				printf("WARNING!! First fip header position exceed backup start position\n");
+
+			if (fip_header_count == 1)
+				spi_nand_adjust_max_freq(host, (u32 *)bk_header->tag, &bk_header->checknum);
+
+			if (blk_id < BACKUP_FIP_START_POSITION) {
+				if (fip_info[0].bk_position[0] == 0xff) {
+					fip_info[0].bk_position[0] = blk_id;
+					fip_info[0].checknum[0] = bk_header->checknum;
+					fip_info[0].total_count = bk_header->bk_cnt_or_seq;
+					fip_info[0].current_bk_mask |= 0x1 << 0;
+					SET_MASK_BIT(spi_nand_bk_usage_list, blk_id);
+					continue;
+				} else
+					printf("fip info[0] header is not initialized before\n");
+			} else {
+				if (fip_info[1].bk_position[0] == 0xff) {
+					fip_info[1].bk_position[0] = blk_id;
+					fip_info[1].checknum[0] = bk_header->checknum;
+					fip_info[1].total_count = bk_header->bk_cnt_or_seq;
+					fip_info[1].current_bk_mask |= 0x1 << 0;
+					SET_MASK_BIT(spi_nand_bk_usage_list, blk_id);
+					continue;
+				} else
+					printf("fip info[1] header is not initialized before\n");
+			}
+			if (fip_header_count > SPI_NAND_BASE_DATA_BACKUP_COPY)
+				printf("%s, WARNING!! find unexpected fip_header at bk %d\n", __func__, blk_id);
+		} else if (!memcmp(bk_header->tag, FIP_IMAGE_BODY, FIP_BK_TAG_SIZE)) {
+			if (blk_id < BACKUP_FIP_START_POSITION) {
+				if (fip_info[0].bk_position[bk_header->bk_cnt_or_seq] == 0xff) {
+					fip_info[0].bk_position[bk_header->bk_cnt_or_seq] = blk_id;
+					fip_info[0].checknum[bk_header->bk_cnt_or_seq] = bk_header->checknum;
+					fip_info[0].current_bk_mask |= 0x1 << bk_header->bk_cnt_or_seq;
+					SET_MASK_BIT(spi_nand_bk_usage_list, blk_id);
+					continue;
+				} else
+					printf("fip info[0] body %d is not initialized before\n",
+					       bk_header->bk_cnt_or_seq);
+			} else {
+				if (fip_info[1].bk_position[bk_header->bk_cnt_or_seq] == 0xff) {
+					fip_info[1].bk_position[bk_header->bk_cnt_or_seq] = blk_id;
+					fip_info[1].checknum[bk_header->bk_cnt_or_seq] = bk_header->checknum;
+					fip_info[1].current_bk_mask |= 0x1 << bk_header->bk_cnt_or_seq;
+					SET_MASK_BIT(spi_nand_bk_usage_list, blk_id);
+					continue;
+				} else
+					printf("fip info[1] body %d is not initialized before\n",
+					       bk_header->bk_cnt_or_seq);
+			}
+
+		}
+	}
+
+	if (DEBUG_DUMP_FIP) {
+		for (int i = 0; i < SPI_NAND_BASE_DATA_BACKUP_COPY; i++) {
+			printf("fip_info[%d] total count=%d\n", i, fip_info[i].total_count);
+
+			for (int j = 0; j < (SPI_NAND_FIP_RSVD_BLOCK_COUNT / 2); j++)
+				printf("fip_info[%d].bk_position[%d]= 0x%x, fip_info[%d].checknum[%d] = 0x%x\n",
+				       i, j, fip_info[i].bk_position[j], i, j, fip_info[i].checknum[j]);
+			printf("fip_info[%d].current mask=0x%x\n", i, fip_info[i].current_bk_mask);
+		}
+
+		printf("defect list = %02x%02x%02x\n", spi_nand_defect_bk_list[2],
+		       spi_nand_defect_bk_list[1],  spi_nand_defect_bk_list[0]);
+		printf("usage list = %02x%02x%02x\n", spi_nand_bk_usage_list[2],
+		       spi_nand_bk_usage_list[1], spi_nand_bk_usage_list[0]);
+	}
+
+	boot_src = readl((unsigned int *)BOOT_SOURCE_FLAG_ADDR);
+
+	if (boot_src == MAGIC_NUM_SD_DL || boot_src == MAGIC_NUM_USB_DL)
+		return 0; /* No need to check and update spinand */
+
+	if (fip_header_count <= SPI_NAND_BASE_DATA_BACKUP_COPY) {
+		if (!fip_check_checknum_and_recovery(fip_info)) {
+			/* check page ecc and do revoery if necessary */
+			fip_check_page_and_recovery(fip_info);
+		}
+//	} else if (fip_header_count == 1)	{
+//		printf("Only detect 1 fip header\n");
+	} else if (fip_header_count > SPI_NAND_BASE_DATA_BACKUP_COPY) {
+		printf("WARNING!! find unexpected fip_header\n");
+	} else {
+		printf("WARNING!! cannot find fip_header\n");
+	}
+
+	return 0;
+}
+
+static uint32_t spi_nand_crc16_ccitt_with_tag(unsigned char *buf, int len)
+{
+	uint32_t crc = 0;
+
+	crc = crc16_ccitt(0, buf, len);
+	crc |= 0xCAFE0000;
+
+	return crc;
+}
+
+static void spi_nand_check_size_error(u32 target_len, u32 curr_offset, u32 pg_size)
+{
+	if ((target_len - curr_offset) >= pg_size)
+		printf("## WARNING 1 ## data size %d to be wrote is wrong!!\n", (target_len - curr_offset));
+}
+
+static int spi_nand_flush_fip_bin(void *buf)
+{
+	int status = 0;
+	void *buffer = (void *)buf;
+	void *src_buf_addr = 0;
+	struct cvsnfc_host *host = cvsnfc_get_host();
+	struct _spi_nand_info_t *info = &spinand_info;
+	u32 pg_sz, pg_per_blk, bk_sz;
+	u32 total_len, ttl_block_cnt_to_write, ttl_pg_cnt_to_write;
+	struct block_header_t bk_header;
+	u32 bk_overhead; /* used to  calculate total block header size in page 0 of each block */
+	u32 blk_idx = 0;
+	u32 blk_id = 0;
+	u32 src_len;
+	uint8_t *temp_buf;
+	unsigned int checknum;
+
+	srand(get_timer(0));
+	checknum = rand();
+
+	printf("Generated checknum=0x%x\n", checknum);
+
+	pg_sz = info->page_size;
+	bk_sz = info->block_size;
+	src_len = env_get_ulong("filesize", 16, 0);
+
+	printf("fip size=%d bytes\n", src_len);
+
+	ttl_block_cnt_to_write = src_len / bk_sz;
+	if ((src_len % bk_sz) != 0)
+		ttl_block_cnt_to_write += 1;
+
+	bk_overhead = sizeof(struct block_header_t);
+	memset(&bk_header, 0, sizeof(struct block_header_t));
+
+	total_len = (src_len + (ttl_block_cnt_to_write * bk_overhead));
+
+	ttl_pg_cnt_to_write = total_len / pg_sz;
+	if (total_len % pg_sz != 0)
+		ttl_pg_cnt_to_write += 1; /* add 1 page to write remaining data */
+
+	ttl_block_cnt_to_write = total_len / bk_sz; /* re-calculate new block count */
+	if (total_len % bk_sz != 0)
+		ttl_block_cnt_to_write += 1;
+
+	if (DEBUG_WRITE)
+		printf("Write totol_len=%d, bk_overhead=%d, ttl_page_cnt_to_write=%d, ttl_block_cnt_to_write=%d\n",
+		       total_len, bk_overhead, ttl_pg_cnt_to_write, ttl_block_cnt_to_write);
+
+	pg_per_blk = info->pages_per_block;
+
+	temp_buf = (uint8_t *)malloc(info->page_size);
+
+	for (u32 i = 0; i < SPI_NAND_BASE_DATA_BACKUP_COPY; i++) {
+		u32 offset_in_buf = 0;
+		uint8_t wrote_bk_cnt = 0;
+
+		printf("write %d copy of fip\n", i + 1);
+
+		for (u32 pg_idx_in_buf = 0; pg_idx_in_buf < ttl_pg_cnt_to_write; pg_idx_in_buf++) {
+			u32 pg_idx_in_blk;
+
+			uint8_t block_damage = 0;
+
+			pg_idx_in_blk = GET_PG_IDX_IN_BLK(pg_idx_in_buf, pg_per_blk);
+			blk_idx = GET_BLK_IDX(pg_idx_in_buf, pg_per_blk);
+
+			src_buf_addr = PTR_INC(buffer, offset_in_buf);
+
+			if (pg_idx_in_blk == 0) {
+				if (wrote_bk_cnt == 0) { /* Fill FIP image first block header */
+					struct _fip_param1_t *temp_fip_param;
+					uint32_t crc = 0;
+					int param_crc_size;
+
+					memcpy(bk_header.tag, FIP_IMAGE_HEAD, 4);
+					bk_header.bk_cnt_or_seq = (uint32_t)ttl_block_cnt_to_write;
+					bk_header.checknum = checknum;
+					memcpy(temp_buf, &bk_header, bk_overhead);
+					temp_fip_param = src_buf_addr;
+
+					memcpy(&temp_fip_param->nand_info, info, sizeof(struct _spi_nand_info_t));
+					param_crc_size = 0x800 - offsetof(struct _fip_param1_t, nand_info);
+
+					crc = spi_nand_crc16_ccitt_with_tag((unsigned char *)&temp_fip_param->nand_info
+						  , param_crc_size);
+					//printf("%s, get crc=0x%08x, param_crc_size=%d\n", __func__,
+					//       crc, param_crc_size);
+					temp_fip_param->param_cksum = crc;
+					memcpy((temp_buf + bk_overhead), src_buf_addr, (pg_sz - bk_overhead));
+
+				} else { /* Fill remaining FIP image body */
+					memcpy(bk_header.tag, FIP_IMAGE_BODY, 4);
+					bk_header.bk_cnt_or_seq = (uint32_t)wrote_bk_cnt;
+					bk_header.checknum = checknum;
+					memcpy(temp_buf, &bk_header, bk_overhead);
+					if (pg_idx_in_buf == (ttl_pg_cnt_to_write - 1)) { /* last page */
+						spi_nand_check_size_error(src_len, offset_in_buf, pg_sz);
+						memcpy((temp_buf + bk_overhead), src_buf_addr,
+						       (src_len - offset_in_buf));
+					} else
+						memcpy((temp_buf + bk_overhead), src_buf_addr, (pg_sz - bk_overhead));
+				}
+				wrote_bk_cnt++;
+				offset_in_buf = offset_in_buf + (pg_sz - bk_overhead); /* Insert fip header in page 0 */
+			} else {
+				if (pg_idx_in_buf == (ttl_pg_cnt_to_write - 1)) { /* last page */
+					spi_nand_check_size_error(src_len, offset_in_buf, pg_sz);
+					memcpy(temp_buf, src_buf_addr, (src_len - offset_in_buf));
+				} else
+					memcpy(temp_buf, src_buf_addr, pg_sz);
+
+				offset_in_buf = offset_in_buf + pg_sz;
+			}
+
+			if (DEBUG_WRITE)
+				printf("flush fip.bin with next offset = 0x%x\n",
+				       offset_in_buf);
+retry:
+			if (pg_idx_in_blk == 0 || block_damage == 1) {
+				/* pg_idx_in_blk == 0 means need a new block */
+				/* damage == 1 means need to find next block*/
+				blk_id = spi_nand_blk_allocator(i);
+
+				if (DEBUG_WRITE)
+					printf("NAND_DEBUG: %s, allocate blk_id=%d for page %d (%x)\n",
+					       __func__, blk_id, pg_idx_in_buf, pg_idx_in_buf);
+
+				if (blk_id == -1) {
+					cvi_assert(0);
+					return -1;
+				}
+
+				block_damage = 0;
+			}
+
+			/* should we supplyment remain data of last page if remaining data is less then 1 page ?*/
+			cvsnfc_write_page(host->mtd, host->chip, (void *)temp_buf, 0,
+					  (blk_id << info->pages_per_block_shift) +  pg_idx_in_blk);
+			/* read page again to check data consistent */
+			memset(pg_buf, 0, sizeof(pg_sz));
+			status = cvsnfc_read_page(host->mtd, host->chip, (void *)pg_buf, pg_sz,
+						  (blk_id << info->pages_per_block_shift) + pg_idx_in_blk);
+
+			if (status < 0) {
+				printf("##WARNING## %s update failed at block %d page %d, please check...\n",
+				       __func__, blk_id, pg_idx_in_blk);
+				//cvi_assert(0);
+				block_damage = 1;
+				host->addr_value[1] = blk_id << info->pages_per_block_shift;
+				cvsnfc_send_cmd_erase(host);
+				SET_MASK_BIT(spi_nand_defect_bk_list, blk_id);
+				goto retry;
+
+			} else if (status > 0) {
+				printf("NAND_DEBUG: Read ecc corr page idx %d, blk_id %d\n", pg_idx_in_blk, blk_id);
+			}
+
+			if (memcmp(temp_buf, pg_buf, pg_sz)) {
+				printf("fip read back compare error!\n");
+				bbt_dump_buf((void *)"temp_buf", temp_buf, pg_sz >> 4);
+				bbt_dump_buf((void *)"pg_buf", pg_buf, pg_sz >> 4);
+				cvi_assert(0);
+			}
+		}
+	}
+
+	free(temp_buf);
+
+	return 0;
+}
+
+int spi_nand_fip_download(void *buf)
+{
+	int status;
+
+	/* always erase fip partition first and then download re-assemble fip */
+
+	status = spi_nand_scan_defect();
+	if (status) {
+		printf("scan factory error\n");
+		return -1;
+	}
+
+	status = spi_nand_flush_fip_bin(buf);
+	if (status)
+		printf("flush fip error\n");
+
+	return 0;
+}
+
+/*
+ * This function is entry point of u-boot download process
+ */
+int do_cvi_update_spinand(uint32_t component, void *addr)
+{
+	printf("%s with version 0x%x\n", __func__, SPI_NAND_VERSION);
+
+	if (DEBUG_WRITE)
+		bbt_dump_buf("source fip", addr, 0x40);
+
+	spi_nand_fip_download(addr);
+
+	return 0;
+}
+
diff --git a/cmd/cvi_update.c b/cmd/cvi_update.c
new file mode 100644
index 000000000..fe4bcfb4f
--- /dev/null
+++ b/cmd/cvi_update.c
@@ -0,0 +1,319 @@
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <imgs.h>
+#include <ubifs_uboot.h>
+#ifdef CONFIG_NAND_SUPPORT
+#include <nand.h>
+#endif
+#include "cvi_update.h"
+
+#define COMPARE_STRING_LEN 3
+#define SD_UPDATE_MAGIC 0x4D474E32
+#define ETH_UPDATE_MAGIC 0x4D474E35
+#define USB_DRIVE_UPGRADE_MAGIC 0x55425355
+#define FIP_UPDATE_MAGIC 0x55464950
+#define UPDATE_DONE_MAGIC 0x50524F47
+#define OTA_MAGIC 0x5245434F
+//#define ALWAYS_USB_DRVIVE_UPGRATE
+#define HEADER_SIZE 64
+#define SECTOR_SIZE 0x200
+#define HEADER_MAGIC "CIMG"
+#define MAX_LOADSIZE (16 * 1024 * 1024)
+#ifdef CONFIG_CMD_SAVEENV
+#define SET_DL_COMPLETE()			\
+	do {							\
+		env_set("dl_flag", "prog");	\
+		run_command("saveenv", 0);	\
+	} while (0)
+#else
+#define SET_DL_COMPLETE() writel(0x50524F47, (unsigned int *)UPGRADE_SRAM_ADDR)
+#endif /* CONFIG_CMD_SAVEENV */
+
+#ifdef CONFIG_NAND_SUPPORT
+static uint32_t lastend;
+#endif
+
+uint32_t update_magic;
+enum chunk_type_e { dont_care = 0, check_crc };
+enum storage_type_e { sd_dl = 0, usb_dl };
+
+static uint32_t bcd2hex4(uint32_t bcd)
+{
+	return ((bcd) & 0x0f) + (((bcd) >> 4) & 0xf0) + (((bcd) >> 8) & 0xf00) + (((bcd) >> 12) & 0xf000);
+}
+
+static int _storage_update(enum storage_type_e type);
+
+int _prgImage(char *file, uint32_t chunk_header_size, char *file_name)
+{
+	uint32_t size = *(uint32_t *)((uintptr_t)file + 4);
+	uint32_t offset = *(uint32_t *)((uintptr_t)file + 8);
+#if (defined CONFIG_SPI_FLASH)/* || (defined CONFIG_NAND_SUPPORT)*/
+	uint32_t part_size = *(uint32_t *)((uintptr_t)file + 12);
+#endif
+	//uint32_t header_crc = *(uint32_t *)((uintptr_t)file + 16);
+	char cmd[255] = { '\0' };
+	int ret = 0;
+
+	//if (chunk_type == check_crc) {
+	//	uint32_t crc = crc32(
+	//		0, (unsigned char *)file + chunk_header_size, size);
+	//	if (crc != header_crc) {
+	//		printf("Crc check failed header(0x%08x) img(0x%08x), skip it\n",
+	//		       header_crc, crc);
+	//		return 0;
+	//	} else {
+	//		/* Invalidate crc to avoid program garbage */
+	//		*(uint32_t *)((uintptr_t)file + 12) = 0;
+	//	}
+	//}
+#ifdef CONFIG_NAND_SUPPORT
+	int dev = nand_curr_device;
+	struct mtd_info *mtd = nand_info[dev];
+	uint32_t goodblocks = 0, blocks = 0;
+
+	// Calculate real offset when programming chunk.
+	if (offset < lastend)
+		offset = lastend;
+	else
+		lastend = offset;
+
+	blocks = (size & (mtd->erasesize - 1)) ? ALIGN(size, mtd->erasesize) : size;
+	blocks /= mtd->erasesize;
+	for (; goodblocks  < blocks; lastend += mtd->erasesize) {
+		if (!nand_block_isbad(mtd, lastend))
+			goodblocks++;
+	}
+	//pr_debug("offset:0x%x lastoffset:0x%x, end:0x%x\n", offset, lastend, part_size + offset);
+
+	snprintf(cmd, 255, "nand write %p 0x%x 0x%x",
+		 (void *)file + chunk_header_size, offset, size);
+#elif defined(CONFIG_SPI_FLASH)
+	if (update_magic == SD_UPDATE_MAGIC && (!strcmp(file_name, "fip.bin") ||
+						!strcmp(file_name, "boot.spinor"))) {
+		snprintf(cmd, 255, "sf update %p 0x%x 0x%x",
+			 (void *)file + chunk_header_size, offset, size);
+	} else {
+		snprintf(cmd, 255, "sf erase %#x %#x;", offset, part_size);
+		pr_debug("%s\n", cmd);
+		run_command(cmd, 0);
+		snprintf(cmd, 255, "sf write %p 0x%x 0x%x",
+			 (void *)file + chunk_header_size, offset, size);
+	}
+#else
+	if (size & (SECTOR_SIZE - 1))
+		size = ALIGN(size, SECTOR_SIZE);
+
+	size = size / SECTOR_SIZE;
+	offset = offset / SECTOR_SIZE;
+	snprintf(cmd, 255, "mmc write %p 0x%x 0x%x",
+		 (void *)file + chunk_header_size, offset, size);
+#endif
+	pr_debug("%s\n", cmd);
+	ret = run_command(cmd, 0);
+	if (ret)
+		return 0;
+
+	return size;
+}
+
+static int _checkHeader(char *file, char strStorage[10])
+{
+	char *magic = (void *)HEADER_ADDR;
+	uint32_t version = *(uint32_t *)((uintptr_t)HEADER_ADDR + 4);
+	uint32_t chunk_sz = *(uint32_t *)((uintptr_t)HEADER_ADDR + 8);
+	uint32_t total_chunk = *(uint32_t *)((uintptr_t)HEADER_ADDR + 12);
+	uint32_t file_sz = *(uint32_t *)((uintptr_t)HEADER_ADDR + 16);
+#ifdef CONFIG_NAND_SUPPORT
+	char *extra = (void *)((uintptr_t)HEADER_ADDR + 20);
+	static char prevExtra[EXTRA_FLAG_SIZE + 1] = { '\0' };
+#endif
+	int ret = strncmp(magic, HEADER_MAGIC, 4);
+
+	if (ret) {
+		printf("File:%s Magic number is wrong, skip it\n", file);
+		return ret;
+	}
+	printf("Header Version:%d\n", version);
+	char cmd[255] = { '\0' };
+	uint32_t pos = HEADER_SIZE;
+#ifdef CONFIG_NAND_SUPPORT
+	// Erase partition first
+	if (strncmp(extra, prevExtra, EXTRA_FLAG_SIZE)) {
+		strncpy(prevExtra, extra, EXTRA_FLAG_SIZE);
+		snprintf(cmd, 255, "nand erase.part -y %s", prevExtra);
+		pr_debug("%s\n", cmd);
+		run_command(cmd, 0);
+	}
+#endif
+	for (int i = 0; i < total_chunk; i++) {
+		uint32_t load_size = file_sz > (MAX_LOADSIZE + chunk_sz) ?
+				     MAX_LOADSIZE + chunk_sz :
+				     file_sz;
+		snprintf(cmd, 255, "fatload %s %p %s 0x%x 0x%x;", strStorage,
+			 (void *)UPDATE_ADDR, file, load_size, pos);
+		pr_debug("%s\n", cmd);
+		ret = run_command(cmd, 0);
+		if (ret)
+			return ret;
+
+		ret = _prgImage((void *)UPDATE_ADDR, chunk_sz, file);
+		if (ret == 0) {
+			printf("program file:%s failed\n", file);
+			break;
+		}
+		pos += load_size;
+		file_sz -= load_size;
+	}
+	return 0;
+}
+
+static int _storage_update(enum storage_type_e type)
+{
+	int ret = 0;
+	char cmd[255] = { '\0' };
+	char strStorage[10] = { '\0' };
+
+	if (type == sd_dl) {
+		printf("Start SD downloading...\n");
+		// Consider SD card with MBR as default
+#if defined(CONFIG_NAND_SUPPORT) || defined(CONFIG_SPI_FLASH)
+		strlcpy(strStorage, "mmc 0:1", 9);
+#elif defined(CONFIG_EMMC_SUPPORT)
+		strlcpy(strStorage, "mmc 1:1", 9);
+#endif
+		snprintf(cmd, 255, "fatload %s %p fip.bin;", strStorage,
+			 (void *)HEADER_ADDR);
+		ret = run_command(cmd, 0);
+		if (ret) {
+			// Consider SD card without MBR
+			printf("** Trying use partition 0 (without MBR) **\n");
+#if defined(CONFIG_NAND_SUPPORT) || defined(CONFIG_SPI_FLASH)
+			strlcpy(strStorage, "mmc 0:0", 9);
+#elif defined(CONFIG_EMMC_SUPPORT)
+			strlcpy(strStorage, "mmc 1:0", 9);
+#endif
+			snprintf(cmd, 255, "fatload %s %p fip.bin;", strStorage,
+				 (void *)HEADER_ADDR);
+			ret = run_command(cmd, 0);
+			if (ret)
+				return ret;
+		}
+#if defined(CONFIG_NAND_SUPPORT)
+		snprintf(cmd, 255, "cvi_sd_update %p spinand fip",
+			 (void *)HEADER_ADDR);
+		ret = run_command(cmd, 0);
+#elif defined(CONFIG_SPI_FLASH)
+		run_command("sf probe", 0);
+		snprintf(cmd, 255,
+			 "sf update %p ${fip_PART_OFFSET} ${filesize};",
+			 (void *)HEADER_ADDR);
+		ret = run_command(cmd, 0);
+#elif defined(CONFIG_EMMC_SUPPORT)
+		// Switch to boot partition
+		run_command("mmc dev 0 1", 0);
+		snprintf(cmd, 255, "mmc write %p 0 0x800;",
+			 (void *)HEADER_ADDR);
+		run_command(cmd, 0);
+		snprintf(cmd, 255, "mmc write %p 0x800 0x800;;",
+			 (void *)HEADER_ADDR);
+		run_command(cmd, 0);
+		printf("Program fip.bin done\n");
+		// Switch to user partition
+		run_command("mmc dev 0 0", 0);
+#endif
+	}
+	for (int i = 1; i < ARRAY_SIZE(imgs); i++) {
+		snprintf(cmd, 255, "fatload %s %p %s 0x%x 0;", strStorage,
+			 (void *)HEADER_ADDR, imgs[i], HEADER_SIZE);
+		pr_debug("%s\n", cmd);
+		ret = run_command(cmd, 0);
+		if (ret) {
+			printf("load %s failed, skip it!\n", imgs[i]);
+			continue;
+		}
+		if (_checkHeader(imgs[i], strStorage))
+			continue;
+	}
+	if (ret == 0)
+		SET_DL_COMPLETE();
+	return 0;
+}
+
+static int _usb_update(uint32_t usb_pid)
+{
+	int ret = 0;
+	char cmd[255] = { '\0' };
+	char utask_cmd[255] = { '\0' };
+
+	printf("Start USB downloading...\n");
+
+	// Clean download flags
+	writel(0x0, (unsigned int *)BOOT_SOURCE_FLAG_ADDR); //mw.l 0xe00fc00 0x0;
+	// Always download Fip first
+	snprintf(utask_cmd, 255, "cvi_utask vid 0x3346 pid 0x%x", usb_pid);
+	ret = run_command(utask_cmd, 0);
+#ifdef CONFIG_NAND_SUPPORT
+	snprintf(cmd, 255, "cvi_sd_update %p spinand fip", (void *)UPDATE_ADDR);
+	pr_debug("%s\n", cmd);
+	ret = run_command(cmd, 0);
+#elif defined(CONFIG_SPI_FLASH)
+	ret = run_command("sf probe", 0);
+	snprintf(cmd, 255, "sf update %p ${fip_PART_OFFSET} ${fip_PART_SIZE};", (void *)UPDATE_ADDR)
+	pr_debug("%s\n", cmd);
+	ret = run_command(cmd, 0);
+#else
+	// Switch to boot partition
+	run_command("mmc dev 0 1", 0);
+	snprintf(cmd, 255, "mmc write %p 0 0x800;", (void *)UPDATE_ADDR);
+	pr_debug("%s\n", cmd);
+	run_command(cmd, 0);
+	snprintf(cmd, 255, "mmc write %p 0x800 0x800;", (void *)UPDATE_ADDR);
+	pr_debug("%s\n", cmd);
+	run_command(cmd, 0);
+	printf("Program fip.bin done\n");
+	// Switch to user partition
+	run_command("mmc dev 0 0", 0);
+#endif
+	// Since device will reset by host tool, set flag first
+	SET_DL_COMPLETE();
+	while (1) {
+		ret = run_command(utask_cmd, 0);
+		if (ret) {
+			pr_debug("cvi_utask failed(%d)\n", ret);
+			return ret;
+		}
+		//_prgImage((void *)UPDATE_ADDR, readl(HEADER_ADDR + 8));
+	};
+	return 0;
+}
+
+static int do_cvi_update(struct cmd_tbl *cmdtp, int flag, int argc,
+			 char *const argv[])
+{
+	int ret = 1;
+	uint32_t usb_pid = 0;
+
+	if (argc == 1) {
+		update_magic = readl((unsigned int *)BOOT_SOURCE_FLAG_ADDR);
+		if (update_magic == SD_UPDATE_MAGIC) {
+			run_command("env default -a", 0);
+			ret = _storage_update(sd_dl);
+		} else if (update_magic == USB_UPDATE_MAGIC) {
+			run_command("env default -a", 0);
+			usb_pid = in_be32(UBOOT_PID_SRAM_ADDR);
+			usb_pid = bcd2hex4(usb_pid);
+			ret = _usb_update(usb_pid);
+		}
+	} else {
+		printf("Usage:\n%s\n", cmdtp->usage);
+	}
+
+	return ret;
+}
+
+U_BOOT_CMD(
+	cvi_update, 2, 0, do_cvi_update,
+	"cvi_update [eth, sd, usb]- check boot status and update if necessary\n",
+	"run cvi_update without parameter will check the boot status and try to update");
diff --git a/cmd/cvi_utask.c b/cmd/cvi_utask.c
new file mode 100644
index 000000000..0574651c8
--- /dev/null
+++ b/cmd/cvi_utask.c
@@ -0,0 +1,39 @@
+#include <stdlib.h>
+#include <common.h>
+#include <command.h>
+#include <cvi_utask.h>
+
+__weak int cvi_usb_polling(void)
+{
+	return 0;
+}
+
+__weak void acm_patch_id(unsigned short vid, unsigned short pid)
+{
+}
+
+static int do_cvi_utask(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	printf("\nstart usb task!\n");
+
+	if (argc == 3 && strncmp(argv[1], "pid", 3) == 0) {
+		int pid = (int)simple_strtoul(argv[2], NULL, 10);
+
+		acm_patch_id(0, pid);
+	} else if (argc == 5 && (strncmp(argv[1], "vid", 3) == 0) && (strncmp(argv[3], "pid", 3) == 0)) {
+		int vid = (int)simple_strtoul(argv[2], NULL, 10);
+		int pid = (int)simple_strtoul(argv[4], NULL, 10);
+
+		acm_patch_id(vid, pid);
+	}
+
+	cvi_usb_polling();
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(cvi_utask, 5, 0, do_cvi_utask,
+	   "bootloader control block command",
+	   "cvi_bcb <interface> <dev> <varname>\n"
+);
+
diff --git a/cmd/efuse.c b/cmd/efuse.c
new file mode 100644
index 000000000..c9c3baf2f
--- /dev/null
+++ b/cmd/efuse.c
@@ -0,0 +1,711 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <common.h>
+#include <command.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <mmio.h>
+#include <cvi_efuse.h>
+
+#define EFUSE_DEBUG 0
+
+#define _cc_trace(fmt, ...) __trace("", __FILE__, __func__, __LINE__, fmt, ##__VA_ARGS__)
+#define _cc_error(fmt, ...) __trace("ERROR:", __FILE__, __func__, __LINE__, fmt, ##__VA_ARGS__)
+
+#define ERROR(fmt, ...) __trace("ERROR:", __FILE__, __func__, __LINE__, fmt, ##__VA_ARGS__)
+
+#if EFUSE_DEBUG
+
+#define VERBOSE(fmt, ...) __trace("VERBOSE:", __FILE__, __func__, __LINE__, fmt, ##__VA_ARGS__)
+
+static int __trace(const char *prefix, const char *path, const char *func, int lineno, const char *fmt, ...)
+{
+	va_list ap;
+	int ret;
+
+	printf("[%s%s:%s:%d] ", prefix, path, func, lineno);
+	if (!fmt || fmt[0] == '\0') {
+		ret = printf("\n");
+	} else {
+		va_start(ap, fmt);
+		ret = vprintf(fmt, ap);
+		va_end(ap);
+	}
+
+	return ret;
+}
+#else
+
+#define VERBOSE(fmt, ...)
+
+static int __trace(const char *prefix, const char *path, const char *func, int lineno, const char *fmt, ...)
+{
+	return 0;
+}
+#endif
+
+static int hex2bytes(const char *hex, unsigned char *buf, int buf_size)
+{
+	int i, total = 0;
+	char tmp[3];
+
+	memset(buf, 0, buf_size);
+
+	for (i = 0; i < buf_size; i++) {
+		if (!hex[0] || !hex[1])
+			break;
+
+		tmp[0] = hex[0];
+		tmp[1] = hex[1];
+		tmp[2] = '\0';
+
+		buf[i] = simple_strtoul(tmp, NULL, 16);
+		hex += 2;
+		total += 1;
+	}
+
+	return total;
+}
+
+// ===========================================================================
+// EFUSE implementation
+// ===========================================================================
+#define EFUSE_SHADOW_REG (EFUSE_BASE + 0x100)
+#define EFUSE_SIZE 0x100
+
+#define EFUSE_MODE (EFUSE_BASE + 0x0)
+#define EFUSE_ADR (EFUSE_BASE + 0x4)
+#define EFUSE_DIR_CMD (EFUSE_BASE + 0x8)
+#define EFUSE_RD_DATA (EFUSE_BASE + 0xC)
+#define EFUSE_STATUS (EFUSE_BASE + 0x10)
+#define EFUSE_ONE_WAY (EFUSE_BASE + 0x14)
+
+#define EFUSE_BIT_AREAD BIT(0)
+#define EFUSE_BIT_MREAD BIT(1)
+#define EFUSE_BIT_PRG BIT(2)
+#define EFUSE_BIT_PWR_DN BIT(3)
+#define EFUSE_BIT_CMD BIT(4)
+#define EFUSE_BIT_BUSY BIT(0)
+#define EFUSE_CMD_REFRESH (0x30)
+
+enum EFUSE_READ_TYPE { EFUSE_AREAD, EFUSE_MREAD };
+
+static void cvi_efuse_wait_for_ready(void)
+{
+	while (mmio_read_32(EFUSE_STATUS) & EFUSE_BIT_BUSY)
+		;
+}
+
+static void cvi_efuse_power_on(uint32_t on)
+{
+	if (on)
+		mmio_setbits_32(EFUSE_MODE, EFUSE_BIT_CMD);
+	else
+		mmio_setbits_32(EFUSE_MODE, EFUSE_BIT_PWR_DN | EFUSE_BIT_CMD);
+}
+
+static void cvi_efuse_refresh(void)
+{
+	mmio_write_32(EFUSE_MODE, EFUSE_CMD_REFRESH);
+}
+
+static void cvi_efuse_prog_bit(uint32_t word_addr, uint32_t bit_addr, uint32_t high_row)
+{
+	uint32_t phy_addr;
+
+	// word_addr: virtual addr, take "lower 6-bits" from 7-bits (0-127)
+	// bit_addr: virtual addr, 5-bits (0-31)
+
+	// composite physical addr[11:0] = [11:7]bit_addr + [6:0]word_addr
+	phy_addr = ((bit_addr & 0x1F) << 7) | ((word_addr & 0x3F) << 1) | high_row;
+
+	cvi_efuse_wait_for_ready();
+
+	// send efuse program cmd
+	mmio_write_32(EFUSE_ADR, phy_addr);
+	mmio_write_32(EFUSE_MODE, EFUSE_BIT_PRG | EFUSE_BIT_CMD);
+}
+
+static uint32_t cvi_efuse_read_from_phy(uint32_t phy_word_addr, enum EFUSE_READ_TYPE type)
+{
+	// power on efuse macro
+	cvi_efuse_power_on(1);
+
+	cvi_efuse_wait_for_ready();
+
+	mmio_write_32(EFUSE_ADR, phy_word_addr);
+
+	if (type == EFUSE_AREAD) // array read
+		mmio_write_32(EFUSE_MODE, EFUSE_BIT_AREAD | EFUSE_BIT_CMD);
+	else if (type == EFUSE_MREAD) // margin read
+		mmio_write_32(EFUSE_MODE, EFUSE_BIT_MREAD | EFUSE_BIT_CMD);
+	else {
+		ERROR("EFUSE: Unsupported read type!");
+		return (uint32_t)-1;
+	}
+
+	cvi_efuse_wait_for_ready();
+
+	return mmio_read_32(EFUSE_RD_DATA);
+}
+
+static int cvi_efuse_write_word(uint32_t vir_word_addr, uint32_t val)
+{
+	uint32_t i, j, row_val, zero_bit;
+	uint32_t new_value;
+	int err_cnt = 0;
+
+	for (j = 0; j < 2; j++) {
+		VERBOSE("EFUSE: Program physical word addr #%d\n", (vir_word_addr << 1) | j);
+
+		// array read by word address
+		row_val = cvi_efuse_read_from_phy((vir_word_addr << 1) | j,
+						  EFUSE_AREAD); // read low word of word_addr
+		zero_bit = val & (~row_val); // only program zero bit
+
+		// program row which bit is zero
+		for (i = 0; i < 32; i++) {
+			if ((zero_bit >> i) & 1)
+				cvi_efuse_prog_bit(vir_word_addr, i, j);
+		}
+
+		// check by margin read
+		new_value = cvi_efuse_read_from_phy((vir_word_addr << 1) | j, EFUSE_MREAD);
+		VERBOSE("%s(): val=0x%x new_value=0x%x\n", __func__, val, new_value);
+		if ((val & new_value) != val) {
+			err_cnt += 1;
+			ERROR("EFUSE: Program bits check failed (%d)!\n", err_cnt);
+		}
+	}
+
+	cvi_efuse_refresh();
+
+	return err_cnt >= 2 ? -EIO : 0;
+}
+
+static void cvi_efuse_init(void)
+{
+	// power on efuse macro
+	cvi_efuse_power_on(1);
+
+	// send refresh cmd to reload all eFuse values to shadow registers
+	cvi_efuse_refresh();
+
+	// efuse macro will be auto powered off after refresh cmd, so don't
+	// need to turn it off manually
+}
+
+void cvi_efuse_dump(uint32_t vir_word_addr)
+{
+	uint32_t j, val;
+
+	for (j = 0; j < 2; j++) {
+		// check by margin read
+		val = cvi_efuse_read_from_phy((vir_word_addr << 1) | j, EFUSE_MREAD);
+		printf("EFUSE EFUSE_MREAD: Program bits %d check 0x%x\n", j, val);
+		val = cvi_efuse_read_from_phy((vir_word_addr << 1) | j, EFUSE_AREAD);
+		printf("EFUSE EFUSE_AREAD: Program bits %d check 0x%x\n", j, val);
+	}
+}
+
+int64_t cvi_efuse_read_from_shadow(uint32_t addr)
+{
+	if (addr >= EFUSE_SIZE)
+		return -EFAULT;
+
+	if (addr % 4 != 0)
+		return -EFAULT;
+
+	return mmio_read_32(EFUSE_SHADOW_REG + addr);
+}
+
+int cvi_efuse_write(uint32_t addr, uint32_t value)
+{
+	int ret;
+
+	VERBOSE("%s(): 0x%x = 0x%x\n", __func__, addr, value);
+
+	if (addr >= EFUSE_SIZE)
+		return -EFAULT;
+
+	if (addr % 4 != 0)
+		return -EFAULT;
+
+	ret = cvi_efuse_write_word(addr / 4, value);
+	VERBOSE("%s(): ret=%d\n", __func__, ret);
+	cvi_efuse_init();
+	cvi_efuse_wait_for_ready();
+
+	return ret;
+}
+
+// ===========================================================================
+// EFUSE API
+// ===========================================================================
+enum CVI_EFUSE_LOCK_WRITE_E {
+	CVI_EFUSE_LOCK_WRITE_HASH0_PUBLIC = CVI_EFUSE_OTHERS + 1,
+	CVI_EFUSE_LOCK_WRITE_LOADER_EK,
+	CVI_EFUSE_LOCK_WRITE_DEVICE_EK,
+	CVI_EFUSE_LOCK_WRITE_LAST
+};
+
+static struct _CVI_EFUSE_AREA_S {
+	CVI_U32 addr;
+	CVI_U32 size;
+} cvi_efuse_area[] = { [CVI_EFUSE_AREA_USER] = { 0x40, 40 },
+		       [CVI_EFUSE_AREA_DEVICE_ID] = { 0x8c, 8 },
+		       [CVI_EFUSE_AREA_HASH0_PUBLIC] = { 0xA8, 32 },
+		       [CVI_EFUSE_AREA_LOADER_EK] = { 0xD8, 16 },
+		       [CVI_EFUSE_AREA_DEVICE_EK] = { 0xE8, 16 } };
+
+static struct _CVI_EFUSE_LOCK_S {
+	CVI_S32 wlock_shift;
+	CVI_S32 rlock_shift;
+} cvi_efuse_lock[] = { [CVI_EFUSE_LOCK_HASH0_PUBLIC] = { 0, 8 },     [CVI_EFUSE_LOCK_LOADER_EK] = { 4, 12 },
+		       [CVI_EFUSE_LOCK_DEVICE_EK] = { 6, 14 },	     [CVI_EFUSE_LOCK_WRITE_HASH0_PUBLIC] = { 0, -1 },
+		       [CVI_EFUSE_LOCK_WRITE_LOADER_EK] = { 4, -1 }, [CVI_EFUSE_LOCK_WRITE_DEVICE_EK] = { 6, -1 } };
+
+static struct _CVI_EFUSE_USER_S {
+	CVI_U32 addr;
+	CVI_U32 size;
+} cvi_efuse_user[] = {
+	{ 0x40, 4 }, { 0x48, 4 }, { 0x50, 4 }, { 0x58, 4 }, { 0x60, 4 },
+	{ 0x68, 4 }, { 0x70, 4 }, { 0x78, 4 }, { 0x80, 4 }, { 0x88, 4 },
+};
+
+#define CVI_EFUSE_TOTAL_SIZE 0x100
+
+#define CVI_EFUSE_LOCK_ADDR 0xF8
+#define CVI_EFUSE_SECURE_CONF_ADDR 0xA0
+#define CVI_EFUSE_SCS_ENABLE_SHIFT 0
+
+CVI_S32 CVI_EFUSE_GetSize(enum CVI_EFUSE_AREA_E area, CVI_U32 *size)
+{
+	if (area >= ARRAY_SIZE(cvi_efuse_area) || cvi_efuse_area[area].size == 0) {
+		_cc_error("area (%d) is not found\n", area);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+
+	if (size)
+		*size = cvi_efuse_area[area].size;
+
+	return 0;
+}
+
+CVI_S32 _CVI_EFUSE_Read(CVI_U32 addr, void *buf, CVI_U32 buf_size)
+{
+	int64_t ret = -1;
+	int i;
+
+	VERBOSE("%s(): 0x%x(%u) to %p\n", __func__, addr, buf_size, buf);
+
+	if (!buf)
+		return CVI_ERR_EFUSE_INVALID_PARA;
+
+	if (buf_size > EFUSE_SIZE)
+		buf_size = EFUSE_SIZE;
+
+	for (i = 0; i < buf_size; i += 4) {
+		ret = cvi_efuse_read_from_shadow(addr + i);
+		VERBOSE("%s(): i=%x ret=%lx\n", __func__, i, ret);
+		if (ret < 0)
+			return ret;
+
+		*(uint32_t *)(buf + i) = (ret >= 0) ? ret : 0;
+	}
+
+	return 0;
+}
+
+static CVI_S32 _CVI_EFUSE_Write(CVI_U32 addr, const void *buf, CVI_U32 buf_size)
+{
+	_cc_trace("addr=0x%02x\n", addr);
+
+	int ret = -1;
+
+	CVI_U32 value;
+	int i;
+
+	if (!buf)
+		return CVI_ERR_EFUSE_INVALID_PARA;
+
+	for (i = 0; i < buf_size; i += 4) {
+		memcpy(&value, buf + i, sizeof(value));
+
+		_cc_trace("smc call: 0x%02x=0x%08x\n", addr + i, value);
+		ret = cvi_efuse_write(addr + i, value);
+
+		if (ret < 0) {
+			printf("%s: error (%d)\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+CVI_S32 CVI_EFUSE_Read(enum CVI_EFUSE_AREA_E area, CVI_U8 *buf, CVI_U32 buf_size)
+{
+	CVI_U32 user_size = cvi_efuse_area[CVI_EFUSE_AREA_USER].size;
+	CVI_U8 user[user_size], *p;
+	CVI_S32 ret;
+	int i;
+
+	if (area >= ARRAY_SIZE(cvi_efuse_area) || cvi_efuse_area[area].size == 0) {
+		_cc_error("area (%d) is not found\n", area);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+
+	if (!buf)
+		return CVI_ERR_EFUSE_INVALID_PARA;
+
+	memset(buf, 0, buf_size);
+
+	if (buf_size > cvi_efuse_area[area].size)
+		buf_size = cvi_efuse_area[area].size;
+
+	if (area != CVI_EFUSE_AREA_USER)
+		return _CVI_EFUSE_Read(cvi_efuse_area[area].addr, buf, buf_size);
+
+	memset(user, 0, user_size);
+
+	p = user;
+	for (i = 0; i < ARRAY_SIZE(cvi_efuse_user); i++) {
+		ret = _CVI_EFUSE_Read(cvi_efuse_user[i].addr, p, cvi_efuse_user[i].size);
+		if (ret < 0)
+			return ret;
+		p += cvi_efuse_user[i].size;
+	}
+
+	memcpy(buf, user, buf_size);
+
+	return CVI_SUCCESS;
+}
+
+CVI_S32 CVI_EFUSE_Write(enum CVI_EFUSE_AREA_E area, const CVI_U8 *buf, CVI_U32 buf_size)
+{
+	CVI_U32 user_size = cvi_efuse_area[CVI_EFUSE_AREA_USER].size;
+	CVI_U8 user[user_size], *p;
+	CVI_S32 ret;
+	int i;
+
+	if (area >= ARRAY_SIZE(cvi_efuse_area) || cvi_efuse_area[area].size == 0) {
+		_cc_error("area (%d) is not found\n", area);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+	if (!buf)
+		return CVI_ERR_EFUSE_INVALID_PARA;
+
+	if (buf_size > cvi_efuse_area[area].size)
+		buf_size = cvi_efuse_area[area].size;
+
+	if (area != CVI_EFUSE_AREA_USER)
+		return _CVI_EFUSE_Write(cvi_efuse_area[area].addr, buf, buf_size);
+
+	memset(user, 0, user_size);
+	memcpy(user, buf, buf_size);
+
+	p = user;
+	for (i = 0; i < ARRAY_SIZE(cvi_efuse_user); i++) {
+		ret = _CVI_EFUSE_Write(cvi_efuse_user[i].addr, p, cvi_efuse_user[i].size);
+		if (ret < 0)
+			return ret;
+		p += cvi_efuse_user[i].size;
+	}
+
+	return CVI_SUCCESS;
+}
+
+CVI_S32 CVI_EFUSE_EnableSecureBoot(void)
+{
+	CVI_U32 value = 0x3 << CVI_EFUSE_SCS_ENABLE_SHIFT;
+
+	return _CVI_EFUSE_Write(CVI_EFUSE_SECURE_CONF_ADDR, &value, sizeof(value));
+}
+
+CVI_S32 CVI_EFUSE_IsSecureBootEnabled(void)
+{
+	CVI_U32 value = 0;
+	CVI_S32 ret = 0;
+
+	ret = _CVI_EFUSE_Read(CVI_EFUSE_SECURE_CONF_ADDR, &value, sizeof(value));
+	_cc_trace("ret=%d value=%u\n", ret, value);
+	if (ret < 0)
+		return ret;
+
+	value &= 0x3 << CVI_EFUSE_SCS_ENABLE_SHIFT;
+	return !!value;
+}
+
+CVI_S32 CVI_EFUSE_Lock(enum CVI_EFUSE_LOCK_E lock)
+{
+	CVI_U32 value = 0;
+	CVI_U32 ret = 0;
+
+	if (lock >= ARRAY_SIZE(cvi_efuse_lock)) {
+		_cc_error("lock (%d) is not found\n", lock);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+
+	value = 0x3 << cvi_efuse_lock[lock].wlock_shift;
+	ret = _CVI_EFUSE_Write(CVI_EFUSE_LOCK_ADDR, &value, sizeof(value));
+	if (ret < 0)
+		return ret;
+
+	if (cvi_efuse_lock[lock].rlock_shift >= 0) {
+		value = 0x3 << cvi_efuse_lock[lock].rlock_shift;
+		ret = _CVI_EFUSE_Write(CVI_EFUSE_LOCK_ADDR, &value, sizeof(value));
+	}
+
+	return ret;
+}
+
+CVI_S32 CVI_EFUSE_IsLocked(enum CVI_EFUSE_LOCK_E lock)
+{
+	CVI_S32 ret = 0;
+	CVI_U32 value = 0;
+
+	if (lock >= ARRAY_SIZE(cvi_efuse_lock)) {
+		_cc_error("lock (%d) is not found\n", lock);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+
+	ret = _CVI_EFUSE_Read(CVI_EFUSE_LOCK_ADDR, &value, sizeof(value));
+	_cc_trace("ret=%d value=%u\n", ret, value);
+	if (ret < 0)
+		return ret;
+
+	value &= 0x3 << cvi_efuse_lock[lock].wlock_shift;
+	return !!value;
+}
+
+CVI_S32 CVI_EFUSE_LockWrite(enum CVI_EFUSE_LOCK_E lock)
+{
+	CVI_U32 value = 0;
+	CVI_S32 ret = 0;
+
+	if (lock >= ARRAY_SIZE(cvi_efuse_lock)) {
+		_cc_error("lock (%d) is not found\n", lock);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+
+	value = 0x3 << cvi_efuse_lock[lock].wlock_shift;
+	ret = _CVI_EFUSE_Write(CVI_EFUSE_LOCK_ADDR, &value, sizeof(value));
+	return ret;
+}
+
+CVI_S32 CVI_EFUSE_IsWriteLocked(enum CVI_EFUSE_LOCK_E lock)
+{
+	CVI_S32 ret = 0;
+	CVI_U32 value = 0;
+
+	if (lock >= ARRAY_SIZE(cvi_efuse_lock)) {
+		_cc_error("lock (%d) is not found\n", lock);
+		return CVI_ERR_EFUSE_INVALID_AREA;
+	}
+
+	ret = _CVI_EFUSE_Read(CVI_EFUSE_LOCK_ADDR, &value, sizeof(value));
+	_cc_trace("ret=%d value=%u\n", ret, value);
+	if (ret < 0)
+		return ret;
+
+	value &= 0x3 << cvi_efuse_lock[lock].wlock_shift;
+	return !!value;
+}
+
+static const char *const efuse_index[] = {
+	[CVI_EFUSE_AREA_USER] = "USER",
+	[CVI_EFUSE_AREA_DEVICE_ID] = "DEVICE_ID",
+	[CVI_EFUSE_AREA_HASH0_PUBLIC] = "HASH0_PUBLIC",
+	[CVI_EFUSE_AREA_LOADER_EK] = "LOADER_EK",
+	[CVI_EFUSE_AREA_DEVICE_EK] = "DEVICE_EK",
+	[CVI_EFUSE_LOCK_HASH0_PUBLIC] = "LOCK_HASH0_PUBLIC",
+	[CVI_EFUSE_LOCK_LOADER_EK] = "LOCK_LOADER_EK",
+	[CVI_EFUSE_LOCK_DEVICE_EK] = "LOCK_DEVICE_EK",
+	[CVI_EFUSE_LOCK_WRITE_HASH0_PUBLIC] = "LOCK_WRITE_HASH0_PUBLIC",
+	[CVI_EFUSE_LOCK_WRITE_LOADER_EK] = "LOCK_WRITE_LOADER_EK",
+	[CVI_EFUSE_LOCK_WRITE_DEVICE_EK] = "LOCK_WRITE_DEVICE_EK",
+	[CVI_EFUSE_SECUREBOOT] = "SECUREBOOT",
+};
+
+static int find_efuse_by_name(const char *name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(efuse_index); i++) {
+		if (!efuse_index[i])
+			continue;
+
+		if (!strcmp(name, efuse_index[i]))
+			return i;
+	}
+
+	return -1;
+}
+
+static int do_efuser(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int idx;
+	int ret;
+	unsigned int size;
+	unsigned char buf[128];
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	_cc_trace("Read eFuse: %s\n", argv[1]);
+	idx = find_efuse_by_name(argv[1]);
+	if (idx < 0)
+		return CMD_RET_USAGE;
+
+	_cc_trace("idx=%d %s\n", idx, efuse_index[idx]);
+
+	if (idx < CVI_EFUSE_AREA_LAST) {
+		if (CVI_EFUSE_GetSize(idx, &size) < 0)
+			return CMD_RET_FAILURE;
+
+		_cc_trace("size=%d\n", size);
+
+		if (CVI_EFUSE_Read(idx, buf, size) < 0)
+			return CMD_RET_FAILURE;
+
+		print_buffer(0, buf, 1, size, 0);
+		return 0;
+	} else if (idx < CVI_EFUSE_LOCK_LAST) {
+		ret = CVI_EFUSE_IsLocked(idx);
+		printf("%s is %s locked\n", efuse_index[idx], ret ? "" : "not");
+		return 0;
+	} else if (idx < CVI_EFUSE_LOCK_WRITE_LAST) {
+		ret = CVI_EFUSE_IsWriteLocked(idx);
+		printf("%s is %s write_locked\n", efuse_index[idx], ret ? "" : "not");
+		return 0;
+	} else if (idx == CVI_EFUSE_SECUREBOOT) {
+		ret = CVI_EFUSE_IsSecureBootEnabled();
+		printf("Secure Boot is %s\n", ret ? "enabled" : "disabled");
+		return 0;
+	}
+
+	return CMD_RET_FAILURE;
+}
+
+static int do_efusew(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int idx;
+	int ret;
+	unsigned int size;
+	unsigned char buf[128] = { 0 };
+
+	_cc_trace("argc=%d\n", argc);
+
+	if (argc != 2 && argc != 3)
+		return CMD_RET_USAGE;
+
+	_cc_trace("Write eFuse: %s=%s\n", argv[1], argv[2]);
+	idx = find_efuse_by_name(argv[1]);
+	if (idx < 0)
+		return CMD_RET_USAGE;
+
+	_cc_trace("idx=%d %s\n", idx, efuse_index[idx]);
+	printf("Write eFuse %s(%d) with:\n", efuse_index[idx], idx);
+
+	if (idx < CVI_EFUSE_AREA_LAST) {
+		if (argc != 3)
+			return CMD_RET_USAGE;
+
+		size = hex2bytes(argv[2], buf, sizeof(buf));
+		if (size <= 0)
+			return CMD_RET_USAGE;
+
+		print_buffer(0, buf, 1, size, 0);
+
+		if (CVI_EFUSE_GetSize(idx, &size) < 0)
+			return CMD_RET_FAILURE;
+
+		_cc_trace("size=%d\n", size);
+
+		ret = CVI_EFUSE_Write(idx, buf, size);
+		if (ret < 0) {
+			printf("Failed to write %s\n", efuse_index[idx]);
+			return CMD_RET_FAILURE;
+		}
+
+		return 0;
+
+	} else if (idx < CVI_EFUSE_LOCK_LAST) {
+		if (CVI_EFUSE_Lock(idx) < 0) {
+			printf("Failed to lock %s\n", efuse_index[idx]);
+			return CMD_RET_FAILURE;
+		}
+
+		printf("%s is locked\n", efuse_index[idx]);
+		return 0;
+	} else if (idx < CVI_EFUSE_LOCK_WRITE_LAST) {
+		if (CVI_EFUSE_LockWrite(idx) < 0) {
+			printf("Failed to lock write %s\n", efuse_index[idx]);
+			return CMD_RET_FAILURE;
+		}
+
+		printf("%s is locked\n", efuse_index[idx]);
+		return 0;
+
+	} else if (idx == CVI_EFUSE_SECUREBOOT) {
+		ret = CVI_EFUSE_EnableSecureBoot();
+		printf("Enabled Secure Boot is %s\n", ret >= 0 ? "success" : "failed");
+		return 0;
+	}
+
+	return CMD_RET_FAILURE;
+}
+
+static int do_efusew_word(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	uint32_t addr, value;
+	int ret = -1;
+
+	if (argc != 3)
+		return CMD_RET_USAGE;
+
+	addr = simple_strtoul(argv[1], NULL, 0);
+	value = simple_strtoul(argv[2], NULL, 0);
+
+	printf("Write eFuse: 0x%04x=0x%08x\n", addr, value);
+
+	ret = cvi_efuse_write(addr, value);
+
+	if (ret < 0) {
+		printf("ERROR: ret=%d\n", ret);
+		return CMD_RET_FAILURE;
+	}
+
+	return 0;
+}
+
+static int do_efuser_dump(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int i;
+	uint32_t buf[EFUSE_SIZE / sizeof(uint32_t)];
+
+	for (i = 0; i < ARRAY_SIZE(buf); i++)
+		buf[i] = cvi_efuse_read_from_shadow(i * sizeof(uint32_t));
+
+	print_buffer(0, buf, 1, sizeof(buf), 16);
+
+	return 0;
+}
+
+U_BOOT_CMD(efuser, 9, 1, do_efuser, "Read efuse",
+	   "[args..]\n"
+	   "    - args ...");
+
+U_BOOT_CMD(efusew, 9, 1, do_efusew, "Write efuse",
+	   "[args..]\n"
+	   "    - args ...");
+
+U_BOOT_CMD(efusew_word, 9, 1, do_efusew_word, "Write word to efuse",
+	   "efusew_word addr value\n"
+	   "    - args ...");
+
+U_BOOT_CMD(efuser_dump, 9, 1, do_efuser_dump, "Read/Dump efuse",
+	   "do_efuser_dump\n"
+	   "    - args ...");
\ No newline at end of file
diff --git a/cmd/mmc.c b/cmd/mmc.c
index f1e30d0cf..bee9551ec 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -13,6 +13,8 @@
 #include <part.h>
 #include <sparse_format.h>
 #include <image-sparse.h>
+#include <div64.h>
+#include <linux/math64.h>
 
 static int curr_device = -1;
 
@@ -341,6 +343,7 @@ static int do_mmc_read(struct cmd_tbl *cmdtp, int flag,
 	struct mmc *mmc;
 	u32 blk, cnt, n;
 	void *addr;
+	ulong start_time, delta;
 
 	if (argc != 4)
 		return CMD_RET_USAGE;
@@ -355,9 +358,17 @@ static int do_mmc_read(struct cmd_tbl *cmdtp, int flag,
 
 	printf("\nMMC read: dev # %d, block # %d, count %d ... ",
 	       curr_device, blk, cnt);
-
+	start_time = get_timer(0);
 	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
-	printf("%d blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+	delta = get_timer(start_time);
+	printf("%d blocks read: %s in %lu ms", n, (n == cnt) ? "OK" : "ERROR", delta);
+
+	if (delta > 0) {
+		puts(" (");
+		print_size(div_u64(n * 512, delta) * 1000, "/s");
+		puts(")");
+	}
+	puts("\n");
 
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
@@ -434,6 +445,7 @@ static int do_mmc_write(struct cmd_tbl *cmdtp, int flag,
 	struct mmc *mmc;
 	u32 blk, cnt, n;
 	void *addr;
+	ulong start_time, delta;
 
 	if (argc != 4)
 		return CMD_RET_USAGE;
@@ -453,8 +465,16 @@ static int do_mmc_write(struct cmd_tbl *cmdtp, int flag,
 		printf("Error: card is write protected!\n");
 		return CMD_RET_FAILURE;
 	}
+	start_time = get_timer(0);
 	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
-	printf("%d blocks written: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+	delta = get_timer(start_time);
+	printf("%d blocks written: %s in %lu ms", n, (n == cnt) ? "OK" : "ERROR", delta);
+	if (delta > 0) {
+		puts(" (");
+		print_size(div_u64(n * 512, delta) * 1000, "/s");
+		puts(")");
+	}
+	puts("\n");
 
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
@@ -464,6 +484,7 @@ static int do_mmc_erase(struct cmd_tbl *cmdtp, int flag,
 {
 	struct mmc *mmc;
 	u32 blk, cnt, n;
+	ulong start_time, delta;
 
 	if (argc != 3)
 		return CMD_RET_USAGE;
@@ -482,8 +503,16 @@ static int do_mmc_erase(struct cmd_tbl *cmdtp, int flag,
 		printf("Error: card is write protected!\n");
 		return CMD_RET_FAILURE;
 	}
+	start_time = get_timer(0);
 	n = blk_derase(mmc_get_blk_desc(mmc), blk, cnt);
-	printf("%d blocks erased: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+	delta = get_timer(start_time);
+	printf("%d blocks erased: %s in %lu ms ", n, (n == cnt) ? "OK" : "ERROR", delta);
+	if (delta > 0) {
+		puts(" (");
+		print_size(div_u64(n * 512, delta) * 1000, "/s");
+		puts(")");
+	}
+	puts("\n");
 
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
@@ -585,6 +614,30 @@ static int do_mmc_dev(struct cmd_tbl *cmdtp, int flag,
 	return CMD_RET_SUCCESS;
 }
 
+static int do_mmc_fuse_rstn(struct cmd_tbl *cmdtp, int flag,
+			    int argc, char *const argv[])
+{
+	int dev, ret;
+	struct mmc *mmc;
+
+	if (argc == 2) {
+		dev = (int)dectoul(argv[1], NULL);
+		mmc = init_mmc_device(dev, true);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	ret = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_RST_N_FUNCTION, 0x1);
+	printf("Set RST_N = 0x1 ret: %d\n", ret);
+	if (ret)
+		return 1;
+
+	return CMD_RET_SUCCESS;
+}
+
 static int do_mmc_list(struct cmd_tbl *cmdtp, int flag,
 		       int argc, char *const argv[])
 {
@@ -1019,6 +1072,7 @@ static struct cmd_tbl cmd_mmc[] = {
 	U_BOOT_CMD_MKENT(rescan, 2, 1, do_mmc_rescan, "", ""),
 	U_BOOT_CMD_MKENT(part, 1, 1, do_mmc_part, "", ""),
 	U_BOOT_CMD_MKENT(dev, 4, 0, do_mmc_dev, "", ""),
+	U_BOOT_CMD_MKENT(fuse_rstn, 2, 0, do_mmc_fuse_rstn, "", ""),
 	U_BOOT_CMD_MKENT(list, 1, 1, do_mmc_list, "", ""),
 #if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
 	U_BOOT_CMD_MKENT(hwpartition, 28, 0, do_mmc_hwpartition, "", ""),
diff --git a/cmd/nand.c b/cmd/nand.c
index d381053c6..6daa3ea0b 100644
--- a/cmd/nand.c
+++ b/cmd/nand.c
@@ -393,6 +393,11 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 	int dev = nand_curr_device;
 	int repeat = flag & CMD_FLAG_REPEAT;
 
+	ulong start;
+	int temp;
+
+	start = get_timer(0);
+
 	/* at least two arguments please */
 	if (argc < 2)
 		goto usage;
@@ -621,7 +626,7 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 				ret = nand_write_skip_bad(mtd, off, &rwsize,
 							  NULL, maxsize,
 							  (u_char *)addr,
-							  WITH_WR_VERIFY);
+							  0);
 #ifdef CONFIG_CMD_NAND_TRIMFFS
 		} else if (!strcmp(s, ".trimffs")) {
 			if (read) {
@@ -655,6 +660,9 @@ static int do_nand(struct cmd_tbl *cmdtp, int flag, int argc,
 		printf(" %zu bytes %s: %s\n", rwsize,
 		       read ? "read" : "written", ret ? "ERROR" : "OK");
 
+		temp = rwsize / get_timer(start);
+		printf("nand %s speed %d.%d MB/s\n", argv[0], temp / 1000, (temp - (temp / 1000) * 1000));
+
 		return ret == 0 ? 0 : 1;
 	}
 
diff --git a/cmd/net.c b/cmd/net.c
index 651c1411f..c54367abe 100644
--- a/cmd/net.c
+++ b/cmd/net.c
@@ -17,7 +17,9 @@
 #include <net/udp.h>
 #include <net/sntp.h>
 
-static int netboot_common(enum proto_t, struct cmd_tbl *, int, char * const []);
+static int __attribute__((unused)) netboot_common(enum proto_t,
+						  struct cmd_tbl *,
+						  int, char * const []);
 
 #ifdef CONFIG_CMD_BOOTP
 static int do_bootp(struct cmd_tbl *cmdtp, int flag, int argc,
@@ -191,8 +193,9 @@ static void netboot_update_env(void)
 #endif
 }
 
-static int netboot_common(enum proto_t proto, struct cmd_tbl *cmdtp, int argc,
-			  char *const argv[])
+static int __attribute__((unused)) netboot_common(enum proto_t proto,
+						  struct cmd_tbl *cmdtp,
+						  int argc, char *const argv[])
 {
 	char *s;
 	char *end;
diff --git a/cmd/sf.c b/cmd/sf.c
index eac27ed2d..5145f9f84 100644
--- a/cmd/sf.c
+++ b/cmd/sf.c
@@ -172,6 +172,7 @@ static const char *spi_flash_update_block(struct spi_flash *flash, u32 offset,
 		size_t len, const char *buf, char *cmp_buf, size_t *skipped)
 {
 	char *ptr = (char *)buf;
+	u8 *tmp = NULL;
 
 	debug("offset=%#x, sector_size=%#x, len=%#zx\n",
 	      offset, flash->sector_size, len);
@@ -190,6 +191,10 @@ static const char *spi_flash_update_block(struct spi_flash *flash, u32 offset,
 		return "erase";
 	/* If it's a partial sector, copy the data into the temp-buffer */
 	if (len != flash->sector_size) {
+		for (int i = 0; i < flash->sector_size; i++) {
+			tmp = (u8 *)cmp_buf;
+			tmp[i] = 0xff;
+		}
 		memcpy(cmp_buf, buf, len);
 		ptr = cmp_buf;
 	}
@@ -268,6 +273,10 @@ static int do_spi_flash_read_write(int argc, char *const argv[])
 	int ret = 1;
 	int dev = 0;
 	loff_t offset, len, maxsize;
+	ulong start;
+	int temp = 0;
+
+	start = get_timer(0);
 
 	if (argc < 3)
 		return -1;
@@ -313,6 +322,9 @@ static int do_spi_flash_read_write(int argc, char *const argv[])
 			printf("OK\n");
 	}
 
+	temp = len / get_timer(start);
+	printf("sf %s speed %d.%d MB/s\n", argv[0], temp / 1000, (temp - (temp / 1000) * 1000));
+
 	unmap_physmem(buf, len);
 
 	return ret == 0 ? 0 : 1;
diff --git a/common/Kconfig.boot b/common/Kconfig.boot
index 902a5b8fb..46a6050a5 100644
--- a/common/Kconfig.boot
+++ b/common/Kconfig.boot
@@ -329,7 +329,7 @@ config HAVE_SYS_TEXT_BASE
 	bool
 	depends on !NIOS2 && !XTENSA
 	depends on !EFI_APP
-	default y
+	default n
 
 config SYS_TEXT_BASE
 	depends on HAVE_SYS_TEXT_BASE
diff --git a/common/autoboot.c b/common/autoboot.c
index 5bb2e1908..eb3dd751e 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -486,6 +486,7 @@ void autoboot_command(const char *s)
 		if (lock)
 			prev = disable_ctrlc(1); /* disable Ctrl-C checking */
 
+		board_save_time_record(TIME_RECORDS_FIELD_BOOTCMD_START);
 		run_command_list(s, -1, 0);
 
 		if (lock)
diff --git a/common/board_f.c b/common/board_f.c
index f2746537c..85bcec66e 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -359,6 +359,15 @@ static int setup_dest_addr(void)
 	return 0;
 }
 
+#if (CONFIG_SYS_RESVIONSZ != 0)
+static int reserve_ion(void)
+{
+	gd->relocaddr -= CONFIG_SYS_RESVIONSZ;
+	debug("Reserving %dk for ion buffer at %08lx\n", (CONFIG_SYS_RESVIONSZ >> 16), gd->relocaddr);
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_PRAM
 /* reserve protected RAM */
 static int reserve_pram(void)
@@ -472,8 +481,8 @@ static int reserve_noncached(void)
 		MMU_SECTION_SIZE;
 	gd->start_addr_sp -= ALIGN(CONFIG_SYS_NONCACHED_MEMORY,
 				   MMU_SECTION_SIZE);
-	debug("Reserving %dM for noncached_alloc() at: %08lx\n",
-	      CONFIG_SYS_NONCACHED_MEMORY >> 20, gd->start_addr_sp);
+	debug("Reserving %lldM for noncached_alloc() at: %08lx\n",
+	      (long long)(CONFIG_SYS_NONCACHED_MEMORY >> 20), gd->start_addr_sp);
 
 	return 0;
 }
@@ -734,6 +743,7 @@ static int jump_to_copy(void)
 	arch_setup_gd(gd->new_gd);
 	board_init_f_r_trampoline(gd->start_addr_sp);
 #else
+	printf("gd->relocaddr=0x%lx. offset=0x%lx\n", gd->relocaddr, gd->relocaddr - CONFIG_SYS_TEXT_BASE);
 	relocate_code(gd->start_addr_sp, gd->new_gd, gd->relocaddr);
 #endif
 
@@ -905,6 +915,10 @@ static const init_fnc_t init_sequence_f[] = {
 	 *  - board info struct
 	 */
 	setup_dest_addr,
+#if (CONFIG_SYS_RESVIONSZ != 0)
+	reserve_ion,
+#endif
+
 #ifdef CONFIG_OF_BOARD_FIXUP
 	fix_fdt,
 #endif
diff --git a/common/board_r.c b/common/board_r.c
index 630c2451a..915f922e6 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -661,9 +661,6 @@ static init_fnc_t init_sequence_r[] = {
 	stdio_init_tables,
 	serial_initialize,
 	initr_announce,
-#if CONFIG_IS_ENABLED(WDT)
-	initr_watchdog,
-#endif
 	INIT_FUNC_WATCHDOG_RESET
 #if defined(CONFIG_NEEDS_MANUAL_RELOC) && defined(CONFIG_BLOCK_CACHE)
 	blkcache_init,
@@ -689,6 +686,9 @@ static init_fnc_t init_sequence_r[] = {
 #endif
 #ifdef CONFIG_ARCH_EARLY_INIT_R
 	arch_early_init_r,
+#endif
+#if CONFIG_IS_ENABLED(WDT)
+	initr_watchdog,
 #endif
 	power_init_board,
 #ifdef CONFIG_MTD_NOR_FLASH
diff --git a/common/image.c b/common/image.c
index 59c52a1f9..0cad38503 100644
--- a/common/image.c
+++ b/common/image.c
@@ -17,6 +17,7 @@
 #include <asm/cache.h>
 #include <u-boot/crc.h>
 #include <watchdog.h>
+#include <time.h>
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 #include <status_led.h>
@@ -444,10 +445,19 @@ int image_decomp(int comp, ulong load, ulong image_start, int type,
 		 uint unc_len, ulong *load_end)
 {
 	int ret = 0;
+#ifndef USE_HOSTCC
+	ulong start;
+#endif
 
 	*load_end = load;
 	print_decomp_msg(comp, type, load == image_start);
 
+#ifndef USE_HOSTCC
+	// Save decompression start time
+	board_save_time_record(TIME_RECORDS_FIELD_DECOMPRESS_KERNEL_START);
+	start = get_timer(0);
+#endif
+
 	/*
 	 * Load the image to the right place, decompressing if needed. After
 	 * this, image_len will be set to the number of uncompressed bytes
@@ -581,6 +591,10 @@ int image_decomp(int comp, ulong load, ulong image_start, int type,
 
 	*load_end = load + image_len;
 
+#ifndef USE_HOSTCC
+	printf("   Decompressing %lu bytes used %lums\n", image_len, get_timer(start));
+#endif
+
 	return ret;
 }
 
diff --git a/cvitek.mk b/cvitek.mk
new file mode 100644
index 000000000..dccb84850
--- /dev/null
+++ b/cvitek.mk
@@ -0,0 +1,51 @@
+ifeq (${UBOOT_VBOOT}, 1)
+KBUILD_CPPFLAGS += -DUBOOT_VBOOT
+endif
+
+ifeq (${CONFIG_SKIP_RAMDISK},y)
+KBUILD_CPPFLAGS += -DCONFIG_SKIP_RAMDISK=${CONFIG_SKIP_RAMDISK}
+endif
+
+ifeq (${CONFIG_USE_DEFAULT_ENV},y)
+KBUILD_CPPFLAGS += -DCONFIG_USE_DEFAULT_ENV=${CONFIG_USE_DEFAULT_ENV}
+endif
+
+ifeq (${STORAGE_TYPE}, spinand)
+KBUILD_CFLAGS += -DCONFIG_NAND_SUPPORT
+KBUILD_CFLAGS += -DSPINAND_SQSH
+endif
+
+ifeq (${STORAGE_TYPE}, emmc)
+KBUILD_CFLAGS += -DCONFIG_EMMC_SUPPORT
+endif
+
+ifeq (${STORAGE_TYPE}, sd)
+KBUILD_CFLAGS += -DCONFIG_SD_BOOT
+endif
+
+ifeq (${RELEASE}, 1)
+KBUILD_CPPFLAGS += -DRELEASE
+endif
+
+cvichip = $(shell echo $(CHIP) | tr a-z A-Z)
+cviboard = $(shell echo $(CVIBOARD) | tr a-z A-Z)
+KBUILD_CPPFLAGS += -DCVICHIP=${CHIP}
+KBUILD_CPPFLAGS += -DCVIBOARD=${CVIBOARD} -D${cvichip}_${cviboard}
+
+ifneq (${PANEL_TUNING_PARAM},)
+cvi_panel = $(shell echo $(PANEL_TUNING_PARAM) | tr a-z A-Z)
+KBUILD_CPPFLAGS += -D${cvi_panel}
+KBUILD_CPPFLAGS += $(if $(findstring I80,$(cvi_panel)),-D${cvichip}_${cviboard}_I80,)
+endif
+
+ifneq (${PANEL_LANE_NUM_TUNING_PARAM},)
+KBUILD_CPPFLAGS += -D$(shell echo $(PANEL_LANE_NUM_TUNING_PARAM) | tr a-z A-Z)
+endif
+
+ifneq (${PANEL_LANE_SWAP_TUNING_PARAM},)
+KBUILD_CPPFLAGS += -D$(shell echo $(PANEL_LANE_SWAP_TUNING_PARAM) | tr a-z A-Z)
+endif
+
+KBUILD_CPPFLAGS += $(if $(findstring CV183X,$(CHIP_ARCH)),-DBOOTLOGO_ISP_RESET,)
+
+KBUILD_CFLAGS += -I$(srctree)/include/cvitek
diff --git a/drivers/adc/Kconfig b/drivers/adc/Kconfig
index e719c38bb..5e99dbf3f 100644
--- a/drivers/adc/Kconfig
+++ b/drivers/adc/Kconfig
@@ -11,6 +11,15 @@ config ADC
 	  - support supply's phandle with auto-enable
 	  - supply polarity setting in fdt
 
+config ADC_CVITEK
+	bool "Enable cvitek ADC driver"
+	help
+	  This enables basic driver for cvitek ADC compatible with cvitek soc.
+	  It provides:
+	  - 3 analog input channels
+	  - 12-bit resolution
+	  - 320 KSPS of sample rate
+
 config ADC_EXYNOS
 	bool "Enable Exynos 54xx ADC driver"
 	help
diff --git a/drivers/adc/Makefile b/drivers/adc/Makefile
index c1387f3a3..fa08de34d 100644
--- a/drivers/adc/Makefile
+++ b/drivers/adc/Makefile
@@ -5,6 +5,7 @@
 #
 
 obj-$(CONFIG_ADC) += adc-uclass.o
+obj-$(CONFIG_ADC_CVITEK) += cvitek-adc.o
 obj-$(CONFIG_ADC_EXYNOS) += exynos-adc.o
 obj-$(CONFIG_ADC_SANDBOX) += sandbox.o
 obj-$(CONFIG_SARADC_ROCKCHIP) += rockchip-saradc.o
diff --git a/drivers/adc/adc-uclass.c b/drivers/adc/adc-uclass.c
index 67137ffb3..e89fbfc64 100644
--- a/drivers/adc/adc-uclass.c
+++ b/drivers/adc/adc-uclass.c
@@ -22,7 +22,7 @@
 #define CHECK_MASK			(!CHECK_NUMBER)
 
 /* TODO: add support for timer uclass (for early calls) */
-#ifdef CONFIG_SANDBOX_ARCH
+#if defined(CONFIG_SANDBOX_ARCH) || defined(CONFIG_ADC_CVITEK)
 #define sdelay(x)	udelay(x)
 #else
 extern void sdelay(unsigned long loops);
diff --git a/drivers/adc/cvitek-adc.c b/drivers/adc/cvitek-adc.c
new file mode 100644
index 000000000..f99471e69
--- /dev/null
+++ b/drivers/adc/cvitek-adc.c
@@ -0,0 +1,219 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2022 cvitek All rights reserved.
+ * Author: jinyu zhao <jinyu.zhaok@cvitek.com>
+ *
+ * cvitek SARADC driver for U-Boot
+ */
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <adc.h>
+#include <asm/io.h>
+
+#define CVITEK_ADC_MAX_CHANNELS 6
+#define CVITEK_ADC_DATA_BITS 12
+
+enum channel {
+	/* Top domain ADC ch1, ch2, ch3 */
+	ADC1 = 1,
+	ADC2,
+	ADC3,
+	/* no die domain ADC ch1, ch2, ch3 */
+	PWR_ADC1,/* ADC4 <== PWR_GPIO2 */
+	PWR_ADC2,/* ADC5 <== PWR_GPIO1 */
+	PWR_ADC3,/* ADC6 <== PWR_VBAT_DET */
+};
+
+struct cvitek_adc_regs {
+	unsigned int reserved_1[1];
+	unsigned int ctrl;/* 0x04 */
+	unsigned int status;/* 0x08 */
+	unsigned int cyc_set;/* 0x0c */
+	unsigned int reserved_2[1];
+	unsigned int ch1_result;/* 0x14 */
+	unsigned int ch2_result;/* 0x18 */
+	unsigned int ch3_result;/* 0x1c */
+	unsigned int intr_en;/* 0x20 */
+	unsigned int intr_clr;/* 0x24 */
+	unsigned int intr_sta;/* 0x28 */
+	unsigned int intr_raw;/* 0x2c */
+};
+
+struct cvitek_adc_priv {
+	struct udevice *dev;		/* Device, NULL for invalid adc */
+	void __iomem	*top_domain_base;
+	void __iomem	*rtc_domain_base;
+	int active_channel;
+};
+
+static void cvitek_adc_cyc_setting(struct cvitek_adc_regs *regs)
+{
+	uint32_t value;
+
+	value = readl(&regs->cyc_set);
+	value &= ~(0xf << 12);
+	value |= (0xf << 12);//set saradc clock cycle=840ns
+	writel(value, &regs->cyc_set);
+}
+
+int cvitek_adc_channel_data(struct udevice *dev, int channel,
+			    unsigned int *data)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct cvitek_adc_priv *priv = dev_get_priv(dev);
+	struct cvitek_adc_regs *regs;
+	unsigned int value;
+
+	if (channel != priv->active_channel) {
+		pr_err("Requested channel is not active!");
+		return -EINVAL;
+	}
+
+	switch (channel) {
+	case ADC1:
+	case ADC2:
+	case ADC3:
+		regs = (struct cvitek_adc_regs *)priv->top_domain_base;
+		break;
+	case PWR_ADC1:
+	case PWR_ADC2:
+	case PWR_ADC3:
+		regs = (struct cvitek_adc_regs *)priv->rtc_domain_base;
+		break;
+	}
+
+	// Trigger measurement
+	value = readl(&regs->ctrl);
+	writel(value | 0x1, &regs->ctrl);
+
+	// Check busy status
+	while (readl(&regs->status) & 0x1)
+		;
+
+	switch (channel) {
+	case PWR_ADC1:
+	case ADC1:
+		value = readl(&regs->ch1_result) & uc_pdata->data_mask;
+		break;
+	case PWR_ADC2:
+	case ADC2:
+		value = readl(&regs->ch2_result) & uc_pdata->data_mask;
+		break;
+	case PWR_ADC3:
+	case ADC3:
+		value = readl(&regs->ch3_result) & uc_pdata->data_mask;
+		break;
+	}
+
+	*data = value;
+
+	return 0;
+}
+
+int cvitek_adc_start_channel(struct udevice *dev, int channel)
+{
+	struct cvitek_adc_priv *priv = dev_get_priv(dev);
+	struct cvitek_adc_regs *regs;
+	unsigned int value;
+
+	priv->active_channel = channel;
+
+	switch (channel) {
+	case ADC1:
+	case ADC2:
+	case ADC3:
+		regs = (struct cvitek_adc_regs *)priv->top_domain_base;
+		break;
+	case PWR_ADC1:
+	case PWR_ADC2:
+	case PWR_ADC3:
+		channel -= 3;
+		regs = (struct cvitek_adc_regs *)priv->rtc_domain_base;
+		break;
+	}
+
+	// Disable saradc interrupt
+	writel(0x0, &regs->intr_en);
+
+	// Set saradc cycle
+	cvitek_adc_cyc_setting(regs);
+
+	// Set channel
+	value = readl(&regs->ctrl);
+	writel(value | (1 << (4 + channel)),
+	       &regs->ctrl);
+
+	return 0;
+}
+
+int cvitek_adc_stop(struct udevice *dev)
+{
+	struct cvitek_adc_priv *priv = dev_get_priv(dev);
+	struct cvitek_adc_regs *top_regs, *rtcsyc_regs;
+	unsigned int value;
+
+	top_regs = (struct cvitek_adc_regs *)priv->top_domain_base;
+	rtcsyc_regs = (struct cvitek_adc_regs *)priv->rtc_domain_base;
+
+	// disable measurement
+	value = readl(&top_regs->ctrl);
+	writel(value & ~0x1, &top_regs->ctrl);
+	value = readl(&rtcsyc_regs->ctrl);
+	writel(value & ~0x1, &rtcsyc_regs->ctrl);
+
+	priv->active_channel = -1;
+
+	return 0;
+}
+
+int cvitek_adc_probe(struct udevice *dev)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct cvitek_adc_priv *priv = dev_get_priv(dev);
+	fdt_addr_t base;
+
+	base = dev_read_addr_index(dev, 0);
+	if (base == FDT_ADDR_T_NONE) {
+		pr_err("Can't get the top SARADC register base address\n");
+		return -ENXIO;
+	}
+	priv->top_domain_base = (void *)base;
+	base = dev_read_addr_index(dev, 1);
+	if (base == FDT_ADDR_T_NONE) {
+		pr_err("Can't get the rtcsys SARADC register base address\n");
+		return -ENXIO;
+	}
+	priv->rtc_domain_base = (void *)base;
+
+	priv->dev = dev;
+	priv->active_channel = -1;
+
+	uc_pdata->data_mask = (1 << CVITEK_ADC_DATA_BITS) - 1;
+	uc_pdata->data_format = 0;
+	uc_pdata->data_timeout_us = 15;
+	/* Mask available channel bits: [1:5] */
+	uc_pdata->channel_mask = (2 << CVITEK_ADC_MAX_CHANNELS) - 2;
+
+	return 0;
+}
+
+static const struct adc_ops cvitek_adc_ops = {
+	.start_channel = cvitek_adc_start_channel,
+	.channel_data = cvitek_adc_channel_data,
+	.stop = cvitek_adc_stop,
+};
+
+static const struct udevice_id cvitek_adc_ids[] = {
+	{ .compatible = "cvitek,saradc" },
+	{ }
+};
+
+U_BOOT_DRIVER(cvitek_adc) = {
+	.name		= "cvitek-adc",
+	.id		= UCLASS_ADC,
+	.of_match	= cvitek_adc_ids,
+	.ops		= &cvitek_adc_ops,
+	.probe		= cvitek_adc_probe,
+	.priv_auto	= sizeof(struct cvitek_adc_priv),
+};
diff --git a/drivers/cvi_usb/Makefile b/drivers/cvi_usb/Makefile
new file mode 100644
index 000000000..be5963391
--- /dev/null
+++ b/drivers/cvi_usb/Makefile
@@ -0,0 +1,5 @@
+obj-y := utask/cv181x/cvi_usb.o
+obj-y += utask/cv181x/cps_cvi.o
+obj-y += utask/cv181x/cvi_udc_otg.o
+obj-y += utask/cv181x/cvi_udc_otg_xfer_dma.o
+obj-y += utask/cv181x/usb_tty.o
diff --git a/drivers/cvi_usb/utask/cv181x/cps_cvi.c b/drivers/cvi_usb/utask/cv181x/cps_cvi.c
new file mode 100644
index 000000000..52caa9f74
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/cps_cvi.c
@@ -0,0 +1,46 @@
+#include <common.h>
+#include <linux/types.h>
+#include <stdlib.h>
+#include <cpu_func.h>
+
+/* see dps.h */
+uint32_t cvi_uncached_read32(uint32_t *address)
+{
+	return *address;
+}
+
+/* see dps.h */
+void cvi_uncached_write32(uint32_t value, uint32_t *address)
+{
+	*address = value;
+}
+
+/* see dps.h */
+void cvi_buffer_copy(uint8_t *dst, uint8_t *src, uint32_t size)
+{
+	memcpy((void *)dst, (void *)src, size);
+}
+
+/* Since this is a bare-metal system, with no MMU in place, we expect that there will be no cache enabled */
+
+void cvi_cache_invalidate(uintptr_t address, size_t size)
+{
+#ifdef TENSILICA
+	xthal_dcache_region_invalidate(address, size);
+#else
+	invalidate_dcache_range(address, address + ROUND(size, CONFIG_SYS_CACHELINE_SIZE));
+#endif
+}
+
+void cvi_cache_flush(uintptr_t address, size_t size)
+{
+#ifdef TENSILICA
+	xthal_dcache_region_writeback(address, size);
+#else
+	flush_dcache_range(address, address + ROUND(size, CONFIG_SYS_CACHELINE_SIZE));
+#endif
+}
+
+void cvi_delay_ns(uint32_t ns)
+{
+}
diff --git a/drivers/cvi_usb/utask/cv181x/cvi_udc_otg.c b/drivers/cvi_usb/utask/cv181x/cvi_udc_otg.c
new file mode 100644
index 000000000..405b8e2aa
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/cvi_udc_otg.c
@@ -0,0 +1,1117 @@
+/*
+ * drivers/usb/gadget/cvi_udc_otg.c
+ * Designware CVI on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2008 for Samsung Electronics
+ *
+ * BSP Support for Samsung's UDC driver
+ * available at:
+ * git://git.kernel.org/pub/scm/linux/kernel/git/kki_ap/linux-2.6-samsung.git
+ *
+ * State machine bugfixes:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ *
+ * Ported to u-boot:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ * Lukasz Majewski <l.majewski@samsumg.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <stdlib.h>
+#include "include/cvi_ch9.h"
+#include "include/cvi_drv_if.h"
+#include "include/byteorder.h"
+#include "include/cvi_stdtypes.h"
+#include "include/cvi_errno.h"
+#include "include/cvi_udc_otg_regs.h"
+#include "include/cvi_udc_otg_priv.h"
+#include "include/cvi_udc.h"
+#include "include/dps.h"
+
+/***********************************************************/
+#define DRIVER_VERSION "15 March 2009"
+
+static const char ep0name[] = "ep0-control";
+static const char ep1name[] = "ep1in-bulk";
+static const char ep2name[] = "ep2out-bulk";
+static const char ep3name[] = "ep3in-int";
+
+static struct cvi_udc	*the_controller;
+
+static const char driver_name[] = "cvi-udc";
+
+/*
+ * Local declarations.
+ */
+
+static int cvi_ep_enable(struct usb_ep *ep,
+			  const CH9_UsbEndpointDescriptor *);
+static int cvi_ep_disable(struct usb_ep *ep);
+static struct usb_request *cvi_alloc_request(struct usb_ep *ep);
+static void cvi_free_request(struct usb_ep *ep, struct usb_request *);
+
+static int cvi_dequeue(struct usb_ep *ep, struct usb_request *);
+static int cvi_fifo_status(struct usb_ep *ep);
+static void cvi_fifo_flush(struct usb_ep *ep);
+static void stop_activity(struct cvi_udc *dev,
+			  struct usb_gadget_driver *driver);
+static int udc_enable(struct cvi_udc *dev);
+static void cvi_usbd_init(struct cvi_udc *dev);
+static void udc_reinit(struct cvi_udc *dev);
+static int _cvi_ep_disable(struct cvi_ep *ep);
+
+#undef CVI_LOG
+
+#if defined(CVI_LOG)
+
+#define CVI_LOG_ENTRY_NUM	1024
+
+struct cvi_log_s {
+	uint32_t time;
+	uint32_t tag;
+	uint32_t param1;
+	uint32_t param2;
+	uint32_t param3;
+	uint32_t param4;
+};
+
+static unsigned int log_idx;
+static struct cvi_log_s cvi_log[CVI_LOG_ENTRY_NUM];
+
+void cvi_log_write(uint32_t tag, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4)
+{
+	//if (log_idx == CVI_LOG_ENTRY_NUM)
+	//	return;
+
+	cvi_log[log_idx].tag = tag;
+	cvi_log[log_idx].param1 = param1;
+	cvi_log[log_idx].param2 = param2;
+	cvi_log[log_idx].param3 = param3;
+	cvi_log[log_idx].param4 = param4;
+	cvi_log[log_idx].time = timer_get_us() / 1000;
+
+	log_idx++;
+	log_idx = log_idx % CVI_LOG_ENTRY_NUM;
+}
+
+void set_trigger_cnt(int cnt)
+{
+	static int test_reset;
+	uint32_t *test_ptr = (uint32_t *)0x85000000;
+
+	if (test_reset == cnt)
+		*test_ptr = 0xAAA;
+	test_reset++;
+}
+
+#else
+
+void cvi_log_write(uint32_t tag, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4)
+{
+}
+
+void set_trigger_cnt(int cnt)
+{
+}
+
+#endif
+
+static struct usb_ep_ops cvi_ep_ops = {
+	.enable = cvi_ep_enable,
+	.disable = cvi_ep_disable,
+
+	.alloc_request = cvi_alloc_request,
+	.free_request = cvi_free_request,
+
+	.queue = cvi_queue,
+	.dequeue = cvi_dequeue,
+
+	.set_halt = cvi_udc_set_halt,
+	.fifo_status = cvi_fifo_status,
+	.fifo_flush = cvi_fifo_flush,
+};
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+/***********************************************************/
+
+const char *cvi_get_ep0_name(void)
+{
+	return ep0name;
+}
+
+static struct cvi_usbotg_reg *reg;
+
+__weak void otg_phy_init(struct cvi_udc *dev) {}
+__weak void otg_phy_off(struct cvi_udc *dev) {}
+
+/***********************************************************/
+
+//#include "cvi_udc_otg_xfer_dma.c"
+
+/***********************************************************/
+/*
+ *	udc_disable - disable USB device controller
+ */
+static void udc_disable(struct cvi_udc *dev)
+{
+	cvidbg_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);
+
+	cvi_set_address(dev, 0);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = CH9_USB_SPEED_UNKNOWN;
+	dev->usb_address = 0;
+
+	otg_phy_off(dev);
+}
+
+/*
+ *	udc_reinit - initialize software state
+ */
+static void udc_reinit(struct cvi_udc *dev)
+{
+	unsigned int i;
+
+	cvidbg_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	/* basic endpoint records init */
+	for (i = 0; i < CVI_MAX_ENDPOINTS; i++) {
+		struct cvi_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->pio_irqs = 0;
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+
+#define BYTES2MAXP(x)	((x) / 8)
+#define MAXP2BYTES(x)	((x) * 8)
+
+/* until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static int udc_enable(struct cvi_udc *dev)
+{
+	cvidbg_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);
+
+	otg_phy_init(dev);
+	cvi_usbd_init(dev);
+	cvi_reconfig_usbd(dev, 0);
+
+	cvidbg_cond(DEBUG_SETUP != 0,
+		     "CVI USB 2.0 OTG Controller Core Initialized : 0x%x\n",
+		     cvi_uncached_read32(&reg->gintmsk));
+
+	dev->gadget.speed = CH9_USB_SPEED_UNKNOWN;
+
+	return 0;
+}
+
+/*
+ * Register entry point for the peripheral controller driver.
+ */
+int cviusb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct cvi_udc *dev = the_controller;
+	int retval = 0;
+
+	cvidbg_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");
+
+	if (!driver ||
+	    (driver->speed != CH9_USB_SPEED_FULL &&
+	     driver->speed != CH9_USB_SPEED_HIGH) ||
+	    !driver->bind || !driver->disconnect ||
+	    !driver->setup || !driver->req_mem_alloc ||
+	    !driver->req_mem_free)
+		return -EINVAL;
+	if (!dev)
+		return -ENODEV;
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first hook up the driver ... */
+	dev->driver = driver;
+
+	if (retval) { /* TODO */
+		printf("target device_add failed, error %d\n", retval);
+		return retval;
+	}
+
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "%s: bind to driver --> error %d\n",
+			     dev->gadget.name, retval);
+		dev->driver = 0;
+		return retval;
+	}
+
+#if defined(USB_IRQ_MODE)
+	enable_irq(USB_IRQS_0);
+#endif
+	cvidbg_cond(DEBUG_SETUP != 0,
+		     "Registered gadget driver %s\n", dev->gadget.name);
+	udc_enable(dev);
+
+	return 0;
+}
+
+/*
+ * Unregister entry point for the peripheral controller driver.
+ */
+int cviusb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct cvi_udc *dev = the_controller;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	dev->driver = 0;
+	stop_activity(dev, driver);
+
+	driver->unbind(&dev->gadget);
+
+#if defined(USB_IRQ_MODE)
+	disable_irq(USB_IRQS_0);
+#endif
+
+	udc_disable(dev);
+	return 0;
+}
+
+/*
+ *	cvi_done - retire a request; caller blocked irqs
+ */
+void cvi_done(struct cvi_ep *ep, struct cvi_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+
+	cvidbg("%s: %s %p, req = %p, stopped = %d\n",
+		__func__, ep->ep.name, ep, &req->req, stopped);
+
+	list_del_init(&req->queue);
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN) {
+		cvidbg("complete %s req %p stat %d len %u/%u\n",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+	}
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+#ifdef DEBUG
+	printf("calling complete callback\n");
+	{
+		int i, len = req->req.length;
+
+		printf("pkt[%d] = ", req->req.length);
+		if (len > 64)
+			len = 64;
+		for (i = 0; i < len; i++) {
+			printf("%02x", ((uint8_t *)req->req.buf)[i]);
+			if ((i & 7) == 7)
+				printf(" ");
+		}
+		printf("\n");
+	}
+#endif
+	req->req.complete(&ep->ep, &req->req);
+
+	cvidbg("callback completed\n");
+
+	ep->stopped = stopped;
+}
+
+/*
+ *	cvi_nuke - dequeue ALL requests
+ */
+void cvi_nuke(struct cvi_ep *ep, int status)
+{
+	struct cvi_request *req;
+
+	cvidbg("%s: %s %p\n", __func__, ep->ep.name, ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct cvi_request, queue);
+		cvi_done(ep, req, status);
+	}
+}
+
+static void stop_activity(struct cvi_udc *dev,
+			  struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == CH9_USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = CH9_USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < CVI_MAX_ENDPOINTS; i++) {
+		struct cvi_ep *ep = &dev->ep[i];
+
+		ep->stopped = 1;
+		cvi_nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		driver->disconnect(&dev->gadget);
+	}
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+static void cvi_hsotg_init_fifo(struct cvi_udc *dev)
+{
+	uint32_t rx_fifo_sz, tx_fifo_sz, np_tx_fifo_sz;
+	int timeout, i;
+	uint32_t val;
+
+	if (cvi_hsotg_wait_bit_set(&reg->grstctl, AHBIDLE, 10000))
+		printf("%s:  HANG! AHB Idle GRSCTL\n", __func__);
+
+	/* setup fifos */
+	rx_fifo_sz = RX_FIFO_SIZE;
+	np_tx_fifo_sz = NPTX_FIFO_SIZE;
+	tx_fifo_sz = PTX_FIFO_SIZE;
+
+	/* Set Rx FIFO Size (in 32-bit words) */
+	cvi_uncached_write32(rx_fifo_sz, &reg->grxfsiz);
+
+	/* Set Non Periodic Tx FIFO Size (TXFIFO[0]) */
+	cvi_uncached_write32((np_tx_fifo_sz << 16) | rx_fifo_sz,
+			      &reg->gnptxfsiz);
+
+	for (i = 1; i < CVI_MAX_ENDPOINTS; i++)
+		cvi_uncached_write32((rx_fifo_sz + np_tx_fifo_sz + tx_fifo_sz * (i - 1)) |
+				      tx_fifo_sz << 16, &reg->dieptxf[i - 1]);
+
+	/* Flush all the FIFO's */
+	cvi_uncached_write32(TX_FIFO_FLUSH_ALL |
+			      TX_FIFO_FLUSH |
+			      RX_FIFO_FLUSH,
+			      &reg->grstctl);
+	timeout = 100;
+	while (1) {
+		val = cvi_uncached_read32(&reg->grstctl);
+
+		if ((val & (TX_FIFO_FLUSH | RX_FIFO_FLUSH)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			printf("%s: timeout flushing fifos (grstctl = 0x%x)\n",
+			       __func__, val);
+			break;
+		}
+		udelay(1);
+	}
+}
+
+static void cvi_hsotg_txfifo_flush(struct cvi_udc *dev, unsigned int idx)
+{
+	int timeout;
+	int val;
+
+	if (cvi_hsotg_wait_bit_set(&reg->grstctl, AHBIDLE, 10000))
+		printf("%s:  HANG! AHB Idle GRSCTL\n", __func__);
+
+	cvi_uncached_write32(TX_FIFO_NUMBER(idx) | TX_FIFO_FLUSH, &reg->grstctl);
+
+	/* wait until the fifo is flushed */
+	timeout = 100;
+
+	while (1) {
+		val = cvi_uncached_read32(&reg->grstctl);
+
+		if ((val & (TX_FIFO_FLUSH)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			printf("%s: timeout flushing fifo (GRSTCTL=%08x)\n",
+			       __func__, val);
+			break;
+		}
+
+		udelay(1);
+	}
+
+	/* Wait for at least 3 PHY Clocks */
+	udelay(1);
+}
+
+static void kill_all_requests(struct cvi_udc *dev, struct cvi_ep *ep, int result)
+{
+	uint32_t ep_num = ep_index(ep);
+	uint32_t size_max = (ep_num == 0) ? (NPTX_FIFO_SIZE * 4) : (PTX_FIFO_SIZE * 4);
+	uint32_t size;
+
+	cvidbg("%s: %p\n", __func__, ep);
+
+	/* make sure it's actually queued on this endpoint */
+	cvi_nuke(ep, result);
+
+	size = (cvi_uncached_read32(&reg->in_endp[ep_num].dtxfsts) & 0xFFFF) * 4;
+	if (size < size_max)
+		cvi_hsotg_txfifo_flush(dev, ep->fifo_num);
+
+}
+
+void cvi_disconnect(struct cvi_udc *dev)
+{
+	int i;
+
+	if (!dev->connected)
+		return;
+
+	dev->connected = 0;
+
+	for (i = 1; i < CVI_MAX_ENDPOINTS; i++) {
+		struct cvi_ep *ep = &dev->ep[i];
+
+		if (ep->ep.name) {
+			kill_all_requests(dev, ep, -ESHUTDOWN);
+		}
+	}
+
+	/* HACK to let gadget detect disconnected state */
+	if (dev->driver->disconnect) {
+		dev->driver->disconnect(&dev->gadget);
+	}
+}
+
+void cvi_reconfig_usbd(struct cvi_udc *dev, int is_usb_reset)
+{
+	/* 2. Soft-reset OTG Core and then unreset again. */
+	unsigned int val;
+	uint32_t dflt_gusbcfg;
+	struct cvi_plat_otg_data *pdata = (struct cvi_plat_otg_data *)dev->pdata;
+	struct cvi_ep *ep = &dev->ep[0];
+
+	cvidbg("Resetting OTG controller\n");
+
+	kill_all_requests(dev, ep, -ECONNRESET);
+	udc_reinit(dev);
+	if (!is_usb_reset) {
+		uint32_t greset;
+		int count = 0;
+		uint32_t snpsid = cvi_uncached_read32(&reg->gsnpsid) & CVI_CORE_REV_MASK;
+
+		/* check snpsid */
+		if (snpsid < (CVI_CORE_REV_4_20a & CVI_CORE_REV_MASK)) {
+			/* Core Soft Reset */
+			cvi_uncached_write32(CORE_SOFT_RESET, &reg->grstctl);
+			do {
+				udelay(1);
+				greset = cvi_uncached_read32(&reg->grstctl);
+				if (++count > 50) {
+					printf("%s() HANG! Soft Reset GRSTCTL=%0x\n", __func__, greset);
+					return;
+				}
+			} while (greset & CORE_SOFT_RESET);
+		} else {
+			/* Core Soft Reset */
+			cvi_uncached_write32(CORE_SOFT_RESET, &reg->grstctl);
+			do {
+				udelay(1);
+				greset = cvi_uncached_read32(&reg->grstctl);
+				if (++count > 50) {
+					printf("%s() HANG! Soft 4.2 Reset GRSTCTL=%0x\n",
+						__func__, greset);
+					return;
+				}
+			} while (!(greset & CSFTRST_DONE));
+			greset = cvi_uncached_read32(&reg->grstctl);
+			greset &= ~CORE_SOFT_RESET;
+			greset |= CSFTRST_DONE;
+			cvi_uncached_write32(greset, &reg->grstctl);
+		}
+
+		/* Wait for AHB master IDLE state */
+		count = 0;
+		do {
+			udelay(1);
+			greset = cvi_uncached_read32(&reg->grstctl);
+			if (++count > 50) {
+				printf("%s() HANG! AHB Idle GRSTCTL=%0x\n",
+					__func__, greset);
+				return;
+			}
+		} while (!(greset & AHB_MASTER_IDLE));
+	} else {
+		int i;
+
+		for (i = 1; i < CVI_MAX_ENDPOINTS; i++) {
+			struct cvi_ep *ep = &dev->ep[i];
+
+			if (ep->ep.name)
+				_cvi_ep_disable(ep);
+		}
+	}
+
+	dflt_gusbcfg =
+		1 << 30		/* ForceDevMode.*/
+		| 1 << 19		/* 1'b1: PHY does not power down internal clock.*/
+		| 0 << 15		/* PHY Low Power Clock sel*/
+		| 0 << 14		/* Non-Periodic TxFIFO Rewind Enable*/
+		| 0x5 << 10	/* Turnaround time*/
+		| 0 << 9 | 0 << 8	/* [0:HNP disable,1:HNP enable][ 0:SRP disable*/
+		/* 1:SRP enable] H1= 1,1*/
+		| 0 << 7		/* Ulpi DDR sel*/
+		| 0 << 6		/* 0: high speed utmi+, 1: full speed serial*/
+		| 0 << 4		/* 0: utmi+, 1:ulpi*/
+		| 1 << 3		/* phy i/f  0:8bit, 1:16bit*/
+		| 0x7 << 0;	/* HS/FS Timeout**/
+
+	if (pdata->usb_gusbcfg)
+		dflt_gusbcfg = pdata->usb_gusbcfg;
+
+	cvi_uncached_write32(dflt_gusbcfg, &reg->gusbcfg);
+
+	cvi_hsotg_init_fifo(dev);
+
+	if (!is_usb_reset) {
+		/* Put the OTG device core in the disconnected state.*/
+		val = cvi_uncached_read32(&reg->dctl);
+		val |= SOFT_DISCONNECT;
+		cvi_uncached_write32(val, &reg->dctl);
+	}
+
+	/* Configure OTG Core to initial settings of device mode.*/
+	/* [1: full speed(30Mhz) 0:high speed]*/
+	cvi_uncached_write32(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
+
+	/* Clear any pending OTG interrupts */
+	cvi_uncached_write32(0xffffffff, &reg->gotgint);
+
+	/* Clear any pending interrupts */
+	cvi_uncached_write32(0xffffffff, &reg->gintsts);
+
+	/* Unmask the core interrupts*/
+	cvi_uncached_write32(GINTMSK_INIT, &reg->gintmsk);
+
+	/* Initialize ahbcfg.*/
+	cvi_uncached_write32(GAHBCFG_INIT, &reg->gahbcfg);
+
+	/* Unmask device IN EP common interrupts*/
+	cvi_uncached_write32(DIEPMSK_INIT, &reg->diepmsk);
+
+	/* Unmask device OUT EP common interrupts*/
+	cvi_uncached_write32(DOEPMSK_INIT, &reg->doepmsk);
+
+	/* Unmask EPO interrupts*/
+	cvi_uncached_write32(((1 << EP0_CON) << DAINT_OUT_BIT)
+			      | (1 << EP0_CON), &reg->daintmsk);
+
+	if (!is_usb_reset) {
+		val = cvi_uncached_read32(&reg->dctl);
+		val |= PWRONPRGDONE;
+		cvi_uncached_write32(val, &reg->dctl);
+		udelay(10);  /* see openiboot */
+		val = cvi_uncached_read32(&reg->dctl);
+		val &= ~PWRONPRGDONE;
+		cvi_uncached_write32(val, &reg->dctl);
+	}
+
+	/* prepare the setup */
+	cvi_udc_pre_setup(dev);
+	/* enable, but don't activate EP0in */
+	cvi_uncached_write32(DEPCTL_USBACTEP, &reg->in_endp[0].diepctl);
+
+	/* clear global NAKs */
+	val = CGOUTNAK | CGNPINNAK;
+	if (!is_usb_reset)
+		val |= SOFT_DISCONNECT;
+	val |= cvi_uncached_read32(&reg->dctl);
+	cvi_uncached_write32(val, &reg->dctl);
+
+	/* must be at-least 3ms to allow bus to see disconnect */
+	mdelay(3);
+}
+
+static void cvi_usbd_init(struct cvi_udc *dev)
+{
+	unsigned int temp;
+	uint32_t dflt_gusbcfg;
+	struct cvi_plat_otg_data *pdata = (struct cvi_plat_otg_data *)dev->pdata;
+
+	cvidbg("Init OTG controller\n");
+
+	/* Unmask subset of endpoint interrupts */
+	cvi_uncached_write32(DOEPMSK_INIT, &reg->doepmsk);
+	cvi_uncached_write32(DIEPMSK_INIT, &reg->diepmsk);
+	cvi_uncached_write32(0, &reg->daintmsk);
+
+	/* Be in disconnected state until gadget is registered */
+	temp = cvi_uncached_read32(&reg->dctl);
+	temp |= SOFT_DISCONNECT;
+	cvi_uncached_write32(temp, &reg->dctl);
+
+	/* setup fifo*/
+	cvi_hsotg_init_fifo(dev);
+
+	dflt_gusbcfg =
+		1 << 30		/* ForceDevMode.*/
+		| 1 << 19		/* 1'b1: PHY does not power down internal clock.*/
+		| 0 << 15		/* PHY Low Power Clock sel*/
+		| 0 << 14		/* Non-Periodic TxFIFO Rewind Enable*/
+		| 0x5 << 10	/* Turnaround time*/
+		| 0 << 9 | 0 << 8	/* [0:HNP disable,1:HNP enable][ 0:SRP disable*/
+		/* 1:SRP enable] H1= 1,1*/
+		| 0 << 7		/* Ulpi DDR sel*/
+		| 0 << 6		/* 0: high speed utmi+, 1: full speed serial*/
+		| 0 << 4		/* 0: utmi+, 1:ulpi*/
+		| 0 << 3		/* phy i/f  0:8bit, 1:16bit*/
+		| 0x7 << 0;	/* HS/FS Timeout**/
+
+	if (pdata->usb_gusbcfg)
+		dflt_gusbcfg = pdata->usb_gusbcfg;
+
+	cvi_uncached_write32(dflt_gusbcfg, &reg->gusbcfg);
+	/* Initialize OTG Link Core.*/
+	cvi_uncached_write32(GAHBCFG_INIT, &reg->gahbcfg);
+}
+
+static int cvi_ep_enable(struct usb_ep *_ep,
+			  const CH9_UsbEndpointDescriptor *desc)
+{
+	struct cvi_ep *ep;
+	struct cvi_udc *dev;
+
+	cvidbg("%s: %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name ||
+	    desc->bDescriptorType != CH9_USB_DT_ENDPOINT ||
+	    ep->bEndpointAddress != desc->bEndpointAddress ||
+	    ep_maxpacket(ep) < le16ToCpu(desc->wMaxPacketSize)) {
+
+		cvidbg("%s: bad ep or descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes &&
+	    ep->bmAttributes != CH9_USB_EP_BULK &&
+	    desc->bmAttributes != CH9_USB_EP_INTERRUPT) {
+
+		cvidbg("%s: %s type mismatch\n", __func__, _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == CH9_USB_EP_BULK &&
+	     le16ToCpu(desc->wMaxPacketSize) >
+	     ep_maxpacket(ep)) || !desc->wMaxPacketSize) {
+
+		cvidbg("%s: bad %s maxpacket\n", __func__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == CH9_USB_SPEED_UNKNOWN) {
+
+		cvidbg("%s: bogus device state\n", __func__);
+		return -ESHUTDOWN;
+	}
+
+	ep->stopped = 0;
+	ep->ep.desc = desc;
+	ep->desc = desc;
+	ep->pio_irqs = 0;
+	ep->ep.maxpacket = le16ToCpu(desc->wMaxPacketSize);
+
+	/* Reset halt state */
+	cvi_udc_set_nak(ep);
+	cvi_udc_set_halt(_ep, 0);
+
+	cvi_udc_ep_activate(ep);
+
+	cvidbg("%s: enabled %s, stopped = %d, maxpacket = %d\n",
+		__func__, _ep->name, ep->stopped, ep->ep.maxpacket);
+
+	return 0;
+}
+
+void cvi_hsotg_set_bit(uint32_t *reg, uint32_t val)
+{
+	cvi_uncached_write32(cvi_uncached_read32(reg) | val, reg);
+}
+
+void cvi_hsotg_clear_bit(uint32_t *reg, uint32_t val)
+{
+	cvi_uncached_write32(cvi_uncached_read32(reg) & ~val, reg);
+}
+
+int cvi_hsotg_wait_bit_set(uint32_t *reg, uint32_t bit, uint32_t timeout)
+{
+	uint32_t i;
+
+	for (i = 0; i < timeout; i++) {
+		if (cvi_uncached_read32(reg) & bit)
+			return 0;
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void cvi_ep_stop_xfer(struct cvi_udc *dev, struct cvi_ep *ep)
+{
+	uint32_t ep_num = ep_index(ep);
+	uint32_t *epctrl_reg, *epint_reg;
+
+	epctrl_reg = ep_is_in(ep) ? &reg->in_endp[ep_num].diepctl :
+		     &reg->out_endp[ep_num].doepctl;
+	epint_reg = ep_is_in(ep) ? &reg->in_endp[ep_num].diepint :
+		    &reg->out_endp[ep_num].doepint;
+	if (ep_is_in(ep)) {
+		cvi_hsotg_set_bit(epctrl_reg, DEPCTL_SNAK);
+		/* Wait for Nak effect */
+		if (cvi_hsotg_wait_bit_set(epint_reg, INEPNAKEFF, 100))
+			printf("%s: timeout DIEPINT.NAKEFF\n", __func__);
+	} else {
+		if (!(cvi_uncached_read32(&reg->gintsts) & INT_GOUTNakEff)) {
+			cvi_hsotg_set_bit(&reg->dctl, SGOUTNAK);
+		}
+		/* Wait for global nak to take effect */
+		if (cvi_hsotg_wait_bit_set(&reg->gintsts, INT_GOUTNakEff, 100)) {
+			printf("%s: timeout GINTSTS.GOUTNAKEFF\n", __func__);
+		}
+	}
+
+	/* disable ep */
+	cvi_hsotg_set_bit(epctrl_reg, DEPCTL_SNAK | DEPCTL_EPDIS);
+	/* Wait for ep to be disabled */
+	if (cvi_hsotg_wait_bit_set(epint_reg, EPDISBLD, 100)) {
+		printf("%s: timeout DOEPCTL.EPDisable\n", __func__);
+	}
+	/* Clear EPDISBLD interrupt */
+	cvi_hsotg_set_bit(epint_reg, EPDISBLD);
+	if (ep_is_in(ep)) {
+		cvi_hsotg_txfifo_flush(dev, ep->fifo_num);
+	} else {
+		cvi_hsotg_set_bit(&reg->dctl, CGOUTNAK);
+	}
+}
+
+static int _cvi_ep_disable(struct cvi_ep *ep)
+{
+	uint32_t ep_num = ep_index(ep);
+	uint32_t *epctrl_reg;
+	uint32_t ctrl;
+
+	if (ep == &the_controller->ep[0]) {
+		printf("%s: call for ep0-out\n", __func__);
+		return -EINVAL;
+	}
+
+	epctrl_reg = ep_is_in(ep) ? &reg->in_endp[ep_num].diepctl :
+		     &reg->out_endp[ep_num].doepctl;
+	ctrl = cvi_uncached_read32(epctrl_reg);
+	if (ctrl & DEPCTL_EPENA)
+		cvi_ep_stop_xfer(the_controller, ep);
+	ctrl &= ~DEPCTL_EPENA;
+	ctrl &= ~DEPCTL_USBACTEP;
+	ctrl |= DEPCTL_SNAK;
+	cvi_uncached_write32(ctrl, epctrl_reg);
+	/* Nuke all pending requests */
+	kill_all_requests(the_controller, ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	return 0;
+}
+
+/*
+ * Disable EP
+ */
+static int cvi_ep_disable(struct usb_ep *_ep)
+{
+	struct cvi_ep *ep;
+
+	cvidbg("%s: %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+
+	if (!_ep || !ep->desc) {
+		cvidbg("%s: %s not enabled\n", __func__,
+			_ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	_cvi_ep_disable(ep);
+
+	cvidbg("%s: disabled %s\n", __func__, _ep->name);
+
+	return 0;
+}
+
+static struct usb_request *cvi_alloc_request(struct usb_ep *ep)
+{
+	struct cvi_udc *dev = the_controller;
+	struct usb_gadget_driver *driver = dev->driver;
+	struct cvi_request *req;
+
+	cvidbg("%s: %s %p\n", __func__, ep->name, ep);
+
+	req = driver->req_mem_alloc(&dev->gadget, sizeof(*req));
+	if (!req)
+		return 0;
+
+	memset(req, 0, sizeof(*req));
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void cvi_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct cvi_udc *dev = the_controller;
+	struct usb_gadget_driver *driver = dev->driver;
+	struct cvi_request *req;
+
+	cvidbg("%s: %p\n", __func__, ep);
+
+	req = container_of(_req, struct cvi_request, req);
+	if (!list_empty(&req->queue))
+		printf("warning! free unfinished request!\n");
+	driver->req_mem_free(&dev->gadget, req);
+}
+
+/* dequeue JUST ONE request */
+static int cvi_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct cvi_ep *ep;
+	struct cvi_request *req;
+
+	cvidbg("%s: %p\n", __func__, _ep);
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		return -EINVAL;
+	}
+
+	cvi_done(ep, req, -ECONNRESET);
+
+	return 0;
+}
+
+/*
+ * Return bytes in EP FIFO
+ */
+static int cvi_fifo_status(struct usb_ep *_ep)
+{
+	int count = 0;
+	struct cvi_ep *ep;
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	if (!_ep) {
+		cvidbg("%s: bad ep\n", __func__);
+		return -ENODEV;
+	}
+
+	cvidbg("%s: %d\n", __func__, ep_index(ep));
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (ep_is_in(ep))
+		return -EOPNOTSUPP;
+
+	return count;
+}
+
+/*
+ * Flush EP FIFO
+ */
+static void cvi_fifo_flush(struct usb_ep *_ep)
+{
+	struct cvi_ep *ep;
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	if (!_ep || (!ep->desc && ep->ep.name != ep0name)) {
+		cvidbg("%s: bad ep\n", __func__);
+		return;
+	}
+
+	cvidbg("%s: %d\n", __func__, ep_index(ep));
+}
+
+static int pullup(struct usb_gadget *gadget, int is_on)
+{
+	unsigned int temp = cvi_uncached_read32(&reg->dctl);
+
+	if (!is_on) {
+		temp |= SOFT_DISCONNECT;
+		cvi_uncached_write32(temp, &reg->dctl);
+	} else {
+		temp &= ~SOFT_DISCONNECT;
+		cvi_uncached_write32(temp, &reg->dctl);
+	}
+
+	return 0;
+}
+
+static int wakeup(struct usb_gadget *gadget)
+{
+	cvi_hsotg_set_bit(&reg->dctl, RMTWKUPSIG);
+	mdelay(10);
+	cvi_hsotg_clear_bit(&reg->dctl, RMTWKUPSIG);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops cvi_udc_ops = {
+	/* current versions must always be self-powered */
+	.pullup = pullup,
+	.wakeup = wakeup,
+};
+
+uint8_t cvi_phy_to_log_ep(uint8_t phy_num, uint8_t dir)
+{
+	return (phy_num) ? ((phy_num << 1) - (!!dir)) : 0;
+}
+
+/*
+ *	probe - binds to the platform device
+ */
+
+int cvi_udc_probe(struct cvi_plat_otg_data *pdata)
+{
+	struct cvi_udc *dev;
+	int retval = 0;
+
+	cvidbg("%s: %p\n", __func__, pdata);
+
+	if (pdata->size < sizeof(*dev)) {
+		printf("size for handler is too samll (%ld, %d)\n", sizeof(*dev), pdata->size);
+		return -1;
+	}
+
+	cvi_log_write(0xbeefbeef, 0, 0, 0, 0);
+	dev = (struct cvi_udc *)pdata->handler;
+	memset(dev, 0, sizeof(*dev));
+
+	dev->pdata = (void *)pdata;
+
+	reg = (struct cvi_usbotg_reg *)pdata->regs_otg;
+
+	/* gadget init */
+	dev->usb_address = 0;
+	dev->gadget.ops = &cvi_udc_ops;
+	dev->gadget.ep0 = &dev->ep[0].ep;
+	dev->gadget.name = driver_name;
+	dev->gadget.is_dualspeed = 1;
+	dev->gadget.is_otg = 0;
+	dev->gadget.is_a_peripheral = 0;
+	dev->gadget.b_hnp_enable = 0;
+	dev->gadget.a_hnp_support = 0;
+	dev->gadget.a_alt_hnp_support = 0;
+	dev->gadget.max_speed = CH9_USB_SPEED_HIGH;
+	/* eps init */
+	dev->ep[0].ep.name = ep0name;
+	dev->ep[0].ep.ops = &cvi_ep_ops;
+	dev->ep[0].ep.maxpacket = EP0_FIFO_SIZE;
+	dev->ep[0].dev = dev;
+	dev->ep[0].bEndpointAddress = 0;
+	dev->ep[0].bmAttributes = 0;
+	dev->ep[0].ep_type = ep_control;
+	dev->ep[1].ep.name = ep1name;
+	dev->ep[1].ep.ops = &cvi_ep_ops;
+	dev->ep[1].ep.maxpacket = EP_FIFO_SIZE;
+	dev->ep[1].dev = dev;
+	dev->ep[1].bEndpointAddress = USB_DIR_IN | 1;
+	dev->ep[1].bmAttributes = CH9_USB_EP_BULK;
+	dev->ep[1].ep_type = ep_bulk_out;
+	dev->ep[1].fifo_num = 1;
+	dev->ep[2].ep.name = ep2name;
+	dev->ep[2].ep.ops = &cvi_ep_ops;
+	dev->ep[2].ep.maxpacket = EP_FIFO_SIZE;
+	dev->ep[2].dev = dev;
+	dev->ep[2].bEndpointAddress = USB_DIR_OUT | 1;
+	dev->ep[2].bmAttributes = CH9_USB_EP_BULK;
+	dev->ep[2].ep_type = ep_bulk_in;
+	dev->ep[2].fifo_num = 1;
+	dev->ep[3].ep.name = ep3name;
+	dev->ep[3].ep.ops = &cvi_ep_ops;
+	dev->ep[3].ep.maxpacket = EP_FIFO_SIZE;
+	dev->ep[3].dev = dev;
+	dev->ep[3].bEndpointAddress = USB_DIR_IN | 2;
+	dev->ep[3].bmAttributes = CH9_USB_EP_INTERRUPT;
+	dev->ep[3].ep_type = ep_interrupt;
+	dev->ep[3].fifo_num = 2;
+
+	the_controller = dev;
+
+	dev->usb_ctrl = (CH9_UsbSetup *)pdata->ctrl_req;
+	if (!dev->usb_ctrl) {
+		printf("No memory available for UDC!\n");
+		return -ENOMEM;
+	}
+
+	dev->usb_ctrl_dma_addr = (dma_addr_t)((uintptr_t)dev->usb_ctrl);
+	dev->reg = reg;
+
+	udc_reinit(dev);
+
+	return retval;
+}
+
+int cviusb_gadget_handle_interrupts(int index)
+{
+	uint32_t intr_status = cvi_uncached_read32(&reg->gintsts);
+	uint32_t gintmsk = cvi_uncached_read32(&reg->gintmsk);
+
+#ifdef DEBUG
+	{
+		static uint32_t print_cnt = 0xFFFF;
+
+		if (print_cnt) {
+			print_cnt--;
+		} else {
+			printf("still alive\n");
+			print_cnt = 0xFFFF;
+		}
+	}
+#endif
+	if (intr_status & gintmsk)
+		return cvi_udc_irq(1, (void *)the_controller);
+	return 0;
+}
diff --git a/drivers/cvi_usb/utask/cv181x/cvi_udc_otg_xfer_dma.c b/drivers/cvi_usb/utask/cv181x/cvi_udc_otg_xfer_dma.c
new file mode 100644
index 000000000..91241bff0
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/cvi_udc_otg_xfer_dma.c
@@ -0,0 +1,1584 @@
+/*
+ * drivers/usb/gadget/cvi_udc_otg_xfer_dma.c
+ * Designware CVI on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2009 for Samsung Electronics
+ *
+ * BSP Support for Samsung's UDC driver
+ * available at:
+ * git://git.kernel.org/pub/scm/linux/kernel/git/kki_ap/linux-2.6-samsung.git
+ *
+ * State machine bugfixes:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ *
+ * Ported to u-boot:
+ * Marek Szyprowski <m.szyprowski@samsung.com>
+ * Lukasz Majewski <l.majewski@samsumg.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <stdlib.h>
+#include "include/cvi_ch9.h"
+#include "include/cvi_drv_if.h"
+#include "include/byteorder.h"
+#include "include/cvi_stdtypes.h"
+#include "include/cvi_errno.h"
+#include "include/cvi_udc_otg_regs.h"
+#include "include/cvi_udc_otg_priv.h"
+#include "include/cvi_udc.h"
+#include "include/dps.h"
+
+static unsigned int ep0_fifo_size = 64;
+static unsigned int ep_fifo_size =  512;
+static unsigned int ep_fifo_size2 = 1024;
+
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV",
+	"WAIT_FOR_COMPLETE",
+	"WAIT_FOR_OUT_COMPLETE",
+	"WAIT_FOR_IN_COMPLETE",
+	"WAIT_FOR_NULL_COMPLETE",
+};
+
+/* Bulk-Only Mass Storage Reset (class-specific request) */
+#define GET_MAX_LUN_REQUEST	0xFE
+#define BOT_RESET_REQUEST	0xFF
+
+static void set_max_pktsize(struct cvi_udc *dev, CH9_UsbSpeed speed)
+{
+	unsigned int ep_ctrl;
+	struct cvi_usbotg_reg *reg = dev->reg;
+	int i;
+
+	if (speed == CH9_USB_SPEED_HIGH) {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 512;
+		ep_fifo_size2 = 1024;
+		dev->gadget.speed = CH9_USB_SPEED_HIGH;
+	} else {
+		ep0_fifo_size = 64;
+		ep_fifo_size = 64;
+		ep_fifo_size2 = 64;
+		dev->gadget.speed = CH9_USB_SPEED_FULL;
+	}
+
+	dev->ep[0].ep.maxpacket = ep0_fifo_size;
+	for (i = 1; i < CVI_MAX_ENDPOINTS; i++)
+		dev->ep[i].ep.maxpacket = ep_fifo_size;
+
+	/* EP0 - Control IN (64 bytes)*/
+	ep_ctrl = cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl);
+	cvi_uncached_write32(ep_ctrl & ~(3 << 0), &reg->in_endp[EP0_CON].diepctl);
+
+	/* EP0 - Control OUT (64 bytes)*/
+	ep_ctrl = cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl);
+	cvi_uncached_write32(ep_ctrl & ~(3 << 0), &reg->out_endp[EP0_CON].doepctl);
+}
+
+static inline void cvi_udc_ep0_zlp(struct cvi_udc *dev)
+{
+	uint32_t ep_ctrl;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	cvi_uncached_write32(dev->usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
+	cvi_uncached_write32(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
+
+	ep_ctrl = cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl);
+	ep_ctrl &= ~(1 << 30);
+	ep_ctrl |= (DEPCTL_EPENA | DEPCTL_CNAK);
+	cvi_uncached_write32(ep_ctrl,
+			      &reg->in_endp[EP0_CON].diepctl);
+
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl));
+	dev->ep0state = WAIT_FOR_IN_COMPLETE;
+	cvi_log_write(0xAAAAA, ep_ctrl, dev->usb_ctrl_dma_addr,
+		       DIEPT_SIZ_PKT_CNT(1), 0);
+}
+
+void cvi_udc_pre_setup(struct cvi_udc *dev)
+{
+	uint32_t ep_ctrl, tmp, tmp1;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	cvidbg_cond(DEBUG_SETUP,
+		     "%s : Prepare Setup packets.\n", __func__);
+
+	cvi_uncached_write32(DOEPT_SIZ_SUS_CNT(1) | DOEPT_SIZ_PKT_CNT(1) | sizeof(CH9_UsbSetup),
+			      &reg->out_endp[EP0_CON].doeptsiz);
+	cvi_uncached_write32(dev->usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
+
+	tmp = cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl);
+	ep_ctrl = DEPCTL_EPENA | DEPCTL_USBACTEP;
+	cvi_uncached_write32(ep_ctrl, &reg->out_endp[EP0_CON].doepctl);
+
+	tmp1 = cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl);
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl));
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl));
+	cvi_log_write(0x99999, ep_ctrl, dev->usb_ctrl_dma_addr,
+		       tmp, tmp1);
+
+}
+
+static inline void cvi_ep0_complete_out(struct cvi_udc *dev)
+{
+	uint32_t ep_ctrl;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl));
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl));
+
+	cvidbg_cond(DEBUG_OUT_EP,
+		     "%s : Prepare Complete Out packet.\n", __func__);
+
+	//cvidbg_cond(1,
+	//	   "CO\n");
+	cvi_uncached_write32(DOEPT_SIZ_PKT_CNT(1) | sizeof(CH9_UsbSetup),
+			      &reg->out_endp[EP0_CON].doeptsiz);
+	cvi_uncached_write32(dev->usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
+
+	ep_ctrl = cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl);
+	ep_ctrl &= ~(1 << 30);
+	ep_ctrl |= (DEPCTL_EPENA | DEPCTL_CNAK);
+	cvi_uncached_write32(ep_ctrl,
+			      &reg->out_endp[EP0_CON].doepctl);
+
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl));
+	cvidbg_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
+		     __func__, cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl));
+	cvi_log_write(0x88888, ep_ctrl, dev->usb_ctrl_dma_addr, DOEPT_SIZ_PKT_CNT(1) | sizeof(CH9_UsbSetup), 0);
+
+}
+
+static int setdma_rx(struct cvi_ep *ep, struct cvi_request *req)
+{
+	uint32_t *buf, ctrl;
+	uint32_t length, pktcnt;
+	uint32_t ep_num = ep_index(ep);
+	uint32_t dma_addr;
+	struct cvi_usbotg_reg *reg = ep->dev->reg;
+
+	buf = req->req.buf + req->req.actual;
+	length = min_t(uint32_t, req->req.length - req->req.actual,
+		       ep_num ? DMA_BUFFER_SIZE : ep->ep.maxpacket);
+
+	ep->len = length;
+	ep->dma_buf = buf;
+
+	if (ep_num == EP0_CON || length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1) / (ep->ep.maxpacket) + 1;
+
+	ctrl =  cvi_uncached_read32(&reg->out_endp[ep_num].doepctl);
+
+	dma_addr = (uint32_t)((uintptr_t)ep->dma_buf);
+	cvi_cache_invalidate(dma_addr, ep->len);
+
+	cvi_uncached_write32(dma_addr, &reg->out_endp[ep_num].doepdma);
+	cvi_uncached_write32(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
+			      &reg->out_endp[ep_num].doeptsiz);
+	ctrl &= ~(1 << 30);
+	ctrl |= (DEPCTL_EPENA | DEPCTL_CNAK);
+	cvi_uncached_write32(ctrl, &reg->out_endp[ep_num].doepctl);
+
+	cvidbg_cond(DEBUG_OUT_EP != 0,
+		     "%s: EP%d RX DMA start : DOEPDMA = 0x%x, DOEPTSIZ = 0x%x, DOEPCTL = 0x%x\n",
+		     __func__, ep_num,
+		     cvi_uncached_read32(&reg->out_endp[ep_num].doepdma),
+		     cvi_uncached_read32(&reg->out_endp[ep_num].doeptsiz),
+		     cvi_uncached_read32(&reg->out_endp[ep_num].doepctl));
+	cvidbg_cond(DEBUG_OUT_EP != 0,
+		     "\tbuf = 0x%p, pktcnt = %d, xfersize = %d\n",
+		     buf, pktcnt, length);
+
+	cvi_log_write(0x77777, ctrl, dma_addr, DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length), 0);
+	return 0;
+
+}
+
+static int setdma_tx(struct cvi_ep *ep, struct cvi_request *req)
+{
+	uint32_t *buf, ctrl = 0, tmp, tmp1;
+	uint32_t length, pktcnt;
+	uint32_t ep_num = ep_index(ep);
+	uint32_t dma_addr;
+	struct cvi_usbotg_reg *reg = ep->dev->reg;
+
+	buf = req->req.buf + req->req.actual;
+	length = req->req.length - req->req.actual;
+	if (length > DMA_BUFFER_SIZE)
+		length = DMA_BUFFER_SIZE;
+
+	if (ep_num == EP0_CON)
+		length = min(length, (uint32_t)ep_maxpacket(ep));
+
+	ep->len = length;
+	ep->dma_buf = buf;
+
+	dma_addr = (uint32_t)((uintptr_t)ep->dma_buf);
+	cvi_cache_flush(dma_addr, ROUND(ep->len, CONFIG_SYS_CACHELINE_SIZE));
+
+	if (length == 0)
+		pktcnt = 1;
+	else
+		pktcnt = (length - 1) / (ep->ep.maxpacket) + 1;
+
+	/* Flush the endpoint's Tx FIFO */
+	//cvi_uncached_write32(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
+	//cvi_uncached_write32(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
+	//while (cvi_uncached_read32(&reg->grstctl) & TX_FIFO_FLUSH)
+	//	;
+
+	cvi_uncached_write32(dma_addr, &reg->in_endp[ep_num].diepdma);
+	cvi_uncached_write32(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
+			      &reg->in_endp[ep_num].dieptsiz);
+
+	ctrl = cvi_uncached_read32(&reg->in_endp[ep_num].diepctl);
+	tmp = ctrl;
+
+	/* Write the FIFO number to be used for this endpoint */
+	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
+	ctrl &= ~(1 << 30);
+	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
+
+	/* Clear reserved (Next EP) bits */
+	ctrl = (ctrl & ~(EP_MASK << DEPCTL_NEXT_EP_BIT));
+	ctrl |= (DEPCTL_EPENA | DEPCTL_CNAK);
+	//printf("diepctl0 = 0x%x\n", ctrl);
+	cvi_uncached_write32(ctrl, &reg->in_endp[ep_num].diepctl);
+
+	tmp1 = cvi_uncached_read32(&reg->in_endp[ep_num].diepctl);
+	cvidbg_cond(DEBUG_IN_EP,
+		     "%s:EP%d TX DMA start : DIEPDMA0 = 0x%x, DIEPTSIZ0 = 0x%x, DIEPCTL0 = 0x%x\n",
+		     __func__, ep_num,
+		     cvi_uncached_read32(&reg->in_endp[ep_num].diepdma),
+		     cvi_uncached_read32(&reg->in_endp[ep_num].dieptsiz),
+		     cvi_uncached_read32(&reg->in_endp[ep_num].diepctl));
+	cvidbg_cond(DEBUG_IN_EP,
+		     "\tbuf = 0x%p, pktcnt = %d, xfersize = %d\n",
+		     buf, pktcnt, length);
+
+	cvi_log_write(0x44444, ctrl, dma_addr, tmp, tmp1);
+	cvi_log_write(0x46464, cvi_uncached_read32(&reg->in_endp[ep_num].dieptsiz), length, ep_num, 0);
+
+	return length;
+}
+
+static void complete_rx(struct cvi_udc *dev, uint8_t ep_num)
+{
+	struct cvi_ep *ep = &dev->ep[cvi_phy_to_log_ep(ep_num, 0)];
+	struct cvi_request *req = NULL;
+	uint32_t ep_tsr = 0, xfer_size = 0, is_short = 0;
+	uint32_t dma_addr;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	if (list_empty(&ep->queue)) {
+		cvidbg_cond(DEBUG_OUT_EP != 0,
+			     "%s: RX DMA done : NULL REQ on OUT EP-%d\n",
+			     __func__, ep_num);
+		return;
+
+	}
+
+	req = list_entry(ep->queue.next, struct cvi_request, queue);
+	ep_tsr = cvi_uncached_read32(&reg->out_endp[ep_num].doeptsiz);
+
+	if (ep_num == EP0_CON)
+		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
+	else
+		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
+
+	xfer_size = ep->len - xfer_size;
+
+	/*
+	 * NOTE:
+	 *
+	 * Please be careful with proper buffer allocation for USB request,
+	 * which needs to be aligned to CONFIG_SYS_CACHELINE_SIZE, not only
+	 * with starting address, but also its size shall be a cache line
+	 * multiplication.
+	 *
+	 * This will prevent from corruption of data allocated immediately
+	 * before or after the buffer.
+	 *
+	 * For armv7, the cache_v7.c provides proper code to emit "ERROR"
+	 * message to warn users.
+	 */
+	dma_addr = (uint32_t)((uintptr_t)ep->dma_buf);
+	cvi_cache_invalidate(dma_addr, ROUND(xfer_size, CONFIG_SYS_CACHELINE_SIZE));
+
+	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
+	is_short = !!(xfer_size % ep->ep.maxpacket);
+
+	cvidbg_cond(DEBUG_OUT_EP != 0,
+		     "%s: RX DMA done : ep = %d, rx bytes = %d/%d,",
+		     __func__, ep_num, req->req.actual, req->req.length);
+	cvidbg_cond(DEBUG_OUT_EP != 0,
+		     "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
+		     is_short, ep_tsr, req->req.length - req->req.actual);
+
+	if (is_short || req->req.actual == req->req.length) {
+		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
+			cvidbg_cond(DEBUG_OUT_EP != 0, "	=> Send ZLP\n");
+			cvi_udc_ep0_zlp(dev);
+			/* packet will be completed in complete_tx() */
+			dev->ep0state = WAIT_FOR_IN_COMPLETE;
+		} else {
+			cvi_done(ep, req, 0);
+
+			if (!list_empty(&ep->queue)) {
+				req = list_entry(ep->queue.next, struct cvi_request, queue);
+				cvidbg_cond(DEBUG_OUT_EP != 0,
+					     "%s: Next Rx request start...\n",
+					     __func__);
+				setdma_rx(ep, req);
+			}
+		}
+	} else
+		setdma_rx(ep, req);
+}
+
+static void complete_tx(struct cvi_udc *dev, uint8_t ep_num)
+{
+	struct cvi_ep *ep = &dev->ep[cvi_phy_to_log_ep(ep_num, 1)];
+	struct cvi_request *req;
+	//uint32_t ep_tsr = 0, xfer_size = 0, is_short = 0;
+	uint32_t xfer_size = 0;
+	uint32_t last;
+	//struct cvi_usbotg_reg *reg = dev->reg;
+
+	cvi_log_write(0x55555, dev->ep0state, list_empty(&ep->queue), 0, 0);
+
+	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
+		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
+		cvi_ep0_complete_out(dev);
+		return;
+	}
+
+	if (list_empty(&ep->queue)) {
+		cvidbg_cond(DEBUG_IN_EP,
+			     "%s: TX DMA done : NULL REQ on IN EP-%d\n",
+			     __func__, ep_num);
+		return;
+
+	}
+
+	req = list_entry(ep->queue.next, struct cvi_request, queue);
+
+	xfer_size = ep->len;
+	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
+
+	if (ep_num == 0) {
+		if (dev->ep0state == DATA_STATE_XMIT) {
+			cvidbg_cond(DEBUG_IN_EP,
+				     "%s: ep_num = %d, ep0stat == DATA_STATE_XMIT\n",
+				     __func__, ep_num);
+			last = cvi_write_fifo_ep0(ep, req);
+			if (last)
+				dev->ep0state = WAIT_FOR_COMPLETE;
+		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
+			cvidbg_cond(DEBUG_IN_EP,
+				     "%s: ep_num = %d, completing request\n",
+				     __func__, ep_num);
+			cvi_done(ep, req, 0);
+			dev->ep0state = WAIT_FOR_SETUP;
+		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
+			cvidbg_cond(DEBUG_IN_EP,
+				     "%s: ep_num = %d, completing request\n",
+				     __func__, ep_num);
+			cvi_done(ep, req, 0);
+			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
+			cvi_ep0_complete_out(dev);
+		} else {
+			cvidbg_cond(DEBUG_IN_EP,
+				     "%s: ep_num = %d, invalid ep state\n",
+				     __func__, ep_num);
+		}
+		return;
+	}
+
+	if (req->req.actual == req->req.length)
+		cvi_done(ep, req, 0);
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct cvi_request, queue);
+		cvidbg_cond(DEBUG_IN_EP,
+			     "%s: Next Tx request start...\n", __func__);
+		setdma_tx(ep, req);
+	}
+}
+
+static inline void cvi_udc_check_tx_queue(struct cvi_udc *dev, uint8_t ep_num)
+{
+	struct cvi_ep *ep = &dev->ep[cvi_phy_to_log_ep(ep_num, 1)];
+	struct cvi_request *req;
+
+	cvidbg_cond(DEBUG_IN_EP,
+		     "%s: Check queue, ep_num = %d\n", __func__, ep_num);
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct cvi_request, queue);
+		cvidbg_cond(DEBUG_IN_EP,
+			     "%s: Next Tx request(0x%p) start...\n",
+			     __func__, req);
+
+		if (ep_is_in(ep))
+			setdma_tx(ep, req);
+		else
+			setdma_rx(ep, req);
+	} else {
+		cvidbg_cond(DEBUG_IN_EP,
+			     "%s: NULL REQ on IN EP-%d\n", __func__, ep_num);
+
+		return;
+	}
+
+}
+
+static int cvi_set_test_mode(struct cvi_udc *dev, int testmode)
+{
+	struct cvi_usbotg_reg *reg = dev->reg;
+	uint32_t dctl = cvi_uncached_read32(&reg->dctl);
+
+	dctl &= ~DCTL_TSTCTL_MASK;
+	switch (testmode) {
+	case CH9_TEST_J:
+	case CH9_TEST_K:
+	case CH9_TEST_SE0_NAK:
+	case CH9_TEST_PACKET:
+	case CH9_TEST_FORCE_EN:
+		printf("run test mode %d\n", testmode);
+		dctl |= testmode << DCTL_TSTCTL_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+	cvi_uncached_write32(dctl, &reg->dctl);
+
+	return 0;
+}
+
+static void process_ep_in_intr(struct cvi_udc *dev)
+{
+	uint32_t ep_intr, ep_intr_status;
+	uint8_t ep_num = 0;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	ep_intr = cvi_uncached_read32(&reg->daint);
+	cvidbg_cond(DEBUG_IN_EP,
+		     "*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);
+
+	ep_intr &= DAINT_MASK;
+
+	while (ep_intr) {
+		if (ep_intr & DAINT_IN_EP_INT(1)) {
+			ep_intr_status = cvi_uncached_read32(&reg->in_endp[ep_num].diepint);
+			cvidbg_cond(DEBUG_IN_EP,
+				     "\tEP%d-IN : DIEPINT = 0x%x\n",
+				     ep_num, ep_intr_status);
+			cvi_log_write(0x737373, ep_num, ep_intr_status,
+				       cvi_uncached_read32(&reg->in_endp[ep_num].dieptsiz),
+				       cvi_uncached_read32(&reg->in_endp[ep_num].diepctl));
+			cvi_log_write(0x747474,
+				       cvi_uncached_read32(&reg->in_endp[ep_num].diepdma),
+				       cvi_uncached_read32(&reg->in_endp[ep_num].dtxfsts),
+				       0, 0);
+
+			/* Interrupt Clear */
+			cvi_uncached_write32(ep_intr_status, &reg->in_endp[ep_num].diepint);
+
+			if (ep_intr_status & TRANSFER_DONE) {
+				complete_tx(dev, ep_num);
+
+				if (ep_num == 0) {
+					if (dev->test_mode) {
+						cvi_set_test_mode(dev, dev->test_mode);
+					}
+					if (dev->ep0state ==
+					    WAIT_FOR_IN_COMPLETE)
+						dev->ep0state = WAIT_FOR_SETUP;
+
+					if (dev->ep0state == WAIT_FOR_SETUP)
+						cvi_udc_pre_setup(dev);
+
+					/* continue transfer after
+					 * set_clear_halt for DMA mode
+					 */
+					if (dev->clear_feature_flag == 1) {
+						cvi_udc_check_tx_queue(dev, dev->clear_feature_num);
+						dev->clear_feature_flag = 0;
+					}
+				}
+			}
+		}
+		ep_num++;
+		ep_intr >>= 1;
+	}
+}
+
+static void process_ep_out_intr(struct cvi_udc *dev)
+{
+	uint32_t ep_intr, ep_intr_status;
+	uint8_t ep_num = 0;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	ep_intr = cvi_uncached_read32(&reg->daint);
+	cvidbg_cond(DEBUG_OUT_EP != 0,
+		     "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
+		     __func__, ep_intr);
+
+	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
+
+	while (ep_intr) {
+		if (ep_intr & 0x1) {
+			ep_intr_status = cvi_uncached_read32(&reg->out_endp[ep_num].doepint);
+			cvidbg_cond(DEBUG_OUT_EP != 0,
+				     "\tEP%d-OUT : DOEPINT = 0x%x\n",
+				     ep_num, ep_intr_status);
+
+			/* Interrupt Clear */
+			cvi_uncached_write32(ep_intr_status, &reg->out_endp[ep_num].doepint);
+
+			if (ep_num == 0) {
+				if (ep_intr_status &
+				    CTRL_OUT_EP_SETUP_PHASE_DONE) {
+					cvidbg_cond(DEBUG_OUT_EP != 0,
+						     "SETUP packet arrived\n");
+					//cvidbg_cond(1, "SP\n");
+					cvi_log_write(0x3333, 0, 0, 0, 0);
+					cvi_handle_ep0(dev);
+				} else if (ep_intr_status & TRANSFER_DONE) {
+					if (dev->ep0state !=
+					    WAIT_FOR_OUT_COMPLETE) {
+						cvi_log_write(0x66666, 1, ep_intr_status, 0, 0);
+						complete_rx(dev, ep_num);
+					} else {
+						cvi_log_write(0x66666, 2, ep_intr_status, 0, 0);
+						dev->ep0state = WAIT_FOR_SETUP;
+						cvi_udc_pre_setup(dev);
+					}
+				}
+			} else {
+				if (ep_intr_status & TRANSFER_DONE)
+					complete_rx(dev, ep_num);
+			}
+		}
+		ep_num++;
+		ep_intr >>= 1;
+	}
+}
+
+/*
+ *	usb client interrupt handler.
+ */
+int cvi_udc_irq(int irq, void *_dev)
+{
+	struct cvi_udc *dev = _dev;
+	uint32_t intr_status;
+	uint32_t usb_status, gintmsk;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	intr_status = cvi_uncached_read32(&reg->gintsts);
+	gintmsk = cvi_uncached_read32(&reg->gintmsk);
+
+	cvidbg_cond(DEBUG_ISR,
+		     "\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x,",
+		     __func__, intr_status, state_names[dev->ep0state], gintmsk);
+	cvidbg_cond(DEBUG_ISR,
+		     "DAINT : 0x%x, DAINTMSK : 0x%x\n",
+		     cvi_uncached_read32(&reg->daint), cvi_uncached_read32(&reg->daintmsk));
+
+	if (!intr_status) {
+		return 0;
+	}
+
+	cvi_log_write(0xEFEF, intr_status, dev->ep0state,
+		       cvi_uncached_read32(&reg->daint), 0);
+
+	if (intr_status & INT_ENUMDONE) {
+		cvidbg_cond(DEBUG_ISR, "\tSpeed Detection interrupt\n");
+
+		cvi_uncached_write32(INT_ENUMDONE, &reg->gintsts);
+		usb_status = (cvi_uncached_read32(&reg->dsts) & 0x6);
+
+		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
+			cvidbg_cond(DEBUG_ISR,
+				     "\t\tFull Speed Detection\n");
+			set_max_pktsize(dev, CH9_USB_SPEED_FULL);
+			cvi_log_write(0x2222, 2, 0, 0, 0);
+
+		} else {
+			cvidbg_cond(DEBUG_ISR,
+				     "\t\tHigh Speed Detection : 0x%x\n",
+				     usb_status);
+			//cvidbg_cond(1, "HS\n");
+			cvi_log_write(0x2222, 1, 0, 0, 0);
+			set_max_pktsize(dev, CH9_USB_SPEED_HIGH);
+		}
+	}
+
+	if (intr_status & INT_EARLY_SUSPEND) {
+		cvidbg_cond(DEBUG_ISR, "\tEarly suspend interrupt\n");
+		cvi_uncached_write32(INT_EARLY_SUSPEND, &reg->gintsts);
+	}
+
+	if (intr_status & INT_SUSPEND) {
+		usb_status = cvi_uncached_read32(&reg->dsts);
+		cvidbg_cond(DEBUG_ISR,
+			     "\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
+		cvi_uncached_write32(INT_SUSPEND, &reg->gintsts);
+
+		if (dev->gadget.speed != CH9_USB_SPEED_UNKNOWN && dev->driver) {
+			if (dev->driver->suspend)
+				dev->driver->suspend(&dev->gadget);
+		}
+		//cvi_hsotg_set_bit(&reg->pcgcctl, PCGCTL_GATEHCLK);
+		//cvi_hsotg_set_bit(&reg->pcgcctl, PCGCTL_STOPPCLK);
+	}
+
+	if (intr_status & INT_RESUME) {
+		cvidbg_cond(DEBUG_ISR, "\tResume interrupt\n");
+		cvi_uncached_write32(INT_RESUME, &reg->gintsts);
+
+		//cvi_hsotg_clear_bit(&reg->pcgcctl, PCGCTL_GATEHCLK);
+		//cvi_hsotg_clear_bit(&reg->pcgcctl, PCGCTL_STOPPCLK);
+
+		if (dev->gadget.speed != CH9_USB_SPEED_UNKNOWN && dev->driver && dev->driver->resume) {
+
+			dev->driver->resume(&dev->gadget);
+		}
+	}
+
+	if ((intr_status & INT_RESET) || (intr_status & INT_RESETDET)) {
+		//cvi_hsotg_clear_bit(&reg->pcgcctl, PCGCTL_GATEHCLK);
+		//cvi_hsotg_clear_bit(&reg->pcgcctl, PCGCTL_STOPPCLK);
+
+		usb_status = cvi_uncached_read32(&reg->gotgctl);
+		cvidbg_cond(DEBUG_ISR,
+			     "\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
+		//cvidbg_cond(1,	"R\n");
+		cvi_log_write(0x1111, usb_status, 0, 0, 0);
+		if (intr_status & INT_RESET)
+			cvi_uncached_write32(INT_RESET, &reg->gintsts);
+		if (intr_status & INT_RESETDET)
+			cvi_uncached_write32(INT_RESETDET, &reg->gintsts);
+
+		if ((usb_status & 0xc0000) == (0x3 << 18)) {
+			unsigned int connected = dev->connected;
+
+			cvidbg_cond(DEBUG_ISR,
+				     "\t\tOTG core got reset!!\n");
+			cvi_disconnect(dev);
+			if (connected)
+				cvi_reconfig_usbd(dev, 1);
+			dev->ep0state = WAIT_FOR_SETUP;
+		} else {
+			cvidbg_cond(DEBUG_ISR,
+				     "\t\tRESET handling skipped\n");
+		}
+	}
+
+	if (intr_status & INT_IN_EP)
+		process_ep_in_intr(dev);
+
+	if (intr_status & INT_OUT_EP)
+		process_ep_out_intr(dev);
+
+	return 0;
+}
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ */
+int cvi_queue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct cvi_request *req;
+	struct cvi_ep *ep;
+	struct cvi_udc *dev;
+	uint32_t ep_num, gintsts;
+	struct cvi_usbotg_reg *reg;
+
+	req = container_of(_req, struct cvi_request, req);
+	if (!_req || !_req->complete || !_req->buf || !list_empty(&req->queue)) {
+		cvidbg("%s: bad params\n", __func__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+
+	if (!_ep || (!ep->desc && ep->ep.name != cvi_get_ep0_name())) {
+		cvidbg("%s: bad ep: %s, %d, %p\n", __func__,
+			ep->ep.name, !ep->desc, _ep);
+		return -EINVAL;
+	}
+
+	ep_num = ep_index(ep);
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == CH9_USB_SPEED_UNKNOWN) {
+		cvidbg("%s: bogus device state %p\n", __func__, dev->driver);
+		return -ESHUTDOWN;
+	}
+	reg = dev->reg;
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	cvidbg("\n*** %s: %s-%s req = %p, len = %d, buf = %p, Q empty = %d, stopped = %d\n",
+		__func__, _ep->name, ep_is_in(ep) ? "in" : "out",
+		_req, _req->length, _req->buf,
+		list_empty(&ep->queue), ep->stopped);
+
+#ifdef DEBUG
+	{
+		int i, len = _req->length;
+
+		printf("pkt = ");
+		if (len > 64)
+			len = 64;
+		for (i = 0; i < len; i++) {
+			printf("%02x", ((uint8_t *)_req->buf)[i]);
+			if ((i & 7) == 7)
+				printf(" ");
+		}
+		printf("\n");
+	}
+#endif
+
+	if (list_empty(&ep->queue) && !ep->stopped) {
+
+		if (ep_num == 0) {
+			/* EP0 */
+			list_add_tail(&req->queue, &ep->queue);
+			cvi_ep0_kick(dev, ep);
+			req = 0;
+
+		} else if (ep_is_in(ep)) {
+			gintsts = cvi_uncached_read32(&reg->gintsts);
+			cvidbg_cond(DEBUG_IN_EP,
+				     "%s: ep_is_in, CVI_UDC_OTG_GINTSTS=0x%x\n",
+				     __func__, gintsts);
+
+			setdma_tx(ep, req);
+		} else {
+			gintsts = cvi_uncached_read32(&reg->gintsts);
+			cvidbg_cond(DEBUG_OUT_EP != 0,
+				     "%s:ep_is_out, CVI_UDC_OTG_GINTSTS=0x%x\n",
+				     __func__, gintsts);
+
+			setdma_rx(ep, req);
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (req != 0)
+		list_add_tail(&req->queue, &ep->queue);
+
+	return 0;
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+int cvi_write_fifo_ep0(struct cvi_ep *ep, struct cvi_request *req)
+{
+	uint32_t max;
+	unsigned int count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	cvidbg_cond(DEBUG_EP0 != 0, "%s: max = %d\n", __func__, max);
+
+	count = setdma_tx(ep, req);
+
+	/* last packet is usually short (or a zlp) */
+	if (count != max)
+		is_last = 1;
+	else {
+		if ((req->req.length != req->req.actual + count) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	cvidbg_cond(DEBUG_EP0 != 0,
+		     "%s: wrote %s %d bytes%s %d left %p\n", __func__,
+		     ep->ep.name, count,
+		     is_last ? "/L" : "",
+		     req->req.length - req->req.actual - count, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		ep->dev->ep0state = WAIT_FOR_SETUP;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int cvi_fifo_read(struct cvi_ep *ep, uintptr_t *cp, int max)
+{
+	cvi_cache_invalidate((uintptr_t)cp, ROUND(max, CONFIG_SYS_CACHELINE_SIZE));
+
+	cvidbg_cond(DEBUG_EP0 != 0,
+		     "%s: bytes=%d, ep_index=%d 0x%p\n", __func__,
+		     max, ep_index(ep), cp);
+
+	return max;
+}
+
+/**
+ * cvi_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+void cvi_set_address(struct cvi_udc *dev, unsigned char address)
+{
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	uint32_t ctrl = cvi_uncached_read32(&reg->dcfg);
+
+	cvi_uncached_write32(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
+
+	cvi_udc_ep0_zlp(dev);
+
+	cvidbg_cond(DEBUG_EP0 != 0,
+		     "%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
+		     __func__, address, cvi_uncached_read32(&reg->dcfg));
+
+	dev->usb_address = address;
+	dev->connected = 1;
+}
+
+static inline void cvi_udc_ep0_set_stall(struct cvi_ep *ep, uint32_t is_in)
+{
+	struct cvi_udc *dev = ep->dev;
+	struct cvi_usbotg_reg *reg = dev->reg;
+	uint32_t		ep_ctrl = 0;
+
+	cvi_log_write(0x087087, is_in, 0, 0, 0);
+
+	if (is_in)
+		ep_ctrl = cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl);
+	else
+		ep_ctrl = cvi_uncached_read32(&reg->out_endp[EP0_CON].doepctl);
+
+	/* set the disable and stall bits */
+	//if (ep_ctrl & DEPCTL_EPENA)
+	//	ep_ctrl |= DEPCTL_EPDIS;
+
+	ep_ctrl |= DEPCTL_STALL;
+
+	if (is_in) {
+		cvi_uncached_write32(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
+		cvidbg_cond(DEBUG_EP0 != 0,
+			     "%s: set ep%d stall, DIEPCTL0 = 0x%p\n",
+			     __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
+	} else {
+		cvi_uncached_write32(ep_ctrl, &reg->out_endp[EP0_CON].doepctl);
+		cvidbg_cond(DEBUG_EP0 != 0,
+			     "%s: set ep%d stall, DOEPCTL0 = 0x%p\n",
+			     __func__, ep_index(ep), &reg->out_endp[EP0_CON].doepctl);
+	}
+
+	/*
+	 * The application can only set this bit, and the core clears it,
+	 * when a SETUP token is received for this endpoint
+	 */
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	cvi_udc_pre_setup(dev);
+}
+
+void cvi_ep0_read(struct cvi_udc *dev)
+{
+	struct cvi_request *req;
+	struct cvi_ep *ep = &dev->ep[0];
+
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct cvi_request, queue);
+
+	} else {
+		cvidbg("%s: ---> BUG\n", __func__);
+		return;
+	}
+
+	cvidbg_cond(DEBUG_EP0 != 0,
+		     "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
+		     __func__, req, req->req.length, req->req.actual);
+
+	if (req->req.length == 0) {
+		/* zlp for Set_configuration, Set_interface,
+		 * or Bulk-Only mass storge reset
+		 */
+
+		ep->len = 0;
+		cvi_udc_ep0_zlp(dev);
+
+		cvidbg_cond(DEBUG_EP0 != 0,
+			     "%s: req.length = 0, bRequest = %d\n",
+			     __func__, dev->usb_ctrl->bRequest);
+		return;
+	}
+
+	setdma_rx(ep, req);
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+int cvi_ep0_write(struct cvi_udc *dev)
+{
+	struct cvi_request *req;
+	struct cvi_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct cvi_request, queue);
+
+	if (!req) {
+		cvidbg_cond(DEBUG_EP0 != 0, "%s: NULL REQ\n", __func__);
+		return 0;
+	}
+
+	cvidbg_cond(DEBUG_EP0 != 0,
+		     "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
+		     __func__, req, req->req.length, req->req.actual);
+
+	ret = cvi_write_fifo_ep0(ep, req);
+
+	if ((ret == 1) && !need_zlp) {
+		/* Last packet */
+		dev->ep0state = WAIT_FOR_COMPLETE;
+		cvidbg_cond(DEBUG_EP0 != 0,
+			     "%s: finished, waiting for status\n", __func__);
+
+	} else {
+		dev->ep0state = DATA_STATE_XMIT;
+		cvidbg_cond(DEBUG_EP0 != 0,
+			     "%s: not finished\n", __func__);
+	}
+
+	return 1;
+}
+
+static int cvi_udc_get_status(struct cvi_udc *dev, CH9_UsbSetup *crq)
+{
+	uint8_t ep_num = cvi_phy_to_log_ep(crq->wIndex & 0x7F, !!(crq->wIndex & 0x80));
+	uint16_t g_status = 0;
+	uint32_t ep_ctrl;
+	struct cvi_usbotg_reg *reg = dev->reg;
+
+	cvidbg_cond(DEBUG_SETUP != 0,
+		     "%s: *** USB_REQ_GET_STATUS\n", __func__);
+	printf("crq->brequest:0x%x\n", crq->bmRequestType & CH9_REQ_RECIPIENT_MASK);
+	switch (crq->bmRequestType & CH9_REQ_RECIPIENT_MASK) {
+	case CH9_USB_REQ_RECIPIENT_INTERFACE:
+		g_status = 0;
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tGET_STATUS:CH9_USB_REQ_RECIPIENT_INTERFACE, g_stauts = %d\n",
+			     g_status);
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_DEVICE:
+		g_status = 0x1; /* Self powered */
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tGET_STATUS: CH9_USB_REQ_RECIPIENT_DEVICE, g_stauts = %d\n",
+			     g_status);
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_ENDPOINT:
+		if (crq->wLength > 2) {
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tGET_STATUS:Not support EP or wLength\n");
+			return 1;
+		}
+
+		g_status = dev->ep[ep_num].stopped;
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tGET_STATUS: CH9_USB_REQ_RECIPIENT_ENDPOINT, g_stauts = %d\n",
+			     g_status);
+
+		break;
+
+	default:
+		return 1;
+	}
+
+	memcpy(dev->usb_ctrl, &g_status, sizeof(g_status));
+
+	cvi_cache_flush((unsigned long)dev->usb_ctrl, ROUND(sizeof(g_status), CONFIG_SYS_CACHELINE_SIZE));
+
+	cvi_uncached_write32(dev->usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
+	cvi_uncached_write32(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
+			      &reg->in_endp[EP0_CON].dieptsiz);
+
+	ep_ctrl = cvi_uncached_read32(&reg->in_endp[EP0_CON].diepctl);
+	ep_ctrl &= ~(1 << 30);
+	cvi_uncached_write32(ep_ctrl | DEPCTL_EPENA | DEPCTL_CNAK,
+			      &reg->in_endp[EP0_CON].diepctl);
+	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
+
+	return 0;
+}
+
+void cvi_udc_set_nak(struct cvi_ep *ep)
+{
+	uint8_t		ep_num;
+	uint32_t		ep_ctrl = 0;
+	struct cvi_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+	cvidbg("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = cvi_uncached_read32(&reg->in_endp[ep_num].diepctl);
+		ep_ctrl |= DEPCTL_SNAK;
+		cvi_uncached_write32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+		cvidbg("%s: set NAK, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, cvi_uncached_read32(&reg->in_endp[ep_num].diepctl));
+	} else {
+		ep_ctrl = cvi_uncached_read32(&reg->out_endp[ep_num].doepctl);
+		ep_ctrl |= DEPCTL_SNAK;
+		cvi_uncached_write32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+		cvidbg("%s: set NAK, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, cvi_uncached_read32(&reg->out_endp[ep_num].doepctl));
+	}
+}
+
+static void cvi_udc_ep_set_stall(struct cvi_ep *ep)
+{
+	uint8_t		ep_num;
+	uint32_t		ep_ctrl = 0;
+	struct cvi_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+	cvidbg("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = cvi_uncached_read32(&reg->in_endp[ep_num].diepctl);
+
+		/* set the disable and stall bits */
+		if (ep_ctrl & DEPCTL_EPENA)
+			ep_ctrl |= DEPCTL_EPDIS;
+
+		ep_ctrl |= DEPCTL_STALL;
+
+		cvi_uncached_write32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+		cvidbg("%s: set stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, cvi_uncached_read32(&reg->in_endp[ep_num].diepctl));
+
+	} else {
+		ep_ctrl = cvi_uncached_read32(&reg->out_endp[ep_num].doepctl);
+
+		/* set the stall bit */
+		ep_ctrl |= DEPCTL_STALL;
+
+		cvi_uncached_write32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+		cvidbg("%s: set stall, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, cvi_uncached_read32(&reg->out_endp[ep_num].doepctl));
+	}
+}
+
+static void cvi_udc_ep_clear_stall(struct cvi_ep *ep)
+{
+	uint8_t		ep_num;
+	uint32_t		ep_ctrl = 0;
+	struct cvi_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+	cvidbg("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);
+
+	if (ep_is_in(ep)) {
+		ep_ctrl = cvi_uncached_read32(&reg->in_endp[ep_num].diepctl);
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		/*
+		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
+		 * of whether an endpoint has the Halt feature set, a
+		 * ClearFeature(ENDPOINT_HALT) request always results in the
+		 * data toggle being reinitialized to DATA0.
+		 */
+		if (ep->bmAttributes == CH9_USB_EP_INTERRUPT || ep->bmAttributes == CH9_USB_EP_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		cvi_uncached_write32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+		cvidbg("%s: cleared stall, DIEPCTL%d = 0x%x\n",
+			__func__, ep_num, cvi_uncached_read32(&reg->in_endp[ep_num].diepctl));
+
+	} else {
+		ep_ctrl = cvi_uncached_read32(&reg->out_endp[ep_num].doepctl);
+
+		/* clear stall bit */
+		ep_ctrl &= ~DEPCTL_STALL;
+
+		if (ep->bmAttributes == CH9_USB_EP_INTERRUPT || ep->bmAttributes == CH9_USB_EP_BULK) {
+			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
+		}
+
+		cvi_uncached_write32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+		cvidbg("%s: cleared stall, DOEPCTL%d = 0x%x\n",
+			__func__, ep_num, cvi_uncached_read32(&reg->out_endp[ep_num].doepctl));
+	}
+}
+
+int cvi_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct cvi_ep	*ep;
+	struct cvi_udc	*dev;
+	uint8_t		ep_num;
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	ep_num = ep_index(ep);
+
+	if (!_ep || !ep->desc || ep_num == EP0_CON ||
+	    ep->desc->bmAttributes == CH9_USB_EP_ISOCHRONOUS) {
+		cvidbg("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
+		return -EINVAL;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue
+	 */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		cvidbg("%s: %s queue not empty, req = %p\n",
+			__func__, ep->ep.name,
+			list_entry(ep->queue.next, struct cvi_request, queue));
+
+		return -EAGAIN;
+	}
+
+	dev = ep->dev;
+	cvidbg("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);
+
+	if (value == 0) {
+		ep->stopped = 0;
+		cvi_udc_ep_clear_stall(ep);
+	} else {
+		if (ep_num == 0)
+			dev->ep0state = WAIT_FOR_SETUP;
+
+		ep->stopped = 1;
+		cvi_udc_ep_set_stall(ep);
+	}
+
+	return 0;
+}
+
+void cvi_udc_ep_activate(struct cvi_ep *ep)
+{
+	uint8_t ep_num;
+	uint32_t ep_ctrl = 0, daintmsk = 0;
+	struct cvi_usbotg_reg *reg = ep->dev->reg;
+
+	ep_num = ep_index(ep);
+
+	/* Read DEPCTLn register */
+	if (ep_is_in(ep)) {
+		ep_ctrl = cvi_uncached_read32(&reg->in_endp[ep_num].diepctl);
+		daintmsk = 1 << ep_num;
+	} else {
+		ep_ctrl = cvi_uncached_read32(&reg->out_endp[ep_num].doepctl);
+		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
+	}
+
+	cvidbg("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
+		__func__, ep_num, ep_ctrl, ep_is_in(ep));
+
+	/* If the EP is already active don't change the EP Control
+	 * register.
+	 */
+	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
+		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
+			(ep->bmAttributes << DEPCTL_TYPE_BIT);
+		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
+			(ep->ep.maxpacket << DEPCTL_MPS_BIT);
+		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
+
+		if (ep_is_in(ep)) {
+			cvi_uncached_write32(ep_ctrl, &reg->in_endp[ep_num].diepctl);
+			cvidbg("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
+				__func__, ep_num, ep_num,
+				cvi_uncached_read32(&reg->in_endp[ep_num].diepctl));
+		} else {
+			cvi_uncached_write32(ep_ctrl, &reg->out_endp[ep_num].doepctl);
+			cvidbg("%s: USB Ative EP%d, DOEPCTRL%d = 0x%x\n",
+				__func__, ep_num, ep_num,
+				cvi_uncached_read32(&reg->out_endp[ep_num].doepctl));
+		}
+	}
+
+	/* Unmask EP Interrtupt */
+	cvi_uncached_write32(cvi_uncached_read32(&reg->daintmsk) | daintmsk, &reg->daintmsk);
+	cvidbg("%s: DAINTMSK = 0x%x\n", __func__, cvi_uncached_read32(&reg->daintmsk));
+
+}
+
+static int cvi_udc_clear_feature(struct usb_ep *_ep)
+{
+	struct cvi_udc	*dev;
+	struct cvi_ep	*ep;
+	uint8_t		ep_num;
+	CH9_UsbSetup *usb_ctrl;
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	ep_num = ep_index(ep);
+
+	dev = ep->dev;
+	usb_ctrl = dev->usb_ctrl;
+
+	cvidbg_cond(DEBUG_SETUP != 0,
+		     "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
+		     __func__, ep_num, ep_is_in(ep), dev->clear_feature_flag);
+
+	if (usb_ctrl->wLength != 0) {
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tCLEAR_FEATURE: wLength is not zero.....\n");
+		return 1;
+	}
+
+	switch (usb_ctrl->bmRequestType & CH9_REQ_RECIPIENT_MASK) {
+	case CH9_USB_REQ_RECIPIENT_DEVICE:
+		switch (usb_ctrl->wValue) {
+		case CH9_USB_FS_DEVICE_REMOTE_WAKEUP:
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tOFF:USB_DEVICE_REMOTE_WAKEUP\n");
+			break;
+
+		case CH9_USB_FS_TEST_MODE:
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
+			/** @todo Add CLEAR_FEATURE for TEST modes. */
+			break;
+		}
+
+		cvi_udc_ep0_zlp(dev);
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_ENDPOINT:
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tCLEAR_FEATURE:CH9_USB_REQ_RECIPIENT_ENDPOINT, wValue = %d\n",
+			     usb_ctrl->wValue);
+
+		if (usb_ctrl->wValue == CH9_USB_FS_ENDPOINT_HALT) {
+			if (ep_num == 0) {
+				cvi_udc_ep0_set_stall(ep, 1);
+				return 0;
+			}
+
+			cvi_udc_ep0_zlp(dev);
+
+			cvi_udc_ep_clear_stall(ep);
+			cvi_udc_ep_activate(ep);
+			ep->stopped = 0;
+
+			dev->clear_feature_num = ep_num;
+			dev->clear_feature_flag = 1;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static int cvi_udc_set_feature(struct usb_ep *_ep)
+{
+	struct cvi_udc	*dev;
+	struct cvi_ep	*ep;
+	uint8_t		ep_num;
+	CH9_UsbSetup *usb_ctrl;
+
+	ep = container_of(_ep, struct cvi_ep, ep);
+	ep_num = ep_index(ep);
+	dev = ep->dev;
+	usb_ctrl = dev->usb_ctrl;
+
+	cvidbg_cond(DEBUG_SETUP != 0,
+		     "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
+		      __func__, ep_num);
+
+	if (usb_ctrl->wLength != 0) {
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tSET_FEATURE: wLength is not zero.....\n");
+		return 1;
+	}
+
+	switch (usb_ctrl->bmRequestType & CH9_REQ_RECIPIENT_MASK) {
+	case CH9_USB_REQ_RECIPIENT_DEVICE:
+		switch (usb_ctrl->wValue) {
+		case CH9_USB_FS_DEVICE_REMOTE_WAKEUP:
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tSET_FEATURE:USB_DEVICE_REMOTE_WAKEUP\n");
+			break;
+		case CH9_USB_FS_B_HNP_ENABLE:
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tSET_FEATURE: USB_DEVICE_B_HNP_ENABLE\n");
+			break;
+
+		case CH9_USB_FS_A_HNP_SUPPORT:
+			/* RH port supports HNP */
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tSET_FEATURE:USB_DEVICE_A_HNP_SUPPORT\n");
+			break;
+
+		case CH9_USB_FS_A_ALT_HNP_SUPPORT:
+			/* other RH port does */
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tSET: USB_DEVICE_A_ALT_HNP_SUPPORT\n");
+			break;
+		case CH9_USB_FS_TEST_MODE:
+			dev->test_mode = usb_ctrl->wIndex >> 8;
+			break;
+		}
+
+		cvi_udc_ep0_zlp(dev);
+		return 0;
+
+	case CH9_USB_REQ_RECIPIENT_INTERFACE:
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tSET_FEATURE: CH9_USB_REQ_RECIPIENT_INTERFACE\n");
+		break;
+
+	case CH9_USB_REQ_RECIPIENT_ENDPOINT:
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tSET_FEATURE: CH9_USB_REQ_RECIPIENT_ENDPOINT\n");
+		if (usb_ctrl->wValue == CH9_USB_FS_ENDPOINT_HALT) {
+			if (ep_num == 0) {
+				cvi_udc_ep0_set_stall(ep, 1);
+				return 0;
+			}
+			ep->stopped = 1;
+			cvi_udc_ep_set_stall(ep);
+		}
+
+		cvi_udc_ep0_zlp(dev);
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * WAIT_FOR_SETUP (OUT_PKT_RDY)
+ */
+static void cvi_ep0_setup(struct cvi_udc *dev)
+{
+	struct cvi_ep *ep = &dev->ep[0];
+	int i;
+	uint8_t ep_num;
+	CH9_UsbSetup *usb_ctrl = dev->usb_ctrl;
+	uint8_t three_stage = 0;
+
+	/* Nuke all previous transfers */
+	cvi_nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	cvi_fifo_read(ep, (uintptr_t *)usb_ctrl, 8);
+
+	cvidbg_cond(DEBUG_SETUP != 0,
+		     "%s: bmRequestType = 0x%x(%s), bRequest = 0x%x, wLength = 0x%x, wValue = 0x%x, wIndex= 0x%x\n",
+		     __func__, usb_ctrl->bmRequestType,
+		     (usb_ctrl->bmRequestType & USB_DIR_IN) ? "IN" : "OUT",
+		     usb_ctrl->bRequest,
+		     usb_ctrl->wLength, usb_ctrl->wValue, usb_ctrl->wIndex);
+
+	three_stage = usb_ctrl->wLength ? 1 : 0;
+#ifdef DEBUG
+	{
+		int i, len = sizeof(*usb_ctrl);
+		char *p = (char *)usb_ctrl;
+
+		printf("pkt = ");
+		for (i = 0; i < len; i++) {
+			printf("%02x", ((uint8_t *)p)[i]);
+			if ((i & 7) == 7)
+				printf(" ");
+		}
+		printf("\n");
+	}
+#endif
+
+	/* Set direction of EP0 */
+	if (usb_ctrl->bmRequestType & USB_DIR_IN) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+	}
+	/* cope with automagic for some standard requests. */
+	dev->req_std = (usb_ctrl->bmRequestType & CH9_USB_REQ_TYPE_MASK)
+		== CH9_USB_REQ_TYPE_STANDARD;
+
+	dev->req_pending = 1;
+
+	/* Handle some SETUP packets ourselves */
+	if (dev->req_std) {
+		switch (usb_ctrl->bRequest) {
+		case CH9_USB_REQ_SET_ADDRESS:
+			cvi_log_write(0xBBBBB, 1, usb_ctrl->wValue, 0, 0);
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "%s: *** USB_REQ_SET_ADDRESS (%d)\n",
+				     __func__, usb_ctrl->wValue);
+			if (usb_ctrl->bmRequestType
+				!= (CH9_USB_REQ_TYPE_STANDARD | CH9_USB_REQ_RECIPIENT_DEVICE))
+				break;
+
+			cvi_set_address(dev, usb_ctrl->wValue);
+			return;
+
+		case CH9_USB_REQ_SET_CONFIGURATION:
+			cvi_log_write(0xBBBBB, 2, usb_ctrl->wValue, 0, 0);
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "=====================================\n");
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "%s: USB_REQ_SET_CONFIGURATION (%d)\n",
+				     __func__, usb_ctrl->wValue);
+
+			break;
+
+		case CH9_USB_REQ_GET_DESCRIPTOR:
+			cvi_log_write(0xBBBBB, 3, 0, 0, 0);
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "%s: *** USB_REQ_GET_DESCRIPTOR\n",
+				     __func__);
+			break;
+
+		case CH9_USB_REQ_SET_INTERFACE:
+			cvi_log_write(0xBBBBB, 4, 0, 0, 0);
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "%s: *** USB_REQ_SET_INTERFACE (%d)\n",
+				     __func__, usb_ctrl->wValue);
+
+			break;
+
+		case CH9_USB_REQ_GET_CONFIGURATION:
+			cvi_log_write(0xBBBBB, 5, 0, 0, 0);
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "%s: *** USB_REQ_GET_CONFIGURATION\n",
+				     __func__);
+			break;
+
+		case CH9_USB_REQ_GET_STATUS:
+			cvi_log_write(0xBBBBB, 6, 0, 0, 0);
+			if (!cvi_udc_get_status(dev, usb_ctrl))
+				return;
+
+			break;
+
+		case CH9_USB_REQ_CLEAR_FEATURE:
+			cvi_log_write(0xBBBBB, 7, 0, 0, 0);
+			ep_num = cvi_phy_to_log_ep(usb_ctrl->wIndex & 0x7F, !!(usb_ctrl->wIndex & 0x80));
+
+			if (!cvi_udc_clear_feature(&dev->ep[ep_num].ep))
+				return;
+
+			break;
+
+		case CH9_USB_REQ_SET_FEATURE:
+			cvi_log_write(0xBBBBB, 8, 0, 0, 0);
+			ep_num = cvi_phy_to_log_ep(usb_ctrl->wIndex & 0x7F, !!(usb_ctrl->wIndex & 0x80));
+
+			if (!cvi_udc_set_feature(&dev->ep[ep_num].ep))
+				return;
+
+			break;
+
+		default:
+			cvi_log_write(0xBBBBB, 9, 0, 0, 0);
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "%s: *** Default of usb_ctrl->bRequest=0x%x happened.\n",
+				     __func__, usb_ctrl->bRequest);
+			break;
+		}
+	}
+
+	if (dev->driver) {
+		/* device-2-host (IN) or no data setup command,
+		 * process immediately
+		 */
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "%s:usb_ctrlreq will be passed to fsg_setup()\n",
+			     __func__);
+
+		i = dev->driver->setup(&dev->gadget, usb_ctrl);
+
+		if (i < 0) {
+			uint32_t dir = (usb_ctrl->wLength == 0) ? 1 : ep_is_in(ep);
+			/* setup processing failed, force stall */
+			cvi_udc_ep0_set_stall(ep, dir);
+			dev->ep0state = WAIT_FOR_SETUP;
+
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tdev->driver->setup failed (%d), bRequest = %d\n",
+				     i, usb_ctrl->bRequest);
+			return;
+
+		} else if (dev->req_pending) {
+			dev->req_pending = 0;
+			cvidbg_cond(DEBUG_SETUP != 0,
+				     "\tdev->req_pending...\n");
+		}
+
+		cvidbg_cond(DEBUG_SETUP != 0,
+			     "\tep0state = %s\n", state_names[dev->ep0state]);
+
+	}
+
+	if (!three_stage)
+		cvi_udc_ep0_zlp(dev);
+}
+
+/*
+ * handle ep0 interrupt
+ */
+void cvi_handle_ep0(struct cvi_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP) {
+		cvidbg_cond(DEBUG_OUT_EP != 0,
+			     "%s: WAIT_FOR_SETUP\n", __func__);
+		cvi_ep0_setup(dev);
+
+	} else {
+		cvidbg_cond(DEBUG_OUT_EP != 0,
+			     "%s: strange state!!(state = %s)\n",
+			     __func__, state_names[dev->ep0state]);
+	}
+}
+
+void cvi_ep0_kick(struct cvi_udc *dev, struct cvi_ep *ep)
+{
+	cvidbg_cond(DEBUG_EP0 != 0,
+		     "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		cvi_ep0_write(dev);
+
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		cvi_ep0_read(dev);
+	}
+}
diff --git a/drivers/cvi_usb/utask/cv181x/cvi_usb.c b/drivers/cvi_usb/utask/cv181x/cvi_usb.c
new file mode 100644
index 000000000..6ad769f61
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/cvi_usb.c
@@ -0,0 +1,47 @@
+/**********************************************************************
+ * main.c
+ *
+ * USB Core Driver
+ * main component function
+ ***********************************************************************/
+#include "include/debug.h"
+#include "include/cvi_usb.h"
+#include "include/platform_def.h"
+#include <common.h>
+#include <linux/delay.h>
+#include <mmio.h>
+#include <cpu_func.h>
+
+extern int acm_app(void);
+
+static void cvi_usb_hw_init(void)
+{
+	uint32_t value;
+
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) & (~BIT_TOP_SOFT_RST_USB);
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+	udelay(50);
+	value = mmio_read_32(TOP_BASE + REG_TOP_SOFT_RST) | BIT_TOP_SOFT_RST_USB;
+	mmio_write_32(TOP_BASE + REG_TOP_SOFT_RST, value);
+
+	/* Set USB phy configuration */
+	value = mmio_read_32(REG_TOP_USB_PHY_CTRL);
+	mmio_write_32(REG_TOP_USB_PHY_CTRL, value | BIT_TOP_USB_PHY_CTRL_EXTVBUS
+					| USB_PHY_ID_OVERRIDE_ENABLE
+					| USB_PHY_ID_VALUE);
+
+	/* Enable ECO RXF */
+	// mmio_write_32(REG_TOP_USB_ECO, mmio_read_32(REG_TOP_USB_ECO) | BIT_TOP_USB_ECO_RX_FLUSH);
+
+	NOTICE("%s\n", __func__);
+}
+
+/* program starts here */
+int cvi_usb_polling(void)
+{
+	cvi_usb_hw_init();
+
+	acm_app();
+
+	return 0;
+}
diff --git a/drivers/cvi_usb/utask/cv181x/include/big_endian.h b/drivers/cvi_usb/utask/cv181x/include/big_endian.h
new file mode 100644
index 000000000..72f6f8be7
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/big_endian.h
@@ -0,0 +1,24 @@
+#ifndef BYTEORDER_BENDIAN_H
+#define BYTEORDER_BENDIAN_H
+
+#include "swap.h"
+
+#define cpuToLe32(x) ((uint32_t)swap32(x))
+#define le32ToCpu(x) ((uint32_t)swap32(x))
+#define cpuToLe16(x) ((uint16_t)swap16(x))
+#define le16ToCpu(x) ((uint16_t)swap16(x))
+
+#define cpuToBe32(x) (x)
+#define be32ToCpu(x) (x)
+#define cpuToBe16(x) (x)
+#define be16ToCpu(x) (x)
+
+/**
+ * Macros used for reading 16-bits and 32-bits data from memory which
+ * starting address could be unaligned.
+ */
+#define ptrToWord(ptr) ((*(uint8_t *)ptr) | (*((uint8_t *)(ptr + 1)) << 8))
+#define ptrToDword(ptr) ((*(uint8_t *)ptr) | (*((uint8_t *)(ptr + 1)) << 8) | \
+	(*((uint8_t *)(ptr + 2)) << 16) | (*((uint8_t *)(ptr + 3)) << 24))
+
+#endif /* BYTEORDER_BENDIAN_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/byteorder.h b/drivers/cvi_usb/utask/cv181x/include/byteorder.h
new file mode 100644
index 000000000..f8d9cc28f
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/byteorder.h
@@ -0,0 +1,12 @@
+#ifndef BYTEORDER_H
+#define BYTEORDER_H
+
+#define CPU_LITTLE_ENDIAN
+
+#ifdef CPU_LITTLE_ENDIAN
+#include "little_endian.h"
+#else
+#include "big_endian.h"
+#endif
+
+#endif /* BYTEORDER_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_ch9.h b/drivers/cvi_usb/utask/cv181x/include/cvi_ch9.h
new file mode 100644
index 000000000..8ab9b0a2b
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_ch9.h
@@ -0,0 +1,890 @@
+#ifndef CVI_CH9_H
+#define CVI_CH9_H
+
+#include "cvi_stdtypes.h"
+#include "linux/bitops.h"
+
+/** @defgroup ConfigInfo  Configuration and Hardware Operation Information
+ *  The following definitions specify the driver operation environment that
+ *  is defined by hardware configuration or client code. These defines are
+ *  located in the header file of the core driver.
+ *  @{
+ */
+
+/**********************************************************************
+ * Defines
+ **********************************************************************
+ */
+
+/** Data transfer direction */
+#define	CH9_USB_DIR_HOST_TO_DEVICE 0
+
+#define	CH9_USB_DIR_DEVICE_TO_HOST BIT(7)
+
+/** Type of request */
+#define	CH9_USB_REQ_TYPE_MASK (3 << 5)
+
+#define	CH9_USB_REQ_TYPE_STANDARD (0 << 5)
+
+#define	CH9_USB_REQ_TYPE_CLASS BIT(5)
+
+#define	CH9_USB_REQ_TYPE_VENDOR (2 << 5)
+
+#define	CH9_USB_REQ_TYPE_OTHER (3 << 5)
+
+/** Recipient of request */
+#define	CH9_REQ_RECIPIENT_MASK 0x0f
+
+#define	CH9_USB_REQ_RECIPIENT_DEVICE 0
+
+#define	CH9_USB_REQ_RECIPIENT_INTERFACE 1
+
+#define	CH9_USB_REQ_RECIPIENT_ENDPOINT 2
+
+#define	CH9_USB_REQ_RECIPIENT_OTHER 3
+
+/** Standard  Request Code (chapter 9.4, Table 9-5 of USB Spec.) */
+#define	CH9_USB_REQ_GET_STATUS 0
+
+#define	CH9_USB_REQ_CLEAR_FEATURE 1
+
+#define	CH9_USB_REQ_SET_FEATURE 3
+
+#define	CH9_USB_REQ_SET_ADDRESS 5
+
+#define	CH9_USB_REQ_GET_DESCRIPTOR 6
+
+#define	CH9_USB_REQ_SET_DESCRIPTOR 7
+
+#define	CH9_USB_REQ_GET_CONFIGURATION 8
+
+#define	CH9_USB_REQ_SET_CONFIGURATION 9
+
+#define	CH9_USB_REQ_GET_INTERFACE 10
+
+#define	CH9_USB_REQ_SET_INTERFACE 11
+
+#define	CH9_USB_REQ_SYNCH_FRAME 12
+
+#define	CH9_USB_REQ_SET_ENCRYPTION 13
+
+#define	CH9_USB_REQ_GET_ENCRYPTION 14
+
+#define	CH9_USB_REQ_SET_HANDSHAKE 15
+
+#define	CH9_USB_REQ_GET_HANDSHAKE 16
+
+#define	CH9_USB_REQ_SET_CONNECTION 17
+
+#define	CH9_USB_REQ_SET_SCURITY_DATA 18
+
+#define	CH9_USB_REQ_GET_SCURITY_DATA 19
+
+#define	CH9_USB_REQ_SET_WUSB_DATA 20
+
+#define	CH9_USB_REQ_LOOPBACK_DATA_WRITE 21
+
+#define	CH9_USB_REQ_LOOPBACK_DATA_READ 22
+
+#define	CH9_USB_REQ_SET_INTERFACE_DS 23
+
+#define CH9_USB_REQ_CVI_ENTER_DL 66
+
+#define	CH9_USB_REQ_SET_SEL 48
+
+#define	CH9_USB_REQ_ISOCH_DELAY 49
+
+/** Standard Descriptor Types (chapter 9.4 - Table 9-6 of USB Spec.) */
+#define	CH9_USB_DT_DEVICE 1
+
+#define	CH9_USB_DT_CONFIGURATION 2
+
+#define	CH9_USB_DT_STRING 3
+
+#define	CH9_USB_DT_INTERFACE 4
+
+#define	CH9_USB_DT_ENDPOINT 5
+
+#define	CH9_USB_DT_DEVICE_QUALIFIER 6
+
+/** USB 2 */
+#define	CH9_USB_DT_OTHER_SPEED_CONFIGURATION 7
+
+/** USB 2 */
+#define	CH9_USB_DT_INTERFACE_POWER 8
+
+#define	CH9_USB_DT_OTG 9
+
+#define	CH9_USB_DT_DEBUG 10
+
+#define	CH9_USB_DT_INTERFACE_ASSOCIATION 11
+
+#define	CH9_USB_DT_BOS 15
+
+#define	CH9_USB_DT_DEVICE_CAPABILITY 16
+
+#define	CH9_USB_DT_SS_USB_ENDPOINT_COMPANION 48
+
+#define	CH9_USB_DT_SS_PLUS_ISOCHRONOUS_ENDPOINT_COMPANION 49
+
+#define	CH9_USB_DT_OTG 9
+
+/** Descriptor size */
+#define	CH9_USB_DS_DEVICE 18
+
+#define	CH9_USB_DS_BOS 5
+
+#define	CH9_USB_DS_DEVICE_ACM 12
+
+/** Capability type: USB 2.0 EXTENSION */
+#define	CH9_USB_DS_DEVICE_CAPABILITY_20 7
+
+/** Capability type: SUPERSPEED_USB */
+#define	CH9_USB_DS_DEVICE_CAPABILITY_30 10
+
+/** Capability type: CONTAINER_ID */
+#define	CH9_USB_DS_DEVICE_CAPABILITY_CONTAINER_ID 21
+
+/** Capability type: Capability type: PRECISION_TIME_MEASUREMENT */
+#define	CH9_USB_DS_DEVICE_CAPABILITY_PRECISION_TIME_MEASUREMENT 4
+
+#define	CH9_USB_DS_CONFIGURATION 9
+
+#define	CH9_USB_DS_INTERFACE_ASSOCIATION 8
+
+#define	CH9_USB_DS_SS_USB_ENDPOINT_COMPANION 6
+
+#define	CH9_USB_DS_SS_PLUS_ISOCHRONOUS_ENDPOINT_COMPANION 8
+
+#define	CH9_USB_DS_INTERFACE 9
+
+#define	CH9_USB_DS_ENDPOINT 7
+
+#define	CH9_USB_DS_STRING 3
+
+#define	CH9_USB_DS_OTG 5
+
+/** USB2 */
+#define	CH9_USB_DS_DEVICE_QUALIFIER 10
+
+/** USB2 */
+#define	CH9_USB_DS_OTHER_SPEED_CONFIGURATION 7
+
+#define	CH9_USB_DS_INTERFACE_POWER 8
+
+/** Standard Feature Selectors (chapter 9.4, Table 9-7 of USB Spec) */
+#define	CH9_USB_FS_ENDPOINT_HALT 0
+
+#define	CH9_USB_FS_FUNCTION_SUSPEND 0
+
+#define	CH9_USB_FS_DEVICE_REMOTE_WAKEUP 1
+
+#define	CH9_USB_FS_TEST_MODE 2
+
+#define	CH9_USB_FS_B_HNP_ENABLE 3
+
+#define	CH9_USB_FS_A_HNP_SUPPORT 4
+
+#define	CH9_USB_FS_A_ALT_HNP_SUPPORT 5
+
+#define	CH9_USB_FS_WUSB_DEVICE 6
+
+#define	CH9_USB_FS_U1_ENABLE 48
+
+#define	CH9_USB_FS_U2_ENABLE 49
+
+#define	CH9_USB_FS_LTM_ENABLE 50
+
+#define	CH9_USB_FS_B3_NTF_HOST_REL 51
+
+#define	CH9_USB_FS_B3_RESP_ENABLE 52
+
+#define	CH9_USB_FS_LDM_ENABLE 53
+
+/** Recipient Device (Figure 9-4 of USB Spec) */
+#define	CH9_USB_STATUS_DEV_SELF_POWERED BIT(0)
+
+#define	CH9_USB_STATUS_DEV_REMOTE_WAKEUP BIT(1)
+
+#define	CH9_USB_STATUS_DEV_U1_ENABLE BIT(2)
+
+#define	CH9_USB_STATUS_DEV_U2_ENABLE BIT(3)
+
+#define	CH9_USB_STATUS_DEV_LTM_ENABLE BIT(4)
+
+/** Recipient Interface (Figure 9-5 of USB Spec) */
+#define	CH9_USB_STATUS_INT_REMOTE_WAKE_CAPABLE BIT(0)
+
+#define	CH9_USB_STATUS_INT_REMOTE_WAKEUP BIT(1)
+
+/** Recipient Endpoint (Figure 9-6 of USB Spec) */
+#define	CH9_USB_STATUS_EP_HALT BIT(1)
+
+/** Recipient Endpoint - PTM GetStatus Request(Figure 9-7 of USB Spec) */
+#define	CH9_USB_STATUS_EP_PTM_ENABLE BIT(0)
+
+#define	CH9_USB_STATUS_EP_PTM_VALID BIT(1)
+
+#define	CH9_USB_STATUS_EP_PTM_LINK_DELAY_OFFSET (16)
+
+#define	CH9_USB_STATUS_EP_PTM_LINK_DELAY_MASK (0xFFFF << 16)
+
+/**
+ * Macros describing information for SetFeauture Request and FUNCTION_SUSPEND selector
+ * (chapter 9.4.9, Table 9-9 of USB Spec)
+ */
+#define	CH9_USB_SF_LOW_POWER_SUSPEND_STATE 0x1
+
+#define	CH9_USB_SF_REMOTE_WAKE_ENABLED 0x2
+
+/**
+ * Standard Class Code defined by usb.org
+ * (link: http://www.usb.org/developers/defined_class)
+ */
+#define	CH9_USB_CLASS_INTERFACE 0x0
+
+#define	CH9_USB_CLASS_AUDIO 0x01
+
+#define	CH9_USB_CLASS_CDC 0x02
+
+#define	CH9_USB_CLASS_COMMUNICATION 0x01
+
+#define	CH9_USB_CLASS_HID 0x03
+
+#define	CH9_USB_CLASS_PHYSICAL 0x05
+
+#define	CH9_USB_CLASS_IMAGE 0x06
+
+#define	CH9_USB_CLASS_PRINTER 0x07
+
+#define	CH9_USB_CLASS_MASS_STORAGE 0x08
+
+#define	CH9_USB_CLASS_HUB 0x09
+
+#define	CH9_USB_CLASS_CDC_DATA 0x0A
+
+#define	CH9_USB_CLASS_SMART_CARD 0x0B
+
+#define	CH9_USB_CLASS_CONTENT_SEECURITY 0x0D
+
+#define	CH9_USB_CLASS_VIDEO 0x0E
+
+#define	CH9_USB_CLASS_HEALTHCARE 0x0F
+
+#define	CH9_USB_CLASS_AUDIO_VIDEO 0x10
+
+#define	CH9_USB_CLASS_DIAGNOSTIC 0xDC
+
+#define	CH9_USB_CLASS_WIRELESS 0xE0
+
+#define	CH9_USB_CLASS_MISCELLANEOUS 0xEF
+
+#define	CH9_USB_CLASS_APPLICATION 0xFE
+
+#define	CH9_USB_CLASS_VENDOR 0xFF
+
+/** Device Capability Types Codes (see Table 9-14 of USB Spec 3.1 */
+#define	CH9_USB_DCT_WIRELESS_USB 0x01
+
+#define	CH9_USB_DCT_USB20_EXTENSION 0x02
+
+#define	CH9_USB_DCT_SS_USB 0x03
+
+#define	CH9_USB_DCT_CONTAINER_ID 0x04
+
+#define	CH9_USB_DCT_PLATFORM 0x05
+
+#define	CH9_USB_DCT_POWER_DELIVERY_CAPABILITY 0x06
+
+#define	CH9_USB_DCT_BATTERY_INFO_CAPABILITY 0x07
+
+#define	CH9_USB_DCT_PD_CONSUMER_PORT_CAPABILITY 0x08
+
+#define	CH9_USB_DCT_PD_PROVIDER_PORT_CAPABILITY 0x09
+
+#define	CH9_USB_DCT_SS_PLUS 0x0A
+
+#define	CH9_USB_DCT_PRECISION_TIME_MEASUREMENT 0x0B
+
+#define	CH9_USB_DCT_WIRELESS_USB_EXT 0x0C
+
+/** Describe supports LPM defined in bmAttribues field of CUSBD_Usb20ExtensionDescriptor */
+#define	CH9_USB_USB20_EXT_LPM_SUPPORT BIT(1)
+
+#define	CH9_USB_USB20_EXT_BESL_AND_ALTERNATE_HIRD BIT(2)
+
+/**
+ * Describe supports LTM defined in bmAttribues field
+ * of CUSBD_UsbSuperSpeedDeviceCapabilityDescriptor
+ */
+#define	CH9_USB_SS_CAP_LTM BIT(1)
+
+/**
+ * Describe speed supported defined in wSpeedSupported field
+ * of CUSBD_UsbSuperSpeedDeviceCapabilityDescriptor
+ */
+#define	CH9_USB_SS_CAP_SUPPORT_LS BIT(0)
+
+#define	CH9_USB_SS_CAP_SUPPORT_FS BIT(1)
+
+#define	CH9_USB_SS_CAP_SUPPORT_HS BIT(2)
+
+#define	CH9_USB_SS_CAP_SUPPORT_SS BIT(3)
+
+/** Describe encoding of bmSublinkSpeedAttr0 filed from CUSBD_UsbSuperSpeedPlusDescriptor */
+#define	CH9_USB_SSP_SID_OFFSET 0
+
+#define	CH9_USB_SSP_SID_MASK 0 0x0000000f
+
+#define	CH9_USB_SSP_LSE_OFFSET 4
+
+#define	CH9_USB_SSP_LSE_MASK (0x00000003 << CUSBD_USB_SSP_LSE_OFFSET)
+
+#define	CH9_USB_SSP_ST_OFFSET 6
+
+#define	CH9_USB_SSP_ST_MASK (0x00000003 << CUSBD_USB_SSP_ST_OFFSET)
+
+#define	CH9_USB_SSP_LP_OFFSET 14
+
+#define	CH9_USB_SSP_LP_MASK (0x00000003 << CUSBD_USB_SSP_LP_OFFSET)
+
+#define	CH9_USB_SSP_LSM_OFFSET 16
+
+#define	CH9_USB_SSP_LSM_MASK (0x0000FFFF << CUSBD_USB_SSP_LSM_OFFSET)
+
+/** Description of bmAttributes field from  Configuration Description */
+#define	CH9_USB_CONFIG_RESERVED BIT(7)
+
+/** Self Powered */
+#define	CH9_USB_CONFIG_SELF_POWERED BIT(6)
+
+#define CH9_USB_CONFIG_BUS_POWERED BIT(7)
+
+/** Remote Wakeup */
+#define	CH9_USB_CONFIG_REMOTE_WAKEUP BIT(5)
+
+/** Definitions for bEndpointAddress field from  Endpoint descriptor */
+#define	CH9_USB_EP_DIR_MASK 0x80
+
+#define	CH9_USB_EP_DIR_IN 0x80
+
+#define	CH9_USB_EP_NUMBER_MASK 0x0f
+
+/** Endpoint attributes from Endpoint descriptor - bmAttributes field */
+#define	CH9_USB_EP_TRANSFER_MASK 0x03
+
+#define	CH9_USB_EP_CONTROL 0x0
+
+#define	CH9_USB_EP_ISOCHRONOUS 0x01
+
+#define	CH9_USB_EP_BULK 0x02
+
+#define	CH9_USB_EP_INTERRUPT 0x03
+
+/** Synchronization types for ISOCHRONOUS endpoints */
+#define	CH9_USB_EP_SYNC_MASK 0xC
+
+#define	CH9_USB_EP_SYNC_NO (0x00 >> 2)
+
+#define	CH9_USB_EP_SYNC_ASYNCHRONOUS (0x1 >> 2)
+
+#define	CH9_USB_EP_SYNC_ADAPTIVE (0x02 >> 2)
+
+#define	CH9_USB_EP_SYNC_SYNCHRONOUS (0x03 >> 2)
+
+#define	CH9_USB_EP_USAGE_MASK (0x3 >> 4)
+
+/** Usage types for ISOCHRONOUS endpoints */
+#define	CH9_USB_EP_USAGE_DATA (00 >> 4)
+
+#define	CH9_USB_EP_USAGE_FEEDBACK (0x01 >> 4)
+
+#define	CH9_USB_EP_USAGE_IMPLICIT_FEEDBACK (0x02 >> 4)
+
+/** Usage types for INTERRUPTS endpoints */
+#define	CH9_USB_EP_USAGE_PERIODIC (00 >> 4)
+
+#define	CH9_USB_EP_USAGE_NOTIFICATION (0x01 >> 4)
+
+/** Description of fields bmAttributes from OTG descriptor */
+#define	CH9_USB_OTG_ADP_MASK 0x4
+
+#define	CH9_USB_OTG_HNP_MASK 0x2
+
+#define	CH9_USB_OTG_SRP_MASK 0x1
+
+/**
+ * Test Mode Selectors
+ * See USB 2.0 spec Table 9-7
+ */
+#define	CH9_TEST_J 1
+
+#define	CH9_TEST_K 2
+
+#define	CH9_TEST_SE0_NAK 3
+
+#define	CH9_TEST_PACKET 4
+
+#define	CH9_TEST_FORCE_EN 5
+
+#define	CH9_MAX_PACKET_SIZE_MASK 0x7ff
+
+#define	CH9_PACKET_PER_FRAME_SHIFT 11
+
+/**
+ * OTG status selector
+ * See USB_OTG_AND_EH_2-0 spec Table 6-4
+ */
+#define	CH9_OTG_STATUS_SELECTOR 0xF000
+
+/**
+ *  @}
+ */
+
+/* Conventional codes for class-specific descriptors.  The convention is
+ * defined in the USB "Common Class" Spec (3.11).  Individual class specs
+ * are authoritative for their usage, not the "common class" writeup.
+ */
+#define USB_DT_CS_DEVICE		(CH9_USB_REQ_TYPE_CLASS | CH9_USB_DT_DEVICE)
+#define USB_DT_CS_CONFIG		(CH9_USB_REQ_TYPE_CLASS | CH9_USB_DT_CONFIG)
+#define USB_DT_CS_STRING		(CH9_USB_REQ_TYPE_CLASS | CH9_USB_DT_STRING)
+#define USB_DT_CS_INTERFACE		(CH9_USB_REQ_TYPE_CLASS | CH9_USB_DT_INTERFACE)
+#define USB_DT_CS_ENDPOINT		(CH9_USB_REQ_TYPE_CLASS | CH9_USB_DT_ENDPOINT)
+
+/** @defgroup DataStructure Dynamic Data Structures
+ *  This section defines the data structures used by the driver to provide
+ *  hardware information, modification and dynamic operation of the driver.
+ *  These data structures are defined in the header file of the core driver
+ *  and utilized by the API.
+ *  @{
+ */
+
+/**********************************************************************
+ * Forward declarations
+ **********************************************************************/
+struct CH9_UsbSetup;
+struct CH9_UsbDeviceDescriptor;
+struct CH9_UsbBosDescriptor;
+struct CH9_UsbCapabilityDescriptor;
+struct CH9_Usb20ExtensionDescriptor;
+struct CH9_UsbSSDeviceCapabilityDescriptor;
+struct CH9_UsbContainerIdDescriptor;
+struct CH9_UsbPlatformDescriptor;
+struct CH9_UsbSSPlusDescriptor;
+struct CH9_UsbPTMCapabilityDescriptor;
+struct CH9_UsbConfigurationDescriptor;
+struct CH9_UsbInterfaceAssociationDescriptor;
+struct CH9_UsbInterfaceDescriptor;
+struct CH9_UsbEndpointDescriptor;
+struct CH9_UsbSSEndpointCompanionDescriptor;
+struct CH9_UsbSSPlusIsocEndpointCompanionDescriptor;
+struct CH9_UsbStringDescriptor;
+struct CH9_UsbDeviceQualifierDescriptor;
+struct CH9_UsbOtherSpeedConfigurationDescriptor;
+struct CH9_UsbHeaderDescriptor;
+struct CH9_UsbOtgDescriptor;
+struct CH9_ConfigParams;
+
+/**********************************************************************
+ * Enumerations
+ **********************************************************************/
+/** USB States defined in USB Specification */
+typedef enum {
+    /** Device not attached yet */
+	CH9_USB_STATE_NONE = 0,
+    /** see Figure 9-1 of USB Spec */
+	CH9_USB_STATE_ATTACHED = 1,
+	CH9_USB_STATE_POWERED = 2,
+	CH9_USB_STATE_DEFAULT = 3,
+	CH9_USB_STATE_ADDRESS = 4,
+	CH9_USB_STATE_CONFIGURED = 5,
+	CH9_USB_STATE_SUSPENDED = 6,
+	CH9_USB_STATE_ERROR = 7,
+} CH9_UsbState;
+
+/** Speeds defined in USB Specification */
+typedef enum {
+    /** unknown speed - before enumeration */
+	CH9_USB_SPEED_UNKNOWN = 0,
+    /** (1,5Mb/s) */
+	CH9_USB_SPEED_LOW = 1,
+    /** usb 1.1 (12Mb/s) */
+	CH9_USB_SPEED_FULL = 2,
+    /** usb 2.0 (480Mb/s) */
+	CH9_USB_SPEED_HIGH = 3,
+    /** usb 2.5 wireless */
+	CH9_USB_SPEED_WIRELESS = 4,
+    /** usb 3.0 GEN 1  (5Gb/s) */
+	CH9_USB_SPEED_SUPER = 5,
+    /** usb 3.1 GEN2 (10Gb/s) */
+	CH9_USB_SPEED_SUPER_PLUS = 6,
+} CH9_UsbSpeed;
+
+/**********************************************************************
+ * Structures and unions
+ *********************************************************************
+ */
+
+/** Structure describes USB request (SETUP packet). See USB Specification (chapter 9.3) */
+typedef struct CH9_UsbSetup {
+    /** Characteristics of request */
+	uint8_t bmRequestType;
+    /** Specific request */
+	uint8_t bRequest;
+    /** Field that varies according to request */
+	uint16_t wValue;
+    /** typically used to pass an index or offset. */
+	uint16_t wIndex;
+    /** Number of bytes to transfer if there is a data stage */
+	uint16_t wLength;
+} __packed CH9_UsbSetup;
+
+/** Standard Device Descriptor (see Table 9-11 of USB Spec 3.1) */
+typedef struct CH9_UsbDeviceDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Device descriptor type */
+	uint8_t bDescriptorType;
+    /** USB Specification Release Number */
+	uint16_t bcdUSB;
+    /** Class code (assigned by the USB-IF) */
+	uint8_t bDeviceClass;
+    /** Subclass code (assigned by the USB-IF */
+	uint8_t bDeviceSubClass;
+    /** Protocol code (assigned by the USB-IF */
+	uint8_t bDeviceProtocol;
+    /** Maximum packet size for endpoint zero */
+	uint8_t bMaxPacketSize0;
+    /** Vendor ID (assigned by the USB-IF */
+	uint16_t idVendor;
+    /** Product ID (assigned by manufacturer) */
+	uint16_t idProduct;
+    /** Device release number */
+	uint16_t bcdDevice;
+    /** Index of string descriptor describing manufacturer */
+	uint8_t iManufacturer;
+    /** Index of string descriptor describing product */
+	uint8_t iProduct;
+    /** Index of string descriptor for serial number */
+	uint8_t iSerialNumber;
+    /** Number of possible configurations */
+	uint8_t bNumConfigurations;
+} __packed CH9_UsbDeviceDescriptor;
+
+/** Binary Device Object Store descriptor (see Table 9-12 of USB Spec 3.1) */
+typedef struct CH9_UsbBosDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** Descriptor type: BOS */
+	uint8_t bDescriptorType;
+    /** Length of this descriptor and all of its sub descriptors */
+	uint16_t wTotalLength;
+    /** The number of separate device capability descriptors in the BOS */
+	uint8_t bNumDeviceCaps;
+} __packed CH9_UsbBosDescriptor;
+
+/** Device Capability Descriptor (see Table 9-12 of USB Spec 3.1) */
+typedef struct CH9_UsbCapabilityDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** Descriptor type: DEVICE CAPABILITY type */
+	uint8_t bDescriptorType;
+    /** Capability type: USB 2.0 EXTENSION (002h) */
+	uint8_t bDevCapabilityType;
+    /** Capability specific format */
+	uint32_t bmAttributes;
+} __packed CH9_UsbCapabilityDescriptor;
+
+/** USB 2.0 Extension Descriptor (see Table 9-15 of USB Spec 3.1) */
+typedef struct CH9_Usb20ExtensionDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** Descriptor type: DEVICE CAPABILITY type */
+	uint8_t bDescriptorType;
+    /** Capability type: USB 2.0 EXTENSION (002h) */
+	uint8_t bDevCapabilityType;
+    /** Capability specific format */
+	uint32_t bmAttributes;
+} __packed CH9_Usb20ExtensionDescriptor;
+
+/** SuperSpeed USB Device Capability Descriptor (see Table 9-16 of USB Spec 3.1) */
+typedef struct CH9_UsbSSDeviceCapabilityDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** DEVICE CAPABILITY Descriptor type */
+	uint8_t bDescriptorType;
+    /** Capability type: SUPERSPEED_USB */
+	uint8_t bDevCapabilityType;
+    /** Bitmap encoding of supported device level features */
+	uint8_t bmAttributes;
+    /** Bitmap encoding of the speed supported by device */
+	uint16_t wSpeedSupported;
+    /**
+     * The lowest speed at which all the functionality
+     * supported by the device is available to the user
+     */
+	uint8_t vFunctionalitySupport;
+    /** U1 Device Exit Latency */
+	uint8_t bU1DevExitLat;
+    /** U2 Device Exit Latency */
+	uint16_t bU2DevExitLat;
+} __packed CH9_UsbSSDeviceCapabilityDescriptor;
+
+/** Container ID Descriptor (see Table 9-17 of USB Spec 3.1) */
+typedef struct CH9_UsbContainerIdDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** DEVICE CAPABILITY Descriptor type */
+	uint8_t bDescriptorType;
+    /** Capability type: CONTAINER_ID */
+	uint8_t bDevCapabilityType;
+    /** Field reserved and shall be set to zero */
+	uint8_t bReserved;
+    /** unique number to device instance */
+	uint8_t ContainerId[16];
+} __packed CH9_UsbContainerIdDescriptor;
+
+typedef struct CH9_UsbPlatformDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** DEVICE CAPABILITY Descriptor type */
+	uint8_t bDescriptorType;
+    /** Capability type: PLATFORM */
+	uint8_t bDevCapabilityType;
+    /** Field reserved and shall be set to zero */
+	uint8_t bReserved;
+    /** unique number to identifies a platform */
+	uint8_t PlatformCapabilityUUID[16];
+    /** variable length */
+	uint8_t CapabilityData[0];
+} __packed CH9_UsbPlatformDescriptor;
+
+/** SuperSpeedPlus USB Device Capability  (see Table 9-19 of USB Spec 3.1) */
+typedef struct CH9_UsbSSPlusDescriptor {
+    /** Size of this descriptor */
+	uint8_t bLength;
+    /** DEVICE CAPABILITY Descriptor type */
+	uint8_t bDescriptorType;
+    /** Capability type: SUPERSPEED_PLUS */
+	uint8_t bDevCapabilityType;
+    /** Field reserved and shall be set to zero */
+	uint8_t bReserved;
+    /** Bitmap encoding of supported SuperSpeedPlus features */
+	uint32_t bmAttributes;
+    /** supported functionality */
+	uint16_t wFunctionalitySupport;
+    /** Reserved. Shall be set to zero */
+	uint16_t wReserved;
+    /** Sublink Speed Attribute */
+	uint32_t bmSublinkSpeedAttr0;
+    /** Additional Lane Speed Attributes */
+	uint32_t bmSublinkSpeedAttrSSAC;
+} __packed CH9_UsbSSPlusDescriptor;
+
+/** SuperSpeedPlus USB Device Capability  (see Table 9-19 of USB Spec 3.1) */
+typedef struct CH9_UsbPTMCapabilityDescriptor {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDevCapabilityType;
+} __packed CH9_UsbPTMCapabilityDescriptor;
+
+/** Standard Configuration Descriptor (see Table 9-21 of USB Spec 3.1) */
+typedef struct CH9_UsbConfigurationDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Configuration descriptor type */
+	uint8_t bDescriptorType;
+    /** Total length of configuration */
+	uint16_t wTotalLength;
+    /** Number of interfaces supported by configuration */
+	uint8_t bNumInterfaces;
+    /** Value use as an argument to SetConfiguration() request */
+	uint8_t bConfigurationValue;
+    /** Index of string descriptor describing this configuration */
+	uint8_t iConfiguration;
+    /** Configuration attributes */
+	uint8_t bmAttributes;
+    /** Maximum power consumption of the USB device */
+	uint8_t bMaxPower;
+} __packed CH9_UsbConfigurationDescriptor;
+
+/** Standard Interface Association Descriptor  (see Table 9-22 of USB Spec 3.1) */
+typedef struct CH9_UsbInterfaceAssociationDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Interface Association Descriptor Type */
+	uint8_t bDescriptorType;
+    /** interface number of this interface that is associated with this function */
+	uint8_t bFirstInterface;
+    /** Number of contiguous interfaces that are associated with this function */
+	uint8_t bInterfaceCount;
+    /** Class code assigned by USB-IF */
+	uint8_t bFunctionClass;
+    /** Subclass code */
+	uint8_t bFunctionSubClass;
+    /** Protocol code */
+	uint8_t bFunctionProtocol;
+    /** Index of string descriptor describing this function */
+	uint8_t iFunction;
+} __packed CH9_UsbInterfaceAssociationDescriptor;
+
+/** Standard Interface Descriptor (see Table 9-23 of USB Spec 3.1) */
+typedef struct CH9_UsbInterfaceDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Interface Descriptor Type */
+	uint8_t bDescriptorType;
+    /** Number of this interface */
+	uint8_t bInterfaceNumber;
+    /** Value used to select this alternate setting */
+	uint8_t bAlternateSetting;
+    /** Class code */
+	uint8_t bNumEndpoints;
+    /** Subclass code */
+	uint8_t bInterfaceClass;
+    /** Subclass code */
+	uint8_t bInterfaceSubClass;
+    /** Protocol code */
+	uint8_t bInterfaceProtocol;
+    /** Index of string */
+	uint8_t iInterface;
+} __packed CH9_UsbInterfaceDescriptor;
+
+#define USB_DT_INTERFACE_SIZE		9
+
+#define USB_DIR_OUT			0		/* to device */
+#define USB_DIR_IN			0x80		/* to host */
+/** Standard Endpoint Descriptor */
+typedef struct CH9_UsbEndpointDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Endpoint Descriptor Type */
+	uint8_t bDescriptorType;
+    /** The address of the endpoint */
+	uint8_t bEndpointAddress;
+    /** Endpoint attribute */
+	uint8_t bmAttributes;
+    /** Maximum packet size for this endpoint */
+	uint16_t wMaxPacketSize;
+    /** interval for polling endpoint data transfer */
+	uint8_t bInterval;
+} __packed CH9_UsbEndpointDescriptor;
+
+#define USB_DT_ENDPOINT_SIZE		7
+#define USB_DT_ENDPOINT_AUDIO_SIZE	9	/* Audio extension */
+
+/** Standard SuperSpeed Endpoint Companion Descriptor (see Table 9-26 of USB Spec 3.1) */
+typedef struct CH9_UsbSSEndpointCompanionDescriptor {
+    /** Size of descriptor in bytes */
+	uint8_t bLength;
+    /** SUPERSPEED_USB_ENDPOINT_COMPANION Descriptor types */
+	uint8_t bDescriptorType;
+    /** Number of packets that endpoint can transmit as part of burst */
+	uint8_t bMaxBurst;
+	uint8_t bmAttributes;
+    /** The total number of bytes  for every service interval */
+	uint16_t wBytesPerInterval;
+} __packed CH9_UsbSSEndpointCompanionDescriptor;
+
+/**
+ * Standard SuperSpeedPlus Isochronous Endpoint
+ * Companion Descriptor (see Table 9-27 of USB Spec 3.1)
+ */
+typedef struct CH9_UsbSSPlusIsocEndpointCompanionDescriptor {
+    /** Size of descriptor in bytes */
+	uint8_t bLength;
+    /** SUPERSPEEDPLUS_ISOCHRONOUS_ENDPOINT_COMPANION Descriptor types */
+	uint8_t bDescriptorType;
+    /** Reserved. Shall be set to zero */
+	uint16_t wReserved;
+    /** The total number of bytes  for every service interval */
+	uint32_t dwBytesPerInterval;
+} __packed CH9_UsbSSPlusIsocEndpointCompanionDescriptor;
+
+/** Standard String Descriptor */
+typedef struct CH9_UsbStringDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** STRING Descriptor Type */
+	uint8_t bDescriptorType;
+    /** UNICODE encoded string */
+	uint8_t *bString;
+} __packed CH9_UsbStringDescriptor;
+
+/** Standard Device Qualifier Descriptor (see Table 9-9 of USB Spec 2.0) */
+typedef struct CH9_UsbDeviceQualifierDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Device Qualifier type */
+	uint8_t bDescriptorType;
+    /** USB Specification version number */
+	uint16_t bcdUSB;
+    /** Class code */
+	uint8_t bDeviceClass;
+    /** Subclass code */
+	uint8_t bDeviceSubClass;
+    /** Protocol code */
+	uint8_t bDeviceProtocol;
+    /** Maximum packet size for other speed */
+	uint8_t bMaxPacketSize0;
+    /** Number of other speed configuration */
+	uint8_t bNumConfigurations;
+    /** Reserved for future use */
+	uint8_t bReserved;
+} __packed CH9_UsbDeviceQualifierDescriptor;
+
+/** Standard Other_Speed_Configuration descriptor (see Table 9-11 of USB Spec 2.0) */
+typedef struct CH9_UsbOtherSpeedConfigurationDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** Configuration descriptor type */
+	uint8_t bDescriptorType;
+    /** Total length of configuration */
+	uint16_t wTotalLength;
+    /** Number of interfaces supported by this speed configuration */
+	uint8_t bNumInterfaces;
+    /** Value to use to select configuration */
+	uint8_t bConfigurationValue;
+    /** Index of string descriptor describing this configuration */
+	uint8_t iConfiguration;
+    /** Configuration attributes */
+	uint8_t bmAttributes;
+    /** Maximum power consumption of the USB device */
+	uint8_t bMaxPower;
+} __packed CH9_UsbOtherSpeedConfigurationDescriptor;
+
+/**
+ * Header descriptor. All descriptor have the same header that
+ * consist of bLength and bDescriptorType fields
+ */
+typedef struct CH9_UsbHeaderDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** descriptor Type */
+	uint8_t bDescriptorType;
+} __packed CH9_UsbHeaderDescriptor;
+
+/** OTG descriptor (see OTG spec. Table 6.1) */
+typedef struct CH9_UsbOtgDescriptor {
+    /** Size of descriptor */
+	uint8_t bLength;
+    /** OTG Descriptor Type */
+	uint8_t bDescriptorType;
+    /** Attribute field */
+	uint8_t bmAttributes;
+    /** OTG and EH supplement release number */
+	uint16_t bcdOTG;
+} __packed CH9_UsbOtgDescriptor;
+
+typedef struct CH9_ConfigParams {
+    /** U1 Device exit Latency */
+	uint8_t bU1devExitLat;
+    /** U2 Device exit Latency */
+	uint16_t bU2DevExitLat;
+} __packed CH9_ConfigParams;
+
+/**
+ *  @}
+ */
+
+#endif	/* CVI_CH9_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_drv_if.h b/drivers/cvi_usb/utask/cv181x/include/cvi_drv_if.h
new file mode 100644
index 000000000..f371869dc
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_drv_if.h
@@ -0,0 +1,817 @@
+#ifndef CVI_DRV_IF_H
+#define CVI_DRV_IF_H
+
+#include <linux/errno.h>
+#include <linux/list.h>
+
+//typedef unsigned int		dma_addr_t;
+
+//#define USB_IRQ_MODE 1
+
+struct usb_ep;
+struct usb_request;
+
+typedef void (*cvi_reqComplete)(struct usb_ep *ep, struct usb_request *req);
+/**
+ * struct usb_request - describes one i/o request
+ * @buf: Buffer used for data.  Always provide this; some controllers
+ *	only use PIO, or don't use DMA for some endpoints.
+ * @dma: DMA address corresponding to 'buf'.  If you don't set this
+ *	field, and the usb controller needs one, it is responsible
+ *	for mapping and unmapping the buffer.
+ * @stream_id: The stream id, when USB3.0 bulk streams are being used
+ * @length: Length of that data
+ * @no_interrupt: If true, hints that no completion irq is needed.
+ *	Helpful sometimes with deep request queues that are handled
+ *	directly by DMA controllers.
+ * @zero: If true, when writing data, makes the last packet be "short"
+ *     by adding a zero length packet as needed;
+ * @short_not_ok: When reading data, makes short packets be
+ *     treated as errors (queue stops advancing till cleanup).
+ * @complete: Function called when request completes, so this request and
+ *	its buffer may be re-used.
+ *	Reads terminate with a short packet, or when the buffer fills,
+ *	whichever comes first.  When writes terminate, some data bytes
+ *	will usually still be in flight (often in a hardware fifo).
+ *	Errors (for reads or writes) stop the queue from advancing
+ *	until the completion function returns, so that any transfers
+ *	invalidated by the error may first be dequeued.
+ * @context: For use by the completion callback
+ * @list: For use by the gadget driver.
+ * @status: Reports completion code, zero or a negative errno.
+ *	Normally, faults block the transfer queue from advancing until
+ *	the completion callback returns.
+ *	Code "-ESHUTDOWN" indicates completion caused by device disconnect,
+ *	or when the driver disabled the endpoint.
+ * @actual: Reports bytes transferred to/from the buffer.  For reads (OUT
+ *	transfers) this may be less than the requested length.  If the
+ *	short_not_ok flag is set, short reads are treated as errors
+ *	even when status otherwise indicates successful completion.
+ *	Note that for writes (IN transfers) some data bytes may still
+ *	reside in a device-side FIFO when the request is reported as
+ *	complete.
+ *
+ * These are allocated/freed through the endpoint they're used with.  The
+ * hardware's driver can add extra per-request data to the memory it returns,
+ * which often avoids separate memory allocations (potential failures),
+ * later when the request is queued.
+ *
+ * Request flags affect request handling, such as whether a zero length
+ * packet is written (the "zero" flag), whether a short read should be
+ * treated as an error (blocking request queue advance, the "short_not_ok"
+ * flag), or hinting that an interrupt is not required (the "no_interrupt"
+ * flag, for use with deep request queues).
+ *
+ * Bulk endpoints can use any size buffers, and can also be used for interrupt
+ * transfers. interrupt-only endpoints can be much less functional.
+ *
+ * NOTE:  this is analagous to 'struct urb' on the host side, except that
+ * it's thinner and promotes more pre-allocation.
+ */
+
+struct usb_request {
+	struct list_head	list;
+	void			*buf;
+	unsigned int		length;
+	dma_addr_t		dma;
+
+	unsigned int		stream_id:16;
+	unsigned int		no_interrupt:1;
+	unsigned int		zero:1;
+	unsigned int		short_not_ok:1;
+
+	cvi_reqComplete	complete;
+	void			*context;
+
+	int			status;
+	unsigned int		actual;
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* endpoint-specific parts of the api to the usb controller hardware.
+ * unlike the urb model, (de)multiplexing layers are not required.
+ * (so this api could slash overhead if used on the host side...)
+ *
+ * note that device side usb controllers commonly differ in how many
+ * endpoints they support, as well as their capabilities.
+ */
+struct usb_ep_ops {
+	int (*enable)(struct usb_ep *ep, const CH9_UsbEndpointDescriptor *desc);
+	int (*disable)(struct usb_ep *ep);
+
+	struct usb_request *(*alloc_request)(struct usb_ep *ep);
+	void (*free_request)(struct usb_ep *ep, struct usb_request *req);
+
+	int (*queue)(struct usb_ep *ep, struct usb_request *req);
+	int (*dequeue)(struct usb_ep *ep, struct usb_request *req);
+
+	int (*set_halt)(struct usb_ep *ep, int value);
+	int (*set_wedge)(struct usb_ep *ep);
+	int (*fifo_status)(struct usb_ep *ep);
+	void (*fifo_flush)(struct usb_ep *ep);
+};
+
+/**
+ * struct usb_ep - device side representation of USB endpoint
+ * @name:identifier for the endpoint, such as "ep-a" or "ep9in-bulk"
+ * @ops: Function pointers used to access hardware-specific operations.
+ * @ep_list:the gadget's ep_list holds all of its endpoints
+ * @maxpacket:The maximum packet size used on this endpoint.  The initial
+ *	value can sometimes be reduced (hardware allowing), according to
+ *      the endpoint descriptor used to configure the endpoint.
+ * @maxpacket_limit:The maximum packet size value which can be handled by this
+ *	endpoint. It's set once by UDC driver when endpoint is initialized, and
+ *	should not be changed. Should not be confused with maxpacket.
+ * @max_streams: The maximum number of streams supported
+ *	by this EP (0 - 16, actual number is 2^n)
+ * @maxburst: the maximum number of bursts supported by this EP (for usb3)
+ * @driver_data:for use by the gadget driver.  all other fields are
+ *	read-only to gadget drivers.
+ * @desc: endpoint descriptor.  This pointer is set before the endpoint is
+ *	enabled and remains valid until the endpoint is disabled.
+ * @comp_desc: In case of SuperSpeed support, this is the endpoint companion
+ *	descriptor that is used to configure the endpoint
+ *
+ * the bus controller driver lists all the general purpose endpoints in
+ * gadget->ep_list.  the control endpoint (gadget->ep0) is not in that list,
+ * and is accessed only in response to a driver setup() callback.
+ */
+struct usb_ep {
+	struct list_head	ep_list;	/* must be put here! */
+	void			*driver_data;
+	const char		*name;
+	const struct usb_ep_ops	*ops;
+	unsigned		maxpacket:16;
+	unsigned		maxpacket_limit:16;
+	unsigned		max_streams:16;
+	unsigned		maxburst:5;
+	const CH9_UsbEndpointDescriptor	*desc;
+};
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * usb_ep_set_maxpacket_limit - set maximum packet size limit for endpoint
+ * @ep:the endpoint being configured
+ * @maxpacket_limit:value of maximum packet size limit
+ *
+ * This function should be used only in UDC drivers to initialize endpoint
+ * (usually in probe function).
+ */
+static inline void usb_ep_set_maxpacket_limit(struct usb_ep *ep,
+					      unsigned int maxpacket_limit)
+{
+	ep->maxpacket_limit = maxpacket_limit;
+	ep->maxpacket = maxpacket_limit;
+}
+
+/**
+ * usb_ep_enable - configure endpoint, making it usable
+ * @ep:the endpoint being configured.  may not be the endpoint named "ep0".
+ *	drivers discover endpoints through the ep_list of a usb_gadget.
+ * @desc:descriptor for desired behavior.  caller guarantees this pointer
+ *	remains valid until the endpoint is disabled; the data byte order
+ *	is little-endian (usb-standard).
+ *
+ * when configurations are set, or when interface settings change, the driver
+ * will enable or disable the relevant endpoints.  while it is enabled, an
+ * endpoint may be used for i/o until the driver receives a disconnect() from
+ * the host or until the endpoint is disabled.
+ *
+ * the ep0 implementation (which calls this routine) must ensure that the
+ * hardware capabilities of each endpoint match the descriptor provided
+ * for it.  for example, an endpoint named "ep2in-bulk" would be usable
+ * for interrupt transfers as well as bulk, but it likely couldn't be used
+ * for iso transfers or for endpoint 14.  some endpoints are fully
+ * configurable, with more generic names like "ep-a".  (remember that for
+ * USB, "in" means "towards the USB master".)
+ *
+ * returns zero, or a negative error code.
+ */
+static inline int usb_ep_enable(struct usb_ep *ep,
+				const CH9_UsbEndpointDescriptor *desc)
+{
+	return ep->ops->enable(ep, desc);
+}
+
+/**
+ * usb_ep_disable - endpoint is no longer usable
+ * @ep:the endpoint being unconfigured.  may not be the endpoint named "ep0".
+ *
+ * no other task may be using this endpoint when this is called.
+ * any pending and uncompleted requests will complete with status
+ * indicating disconnect (-ESHUTDOWN) before this call returns.
+ * gadget drivers must call usb_ep_enable() again before queueing
+ * requests to the endpoint.
+ *
+ * returns zero, or a negative error code.
+ */
+static inline int usb_ep_disable(struct usb_ep *ep)
+{
+	return ep->ops->disable(ep);
+}
+
+/**
+ * usb_ep_alloc_request - allocate a request object to use with this endpoint
+ * @ep:the endpoint to be used with with the request
+ * @gfp_flags:GFP_* flags to use
+ *
+ * Request objects must be allocated with this call, since they normally
+ * need controller-specific setup and may even need endpoint-specific
+ * resources such as allocation of DMA descriptors.
+ * Requests may be submitted with usb_ep_queue(), and receive a single
+ * completion callback.  Free requests with usb_ep_free_request(), when
+ * they are no longer needed.
+ *
+ * Returns the request, or null if one could not be allocated.
+ */
+static inline struct usb_request *usb_ep_alloc_request(struct usb_ep *ep)
+{
+	return ep->ops->alloc_request(ep);
+}
+
+/**
+ * usb_ep_free_request - frees a request object
+ * @ep:the endpoint associated with the request
+ * @req:the request being freed
+ *
+ * Reverses the effect of usb_ep_alloc_request().
+ * Caller guarantees the request is not queued, and that it will
+ * no longer be requeued (or otherwise used).
+ */
+static inline void usb_ep_free_request(struct usb_ep *ep,
+				       struct usb_request *req)
+{
+	ep->ops->free_request(ep, req);
+}
+
+/**
+ * usb_ep_queue - queues (submits) an I/O request to an endpoint.
+ * @ep:the endpoint associated with the request
+ * @req:the request being submitted
+ * @gfp_flags: GFP_* flags to use in case the lower level driver couldn't
+ *	pre-allocate all necessary memory with the request.
+ *
+ * This tells the device controller to perform the specified request through
+ * that endpoint (reading or writing a buffer).  When the request completes,
+ * including being canceled by usb_ep_dequeue(), the request's completion
+ * routine is called to return the request to the driver.  Any endpoint
+ * (except control endpoints like ep0) may have more than one transfer
+ * request queued; they complete in FIFO order.  Once a gadget driver
+ * submits a request, that request may not be examined or modified until it
+ * is given back to that driver through the completion callback.
+ *
+ * Each request is turned into one or more packets.  The controller driver
+ * never merges adjacent requests into the same packet.  OUT transfers
+ * will sometimes use data that's already buffered in the hardware.
+ * Drivers can rely on the fact that the first byte of the request's buffer
+ * always corresponds to the first byte of some USB packet, for both
+ * IN and OUT transfers.
+ *
+ * Bulk endpoints can queue any amount of data; the transfer is packetized
+ * automatically.  The last packet will be short if the request doesn't fill it
+ * out completely.  Zero length packets (ZLPs) should be avoided in portable
+ * protocols since not all usb hardware can successfully handle zero length
+ * packets.  (ZLPs may be explicitly written, and may be implicitly written if
+ * the request 'zero' flag is set.)  Bulk endpoints may also be used
+ * for interrupt transfers; but the reverse is not true, and some endpoints
+ * won't support every interrupt transfer.  (Such as 768 byte packets.)
+ *
+ * Interrupt-only endpoints are less functional than bulk endpoints, for
+ * example by not supporting queueing or not handling buffers that are
+ * larger than the endpoint's maxpacket size.  They may also treat data
+ * toggle differently.
+ *
+ * Control endpoints ... after getting a setup() callback, the driver queues
+ * one response (even if it would be zero length).  That enables the
+ * status ack, after transferring data as specified in the response.  Setup
+ * functions may return negative error codes to generate protocol stalls.
+ * (Note that some USB device controllers disallow protocol stall responses
+ * in some cases.)  When control responses are deferred (the response is
+ * written after the setup callback returns), then usb_ep_set_halt() may be
+ * used on ep0 to trigger protocol stalls.
+ *
+ * For periodic endpoints, like interrupt or isochronous ones, the usb host
+ * arranges to poll once per interval, and the gadget driver usually will
+ * have queued some data to transfer at that time.
+ *
+ * Returns zero, or a negative error code.  Endpoints that are not enabled
+ * report errors; errors will also be
+ * reported when the usb peripheral is disconnected.
+ */
+static inline int usb_ep_queue(struct usb_ep *ep,
+			       struct usb_request *req)
+{
+	return ep->ops->queue(ep, req);
+}
+
+/**
+ * usb_ep_dequeue - dequeues (cancels, unlinks) an I/O request from an endpoint
+ * @ep:the endpoint associated with the request
+ * @req:the request being canceled
+ *
+ * if the request is still active on the endpoint, it is dequeued and its
+ * completion routine is called (with status -ECONNRESET); else a negative
+ * error code is returned.
+ *
+ * note that some hardware can't clear out write fifos (to unlink the request
+ * at the head of the queue) except as part of disconnecting from usb.  such
+ * restrictions prevent drivers from supporting configuration changes,
+ * even to configuration zero (a "chapter 9" requirement).
+ */
+static inline int usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
+{
+	return ep->ops->dequeue(ep, req);
+}
+
+/**
+ * usb_ep_set_halt - sets the endpoint halt feature.
+ * @ep: the non-isochronous endpoint being stalled
+ *
+ * Use this to stall an endpoint, perhaps as an error report.
+ * Except for control endpoints,
+ * the endpoint stays halted (will not stream any data) until the host
+ * clears this feature; drivers may need to empty the endpoint's request
+ * queue first, to make sure no inappropriate transfers happen.
+ *
+ * Note that while an endpoint CLEAR_FEATURE will be invisible to the
+ * gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
+ * current altsetting, see usb_ep_clear_halt().  When switching altsettings,
+ * it's simplest to use usb_ep_enable() or usb_ep_disable() for the endpoints.
+ *
+ * Returns zero, or a negative error code.  On success, this call sets
+ * underlying hardware state that blocks data transfers.
+ * Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
+ * transfer requests are still queued, or if the controller hardware
+ * (usually a FIFO) still holds bytes that the host hasn't collected.
+ */
+static inline int usb_ep_set_halt(struct usb_ep *ep)
+{
+	return ep->ops->set_halt(ep, 1);
+}
+
+/**
+ * usb_ep_clear_halt - clears endpoint halt, and resets toggle
+ * @ep:the bulk or interrupt endpoint being reset
+ *
+ * Use this when responding to the standard usb "set interface" request,
+ * for endpoints that aren't reconfigured, after clearing any other state
+ * in the endpoint's i/o queue.
+ *
+ * Returns zero, or a negative error code.  On success, this call clears
+ * the underlying hardware state reflecting endpoint halt and data toggle.
+ * Note that some hardware can't support this request (like pxa2xx_udc),
+ * and accordingly can't correctly implement interface altsettings.
+ */
+static inline int usb_ep_clear_halt(struct usb_ep *ep)
+{
+	return ep->ops->set_halt(ep, 0);
+}
+
+/**
+ * usb_ep_fifo_status - returns number of bytes in fifo, or error
+ * @ep: the endpoint whose fifo status is being checked.
+ *
+ * FIFO endpoints may have "unclaimed data" in them in certain cases,
+ * such as after aborted transfers.  Hosts may not have collected all
+ * the IN data written by the gadget driver (and reported by a request
+ * completion).  The gadget driver may not have collected all the data
+ * written OUT to it by the host.  Drivers that need precise handling for
+ * fault reporting or recovery may need to use this call.
+ *
+ * This returns the number of such bytes in the fifo, or a negative
+ * errno if the endpoint doesn't use a FIFO or doesn't support such
+ * precise handling.
+ */
+static inline int usb_ep_fifo_status(struct usb_ep *ep)
+{
+	if (ep->ops->fifo_status)
+		return ep->ops->fifo_status(ep);
+	else
+		return -EOPNOTSUPP;
+}
+
+/**
+ * usb_ep_fifo_flush - flushes contents of a fifo
+ * @ep: the endpoint whose fifo is being flushed.
+ *
+ * This call may be used to flush the "unclaimed data" that may exist in
+ * an endpoint fifo after abnormal transaction terminations.  The call
+ * must never be used except when endpoint is not being used for any
+ * protocol translation.
+ */
+static inline void usb_ep_fifo_flush(struct usb_ep *ep)
+{
+	if (ep->ops->fifo_flush)
+		ep->ops->fifo_flush(ep);
+}
+
+/*-------------------------------------------------------------------------*/
+
+struct usb_gadget;
+struct usb_gadget_driver;
+
+/* the rest of the api to the controller hardware: device operations,
+ * which don't involve endpoints (or i/o).
+ */
+struct usb_gadget_ops {
+	int	(*get_frame)(struct usb_gadget *);
+	int	(*wakeup)(struct usb_gadget *);
+	int	(*set_selfpowered)(struct usb_gadget *, int is_selfpowered);
+	int	(*vbus_session)(struct usb_gadget *, int is_active);
+	int	(*vbus_draw)(struct usb_gadget *, unsigned int mA);
+	int	(*pullup)(struct usb_gadget *, int is_on);
+	int	(*ioctl)(struct usb_gadget *,
+			 unsigned int code, unsigned long param);
+	int	(*udc_start)(struct usb_gadget *,
+			     struct usb_gadget_driver *);
+	int	(*udc_stop)(struct usb_gadget *);
+};
+
+/**
+ * struct usb_gadget - represents a usb slave device
+ * @ops: Function pointers used to access hardware-specific operations.
+ * @ep0: Endpoint zero, used when reading or writing responses to
+ *	driver setup() requests
+ * @ep_list: List of other endpoints supported by the device.
+ * @speed: Speed of current connection to USB host.
+ * @max_speed: Maximal speed the UDC can handle.  UDC must support this
+ *      and all slower speeds.
+ * @is_dualspeed: true if the controller supports both high and full speed
+ *	operation.  If it does, the gadget driver must also support both.
+ * @is_otg: true if the USB device port uses a Mini-AB jack, so that the
+ *	gadget driver must provide a USB OTG descriptor.
+ * @is_a_peripheral: false unless is_otg, the "A" end of a USB cable
+ *	is in the Mini-AB jack, and HNP has been used to switch roles
+ *	so that the "A" device currently acts as A-Peripheral, not A-Host.
+ * @a_hnp_support: OTG device feature flag, indicating that the A-Host
+ *	supports HNP at this port.
+ * @a_alt_hnp_support: OTG device feature flag, indicating that the A-Host
+ *	only supports HNP on a different root port.
+ * @b_hnp_enable: OTG device feature flag, indicating that the A-Host
+ *	enabled HNP support.
+ * @name: Identifies the controller hardware type.  Used in diagnostics
+ *	and sometimes configuration.
+ * @dev: Driver model state for this abstract device.
+ * @quirk_ep_out_aligned_size: epout requires buffer size to be aligned to
+ *	MaxPacketSize.
+ *
+ * Gadgets have a mostly-portable "gadget driver" implementing device
+ * functions, handling all usb configurations and interfaces.  Gadget
+ * drivers talk to hardware-specific code indirectly, through ops vectors.
+ * That insulates the gadget driver from hardware details, and packages
+ * the hardware endpoints through generic i/o queues.  The "usb_gadget"
+ * and "usb_ep" interfaces provide that insulation from the hardware.
+ *
+ * Except for the driver data, all fields in this structure are
+ * read-only to the gadget driver.  That driver data is part of the
+ * "driver model" infrastructure in 2.6 (and later) kernels, and for
+ * earlier systems is grouped in a similar structure that's not known
+ * to the rest of the kernel.
+ *
+ * Values of the three OTG device feature flags are updated before the
+ * setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before
+ * driver suspend() calls.  They are valid only when is_otg, and when the
+ * device is acting as a B-Peripheral (so is_a_peripheral is false).
+ */
+struct usb_gadget {
+	/* readonly to gadget driver */
+	struct list_head		ep_list;	/* of usb_ep */
+	const struct usb_gadget_ops	*ops;
+	struct usb_ep			*ep0;
+	CH9_UsbSpeed			speed;
+	CH9_UsbSpeed			max_speed;
+	CH9_UsbSpeed			state;
+	unsigned			is_dualspeed:1;
+	unsigned			is_otg:1;
+	unsigned			is_a_peripheral:1;
+	unsigned			b_hnp_enable:1;
+	unsigned			a_hnp_support:1;
+	unsigned			a_alt_hnp_support:1;
+	const char			*name;
+};
+
+/**
+ * gadget_is_dualspeed - return true iff the hardware handles high speed
+ * @g: controller that might support both high and full speeds
+ */
+static inline int gadget_is_dualspeed(struct usb_gadget *g)
+{
+#ifdef CONFIG_USB_GADGET_DUALSPEED
+	/* runtime test would check "g->is_dualspeed" ... that might be
+	 * useful to work around hardware bugs, but is mostly pointless
+	 */
+	return 1;
+#else
+	return 0;
+#endif
+}
+
+/**
+ * gadget_is_otg - return true iff the hardware is OTG-ready
+ * @g: controller that might have a Mini-AB connector
+ *
+ * This is a runtime test, since kernels with a USB-OTG stack sometimes
+ * run on boards which only have a Mini-B (or Mini-A) connector.
+ */
+static inline int gadget_is_otg(struct usb_gadget *g)
+{
+#ifdef CONFIG_USB_OTG
+	return g->is_otg;
+#else
+	return 0;
+#endif
+}
+
+/**
+ * usb_gadget_frame_number - returns the current frame number
+ * @gadget: controller that reports the frame number
+ *
+ * Returns the usb frame number, normally eleven bits from a SOF packet,
+ * or negative errno if this device doesn't support this capability.
+ */
+static inline int usb_gadget_frame_number(struct usb_gadget *gadget)
+{
+	return gadget->ops->get_frame(gadget);
+}
+
+/**
+ * usb_gadget_wakeup - tries to wake up the host connected to this gadget
+ * @gadget: controller used to wake up the host
+ *
+ * Returns zero on success, else negative error code if the hardware
+ * doesn't support such attempts, or its support has not been enabled
+ * by the usb host.  Drivers must return device descriptors that report
+ * their ability to support this, or hosts won't enable it.
+ *
+ * This may also try to use SRP to wake the host and start enumeration,
+ * even if OTG isn't otherwise in use.  OTG devices may also start
+ * remote wakeup even when hosts don't explicitly enable it.
+ */
+static inline int usb_gadget_wakeup(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->wakeup)
+		return -EOPNOTSUPP;
+	return gadget->ops->wakeup(gadget);
+}
+
+/**
+ * usb_gadget_set_selfpowered - sets the device selfpowered feature.
+ * @gadget:the device being declared as self-powered
+ *
+ * this affects the device status reported by the hardware driver
+ * to reflect that it now has a local power supply.
+ *
+ * returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_set_selfpowered(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->set_selfpowered)
+		return -EOPNOTSUPP;
+	return gadget->ops->set_selfpowered(gadget, 1);
+}
+
+/**
+ * usb_gadget_clear_selfpowered - clear the device selfpowered feature.
+ * @gadget:the device being declared as bus-powered
+ *
+ * this affects the device status reported by the hardware driver.
+ * some hardware may not support bus-powered operation, in which
+ * case this feature's value can never change.
+ *
+ * returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_clear_selfpowered(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->set_selfpowered)
+		return -EOPNOTSUPP;
+	return gadget->ops->set_selfpowered(gadget, 0);
+}
+
+/**
+ * usb_gadget_vbus_connect - Notify controller that VBUS is powered
+ * @gadget:The device which now has VBUS power.
+ *
+ * This call is used by a driver for an external transceiver (or GPIO)
+ * that detects a VBUS power session starting.  Common responses include
+ * resuming the controller, activating the D+ (or D-) pullup to let the
+ * host detect that a USB device is attached, and starting to draw power
+ * (8mA or possibly more, especially after SET_CONFIGURATION).
+ *
+ * Returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_vbus_connect(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->vbus_session)
+		return -EOPNOTSUPP;
+	return gadget->ops->vbus_session(gadget, 1);
+}
+
+/**
+ * usb_gadget_vbus_draw - constrain controller's VBUS power usage
+ * @gadget:The device whose VBUS usage is being described
+ * @mA:How much current to draw, in milliAmperes.  This should be twice
+ *	the value listed in the configuration descriptor bMaxPower field.
+ *
+ * This call is used by gadget drivers during SET_CONFIGURATION calls,
+ * reporting how much power the device may consume.  For example, this
+ * could affect how quickly batteries are recharged.
+ *
+ * Returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned int mA)
+{
+	if (!gadget->ops->vbus_draw)
+		return -EOPNOTSUPP;
+	return gadget->ops->vbus_draw(gadget, mA);
+}
+
+/**
+ * usb_gadget_vbus_disconnect - notify controller about VBUS session end
+ * @gadget:the device whose VBUS supply is being described
+ *
+ * This call is used by a driver for an external transceiver (or GPIO)
+ * that detects a VBUS power session ending.  Common responses include
+ * reversing everything done in usb_gadget_vbus_connect().
+ *
+ * Returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_vbus_disconnect(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->vbus_session)
+		return -EOPNOTSUPP;
+	return gadget->ops->vbus_session(gadget, 0);
+}
+
+/**
+ * usb_gadget_connect - software-controlled connect to USB host
+ * @gadget:the peripheral being connected
+ *
+ * Enables the D+ (or potentially D-) pullup.  The host will start
+ * enumerating this gadget when the pullup is active and a VBUS session
+ * is active (the link is powered).  This pullup is always enabled unless
+ * usb_gadget_disconnect() has been used to disable it.
+ *
+ * Returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_connect(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->pullup)
+		return -EOPNOTSUPP;
+	return gadget->ops->pullup(gadget, 1);
+}
+
+/**
+ * usb_gadget_disconnect - software-controlled disconnect from USB host
+ * @gadget:the peripheral being disconnected
+ *
+ * Disables the D+ (or potentially D-) pullup, which the host may see
+ * as a disconnect (when a VBUS session is active).  Not all systems
+ * support software pullup controls.
+ *
+ * This routine may be used during the gadget driver bind() call to prevent
+ * the peripheral from ever being visible to the USB host, unless later
+ * usb_gadget_connect() is called.  For example, user mode components may
+ * need to be activated before the system can talk to hosts.
+ *
+ * Returns zero on success, else negative errno.
+ */
+static inline int usb_gadget_disconnect(struct usb_gadget *gadget)
+{
+	if (!gadget->ops->pullup)
+		return -EOPNOTSUPP;
+	return gadget->ops->pullup(gadget, 0);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * struct usb_gadget_driver - driver for usb 'slave' devices
+ * @function: String describing the gadget's function
+ * @speed: Highest speed the driver handles.
+ * @bind: Invoked when the driver is bound to a gadget, usually
+ *	after registering the driver.
+ *	At that point, ep0 is fully initialized, and ep_list holds
+ *	the currently-available endpoints.
+ *	Called in a context that permits sleeping.
+ * @setup: Invoked for ep0 control requests that aren't handled by
+ *	the hardware level driver. Most calls must be handled by
+ *	the gadget driver, including descriptor and configuration
+ *	management.  The 16 bit members of the setup data are in
+ *	USB byte order. Called in_interrupt; this may not sleep.  Driver
+ *	queues a response to ep0, or returns negative to stall.
+ * @disconnect: Invoked after all transfers have been stopped,
+ *	when the host is disconnected.  May be called in_interrupt; this
+ *	may not sleep.  Some devices can't detect disconnect, so this might
+ *	not be called except as part of controller shutdown.
+ * @unbind: Invoked when the driver is unbound from a gadget,
+ *	usually from rmmod (after a disconnect is reported).
+ *	Called in a context that permits sleeping.
+ * @suspend: Invoked on USB suspend.  May be called in_interrupt.
+ * @resume: Invoked on USB resume.  May be called in_interrupt.
+ * @reset: Invoked on USB bus reset. It is mandatory for all gadget drivers
+ *	and should be called in_interrupt.
+ *
+ * Devices are disabled till a gadget driver successfully bind()s, which
+ * means the driver will handle setup() requests needed to enumerate (and
+ * meet "chapter 9" requirements) then do some useful work.
+ *
+ * If gadget->is_otg is true, the gadget driver must provide an OTG
+ * descriptor during enumeration, or else fail the bind() call.  In such
+ * cases, no USB traffic may flow until both bind() returns without
+ * having called usb_gadget_disconnect(), and the USB host stack has
+ * initialized.
+ *
+ * Drivers use hardware-specific knowledge to configure the usb hardware.
+ * endpoint addressing is only one of several hardware characteristics that
+ * are in descriptors the ep0 implementation returns from setup() calls.
+ *
+ * Except for ep0 implementation, most driver code shouldn't need change to
+ * run on top of different usb controllers.  It'll use endpoints set up by
+ * that ep0 implementation.
+ *
+ * The usb controller driver handles a few standard usb requests.  Those
+ * include set_address, and feature flags for devices, interfaces, and
+ * endpoints (the get_status, set_feature, and clear_feature requests).
+ *
+ * Accordingly, the driver's setup() callback must always implement all
+ * get_descriptor requests, returning at least a device descriptor and
+ * a configuration descriptor.  Drivers must make sure the endpoint
+ * descriptors match any hardware constraints. Some hardware also constrains
+ * other descriptors. (The pxa250 allows only configurations 1, 2, or 3).
+ *
+ * The driver's setup() callback must also implement set_configuration,
+ * and should also implement set_interface, get_configuration, and
+ * get_interface.  Setting a configuration (or interface) is where
+ * endpoints should be activated or (config 0) shut down.
+ *
+ * (Note that only the default control endpoint is supported.  Neither
+ * hosts nor devices generally support control traffic except to ep0.)
+ *
+ * Most devices will ignore USB suspend/resume operations, and so will
+ * not provide those callbacks.  However, some may need to change modes
+ * when the host is not longer directing those activities.  For example,
+ * local controls (buttons, dials, etc) may need to be re-enabled since
+ * the (remote) host can't do that any longer; or an error state might
+ * be cleared, to make the device behave identically whether or not
+ * power is maintained.
+ */
+struct usb_gadget_driver {
+	char			*function;
+	CH9_UsbSpeed		speed;
+	int			(*bind)(struct usb_gadget *);
+	void			(*unbind)(struct usb_gadget *);
+	int			(*setup)(struct usb_gadget *,
+					 const CH9_UsbSetup *);
+	void			(*disconnect)(struct usb_gadget *);
+	void			(*suspend)(struct usb_gadget *);
+	void			(*resume)(struct usb_gadget *);
+	void			(*reset)(struct usb_gadget *);
+	void			*(*req_mem_alloc)(struct usb_gadget *, uint32_t);
+	void			(*req_mem_free)(struct usb_gadget *, void *);
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* driver modules register and unregister, as usual.
+ * these calls must be made in a context that can sleep.
+ *
+ * these will usually be implemented directly by the hardware-dependent
+ * usb bus interface driver, which will only support a single driver.
+ */
+
+/**
+ * cviusb_gadget_register_driver - register a gadget driver
+ * @driver:the driver being registered
+ *
+ * Call this in your gadget driver's module initialization function,
+ * to tell the underlying usb controller driver about your driver.
+ * The driver's bind() function will be called to bind it to a
+ * gadget before this registration call returns.  It's expected that
+ * the bind() functions will be in init sections.
+ * This function must be called in a context that can sleep.
+ */
+int cviusb_gadget_register_driver(struct usb_gadget_driver *driver);
+
+/**
+ * cviusb_gadget_unregister_driver - unregister a gadget driver
+ * @driver:the driver being unregistered
+ *
+ * Call this in your gadget driver's module cleanup function,
+ * to tell the underlying usb controller that your driver is
+ * going away.  If the controller is connected to a USB host,
+ * it will first disconnect().  The driver is also requested
+ * to unbind() and clean up any device state, before this procedure
+ * finally returns.  It's expected that the unbind() functions
+ * will in in exit sections, so may not be linked in some kernels.
+ * This function must be called in a context that can sleep.
+ */
+int cviusb_gadget_unregister_driver(struct usb_gadget_driver *driver);
+/*-------------------------------------------------------------------------*/
+
+/* utility wrapping a simple endpoint selection policy */
+
+extern int cviusb_gadget_handle_interrupts(int index);
+
+#endif	/* CVI_DRV_IF_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_errno.h b/drivers/cvi_usb/utask/cv181x/include/cvi_errno.h
new file mode 100644
index 000000000..7fb41fd1c
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_errno.h
@@ -0,0 +1,92 @@
+#ifndef CVI_ERRNO_H
+#define CVI_ERRNO_H
+
+#ifndef ERRNO_H_NOT_PRESENT
+#include <errno.h>
+#endif //ERRNO_H_NOT_PRESENT
+
+#ifndef EOK
+#define EOK             0      /* no error */
+#endif //EOK
+
+#ifndef EPERM
+#define EPERM           1      /* Operation not permitted */
+#endif //EPERM
+
+#ifndef ENOENT
+#define ENOENT          2      /* No such file or directory */
+#endif //ENOENT
+
+#ifndef EIO
+#define EIO             5      /* I/O error */
+#endif //EIO
+
+#ifndef ENOEXEC
+#define ENOEXEC         8      /* Exec format error */
+#endif //ENOEXEC
+
+#ifndef EAGAIN
+#define EAGAIN          11      /* Try again */
+#endif //EAGAIN
+
+#ifndef ENOMEM
+#define ENOMEM          12      /* Out of memory */
+#endif //ENOMEM
+
+#ifndef EFAULT
+#define EFAULT          14      /* Bad address */
+#endif //EFAULT
+
+#ifndef EBUSY
+#define EBUSY           16      /* Device or resource busy */
+#endif //EBUSY
+
+#ifndef EINVAL
+#define EINVAL          22      /* Invalid argument */
+#endif //EINVAL
+
+#ifndef ENOSPC
+#define ENOSPC          28      /* No space left on device */
+#endif //ENOSPC
+
+#ifndef EBADSLT
+#define EBADSLT         57      /* Invalid slot */
+#endif //EBADSLT
+
+#ifndef EPROTO
+#define EPROTO          71      /* Protocol error */
+#endif //EPROTO
+
+#ifndef EOVERFLOW
+#define EOVERFLOW       75      /* Value too large for defined data type */
+#endif //EOVERFLOW
+
+#ifndef EOPNOTSUPP
+#define EOPNOTSUPP      95      /* Operation not supported */
+#endif //EOPNOTSUPP
+
+#ifndef ESHUTDOWN
+#define ESHUTDOWN       108     /* Cannot send after transport endpoint shutdown */
+#endif
+
+#ifndef ETIMEDOUT
+#define ETIMEDOUT       110     /* Connection timed out */
+#endif //ETIMEDOUT
+
+#ifndef EINPROGRESS
+#define EINPROGRESS     115     /* Operation now in progress */
+#endif //EINPROGRESS
+
+#ifndef EDQUOT
+#define EDQUOT          122     /* Quota exceeded */
+#endif //EDQUOT
+
+#ifndef ENOTSUP
+#define ENOTSUP         EOPNOTSUPP
+#endif //ENOTSUP
+
+#ifndef ECANCELED
+#define ECANCELED       126      /* Cancelled */
+#endif //ECANCELED
+
+#endif /* CVI_ERRNO_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_private.h b/drivers/cvi_usb/utask/cv181x/include/cvi_private.h
new file mode 100644
index 000000000..39a6bb5bc
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_private.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015-2016, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __CVI_PRIVATE_H
+#define __CVI_PRIVATE_H
+
+enum {
+	FIP_SRC_I2C_DWLD = 0x0,
+	FIP_SRC_UART = 0x1,
+	FIP_SRC_NAND = 0x2,
+	FIP_SRC_SPI_FLASH = 0x3,
+	FIP_SRC_EMMC = 0x4,
+	FIP_SRC_SDFAT = 0x5,
+	FIP_SRC_USB = 0x6,
+	FIP_SRC_MEMMAP = 0x7,
+};
+
+enum { /* patch table index in SPI flash */
+	PT_USER_CONF = 0,
+	PT_SDIO_PHY,
+	PT_RESERVED_2,
+	PT_RESERVED_3,
+	PT_RESERVED_4,
+};
+
+void plat_cvi_io_setup(void);
+void plat_cvi_ddr_init(void);
+uint32_t  plat_cvi_efuse_read(uint32_t address);
+uint32_t plat_cvi_gpio_read(uint32_t mask);
+void plat_cvi_unleash_arm926(void);
+void plat_cvi_spi_flash_patch_table(int index);
+void plat_cvi_set_pinmux(int io_type);
+void plat_init_user_conf(void);
+int plat_cvi_clock_init(void);
+int plat_cvi_sd_get_clk(void);
+int plat_cvi_emmc_get_clk(void);
+void plat_cvi_init_uart(void);
+
+#endif /*__CVI_PRIVATE_H*/
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_stdint.h b/drivers/cvi_usb/utask/cv181x/include/cvi_stdint.h
new file mode 100644
index 000000000..10b6ff28c
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_stdint.h
@@ -0,0 +1,29 @@
+#ifndef CVI_STDINT_H
+#define CVI_STDINT_H
+
+#include <stdint.h>
+
+/* NOTE - The driver uses fixed width types as defined in C99
+ *
+ * If not provided by your environment, these are typical definitions for the
+ *        fixed width types used in the driver, and should be provided here.
+ * typedef signed char            int8_t
+ * typedef unsigned char          uint8_t
+ * typedef signed short           int16_t
+ * typedef unsigned short         uint16_t
+ * typedef signed long int        int32_t
+ * typedef unsigned long int      uint32_t
+ * typedef signed long long int   int64_t
+ * typedef unsigned long long int uint64_t
+ * typedef int32_t                intptr_t
+ * typedef uint32_t               uintptr_t
+
+ * These definitions are for a 32bit system with 32bit int, and should be adjusted
+ * for your actual target system and toolchain.
+
+ Under Linux, these will be available in:
+ linux/types.h
+
+*/
+
+#endif
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_stdio.h b/drivers/cvi_usb/utask/cv181x/include/cvi_stdio.h
new file mode 100644
index 000000000..53c5fdf17
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_stdio.h
@@ -0,0 +1 @@
+#include <stdio.h>
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_stdtypes.h b/drivers/cvi_usb/utask/cv181x/include/cvi_stdtypes.h
new file mode 100644
index 000000000..63641d91e
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_stdtypes.h
@@ -0,0 +1,22 @@
+#ifndef CVI_STDTYPES_H
+#define CVI_STDTYPES_H
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include "cvi_stdint.h"
+
+/* Define NULL constant */
+#ifndef NULL
+#define	NULL	((void *)0)
+#endif
+
+/* Define size_t data type */
+typedef	uintptr_t	size_t;
+
+/* Define bool data type */
+#define bool	_Bool
+#define	true	1
+#define	false	0
+#define	__bool_true_false_are_defined 1
+#endif /* __KERNEL__ */
+#endif	/* CVI_STDTYPES_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_string.h b/drivers/cvi_usb/utask/cv181x/include/cvi_string.h
new file mode 100644
index 000000000..3b2f59002
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_string.h
@@ -0,0 +1 @@
+#include <string.h>
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_udc.h b/drivers/cvi_usb/utask/cv181x/include/cvi_udc.h
new file mode 100644
index 000000000..de44d70e5
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_udc.h
@@ -0,0 +1,94 @@
+/*
+ * drivers/usb/gadget/cvi_udc.h
+ * Designware CVI on-chip full/high speed USB device controllers
+ * Copyright (C) 2005 for Samsung Electronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CVI_USB_GADGET
+#define __CVI_USB_GADGET
+
+#include "cvi_udc_otg_regs.h"
+
+#define _DEBUG	0
+
+#define cvidbg_cond(cond, fmt, args...)			\
+	do {						\
+		if (cond)				\
+			printf(fmt, ##args);	\
+	} while (0)
+
+#define cvidbg(fmt, args...)			\
+	cvidbg_cond(_DEBUG, fmt, ##args)
+
+#define DEBUG_SETUP 0
+#define DEBUG_EP0 0
+#define DEBUG_ISR 0
+#define DEBUG_OUT_EP 0
+#define DEBUG_IN_EP 0
+
+#define PHY0_SLEEP              BIT(5)
+
+#ifndef CONFIG_SYS_CACHELINE_SIZE
+#define CONFIG_SYS_CACHELINE_SIZE       64
+#endif
+
+#define ROUND(a, b)		(((a) + (b) - 1) & ~((b) - 1))
+
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+
+#define max(x, y) ({				\
+	typeof(x) _max1 = (x);			\
+	typeof(y) _max2 = (y);			\
+	(void) (&_max1 == &_max2);		\
+	_max1 > _max2 ? _max1 : _max2; })
+
+#define OTG_DMA_MODE		1
+
+#define EP0_CON		0
+#define EP_MASK		0xF
+
+struct cvi_plat_otg_data {
+	void		*handler;
+	unsigned int	size;
+	int		phy_of_node;
+	int		(*phy_control)(int on);
+	uintptr_t	regs_phy;
+	uintptr_t	regs_otg;
+	unsigned int    usb_phy_ctrl;
+	unsigned int    usb_flags;
+	unsigned int	usb_gusbcfg;
+	unsigned int	rx_fifo_sz;
+	unsigned int	np_tx_fifo_sz;
+	unsigned int	tx_fifo_sz;
+	void            *ctrl_req;
+};
+
+struct cvi_drv_obj {
+	struct usb_gadget		*gadget;
+	struct cvi_plat_otg_data	plat;
+};
+
+int cvi_udc_probe(struct cvi_plat_otg_data *pdata);
+void cvi_udc_ep_activate(struct cvi_ep *ep);
+int cvi_udc_irq(int irq, void *_dev);
+int cvi_queue(struct usb_ep *_ep, struct usb_request *_req);
+void cvi_ep0_read(struct cvi_udc *dev);
+void cvi_ep0_kick(struct cvi_udc *dev, struct cvi_ep *ep);
+void cvi_handle_ep0(struct cvi_udc *dev);
+int cvi_ep0_write(struct cvi_udc *dev);
+int cvi_write_fifo_ep0(struct cvi_ep *ep, struct cvi_request *req);
+void cvi_set_address(struct cvi_udc *dev, unsigned char address);
+int cvi_udc_set_halt(struct usb_ep *_ep, int value);
+void cvi_udc_set_nak(struct cvi_ep *ep);
+void cvi_done(struct cvi_ep *ep, struct cvi_request *req, int status);
+void cvi_nuke(struct cvi_ep *ep, int status);
+void cvi_reconfig_usbd(struct cvi_udc *dev, int disconnect);
+const char *cvi_get_ep0_name(void);
+
+#endif	/* __CVI_USB_GADGET */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_priv.h b/drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_priv.h
new file mode 100644
index 000000000..19c55a74c
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_priv.h
@@ -0,0 +1,113 @@
+/*
+ * Designware CVI on-chip full/high speed USB device controllers
+ * Copyright (C) 2005 for Samsung Electronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CVI_UDC_OTG_PRIV__
+#define __CVI_UDC_OTG_PRIV__
+
+#include <linux/errno.h>
+#include <linux/sizes.h>
+#include "cvi_ch9.h"
+#include "cvi_drv_if.h"
+#include "cvi_udc_otg_regs.h"
+
+/*-------------------------------------------------------------------------*/
+/* DMA bounce buffer size, 16K is enough even for mass storage */
+#define DMA_BUFFER_SIZE	(16 * SZ_1K)
+
+#define EP0_FIFO_SIZE		64
+#define EP_FIFO_SIZE		512
+#define EP_FIFO_SIZE2		1024
+/* ep0-control, ep1in-bulk, ep2out-bulk, ep3in-int */
+#define CVI_MAX_ENDPOINTS	4
+#define CVI_MAX_HW_ENDPOINTS	8
+
+#define WAIT_FOR_SETUP          0
+#define DATA_STATE_XMIT         1
+#define DATA_STATE_NEED_ZLP     2
+#define WAIT_FOR_OUT_STATUS     3
+#define DATA_STATE_RECV         4
+#define WAIT_FOR_COMPLETE	5
+#define WAIT_FOR_OUT_COMPLETE	6
+#define WAIT_FOR_IN_COMPLETE	7
+#define WAIT_FOR_NULL_COMPLETE	8
+
+#define TEST_J_SEL		0x1
+#define TEST_K_SEL		0x2
+#define TEST_SE0_NAK_SEL	0x3
+#define TEST_PACKET_SEL		0x4
+#define TEST_FORCE_ENABLE_SEL	0x5
+
+/* ************************************************************************* */
+/* IO
+ */
+
+enum ep_type {
+	ep_control, ep_bulk_in, ep_bulk_out, ep_interrupt
+};
+
+struct cvi_ep {
+	struct usb_ep ep;	/* must be put here! */
+	struct cvi_udc *dev;
+
+	const CH9_UsbEndpointDescriptor *desc;
+	struct list_head queue;
+	unsigned long pio_irqs;
+	int len;
+	void *dma_buf;
+
+	uint8_t stopped;
+	uint8_t bEndpointAddress;
+	uint8_t bmAttributes;
+
+	enum ep_type ep_type;
+	int fifo_num;
+};
+
+struct cvi_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+struct cvi_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+
+	void *pdata;
+
+	int ep0state;
+	struct cvi_ep ep[CVI_MAX_ENDPOINTS];
+
+	unsigned char usb_address;
+
+	unsigned req_pending:1, req_std:1;
+
+	CH9_UsbSetup *usb_ctrl;
+	dma_addr_t usb_ctrl_dma_addr;
+	struct cvi_usbotg_reg *reg;
+	unsigned int connected;
+	uint8_t clear_feature_num;
+	uint8_t clear_feature_flag;
+	uint8_t test_mode;
+
+};
+
+#define ep_is_in(EP) (((EP)->bEndpointAddress & USB_DIR_IN) == USB_DIR_IN)
+#define ep_index(EP) ((EP)->bEndpointAddress & 0xF)
+#define ep_maxpacket(EP) ((EP)->ep.maxpacket)
+
+void otg_phy_init(struct cvi_udc *dev);
+void otg_phy_off(struct cvi_udc *dev);
+void cvi_log_write(uint32_t tag, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4);
+void set_trigger_cnt(int cnt);
+uint8_t cvi_phy_to_log_ep(uint8_t phy_num, uint8_t dir);
+void cvi_udc_pre_setup(struct cvi_udc *dev);
+void cvi_disconnect(struct cvi_udc *dev);
+void cvi_hsotg_set_bit(uint32_t *reg, uint32_t val);
+void cvi_hsotg_clear_bit(uint32_t *reg, uint32_t vla);
+int cvi_hsotg_wait_bit_set(uint32_t *reg, uint32_t bit, uint32_t timeout);
+
+#endif	/* __CVI_UDC_OTG_PRIV__ */
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_regs.h b/drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_regs.h
new file mode 100644
index 000000000..8b3dd1c00
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_udc_otg_regs.h
@@ -0,0 +1,335 @@
+/* linux/arch/arm/plat-s3c/include/plat/regs-otg.h
+ *
+ * Copyright (C) 2004 Herbert Poetzl <herbert@13thfloor.at>
+ *
+ * Registers remapping:
+ * Lukasz Majewski <l.majewski@samsumg.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_REGS_USB_OTG_HS_H
+#define __ASM_ARCH_REGS_USB_OTG_HS_H
+
+/* USB2.0 OTG Controller register */
+struct cvi_usbotg_phy {
+	uint32_t phypwr;
+	uint32_t phyclk;
+	uint32_t rstcon;
+};
+
+/* Device Logical IN Endpoint-Specific Registers */
+struct cvi_dev_in_endp {
+	uint32_t diepctl;
+	uint8_t  res1[4];
+	uint32_t diepint;
+	uint8_t  res2[4];
+	uint32_t dieptsiz;
+	uint32_t diepdma;
+	uint32_t dtxfsts;
+	uint32_t diepdmab;
+};
+
+/* Device Logical OUT Endpoint-Specific Registers */
+struct cvi_dev_out_endp {
+	uint32_t doepctl;
+	uint8_t  res1[4];
+	uint32_t doepint;
+	uint8_t  res2[4];
+	uint32_t doeptsiz;
+	uint32_t doepdma;
+	uint8_t  res3[4];
+	uint32_t doepdmab;
+};
+
+struct ep_fifo {
+	uint32_t fifo;
+	uint8_t  res[4092];
+};
+
+/* USB2.0 OTG Controller register */
+struct cvi_usbotg_reg {
+	/* Core Global Registers */
+	uint32_t gotgctl; /* OTG Control & Status */
+	uint32_t gotgint; /* OTG Interrupt */
+	uint32_t gahbcfg; /* Core AHB Configuration */
+	uint32_t gusbcfg; /* Core USB Configuration */
+	uint32_t grstctl; /* Core Reset */
+	uint32_t gintsts; /* Core Interrupt */
+	uint32_t gintmsk; /* Core Interrupt Mask */
+	uint32_t grxstsr; /* Receive Status Debug Read/Status Read */
+	uint32_t grxstsp; /* Receive Status Debug Pop/Status Pop */
+	uint32_t grxfsiz; /* Receive FIFO Size */
+	uint32_t gnptxfsiz; /* Non-Periodic Transmit FIFO Size */
+	uint8_t  res0[20];
+	uint32_t gsnpsid;
+	uint8_t  res1[192];
+	uint32_t dieptxf[15]; /* Device Periodic Transmit FIFO size register */
+	uint8_t  res2[1728];
+	/* Device Configuration */
+	uint32_t dcfg; /* Device Configuration Register */
+	uint32_t dctl; /* Device Control */
+	uint32_t dsts; /* Device Status */
+	uint8_t  res3[4];
+	uint32_t diepmsk; /* Device IN Endpoint Common Interrupt Mask */
+	uint32_t doepmsk; /* Device OUT Endpoint Common Interrupt Mask */
+	uint32_t daint; /* Device All Endpoints Interrupt */
+	uint32_t daintmsk; /* Device All Endpoints Interrupt Mask */
+	uint8_t  res4[224];
+	struct cvi_dev_in_endp in_endp[16];
+	struct cvi_dev_out_endp out_endp[16];
+	uint8_t  res5[256];
+	uint32_t pcgcctl; /* Power and Clock Gating Control Register */
+	uint8_t  res6[508];
+	struct ep_fifo ep[16];
+};
+
+/*===================================================================== */
+/*definitions related to CSR setting */
+
+/* SNPSID*/
+#define CVI_CORE_REV_4_20a     0x4f54420a
+#define CVI_CORE_REV_MASK      0x0000ffff
+/* CVI_UDC_OTG_GOTGCTL */
+#define B_SESSION_VALID		(0x1<<19)
+#define A_SESSION_VALID		(0x1<<18)
+
+/* CVI_UDC_OTG_GAHBCFG */
+#define PTXFE_HALF			(0<<8)
+#define PTXFE_ZERO			(1<<8)
+#define NPTXFE_HALF			(0<<7)
+#define NPTXFE_ZERO			(1<<7)
+#define MODE_SLAVE			(0<<5)
+#define MODE_DMA			(1<<5)
+#define BURST_SINGLE			(0<<1)
+#define BURST_INCR			(1<<1)
+#define BURST_INCR4			(3<<1)
+#define BURST_INCR8			(5<<1)
+#define BURST_INCR16			(7<<1)
+#define GBL_INT_UNMASK			(1<<0)
+#define GBL_INT_MASK			(0<<0)
+
+/* CVI_UDC_OTG_GRSTCTL */
+#define AHB_MASTER_IDLE		(1u<<31)
+#define CORE_SOFT_RESET		(0x1<<0)
+#define CSFTRST_DONE            (0x1<<29)
+
+/* CVI_UDC_OTG_GINTSTS/CVI_UDC_OTG_GINTMSK core interrupt register */
+#define INT_RESUME			(1u<<31)
+#define INT_DISCONN			(0x1<<29)
+#define INT_CONN_ID_STS_CNG		(0x1<<28)
+#define INT_RESETDET			(0x1<<23)
+#define INT_OUT_EP			(0x1<<19)
+#define INT_IN_EP			(0x1<<18)
+#define INT_ENUMDONE			(0x1<<13)
+#define INT_RESET			(0x1<<12)
+#define INT_SUSPEND			(0x1<<11)
+#define INT_EARLY_SUSPEND		(0x1<<10)
+#define INT_NP_TX_FIFO_EMPTY		(0x1<<5)
+#define INT_RX_FIFO_NOT_EMPTY		(0x1<<4)
+#define INT_SOF			(0x1<<3)
+#define INT_DEV_MODE			(0x0<<0)
+#define INT_HOST_MODE			(0x1<<1)
+#define INT_GOUTNakEff			(0x01<<7)
+#define INT_GINNakEff			(0x01<<6)
+
+#define FULL_SPEED_CONTROL_PKT_SIZE	8
+#define FULL_SPEED_BULK_PKT_SIZE	64
+
+#define HIGH_SPEED_CONTROL_PKT_SIZE	64
+#define HIGH_SPEED_BULK_PKT_SIZE	512
+
+#define RX_FIFO_SIZE			(1024)
+#define NPTX_FIFO_SIZE			(64)
+#define PTX_FIFO_SIZE			(384)
+
+#define DEPCTL_TXFNUM_0		(0x0<<22)
+#define DEPCTL_TXFNUM_1		(0x1<<22)
+#define DEPCTL_TXFNUM_2		(0x2<<22)
+#define DEPCTL_TXFNUM_3		(0x3<<22)
+#define DEPCTL_TXFNUM_4		(0x4<<22)
+
+/* Enumeration speed */
+#define USB_HIGH_30_60MHZ		(0x0<<1)
+#define USB_FULL_30_60MHZ		(0x1<<1)
+#define USB_LOW_6MHZ			(0x2<<1)
+#define USB_FULL_48MHZ			(0x3<<1)
+
+/* CVI_UDC_OTG_GRXSTSP STATUS */
+#define OUT_PKT_RECEIVED		(0x2<<17)
+#define OUT_TRANSFER_COMPLELTED	(0x3<<17)
+#define SETUP_TRANSACTION_COMPLETED	(0x4<<17)
+#define SETUP_PKT_RECEIVED		(0x6<<17)
+#define GLOBAL_OUT_NAK			(0x1<<17)
+
+/* CVI_UDC_OTG_DCTL device control register */
+#define RMTWKUPSIG		(0x1<<0)
+#define SOFT_DISCONNECT		(0x1<<1)
+#define CGNPINNAK			(0x1<<8)
+#define SGOUTNAK			(0x1<<9)
+#define CGOUTNAK			(0x1<<10)
+#define PWRONPRGDONE			(0x1<<11)
+#define DCTL_TSTCTL_SHIFT		(4)
+#define DCTL_TSTCTL_MASK		(0x7<<DCTL_TSTCTL_SHIFT)
+
+/* CVI_UDC_OTG_DAINT device all endpoint interrupt register */
+#define DAINT_OUT_BIT			(16)
+#define DAINT_MASK			(0xFFFF)
+
+/* CVI_UDC_OTG_DIEPCTL0/DOEPCTL0 device
+   control IN/OUT endpoint 0 control register */
+#define DEPCTL_EPENA			(0x1<<31)
+#define DEPCTL_EPDIS			(0x1<<30)
+#define DEPCTL_SETD1PID		(0x1<<29)
+#define DEPCTL_SETD0PID		(0x1<<28)
+#define DEPCTL_SNAK			(0x1<<27)
+#define DEPCTL_CNAK			(0x1<<26)
+#define DEPCTL_STALL			(0x1<<21)
+#define DEPCTL_TYPE_BIT		(18)
+#define DEPCTL_TYPE_MASK		(0x3<<18)
+#define DEPCTL_CTRL_TYPE		(0x0<<18)
+#define DEPCTL_ISO_TYPE		(0x1<<18)
+#define DEPCTL_BULK_TYPE		(0x2<<18)
+#define DEPCTL_INTR_TYPE		(0x3<<18)
+#define DEPCTL_USBACTEP		(0x1<<15)
+#define DEPCTL_NEXT_EP_BIT		(11)
+#define DEPCTL_MPS_BIT			(0)
+#define DEPCTL_MPS_MASK		(0x7FF)
+
+#define DEPCTL0_MPS_64			(0x0<<0)
+#define DEPCTL0_MPS_32			(0x1<<0)
+#define DEPCTL0_MPS_16			(0x2<<0)
+#define DEPCTL0_MPS_8			(0x3<<0)
+#define DEPCTL_MPS_BULK_512		(512<<0)
+#define DEPCTL_MPS_INT_MPS_16		(16<<0)
+
+#define DIEPCTL0_NEXT_EP_BIT		(11)
+
+
+/* CVI_UDC_OTG_DIEPMSK/DOEPMSK device IN/OUT endpoint
+   common interrupt mask register */
+/* CVI_UDC_OTG_DIEPINTn/DOEPINTn device IN/OUT endpoint interrupt register */
+#define BACK2BACK_SETUP_RECEIVED	(0x1<<6)
+#define INEPNAKEFF			(0x1<<6)
+#define INTKNEPMIS			(0x1<<5)
+#define INTKN_TXFEMP			(0x1<<4)
+#define NON_ISO_IN_EP_TIMEOUT		(0x1<<3)
+#define CTRL_OUT_EP_SETUP_PHASE_DONE	(0x1<<3)
+#define CTRL_IN_EP_TIMEOUT		(0x1<<3)
+#define AHB_ERROR			(0x1<<2)
+#define EPDISBLD			(0x1<<1)
+#define TRANSFER_DONE			(0x1<<0)
+
+#define USB_PHY_CTRL_EN0                (0x1 << 0)
+
+/* OPHYPWR */
+#define PHY_0_SLEEP                     (0x1 << 5)
+#define OTG_DISABLE_0                   (0x1 << 4)
+#define ANALOG_PWRDOWN                  (0x1 << 3)
+#define FORCE_SUSPEND_0                 (0x1 << 0)
+
+/* URSTCON */
+#define HOST_SW_RST                     (0x1 << 4)
+#define PHY_SW_RST1                     (0x1 << 3)
+#define PHYLNK_SW_RST                   (0x1 << 2)
+#define LINK_SW_RST                     (0x1 << 1)
+#define PHY_SW_RST0                     (0x1 << 0)
+
+/* OPHYCLK */
+#define COMMON_ON_N1                    (0x1 << 7)
+#define COMMON_ON_N0                    (0x1 << 4)
+#define ID_PULLUP0                      (0x1 << 2)
+#define CLK_SEL_24MHZ                   (0x3 << 0)
+#define CLK_SEL_12MHZ                   (0x2 << 0)
+#define CLK_SEL_48MHZ                   (0x0 << 0)
+
+#define EXYNOS4X12_ID_PULLUP0		(0x01 << 3)
+#define EXYNOS4X12_COMMON_ON_N0	(0x01 << 4)
+#define EXYNOS4X12_CLK_SEL_12MHZ	(0x02 << 0)
+#define EXYNOS4X12_CLK_SEL_24MHZ	(0x05 << 0)
+
+/* Device Configuration Register DCFG */
+#define DEV_SPEED_HIGH_SPEED_20         (0x0 << 0)
+#define DEV_SPEED_FULL_SPEED_20         (0x1 << 0)
+#define DEV_SPEED_LOW_SPEED_11          (0x2 << 0)
+#define DEV_SPEED_FULL_SPEED_11         (0x3 << 0)
+#define EP_MISS_CNT(x)                  (x << 18)
+#define DEVICE_ADDRESS(x)               (x << 4)
+#define DESC_DMA			(1 << 23)
+
+/* Core Reset Register (GRSTCTL) */
+#define TX_FIFO_FLUSH                   (0x1 << 5)
+#define RX_FIFO_FLUSH                   (0x1 << 4)
+#define TX_FIFO_NUMBER(x)               (x << 6)
+#define TX_FIFO_FLUSH_ALL               TX_FIFO_NUMBER(0x10)
+#define AHBIDLE				(0x1 << 31)
+
+/* Masks definitions */
+#define GINTMSK_INIT	(INT_OUT_EP | INT_IN_EP | INT_RESUME | INT_ENUMDONE\
+			| INT_RESET | INT_SUSPEND)
+#define DOEPMSK_INIT	(CTRL_OUT_EP_SETUP_PHASE_DONE | AHB_ERROR|TRANSFER_DONE)
+#define DIEPMSK_INIT	(NON_ISO_IN_EP_TIMEOUT|AHB_ERROR|TRANSFER_DONE)
+#define GAHBCFG_INIT	(PTXFE_HALF | NPTXFE_HALF | MODE_DMA | BURST_INCR4\
+			| GBL_INT_UNMASK)
+
+/* Device Endpoint X Transfer Size Register (DIEPTSIZX) */
+#define DIEPT_SIZ_PKT_CNT(x)                      (x << 19)
+#define DIEPT_SIZ_XFER_SIZE(x)                    (x << 0)
+
+/* Device OUT Endpoint X Transfer Size Register (DOEPTSIZX) */
+#define DOEPT_SIZ_PKT_CNT(x)                      (x << 19)
+#define DOEPT_SIZ_XFER_SIZE(x)                    (x << 0)
+#define DOEPT_SIZ_XFER_SIZE_MAX_EP0               (0x7F << 0)
+#define DOEPT_SIZ_XFER_SIZE_MAX_EP                (0x7FFF << 0)
+#define DOEPT_SIZ_SUS_CNT(x)                      (x << 29)
+
+/* Device Endpoint-N Control Register (DIEPCTLn/DOEPCTLn) */
+#define DIEPCTL_TX_FIFO_NUM(x)                    (x << 22)
+#define DIEPCTL_TX_FIFO_NUM_MASK                  (~DIEPCTL_TX_FIFO_NUM(0xF))
+
+/* Device ALL Endpoints Interrupt Register (DAINT) */
+#define DAINT_IN_EP_INT(x)                        (x << 0)
+#define DAINT_OUT_EP_INT(x)                       (x << 16)
+
+#define PCGCTL_GATEHCLK                 (1 << 1)
+#define PCGCTL_STOPPCLK                 (1 << 0)
+/*===================================================================== */
+/*definitions related to DMA descriptor */
+#define DESC_BS_MASK			(0x3 << 30)
+#define DESC_BS_HOST_RDY		(0x0 << 30)
+#define DESC_BS_DMA_BUSY		(0x1 << 30)
+#define DESC_BS_DMA_DONE		(0x2 << 30)
+#define DESC_BS_HOST_BUSY		(0x3 << 30)
+#define DESC_LAST			(0x1 << 27)
+#define DESC_SP				(0x1 << 26)
+#define DESC_IOC			(0x1 << 25)
+#define DESC_ISO_FRM_NUM_MASK		(0x7FF << 12)
+#define DESC_ISO_FRM_NUM_SHIFT		(12)
+#define DESC_SIZE_MASK			(0xFFFF << 0)
+/* out transfer. */
+#define DESC_RXSTS_MASK			(0x3 << 28)
+#define DESC_RXSTS_NO_ERR		(0x0 << 28)
+#define DESC_RXSTS_BUF_ERR		(0x3 << 28)
+/* varies on non-isochronous out*/
+#define DESC_SR				(0x1 << 24)
+#define DESC_MTRF			(0x1 << 23)
+#define DESC_NAK			(0x1 << 16)
+/* varies on isochronous out*/
+#define DESC_ISO_OUT_PID_MASK		(0x3 << 23)
+#define DESC_ISO_OUT_PID_DATA0		(0x0 << 23)
+#define DESC_ISO_OUT_PID_DATA1		(0x1 << 23)
+#define DESC_ISO_OUT_PID_DATA2		(0x2 << 23)
+#define DESC_ISO_OUT_PID_MDATA		(0x3 << 23)
+#define DESC_ISO_OUT_SIZE_MASK		(0x7FF << 0)
+/* in transfer*/
+#define DESC_TXSTS_MASK			(0x3 << 28)
+#define DESC_TXSTS_NO_ERR		(0x0 << 28)
+#define DESC_TXSTS_BUFFFLUSH		(0x1 << 28)
+#define DESC_TXSTS_BUF_ERR		(0x3 << 28)
+/* varies on isochronous in*/
+#define DESC_ISO_IN_PID_MASK		(0x3 << 23)
+#define DESC_ISO_IN_PID_DATA0		(0x1 << 23)
+#define DESC_ISO_IN_PID_DATA1		(0x2 << 23)
+#define DESC_ISO_IN_PID_MDAT2		(0x3 << 23)
+#define DESC_ISO_IN_SIZE_MASK		(0xFFF << 0)
+#endif
diff --git a/drivers/cvi_usb/utask/cv181x/include/cvi_usb.h b/drivers/cvi_usb/utask/cv181x/include/cvi_usb.h
new file mode 100644
index 000000000..ed2b72d72
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/cvi_usb.h
@@ -0,0 +1,87 @@
+#ifndef CVI_USB_H
+#define CVI_USB_H
+
+#include <linux/types.h>
+#define BCD_USB_SS                      0x0300  // 3.00 version USB
+#define ID_VENDOR                       0x3346  // Cvitek
+#define ID_PRODUCT                      0x1001  // example bulk product
+#define BCD_DEVICE_SS                   0x0001  // 0.1
+#define BCD_USB_HS_ONLY                 0x0201  // 2.01  /*Only HS with BOS descriptor*/
+#define BCD_USB_HS                      0x0210  // 2.10
+#define BCD_DEVICE_HS                   0x0200  // 2.00
+
+#define USB_MANUFACTURER_STRING         "CVITEK"
+#define USB_PRODUCT_STRING              "USB Com Port"
+#define USB_SERIAL_NUMBER_STRING        "123456789ABC" // should 12 chars long
+
+#define BULK_EP_IN 0x81
+#define BULK_EP_OUT 0x01
+#define BULK_EP_NOTIFY 0x82
+#define HEADER_SIZE 8
+
+#define SS_PERIPH_DISABLED_SET BIT(21)
+#define HOST_BUS_DROP          BIT(9)
+#define DEV_BUS_REQ            (1)
+#define INTR_SPI_BASE          32
+#define USB_DEV_INTR0          115
+/*#define USB_DEV_INTR1          116*/
+/*#define USB_IRQ_MODE*/
+
+enum CVI_USB_TOKEN {
+	CVI_USB_NONE = 0,
+	CVI_USB_INFO,
+	CVI_USB_VERBOSE,
+	CVI_USB_JUMP,
+	CVI_USB_BREAK,
+	CVI_USB_KEEP_DL,
+	CVI_USB_PRG_CMD,
+	CVI_USB_RESET_ARM,
+	CVI_USB_TEST_THERMAL_SENSOR,
+	CVI_USB_TEST_EMMC,
+	CVI_USB_TEST_GET_RESULT,
+	CVI_USB_EFUSEW,
+	CVI_USB_READ_SN,
+	CV_USB_EFUSE_PATCH = 13,
+	CVI_USB_EFUSER = 14,
+	CV_USB_NONE_FAST = 20,
+	CV_USB_JUMP_ACK = 21,
+	CVI_USB_REBOOT = 22,
+	CVI_USB_RUNTIME = 0x80,
+	CVI_USB_S2D = 0x81,
+	CVI_USB_D2S = 0x82,
+	CVI_USB_PROGRAM = 0x83
+};
+
+enum ACK_RESULT {
+	ACK_FAIL,
+	ACK_PASS,
+};
+
+typedef void func(void);
+
+#define ALIGN_CACHE_SIZE(x)	ROUND(x, CONFIG_SYS_CACHELINE_SIZE)
+
+#define USB_BUF_BASE      0x0C000000
+#define PD_SIZE           4096
+#define BUF_SIZE          512
+#define EP0_SIZE          64
+#define CB_SIZE           128
+#define RSP_SIZE          64
+#define ACM_SIZE          128
+#define STP_SIZE          8
+#define HANDLER_SIZE	  1024
+
+#define BLK_BUF_ADDR  USB_BUF_BASE				// 512
+#define CMD_BUF_ADDR  (BLK_BUF_ADDR + ALIGN_CACHE_SIZE(BUF_SIZE))  // 512
+#define CB0_BUF_ADDR  (CMD_BUF_ADDR + ALIGN_CACHE_SIZE(BUF_SIZE))  // 128
+#define CB1_BUF_ADDR  (CB0_BUF_ADDR + ALIGN_CACHE_SIZE(CB_SIZE))   // 128
+#define CB2_BUF_ADDR  (CB1_BUF_ADDR + ALIGN_CACHE_SIZE(CB_SIZE))   // 128
+#define EP0_BUF_ADDR  (CB2_BUF_ADDR + ALIGN_CACHE_SIZE(CB_SIZE))   // 64
+#define RSP_BUF_ADDR  (EP0_BUF_ADDR + ALIGN_CACHE_SIZE(EP0_SIZE))  // 32
+#define ACM_BUF_ADDR  (RSP_BUF_ADDR + ALIGN_CACHE_SIZE(RSP_SIZE))  // 128
+#define STP_BUF_ADDR  (ACM_BUF_ADDR + ALIGN_CACHE_SIZE(ACM_SIZE))  // 32
+#define HANDLER_ADDR  (STP_BUF_ADDR + ALIGN_CACHE_SIZE(STP_SIZE))  // 1024
+
+int cvi_usb_polling(void);
+void acm_patch_id(unsigned short vid, unsigned short pid);
+#endif
diff --git a/drivers/cvi_usb/utask/cv181x/include/debug.h b/drivers/cvi_usb/utask/cv181x/include/debug.h
new file mode 100644
index 000000000..a972aa722
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/debug.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2013-2017, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+/* The log output macros print output to the console. These macros produce
+ * compiled log output only if the LOG_LEVEL defined in the makefile (or the
+ * make command line) is greater or equal than the level required for that
+ * type of log output.
+ * The format expected is the same as for INFO(). For example:
+ * INFO("Info %s.\n", "message")    -> INFO:    Info message.
+ * WARN("Warning %s.\n", "message") -> WARNING: Warning message.
+ */
+
+#define LOG_LEVEL_NONE			0
+#define LOG_LEVEL_ERROR			10
+#define LOG_LEVEL_NOTICE		20
+#define LOG_LEVEL_WARNING		30
+#define LOG_LEVEL_INFO			40
+#define LOG_LEVEL_VERBOSE		50
+
+#ifndef __ASSEMBLY__
+
+#define LOG_LEVEL 40
+
+#if LOG_LEVEL >= LOG_LEVEL_NOTICE
+# define NOTICE(...)	printf("NOTICE:  " __VA_ARGS__)
+#else
+# define NOTICE(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_ERROR
+# define ERROR(...)	printf("ERROR:   " __VA_ARGS__)
+#else
+# define ERROR(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_WARNING
+# define WARN(...)	printf("WARNING: " __VA_ARGS__)
+#else
+# define WARN(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_INFO
+# define INFO(...)	printf("INFO:    " __VA_ARGS__)
+#else
+# define INFO(...)
+#endif
+
+#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
+# define VERBOSE(...)	printf("VERBOSE: " __VA_ARGS__)
+#else
+# define VERBOSE(...)
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __DEBUG_H__ */
diff --git a/drivers/cvi_usb/utask/cv181x/include/dps.h b/drivers/cvi_usb/utask/cv181x/include/dps.h
new file mode 100644
index 000000000..7bef1f6d2
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/dps.h
@@ -0,0 +1,133 @@
+#ifndef DPS_H
+#define DPS_H
+
+#include "cvi_stdtypes.h"
+
+/****************************************************************************
+ * Prototypes
+ ***************************************************************************/
+
+/**
+ * Read a (32-bit) word
+ * @param[in] address the address
+ * @return the word at the given address
+ */
+extern uint32_t cvi_read32(volatile uint32_t *address);
+
+/**
+ * Write a (32-bit) word to memory
+ * @param[in] address the address
+ * @param[in] value the word to write
+ */
+extern void cvi_write32(uint32_t value, volatile uint32_t *address);
+/**
+ * Read a byte, bypassing the cache
+ * @param[in] address the address
+ * @return the byte at the given address
+ */
+extern uint8_t cvi_uncached_read8(volatile uint8_t *address);
+
+/**
+ * Read a short, bypassing the cache
+ * @param[in] address the address
+ * @return the short at the given address
+ */
+extern uint16_t cvi_uncached_read16(volatile uint16_t *address);
+
+/**
+ * Read a (32-bit) word, bypassing the cache
+ * @param[in] address the address
+ * @return the word at the given address
+ */
+extern uint32_t cvi_uncached_read32(volatile uint32_t *address);
+
+/**
+ * Write a byte to memory, bypassing the cache
+ * @param[in] address the address
+ * @param[in] value the byte to write
+ */
+extern void cvi_uncached_write8(uint8_t value, volatile uint8_t *address);
+
+/**
+ * Write a short to memory, bypassing the cache
+ * @param[in] address the address
+ * @param[in] value the short to write
+ */
+extern void cvi_uncached_write16(uint16_t value, volatile uint16_t *address);
+/**
+ * Write a (32-bit) word to memory, bypassing the cache
+ * @param[in] address the address
+ * @param[in] value the word to write
+ */
+extern void cvi_uncached_write32(uint32_t value, volatile uint32_t *address);
+/**
+ * Write a (32-bit) address value to memory, bypassing the cache.
+ * This function is for writing an address value, i.e. something that
+ * will be treated as an address by hardware, and therefore might need
+ * to be translated to a physical bus address.
+ * @param[in] location the (CPU) location where to write the address value
+ * @param[in] value the address value to write
+ */
+extern void cvi_write_phys32(uint32_t value, volatile uint32_t *location);
+
+/**
+ * Hardware specific memcpy.
+ * @param[in] src  src address
+ * @param[in] dst  destination address
+ * @param[in] size size of the copy
+ */
+extern void cvi_buffer_copy(volatile uint8_t *dst, volatile uint8_t *src, uint32_t size);
+
+/**
+ * Invalidate the cache for the specified memory region.
+ * This function may be stubbed out if caching is disabled for memory regions
+ * as described in the driver documentation, or if the driver configuration does
+ * not require this function.
+ * @param[in] address Virtual address of memory region. (If an MMU is not in use,
+ * this will be equivalent to the physical address.) This address should be
+ * rounded down to the nearest cache line boundary.
+ * @param[in] size  size of memory in bytes.  This size should be rounded up to
+ * the nearest cache line boundary.  Use size UINTPTR_MAX to invalidate all
+ * memory cache.  A size of 0 should be ignored and the function should return
+ * immediately with no effect.
+ * @param[in] devInfo   This parameter can be used to pass implementation specific
+ * data to this function.  The content and use of this parameter is up to the
+ * implementor of this function to determine, and if not required it may be ignored.
+ *  For example, under Linux it can be used to pass a pointer to
+ * the device struct to be used in a call to dma_sync_single_for_device().  If
+ * used, the parameter should be passed to the core driver at initialisation as
+ * part of the configurationInfo struct.  Please
+ * see the core driver documentation for details of how to do this.
+ */
+extern void cvi_cache_invalidate(uintptr_t address, size_t size);
+
+/**
+ * Flush the cache for the specified memory region
+ * This function may be stubbed out if caching is disabled for memory regions
+ * as described in the driver documentation, or if the driver configuration does
+ * not require this function.
+ * @param[in] address Virtual address of memory region. (If an MMU is not in use,
+ * this will be equivalent to the physical address.) This address should be
+ * rounded down to the nearest cache line boundary.
+ * @param[in] size  size of memory in bytes.  This size should be rounded up to
+ * the nearest cache line boundary.  Use size UINTPTR_MAX to flush all
+ * memory cache.  A size of 0 should be ignored and the function should return
+ * immediately with no effect.
+ * @param[in] devInfo   This parameter can be used to pass implementation specific
+ * data to this function.  The content and use of this parameter is up to the
+ * implementor of this function to determine, and if not required it may be ignored.
+ *  For example, under Linux it can be used to pass a pointer to
+ * the device struct to be used in a call to dma_sync_single_for_device().  If
+ * used, the parameter should be passed to the core driver at initialisation as
+ * part of the configurationInfo struct.  Please
+ * see the core driver documentation for details of how to do this.
+ */
+extern void cvi_cache_flush(uintptr_t address, size_t size);
+
+/**
+ * Delay software execution by a number of nanoseconds
+ * @param[in] ns number of nanoseconds to delay software execution
+ */
+extern void cvi_delay_ns(uint32_t ns);
+
+#endif /* DPS_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/little_endian.h b/drivers/cvi_usb/utask/cv181x/include/little_endian.h
new file mode 100644
index 000000000..d6cd04684
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/little_endian.h
@@ -0,0 +1,25 @@
+#ifndef BYTEORDER_LENDIAN_H
+#define BYTEORDER_LENDIAN_H
+
+#include "swap.h"
+
+#define cpuToLe32(x) (x)
+#define le32ToCpu(x) (x)
+#define cpuToLe16(x) ((uint16_t)(x))
+#define le16ToCpu(x) ((uint16_t)(x))
+
+#define cpuToBe32(x) ((uint32_t)swap32(x))
+#define be32ToCpu(x) ((uint32_t)swap32(x))
+#define cpuToBe16(x) ((uint16_t)swap16(x))
+#define be16ToCpu(x) ((uint16_t)swap16(x))
+
+/**
+ * Macros used for reading 16-bits and 32-bits data from memory which
+ * starting address could be unaligned.
+ */
+#define ptrToWord(ptr) ((*(uint8_t *)(ptr) << 8) | (*(uint8_t *)(ptr + 1)))
+#define ptrToDword(ptr) ((*(uint8_t *)(ptr) << 24) | ((*(uint8_t *)(ptr + 1)) << 16) | \
+	(*((uint8_t *)(ptr + 2)) << 8) | (*((uint8_t *)(ptr + 3))))
+
+#endif /* BYTEORDER_LENDIAN_H */
+
diff --git a/drivers/cvi_usb/utask/cv181x/include/platform_def.h b/drivers/cvi_usb/utask/cv181x/include/platform_def.h
new file mode 100644
index 000000000..eef8d15e8
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/platform_def.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2015-2016, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __PLATFORM_DEF_H__
+#define __PLATFORM_DEF_H__
+
+#if defined(CONFIG_TARGET_CVITEK_CV1835)
+#include <../../../board/cvitek/cv1835/cv1835_reg.h>
+#elif defined(CONFIG_TARGET_CVITEK_CV1822)
+#include <../../../board/cvitek/cv1822/cv1822_reg.h>
+#elif defined(CONFIG_TARGET_CVITEK_CV181X)
+#include <../../../board/cvitek/cv181x/cv181x_reg.h>
+#elif defined(CONFIG_TARGET_CVITEK_CV180X)
+#include <../../../board/cvitek/cv180x/cv180x_reg.h>
+#else
+#error "use cvi_utask at wrong platform"
+#endif
+
+#endif /* __PLATFORM_DEF_H__ */
diff --git a/drivers/cvi_usb/utask/cv181x/include/swap.h b/drivers/cvi_usb/utask/cv181x/include/swap.h
new file mode 100644
index 000000000..dc429aa7e
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/swap.h
@@ -0,0 +1,13 @@
+#ifndef BYTEORDER_SWAB_H
+#define BYTEORDER_SWAB_H
+
+#define swap16(x) \
+((uint16_t)((((uint16_t) (x) & (uint16_t) 0x00ffU) << 8) | (((uint16_t) (x) & (uint16_t) 0xff00U) >> 8)))
+
+#define swap32(x) (((uint32_t) ( \
+(((uint32_t) (x) & (uint32_t) 0x000000ffUL) << 24) | \
+(((uint32_t) (x) & (uint32_t) 0x0000ff00UL) <<  8) | \
+(((uint32_t) (x) & (uint32_t) 0x00ff0000UL) >>  8) | \
+(((uint32_t) (x) & (uint32_t) 0xff000000UL) >> 24))))
+
+#endif /* BYTEORDER_SWAB_H */
diff --git a/drivers/cvi_usb/utask/cv181x/include/system_common.h b/drivers/cvi_usb/utask/cv181x/include/system_common.h
new file mode 100644
index 000000000..824be64d9
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/system_common.h
@@ -0,0 +1,334 @@
+#ifndef _SYSTEM_COMMON_H_
+#define _SYSTEM_COMMON_H_
+
+//#include <stdio.h>
+
+static inline u32 float_to_u32(float x)
+{
+	union {
+		int ival;
+		float fval;
+	} v = { .fval = x };
+	return v.ival;
+}
+
+static inline float u32_to_float(u32 x)
+{
+	union {
+		int ival;
+		float fval;
+	} v = { .ival = x };
+	return v.fval;
+}
+
+#define ALIGNMENT(x, a) __ALIGNMENT_MASK((x), (typeof(x))(a) - 1)
+#define __ALIGNMENT_MASK(x, mask) (((x) + (mask)) & ~(mask))
+#define PTR_ALIGNMENT(p, a) ((typeof(p))ALIGNMENT((unsigned long)(p), (a)))
+#define IS_ALIGNMENT(x, a) (((x) & ((typeof(x))(a) - 1)) == 0)
+
+#ifndef __weak
+#define __weak __attribute__((weak))
+#endif
+
+#ifdef USE_BMTAP
+#define call_atomic(nodechip_idx, atomic_func, p_command, eng_id)              \
+	emit_task_descriptor(p_command, eng_id)
+#endif
+
+#define TOP_USB_PHY_CTRSTS_REG (TOP_BASE + 0x48)
+#define UPCR_EXTERNAL_VBUS_VALID_OFFSET 0
+
+#define TOP_DDR_ADDR_MODE_REG (TOP_BASE + 0x64)
+#define DAMR_REG_USB_REMAP_ADDR_39_32_OFFSET 16
+#define DAMR_REG_USB_REMAP_ADDR_39_32_MSK (0xff)
+
+#define DAMR_REG_VD_REMAP_ADDR_39_32_OFFSET 24
+#define DAMR_REG_VD_REMAP_ADDR_39_32_MSK (0xff)
+
+#define SW_RESET (TOP_BASE + 0x3000)
+#define JPEG_RESET 4
+
+#define TOP_USB_CTRSTS_REG (TOP_BASE + 0x38)
+#define UCR_MODE_STRAP_OFFSET 0
+#define UCR_MODE_STRAP_NON 0x0
+#define UCR_MODE_STRAP_HOST 0x2
+#define UCR_MODE_STRAP_DEVICE 0x4
+#define UCR_MODE_STRAP_MSK (0x7)
+#define UCR_PORT_OVER_CURRENT_ACTIVE_OFFSET 10
+#define UCR_PORT_OVER_CURRENT_ACTIVE_MSK 1
+
+#define PINMUX_UART0 0
+#define PINMUX_UART1 1
+#define PINMUX_UART2 2
+#define PINMUX_UART3 3
+#define PINMUX_UART3_2 4
+#define PINMUX_I2C0 5
+#define PINMUX_I2C1 6
+#define PINMUX_I2C2 7
+#define PINMUX_I2C3 8
+#define PINMUX_I2C4 9
+#define PINMUX_I2C4_2 10
+#define PINMUX_SPI0 11
+#define PINMUX_SPI1 12
+#define PINMUX_SPI2 13
+#define PINMUX_SPI2_2 14
+#define PINMUX_SPI3 15
+#define PINMUX_SPI3_2 16
+#define PINMUX_I2S0 17
+#define PINMUX_I2S1 18
+#define PINMUX_I2S2 19
+#define PINMUX_I2S3 20
+#define PINMUX_USBID 21
+#define PINMUX_SDIO0 22
+#define PINMUX_SDIO1 23
+#define PINMUX_ND 24
+#define PINMUX_EMMC 25
+#define PINMUX_SPI_NOR 26
+#define PINMUX_SPI_NAND 27
+#define PINMUX_CAM0 28
+#define PINMUX_CAM1 29
+#define PINMUX_PCM0 30
+#define PINMUX_PCM1 31
+#define PINMUX_CSI0 32
+#define PINMUX_CSI1 33
+#define PINMUX_CSI2 34
+#define PINMUX_DSI 35
+#define PINMUX_VI0 36
+#define PINMUX_VO 37
+#define PINMUX_PWM1 38
+
+/* addr remap */
+#define REG_TOP_ADDR_REMAP 0x0064
+#define ADDR_REMAP_USB(a) (((a) & 0xFF) << 16)
+
+/* rst */
+#define BITS_PER_REG 32
+#define REG_TOP_SOFT_RST 0x3000
+
+/* irq */
+#define IRQ_LEVEL 0
+#define IRQ_EDGE 3
+
+#define SDMA_INTR 0
+#define I2S0_TX_EMP_INTR 1
+#define I2S0_TX_OR_INTR 2
+#define I2S0_RX_DA_INTR 3
+#define I2S0_RX_OR_INTR 4
+#define I2S1_TX_EMP_INTR 5
+#define I2S1_TX_OR_INTR 6
+#define I2S1_RX_DA_INTR 7
+#define I2S1_RX_OR_INTR 8
+#define UART_INTR_UART0 9
+#define UART_DMA_TX_REQ_UART0 10
+#define UART_DMA_RX_REQ_UART0 11
+#define UART_INTR_UART1 12
+#define UART_DMA_TX_REQ_UART1 13
+#define UART_DMA_RX_REQ_UART1 14
+#define UART_INTR_UART2 15
+#define UART_DMA_TX_REQ_UART2 16
+#define UART_DMA_RX_REQ_UART2 17
+#define UART_INTR_UART3 18
+#define UART_DMA_TX_REQ_UART3 19
+#define UART_DMA_RX_REQ_UART3 20
+#define RTC_ALARM_O 21
+// #defiNE RESERVED 22
+// #defiNE RESERVED 23
+// #defiNE RESERVED 24
+// #defiNE RESERVED 25
+// #defiNE RESERVED 26
+// #defiNE RESERVED 27
+// #defiNE RESERVED 28
+// #defiNE RESERVED 29
+// #defiNE RESERVED 30
+// #defiNE RESERVED 31
+// #defiNE RESERVED 32
+// #defiNE RESERVED 33
+// #defiNE RESERVED 34
+// #defiNE RESERVED 35
+// #defiNE RESERVED 36
+// #defiNE RESERVED 37
+// #defiNE RESERVED 38
+// #defiNE RESERVED 39
+// #defiNE RESERVED 40
+// #defiNE RESERVED 41
+// #defiNE RESERVED 42
+// #defiNE RESERVED 43
+// #defiNE RESERVED 44
+// #defiNE RESERVED 45
+// #defiNE RESERVED 46
+// #defiNE RESERVED 47
+// #defiNE RESERVED 48
+// #defiNE RESERVED 49
+// #defiNE RESERVED 50
+// #defiNE RESERVED 51
+// #defiNE RESERVED 52
+// #defiNE RESERVED 53
+// #defiNE RESERVED 54
+#define ETH0_LPI_INTR 55
+// #defiNE RESERVED 56
+#define ETH0_INTR 57
+#define SD0_WAKEUP_INTR 58
+#define SD0_INTR 59
+#define EMMC_WAKEUP_INTR 60
+#define EMMC_INTR 61
+#define GPIO3_INTR 62
+#define DDR_PI_PHY_INTR 63
+#define SF_INTR 64
+#define SPI0_INTR 65
+#define GPIO2_INTR 66
+#define GPIO1_INTR 67
+#define GPIO0_INTR 68
+#define WDT_INTR 69
+#define IC4_INTR 70
+#define IC3_INTR 71
+#define IC2_INTR 72
+#define IC1_INTR 73
+#define IC0_INTR 74
+#define JPEG_INTR 75
+#define H264C_INTR 76
+#define H265C_INTR 77
+#define KEYSCAN_IRQ 78
+#define TPU0_INTR 79
+#define TDMA0_INTR 80
+// #defiNE RESERVED 81
+// #defiNE RESERVED 82
+#define USB_IRQS_0 83
+// #defiNE RESERVED 84
+// #defiNE RESERVED 85
+// #defiNE RESERVED 86
+// #defiNE RESERVED 87
+// #defiNE RESERVED 88
+// #defiNE RESERVED 89
+// #defiNE RESERVED 90
+// #defiNE RESERVED 91
+// #defiNE RESERVED 92
+#define UART_INTR_UART4 93
+#define UART_DMA_TX_REQ_UART4 94
+#define UART_DMA_RX_REQ_UART4 95
+#define NPMUIRQ_0 96
+#define NPMUIRQ_1 97
+#define CTIIRQ_0 98
+#define CTIIRQ_1 99
+#define NEXTERRIRQ 100
+// #defiNE RESERVED 101
+// #defiNE RESERVED 102
+// #defiNE RESERVED 103
+// #defiNE RESERVED 104
+// #defiNE RESERVED 105
+// #defiNE RESERVED 106
+// #defiNE RESERVED 107
+#define GP_REG15_0 108
+#define GP_REG15_1 109
+#define GP_REG15_2 110
+#define GP_REG15_3 111
+#define GP_REG15_4 112
+#define GP_REG15_5 113
+#define GP_REG15_6 114
+#define GP_REG15_7 115
+#define GP_REG15_8 116
+#define GP_REG15_9 117
+#define GP_REG15_10 118
+#define GP_REG15_11 119
+#define GP_REG15_12 120
+#define GP_REG15_13 121
+#define GP_REG15_14 122
+#define GP_REG15_15 123
+#define SPI1_INTR 124
+#define SPI2_INTR 125
+#define SPI3_INTR 126
+#define I2S2_TX_EMP_INTR 127
+#define I2S2_TX_OR_INTR 128
+#define I2S2_RX_DA_INTR 129
+#define I2S2_RX_OR_INTR 130
+#define I2S3_TX_EMP_INTR 131
+#define I2S3_TX_OR_INTR 132
+#define I2S3_RX_DA_INTR 133
+#define I2S3_RX_OR_INTR 134
+#define WGN0_IRQ 135
+#define WGN1_IRQ 136
+#define WGN2_IRQ 137
+#define VIP_INT_ISP_TOP 138
+#define VIP_INT_SC_TOP 139
+#define IRQ_RTC2AP_0 140
+#define IRQ_RTC2AP_1 141
+#define IRQ_RTC2AP_2 142
+#define IRQ_RTC2AP_3 143
+#define IRQ_RTC2AP_4 144
+#define IRQ_RTC2AP_5 145
+#define IRQ_RTC2AP_6 146
+#define IRQ_RTC2AP_7 147
+// #defiNE RESERVED 148
+// #defiNE RESERVED 149
+// #defiNE RESERVED 150
+// #defiNE RESERVED 151
+// #defiNE RESERVED 152
+// #defiNE RESERVED 153
+// #defiNE RESERVED 154
+#define VIP_INT_CSI_MAC0 155
+#define VIP_INT_CSI_MAC1 156
+#define VIP_INT_DWA_WRAP 157
+// #defiNE RESERVED 158
+#define PERI_FIREWALL_IRQ 159
+#define HSPERI_FIREWALL_IRQ 160
+#define SPACC_IRQ 161
+#define TRNG_IRQ 162
+// #defiNE RESERVED 163
+#define TEMPSEN_IRQ_O 164
+#define INTR_SARADC 165
+#define EPHY_SMI_INT_N 166
+#define EPHY_SMI_MGP_INT_N 167
+#define EPHY_SMI_EXMGP_INT_N 168
+#define DDR_FW_INTR 169
+#define ROM_FIREWALL_IRQ 170
+// #defiNE RESERVED 171
+#define DDR_AXI_MON_INTR 172
+// #defiNE RESERVED 173
+#define VBAT_DEB_IRQ_O 174
+// #defiNE RESERVED 175
+// #defiNE RESERVED 176
+// #defiNE RESERVED 177
+// #defiNE RESERVED 178
+// #defiNE RESERVED 179
+#define TIMER_INTR_FLAG 180
+#define SPI_NAND_INTR 181
+#define DBGSYS_APBUSMON_HANG_INT 182
+#define TIMER_INTR_0 183
+#define TIMER_INTR_1 184
+#define TIMER_INTR_2 185
+#define TIMER_INTR_3 186
+#define TIMER_INTR_4 187
+#define TIMER_INTR_5 188
+#define TIMER_INTR_6 189
+#define TIMER_INTR_7 190
+
+#define IRQF_TRIGGER_NONE 0x00000000
+#define IRQF_TRIGGER_RISING 0x00000001
+#define IRQF_TRIGGER_FALLING 0x00000002
+#define IRQF_TRIGGER_HIGH 0x00000004
+#define IRQF_TRIGGER_LOW 0x00000008
+#define IRQF_TRIGGER_MASK                                                      \
+	(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | IRQF_TRIGGER_RISING |          \
+	 IRQF_TRIGGER_FALLING)
+
+// IRQ API
+typedef int (*irq_handler_t)(int irqn, void *priv);
+
+void disable_irq(unsigned int irqn);
+void enable_irq(unsigned int irqn);
+
+void cpu_enable_irqs(void);
+void cpu_disable_irqs(void);
+
+// PINMUX API
+void pinmux_config(int io_type);
+
+// RESET API
+void cv_reset_assert(uint32_t id);
+void cv_reset_deassert(uint32_t id);
+
+#define NUM_IRQ (256)
+
+#define SPI_SECTOR_SIZE 256
+#define SPI_DMMR_TEST_SIZE 1024
+
+#endif
diff --git a/drivers/cvi_usb/utask/cv181x/include/usb_tty.h b/drivers/cvi_usb/utask/cv181x/include/usb_tty.h
new file mode 100644
index 000000000..796bdc686
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/include/usb_tty.h
@@ -0,0 +1,428 @@
+#ifndef _USB_TTY_H
+#define _USB_TTY_H
+
+#include "byteorder.h"
+#include "cvi_ch9.h"
+
+//------------------------------------------------------------------------------
+/* CDC DEFINE*/
+#define USB_CDC_SUBCLASS_ACM 0x02
+
+#define USB_CDC_PROTO_NONE 0
+
+#define USB_CDC_ACM_PROTO_AT_V25TER 1
+#define USB_CDC_ACM_PROTO_AT_PCCA101 2
+#define USB_CDC_ACM_PROTO_AT_PCCA101_WAKE 3
+#define USB_CDC_ACM_PROTO_AT_GSM 4
+#define USB_CDC_ACM_PROTO_AT_3G 5
+#define USB_CDC_ACM_PROTO_AT_CDMA 6
+#define USB_CDC_ACM_PROTO_VENDOR 0xff
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Class-Specific descriptors ... there are a couple dozen of them
+ */
+
+#define USB_CDC_HEADER_TYPE 0x00 /* header_desc */
+#define USB_CDC_CALL_MANAGEMENT_TYPE 0x01 /* call_mgmt_descriptor */
+#define USB_CDC_ACM_TYPE 0x02 /* acm_descriptor */
+#define USB_CDC_UNION_TYPE 0x06 /* union_desc */
+#define USB_CDC_COUNTRY_TYPE 0x07
+
+/* "Header Functional Descriptor" from CDC spec  5.2.3.1 */
+struct usb_cdc_header_desc {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDescriptorSubType;
+
+	uint16_t bcdCDC;
+} __packed;
+
+/* "Call Management Descriptor" from CDC spec  5.2.3.2 */
+struct usb_cdc_call_mgmt_descriptor {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDescriptorSubType;
+
+	uint8_t bmCapabilities;
+#define USB_CDC_CALL_MGMT_CAP_CALL_MGMT 0x01
+#define USB_CDC_CALL_MGMT_CAP_DATA_INTF 0x02
+
+	uint8_t bDataInterface;
+} __packed;
+
+/* "Abstract Control Management Descriptor" from CDC spec  5.2.3.3 */
+struct usb_cdc_acm_descriptor {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDescriptorSubType;
+
+	uint8_t bmCapabilities;
+} __packed;
+
+/* capabilities from 5.2.3.3 */
+
+#define USB_CDC_COMM_FEATURE 0x01
+#define USB_CDC_CAP_LINE 0x02
+#define USB_CDC_CAP_BRK 0x04
+#define USB_CDC_CAP_NOTIFY 0x08
+
+/* "Union Functional Descriptor" from CDC spec 5.2.3.8 */
+struct usb_cdc_union_desc {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDescriptorSubType;
+
+	uint8_t bMasterInterface0;
+	uint8_t bSlaveInterface0;
+	/* ... and there could be other slave interfaces */
+} __packed;
+
+/* "Country Selection Functional Descriptor" from CDC spec 5.2.3.9 */
+struct usb_cdc_country_functional_desc {
+	uint8_t bLength;
+	uint8_t bDescriptorType;
+	uint8_t bDescriptorSubType;
+
+	uint8_t iCountryCodeRelDate;
+	uint16_t wCountyCode0;
+	/* ... and there can be a lot of country codes */
+} __packed;
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Class-Specific Control Requests (6.2)
+ *
+ * section 3.6.2.1 table 4 has the ACM profile, for modems.
+ * section 3.8.2 table 10 has the ethernet profile.
+ *
+ * Microsoft's RNDIS stack for Ethernet is a vendor-specific CDC ACM variant,
+ * heavily dependent on the encapsulated (proprietary) command mechanism.
+ */
+
+#define USB_CDC_SEND_ENCAPSULATED_COMMAND 0x00
+#define USB_CDC_GET_ENCAPSULATED_RESPONSE 0x01
+#define USB_CDC_REQ_SET_LINE_CODING 0x20
+#define USB_CDC_REQ_GET_LINE_CODING 0x21
+#define USB_CDC_REQ_SET_CONTROL_LINE_STATE 0x22
+#define USB_CDC_REQ_SEND_BREAK 0x23
+
+/* Line Coding Structure from CDC spec 6.2.13 */
+struct usb_cdc_line_coding {
+	int dwDTERate;
+	uint8_t bCharFormat;
+#define USB_CDC_1_STOP_BITS 0
+#define USB_CDC_1_5_STOP_BITS 1
+#define USB_CDC_2_STOP_BITS 2
+
+	uint8_t bParityType;
+#define USB_CDC_NO_PARITY 0
+#define USB_CDC_ODD_PARITY 1
+#define USB_CDC_EVEN_PARITY 2
+#define USB_CDC_MARK_PARITY 3
+#define USB_CDC_SPACE_PARITY 4
+
+	uint8_t bDataBits;
+} __packed;
+
+/* table 62; bits in multicast filter */
+#define USB_CDC_PACKET_TYPE_PROMISCUOUS (1 << 0)
+#define USB_CDC_PACKET_TYPE_ALL_MULTICAST (1 << 1) /* no filter */
+#define USB_CDC_PACKET_TYPE_DIRECTED (1 << 2)
+#define USB_CDC_PACKET_TYPE_BROADCAST (1 << 3)
+#define USB_CDC_PACKET_TYPE_MULTICAST (1 << 4) /* filtered */
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Class-Specific Notifications (6.3) sent by interrupt transfers
+ *
+ * section 3.8.2 table 11 of the CDC spec lists Ethernet notifications
+ * section 3.6.2.1 table 5 specifies ACM notifications, accepted by RNDIS
+ * RNDIS also defines its own bit-incompatible notifications
+ */
+
+#define USB_CDC_NOTIFY_NETWORK_CONNECTION 0x00
+#define USB_CDC_NOTIFY_RESPONSE_AVAILABLE 0x01
+#define USB_CDC_NOTIFY_SERIAL_STATE 0x20
+#define USB_CDC_NOTIFY_SPEED_CHANGE 0x2a
+
+struct usb_cdc_notification {
+	uint8_t bmRequestType;
+	uint8_t bNotificationType;
+	uint16_t wValue;
+	uint16_t wIndex;
+	uint16_t wLength;
+} __packed;
+
+/* utility to simplify dealing with string descriptors */
+
+/**
+ * struct usb_string - wraps a C string and its USB id
+ * @id:the (nonzero) ID for this string
+ * @s:the string, in UTF-8 encoding
+ *
+ * If you're using usb_gadget_get_string(), use this to wrap a string
+ * together with its ID.
+ */
+struct usb_string {
+	uint8_t id;
+	const char *s;
+};
+
+/* notification endpoint uses smallish and infrequent fixed-size messages */
+
+#define GS_LOG2_NOTIFY_INTERVAL 5 /* 1 << 5 == 32 msec */
+#define GS_NOTIFY_MAXPACKET 10 /* notification + 2 bytes */
+
+/* interface and class descriptors: */
+
+#define BCD_CDC 0x0110
+
+//------------------- descriptor set--------------------------------------------
+// device descriptor for HighSpeed mode
+static CH9_UsbDeviceDescriptor devHsDesc = { CH9_USB_DS_DEVICE,
+					     CH9_USB_DT_DEVICE,
+					     cpuToLe16(BCD_USB_HS),
+					     2,
+					     0,
+					     0,
+					     64,
+					     cpuToLe16(ID_VENDOR),
+					     cpuToLe16(ID_PRODUCT),
+					     cpuToLe16(BCD_DEVICE_HS),
+					     1,
+					     2,
+					     3,
+					     1 };
+
+//------------- Start of Super Speed configuration descriptors -----------------
+static struct CH9_UsbInterfaceAssociationDescriptor acm_iad_descriptor = {
+	.bLength = sizeof(acm_iad_descriptor),
+	.bDescriptorType = CH9_USB_DT_INTERFACE_ASSOCIATION,
+
+	/* .bFirstInterface =   DYNAMIC, */
+	.bInterfaceCount = 2, // control + data
+	.bFunctionClass = CH9_USB_CLASS_CDC,
+	.bFunctionSubClass = USB_CDC_SUBCLASS_ACM,
+	.bFunctionProtocol = USB_CDC_ACM_PROTO_AT_V25TER,
+	/* .iFunction =     DYNAMIC */
+};
+
+static struct CH9_UsbInterfaceDescriptor acm_control_interface_desc = {
+	.bLength = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType = CH9_USB_DT_INTERFACE,
+	.bInterfaceNumber = 0,
+	.bAlternateSetting = 0,
+	.bNumEndpoints = 1,
+	.bInterfaceClass = CH9_USB_CLASS_CDC,
+	.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM,
+	.bInterfaceProtocol = USB_CDC_ACM_PROTO_AT_V25TER,
+	.iInterface = 0,
+};
+
+static struct CH9_UsbInterfaceDescriptor acm_data_interface_desc = {
+	.bLength = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType = CH9_USB_DT_INTERFACE,
+	.bInterfaceNumber = 1,
+	.bAlternateSetting = 0,
+	.bNumEndpoints = 2,
+	.bInterfaceClass = CH9_USB_CLASS_CDC_DATA,
+	.bInterfaceSubClass = 0,
+	.bInterfaceProtocol = 0,
+	.iInterface = 0,
+};
+
+static struct usb_cdc_header_desc acm_header_desc = {
+	.bLength = sizeof(acm_header_desc),
+	.bDescriptorType = USB_DT_CS_INTERFACE,
+	.bDescriptorSubType = USB_CDC_HEADER_TYPE,
+	.bcdCDC = cpuToLe16(BCD_CDC),
+};
+
+static struct usb_cdc_call_mgmt_descriptor acm_call_mgmt_descriptor = {
+	.bLength = sizeof(acm_call_mgmt_descriptor),
+	.bDescriptorType = USB_DT_CS_INTERFACE,
+	.bDescriptorSubType = USB_CDC_CALL_MANAGEMENT_TYPE,
+	.bmCapabilities = 3,
+	.bDataInterface = 1,
+};
+
+static struct usb_cdc_acm_descriptor acm_descriptor = {
+	.bLength = sizeof(acm_descriptor),
+	.bDescriptorType = USB_DT_CS_INTERFACE,
+	.bDescriptorSubType = USB_CDC_ACM_TYPE,
+	.bmCapabilities = USB_CDC_CAP_LINE,
+};
+
+static struct usb_cdc_union_desc acm_union_desc = {
+	.bLength = sizeof(acm_union_desc),
+	.bDescriptorType = USB_DT_CS_INTERFACE,
+	.bDescriptorSubType = USB_CDC_UNION_TYPE,
+	.bMasterInterface0 = 0,
+	.bSlaveInterface0 = 1,
+};
+
+/* full speed support: */
+
+static struct CH9_UsbEndpointDescriptor acm_fs_notify_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = CH9_USB_DT_ENDPOINT,
+	.bEndpointAddress = BULK_EP_NOTIFY,
+	.bmAttributes = CH9_USB_EP_INTERRUPT,
+	.wMaxPacketSize = cpuToLe16(GS_NOTIFY_MAXPACKET),
+	.bInterval = 1 << GS_LOG2_NOTIFY_INTERVAL,
+};
+
+static struct CH9_UsbEndpointDescriptor acm_fs_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = CH9_USB_DT_ENDPOINT,
+	.bEndpointAddress = BULK_EP_IN,
+	.bmAttributes = CH9_USB_EP_BULK,
+	.wMaxPacketSize = cpuToLe16(64),
+};
+
+static struct CH9_UsbEndpointDescriptor acm_fs_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = CH9_USB_DT_ENDPOINT,
+	.bEndpointAddress = BULK_EP_OUT,
+	.bmAttributes = CH9_USB_EP_BULK,
+	.wMaxPacketSize = cpuToLe16(64),
+};
+
+static void *descriptorsFs[] = {
+	//&acm_iad_descriptor,
+	&acm_control_interface_desc,
+	&acm_header_desc,
+	&acm_descriptor,
+	&acm_union_desc,
+	&acm_call_mgmt_descriptor,
+	&acm_fs_notify_desc,
+	&acm_data_interface_desc,
+	&acm_fs_out_desc,
+	&acm_fs_in_desc,
+	NULL,
+};
+
+/* high speed support: */
+static struct CH9_UsbEndpointDescriptor acm_hs_notify_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = CH9_USB_DT_ENDPOINT,
+	.bEndpointAddress = BULK_EP_NOTIFY,
+	.bmAttributes = CH9_USB_EP_INTERRUPT,
+	.wMaxPacketSize = cpuToLe16(GS_NOTIFY_MAXPACKET),
+	.bInterval = GS_LOG2_NOTIFY_INTERVAL + 4,
+};
+
+static struct CH9_UsbEndpointDescriptor acm_hs_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = CH9_USB_DT_ENDPOINT,
+	.bEndpointAddress = BULK_EP_IN,
+	.bmAttributes = CH9_USB_EP_BULK,
+	.wMaxPacketSize = cpuToLe16(512),
+};
+
+static struct CH9_UsbEndpointDescriptor acm_hs_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = CH9_USB_DT_ENDPOINT,
+	.bEndpointAddress = BULK_EP_OUT,
+	.bmAttributes = CH9_USB_EP_BULK,
+	.wMaxPacketSize = cpuToLe16(512),
+};
+
+static void *descriptorsHs[] = {
+	//&acm_iad_descriptor,
+	&acm_control_interface_desc,
+	&acm_header_desc,
+	&acm_descriptor,
+	&acm_union_desc,
+	&acm_call_mgmt_descriptor,
+	&acm_hs_notify_desc,
+	&acm_data_interface_desc,
+	&acm_hs_out_desc,
+	&acm_hs_in_desc,
+	NULL,
+};
+
+/* string descriptors: */
+
+#define ACM_CTRL_IDX 0
+#define ACM_DATA_IDX 1
+#define ACM_IAD_IDX 2
+
+// language descriptor for english
+static uint8_t languageDesc[] = { 4, CH9_USB_DT_STRING, 0x09, 0x04 };
+
+static CH9_UsbConfigurationDescriptor ConfDesc = {
+	.bLength = CH9_USB_DS_CONFIGURATION,
+	.bDescriptorType = CH9_USB_DT_CONFIGURATION,
+	.wTotalLength = 0x0000, // will be filed in get_descriptor request
+	.bNumInterfaces = 2,
+	.bConfigurationValue = 1,
+	.iConfiguration = 0,
+	.bmAttributes = CH9_USB_CONFIG_RESERVED | CH9_USB_CONFIG_BUS_POWERED,
+	.bMaxPower = 0xFA
+};
+
+//-------------- BOS descriptor set start --------------------------------------
+
+static CH9_UsbBosDescriptor bosDesc = {
+	CH9_USB_DS_BOS, CH9_USB_DT_BOS,
+	cpuToLe16(CH9_USB_DS_BOS + CH9_USB_DS_DEVICE_CAPABILITY_20), 1
+};
+
+static CH9_UsbCapabilityDescriptor capabilityExtDesc = {
+	CH9_USB_DS_DEVICE_CAPABILITY_20, CH9_USB_DT_DEVICE_CAPABILITY,
+	CH9_USB_DCT_USB20_EXTENSION, cpuToLe32(CH9_USB_USB20_EXT_LPM_SUPPORT)
+};
+//-------------- BOS descriptor set end ----------------------------------------
+
+static CH9_UsbDeviceQualifierDescriptor qualifierDesc = {
+	CH9_USB_DS_DEVICE_QUALIFIER,
+	CH9_USB_DT_DEVICE_QUALIFIER,
+	cpuToLe16(0x0200),
+	0x00,
+	0x00,
+	0x00,
+	64,
+	0x01,
+	0x00
+};
+
+struct f_acm {
+	//struct gserial          port;
+	uint8_t ctrl_id, data_id;
+	uint8_t port_num;
+
+	uint8_t pending;
+
+	/* lock is mostly for pending and notify_req ... they get accessed
+	 * by callbacks both from tty (open/close/break) under its spinlock,
+	 * and notify_req.complete() which can't use that lock.
+	 */
+	//spinlock_t          lock;
+
+	//    struct usb_ep           *notify;
+	//    struct usb_request      *notify_req;
+
+	struct usb_cdc_line_coding port_line_coding; /* 8-N-1 etc */
+
+	/* SetControlLineState request -- CDC 1.1 section 6.2.14 (INPUT) */
+	uint16_t port_handshake_bits;
+#define ACM_CTRL_RTS (1 << 1) /* unused with full duplex */
+#define ACM_CTRL_DTR (1 << 0) /* host is ready for data r/w */
+
+	/* SerialState notification -- CDC 1.1 section 6.3.5 (OUTPUT) */
+	uint16_t serial_state;
+#define ACM_CTRL_OVERRUN (1 << 6)
+#define ACM_CTRL_PARITY (1 << 5)
+#define ACM_CTRL_FRAMING (1 << 4)
+#define ACM_CTRL_RI (1 << 3)
+#define ACM_CTRL_BRK (1 << 2)
+#define ACM_CTRL_DSR (1 << 1)
+#define ACM_CTRL_DCD (1 << 0)
+};
+
+#endif /*_USB_TTY_H*/
diff --git a/drivers/cvi_usb/utask/cv181x/usb_tty.c b/drivers/cvi_usb/utask/cv181x/usb_tty.c
new file mode 100644
index 000000000..ed4a641b4
--- /dev/null
+++ b/drivers/cvi_usb/utask/cv181x/usb_tty.c
@@ -0,0 +1,1537 @@
+/**********************************************************************
+ *
+ * usb_tty.c
+ * ACM class application.
+ *
+ ***********************************************************************/
+#include <stdlib.h>
+#include <malloc.h>
+//#include <memalign.h>
+#include <crc.h>
+#include <watchdog.h>
+#include "include/debug.h"
+#include "include/cvi_usb.h"
+#include <mmio.h>
+#include <asm/io.h>
+#include "include/platform_def.h"
+#include "include/usb_tty.h"
+#include "include/system_common.h"
+#include "include/cvi_ch9.h"
+#include "include/cvi_drv_if.h"
+#include "include/cvi_udc_otg_regs.h"
+#include "include/cvi_udc_otg_priv.h"
+#include "include/cvi_udc.h"
+#include "include/cvi_errno.h"
+#include "include/cvi_private.h"
+#include "cvi_reboot.h"
+#include "cvi_efuse.h"
+#include <common.h>
+#include <command.h>
+#include <linux/delay.h>
+#include "cvi_update.h"
+#include "include/dps.h"
+
+#ifdef BUILD_ATF
+extern uint16_t cvi_usb_vid;
+#else
+uint16_t cvi_usb_vid = 0x3346;
+#endif
+
+uint16_t cvi_usb_pid;
+
+static void bulkOutCmplMain(struct usb_ep *ep, struct usb_request *req);
+static void sramOutReqS2D(uint64_t addr, uint32_t size);
+
+#define GLOBAL_MEM_START_ADDR 0x80000000
+#define USB_PHY_DETECTION
+
+/* cvi USB driver object */
+static struct cvi_drv_obj drv_obj = {
+	.plat = {
+		.regs_otg = USB_BASE, // address where USB core is mapped
+		.usb_gusbcfg    = 0x40081408,
+		.rx_fifo_sz     = 512,
+		.np_tx_fifo_sz  = 512,
+		.tx_fifo_sz     = 512,
+	},
+};
+
+/* variable declare */
+static uint8_t *bulkBuf, *cmdBuf, *ep0Buff;
+static struct usb_ep *epIn, *epOut, *epInNotify;
+static struct usb_request *bulkInReq, *bulkOutReq, *ep0Req, *IntInReq;
+static uint8_t configValue;
+static uint8_t configBreak;
+static uint8_t acm_configValue;
+static uint8_t current_speed = CH9_USB_SPEED_UNKNOWN;
+static uint8_t mem_alloc_cnt;
+static uint32_t transfer_size;
+static uint8_t flagEnterDL;
+struct f_acm *acm;
+
+static uint8_t *bulkBufAlloc;
+static uint8_t *cmdBufAlloc;
+static uint8_t *cb0_buf;
+static uint8_t *cb1_buf;
+static uint8_t *cb2_buf;
+static uint8_t *ep0BuffAlloc;
+static uint8_t *rsp_buf;
+static uint8_t *acm_buf;
+static uint8_t *setup_buf;
+static uint8_t *handler;
+
+/* string will be filled then in initializing section */
+static char vendorDesc[sizeof(USB_MANUFACTURER_STRING) * 2 + 2];
+static char productDesc[sizeof(USB_PRODUCT_STRING) * 2 + 2];
+static char serialDesc[sizeof(USB_SERIAL_NUMBER_STRING) * 2 + 2];
+
+typedef void func(void);
+
+static void init_param(void)
+{
+	bulkBuf = NULL;
+	cmdBuf = NULL;
+	ep0Buff = NULL;
+	epIn = NULL;
+	epOut = NULL;
+	epInNotify = NULL;
+	bulkInReq = NULL;
+	bulkOutReq = NULL;
+	ep0Req = NULL;
+	IntInReq = NULL;
+	configValue = 0;
+	configBreak = 0;
+	acm_configValue = 0;
+	current_speed = CH9_USB_SPEED_UNKNOWN;
+	mem_alloc_cnt = 0;
+	transfer_size = 0;
+	acm = NULL;
+}
+
+struct usb_msg_header {
+	uint8_t token;
+	uint8_t len_hi;
+	uint8_t len_low;
+	uint8_t addr4;
+	uint8_t addr3;
+	uint8_t addr2;
+	uint8_t addr1;
+	uint8_t addr0;
+} __packed;
+
+struct usb_msg {
+	struct usb_msg_header header;
+} __packed;
+
+struct usb_msg_s2d {
+	struct usb_msg_header header;
+	size_t size;
+} __packed;
+
+struct usb_msg_d2s {
+	struct usb_msg_header header;
+	size_t size;
+} __packed;
+
+struct usb_rsp {
+	uint8_t no_use0;
+	uint8_t no_use1;
+	uint8_t crc16_hi;
+	uint8_t crc16_low;
+	uint8_t no_use3;
+	uint8_t no_use4;
+	uint8_t token;
+	uint8_t ack_index;
+	uint8_t reserved[RSP_SIZE - 8];
+} __packed;
+
+struct sram_info {
+	uint64_t sram_dest;
+	uint32_t total_len;
+	uint8_t reserved[4];
+} packed;
+
+static struct sram_info sram_info;
+
+static char *_allow_cmds[] = { "setenv", "saveenv", "efusew", "efuser" };
+
+#if USB_RW_EFUSE // Mark_to_do
+enum CVI_EFUSE_LOCK_WRITE_E {
+	CVI_EFUSE_LOCK_WRITE_HASH0_PUBLIC = CVI_EFUSE_OTHERS + 1,
+	CVI_EFUSE_LOCK_WRITE_LOADER_EK,
+	CVI_EFUSE_LOCK_WRITE_DEVICE_EK,
+	CVI_EFUSE_LOCK_WRITE_LAST
+};
+
+static char *_allow_areas[] = { "USER",	     "DEVICE_ID", "HASH0_PUBLIC",
+				"LOADER_EK", "DEVICE_EK", "AREA_LAST" };
+static char *_allow_wl_areas[] = { "LOCK_HASH0_PUBLIC",
+				   "LOCK_LOADER_EK",
+				   "LOCK_DEVICE_EK",
+				   "LOCK_LAST",
+				   "SECUREBOOT",
+				   "OTHERS",
+				   "LOCK_WRITE_HASH0_PUBLIC",
+				   "LOCK_WRITE_LOADER_EK",
+				   "LOCK_WRITE_DEVICE_EK" };
+#endif // USB_RW_EFUSE
+
+void print_buf_addr(void)
+{
+	INFO("bulkBufAlloc: %p\n", bulkBufAlloc);
+	INFO("cmdBufAlloc: %p\n", cmdBufAlloc);
+	INFO("ep0BuffAlloc: %p\n", ep0BuffAlloc);
+	INFO("setup_buf: %p\n", setup_buf);
+	INFO("handler: %p\n", handler);
+	INFO("cb0_buf: %p\n", cb0_buf);
+	INFO("cb1_buf: %p\n", cb1_buf);
+	INFO("cb2_buf: %p\n", cb2_buf);
+	INFO("rsp_buf: %p\n", rsp_buf);
+	INFO("acm_buf: %p\n", acm_buf);
+}
+
+void __attribute__((optimize("O0"))) set_config_break(uint8_t value)
+{
+	configBreak = value;
+}
+
+uint8_t __attribute__((optimize("O0"))) get_config_break(void)
+{
+	return configBreak;
+}
+
+void __attribute__((optimize("O0"))) set_acm_config(uint8_t value)
+{
+	acm_configValue = value;
+}
+
+uint8_t __attribute__((optimize("O0"))) get_acm_config(void)
+{
+	return acm_configValue;
+}
+
+static int acm_mem_init(void)
+{
+	bulkBufAlloc = memalign(CONFIG_SYS_CACHELINE_SIZE, ALIGN_CACHE_SIZE(BUF_SIZE));
+	memset(bulkBufAlloc, 0, ALIGN_CACHE_SIZE(BUF_SIZE));
+	cmdBufAlloc = memalign(CONFIG_SYS_CACHELINE_SIZE, ALIGN_CACHE_SIZE(BUF_SIZE));
+	memset(cmdBufAlloc, 0, ALIGN_CACHE_SIZE(BUF_SIZE));
+	ep0BuffAlloc = memalign(CONFIG_SYS_CACHELINE_SIZE, ALIGN_CACHE_SIZE(EP0_SIZE));
+	memset(ep0BuffAlloc, 0, ALIGN_CACHE_SIZE(EP0_SIZE));
+	setup_buf = memalign(CONFIG_SYS_CACHELINE_SIZE, ALIGN_CACHE_SIZE(STP_SIZE));
+	memset(setup_buf, 0, ALIGN_CACHE_SIZE(STP_SIZE));
+	handler = memalign(CONFIG_SYS_CACHELINE_SIZE, ALIGN_CACHE_SIZE(HANDLER_SIZE));
+	memset(handler, 0, ALIGN_CACHE_SIZE(HANDLER_SIZE));
+	cb0_buf = malloc(CB_SIZE);
+	memset(cb0_buf, 0, CB_SIZE);
+	cb1_buf = malloc(CB_SIZE);
+	memset(cb1_buf, 0, CB_SIZE);
+	cb2_buf = malloc(CB_SIZE);
+	memset(cb2_buf, 0, CB_SIZE);;
+	rsp_buf = malloc(RSP_SIZE);
+	memset(rsp_buf, 0, RSP_SIZE);
+	acm_buf = malloc(ACM_SIZE);
+	memset(acm_buf, 0, ACM_SIZE);
+
+	set_config_break(0);
+	set_acm_config(0);
+	current_speed = CH9_USB_SPEED_UNKNOWN;
+	mem_alloc_cnt = 0;
+	transfer_size = 0;
+	flagEnterDL = 0;
+	return 0;
+}
+
+static void acm_mem_release(void)
+{
+	free(bulkBufAlloc);
+	free(cmdBufAlloc);
+	free(ep0BuffAlloc);
+	free(setup_buf);
+	free(handler);
+	free(cb0_buf);
+	free(cb1_buf);
+	free(cb2_buf);
+	free(rsp_buf);
+	free(acm_buf);
+}
+
+/* interrupt handler */
+void AcmIsr(void)
+{
+	cviusb_gadget_handle_interrupts(0);
+}
+
+static int getDescAcm(CH9_UsbSpeed speed, uint8_t *acmDesc)
+{
+	int i = 0;
+	void *desc;
+	int sum = 0;
+	void *(*tab)[];
+
+	switch (speed) {
+	case CH9_USB_SPEED_FULL:
+		tab = &descriptorsFs;
+		break;
+	case CH9_USB_SPEED_HIGH:
+		tab = &descriptorsHs;
+		break;
+
+	default:
+		return -1;
+	}
+
+	desc = (*tab)[i];
+
+	while (desc) {
+		int length = *(uint8_t *)desc;
+
+		VERBOSE("acm get length %d\n", length);
+		memcpy(&acmDesc[sum], desc, length);
+		sum += length;
+		desc = (*tab)[++i];
+	}
+	/* VERBOSE("acm get sum:%d\n", sum); */
+	return sum;
+}
+
+static void clearReq(struct usb_request *req)
+{
+	memset(req, 0, sizeof(*req));
+}
+
+static void reset(struct usb_gadget *gadget)
+{
+	/* struct CUSBD_Dev *dev; */
+
+	INFO("Application: %s\n", __func__);
+}
+
+static void disconnect(struct usb_gadget *gadget)
+{
+	set_acm_config(0);
+	mem_alloc_cnt = 1;
+	configValue = 0;
+	NOTICE("Application: %s\n", __func__);
+}
+
+static void resume(struct usb_gadget *gadget)
+{
+	VERBOSE("Application: %s\n", __func__);
+}
+
+static void reqComplete(struct usb_ep *ep, struct usb_request *req)
+{
+	VERBOSE("Request on endpoint completed\n");
+	if (req->status == -EIO) {
+		NOTICE("IO Abort !!!!!\n");
+	}
+}
+
+static void suspend(struct usb_gadget *gadget)
+{
+	VERBOSE("Application: %s %c\n", __func, ' ');
+}
+
+static void *requestMemAlloc(struct usb_gadget *gadget, uint32_t requireSize)
+{
+	void *ptr;
+	/* VERBOSE("requestMemAlloc: size %d\n", requireSize); */
+	if (mem_alloc_cnt == 0)
+		ptr = cb0_buf;
+	else if (mem_alloc_cnt == 1)
+		ptr = cb1_buf;
+	else
+		ptr = cb2_buf;
+	VERBOSE("%s: ptr %p, size %d, mem_alloc_cnt %d\n", __func__, ptr,
+		requireSize, mem_alloc_cnt);
+	mem_alloc_cnt++;
+	return ptr;
+}
+
+static void requestMemFree(struct usb_gadget *gadget, void *usbRequest)
+{
+}
+
+static void resetOutReq(void)
+{
+	VERBOSE("epOut->ops->queue\n");
+	bulkOutReq->length = transfer_size;
+	bulkOutReq->buf = cmdBuf;
+	bulkOutReq->dma = (uintptr_t)cmdBuf;
+	bulkOutReq->complete = bulkOutCmplMain;
+	cvi_cache_flush(bulkOutReq->dma, bulkOutReq->length);
+	epOut->ops->queue(epOut, bulkOutReq);
+}
+
+static void bulkResetOutReq(struct usb_ep *ep, struct usb_request *req)
+{
+	/* INFO("bulkReset%sReq complete\n", (ep->address == BULK_EP_IN)?"In":"Out"); */
+	resetOutReq();
+}
+
+static void sendInReq(uint32_t length, uint8_t token, cvi_reqComplete complete,
+		      uint8_t *pRsp, uint8_t rspLen)
+{
+	uint16_t crc;
+	static uint8_t ack_idx;
+	struct usb_rsp *rsp = (struct usb_rsp *)rsp_buf;
+
+	memset(rsp_buf, 0, RSP_SIZE);
+	if (pRsp && rspLen > 0 && rspLen <= (RSP_SIZE - 8))
+		memcpy(rsp_buf + 8, pRsp, rspLen);
+	crc = crc16_ccitt(0, cmdBuf, length);
+	VERBOSE("CRC: %x\n", crc);
+	rsp->crc16_hi = (crc >> 8) & 0xFF;
+	rsp->crc16_low = crc & 0xFF;
+	rsp->ack_index = ack_idx;
+	rsp->token = token;
+	ack_idx++;
+	clearReq(bulkInReq);
+	if (rspLen > 8)
+		bulkInReq->length = RSP_SIZE;
+	else
+		bulkInReq->length = 16;
+	bulkInReq->buf = rsp_buf;
+	bulkInReq->dma = (uintptr_t)rsp_buf;
+	bulkInReq->complete = complete;
+	VERBOSE("epIn->ops->queue\n");
+
+	cvi_cache_flush(bulkInReq->dma, bulkInReq->length);
+	epIn->ops->queue(epIn, bulkInReq);
+}
+
+static void bulkCmplEmpty(struct usb_ep *ep, struct usb_request *req)
+{
+	VERBOSE("%s\n", __func__);
+}
+
+static void resetOutReqS2D(uint64_t addr, size_t size, cvi_reqComplete complete)
+{
+	/* INFO("epOut->ops->queue S2D, addr:0x%lx, size:0x%lx\n", addr, size); */
+	bulkOutReq->length = size;
+	bulkOutReq->buf = (uint8_t *)addr;
+	bulkOutReq->dma = (uintptr_t)addr;
+	bulkOutReq->complete = complete;
+
+	cvi_cache_flush(bulkOutReq->dma, bulkOutReq->length);
+	epOut->ops->queue(epOut, bulkOutReq);
+}
+
+static void sramCompl(struct usb_ep *ep, struct usb_request *req)
+{
+	uint32_t left = sram_info.total_len -= req->length;
+	uint64_t target = sram_info.sram_dest + req->length;
+	/* INFO("sram copy data to 0x%lx, len = 0x%x\n", sram_info.sram_dest, req->length); */
+	memcpy((void *)sram_info.sram_dest, (void *)req->buf, req->length);
+
+	if (left == 0U)
+		resetOutReq();
+	else
+		sramOutReqS2D(target, left);
+}
+
+static void sramOutReqS2D(uint64_t addr, uint32_t size)
+{
+	sram_info.total_len = size;
+	sram_info.sram_dest = addr;
+
+	bulkOutReq->length = (sram_info.total_len > BUF_SIZE) ?
+				     BUF_SIZE :
+					   sram_info.total_len;
+	bulkOutReq->buf = bulkBuf;
+	bulkOutReq->dma = (uintptr_t)bulkBuf;
+	bulkOutReq->complete = sramCompl;
+
+	cvi_cache_flush(bulkOutReq->dma, bulkOutReq->length);
+	epOut->ops->queue(epOut, bulkOutReq);
+}
+
+static void sendInReqD2S(uint64_t addr, size_t size, cvi_reqComplete complete)
+{
+	/* INFO("epIn->ops->queue D2S\n"); */
+	clearReq(bulkInReq);
+	bulkInReq->length = size;
+	bulkInReq->buf = (uint8_t *)addr;
+	bulkInReq->dma = (uintptr_t)addr;
+	bulkInReq->complete = complete;
+
+	cvi_cache_flush(bulkInReq->dma, bulkInReq->length);
+	epIn->ops->queue(epIn, bulkInReq);
+}
+
+#if USB_RW_EFUSE // Mark_to_do
+static int ahex2int(char a, char b)
+{
+	a = (a <= '9') ? a - '0' : (a & 0x7) + 9;
+	b = (b <= '9') ? b - '0' : (b & 0x7) + 9;
+
+	return (a << 4) + b;
+}
+
+static void efusew_cmd(uint32_t length, uint8_t *ack_result, uint8_t ack_len)
+{
+	uint8_t read_buf[128];
+	uint32_t i;
+
+	if (strncmp((void *)((uintptr_t)cmdBuf + (uintptr_t)HEADER_SIZE),
+		    "efusew ", strlen("efusew ")) == 0) {
+		char cmd[128] = { '\0' };
+		uint8_t area_idx = 0;
+		uint8_t area_size = 0;
+		uint8_t data_offset = 0;
+		uint8_t efuse_locked = 0;
+#ifdef CONFIG_HW_WATCHDOG
+		hw_watchdog_disable();
+#endif
+		strlcpy(cmd,
+			(void *)((uintptr_t)cmdBuf + (uintptr_t)HEADER_SIZE),
+			min((uint32_t)(length - HEADER_SIZE),
+			    (uint32_t)sizeof(cmd)));
+		NOTICE("run command: %s\n", cmd);
+		run_command(cmd, 0);
+
+		memset(ack_result, ACK_FAIL, ack_len);
+
+		// Check param for lock efuse area
+		for (area_idx = 0; area_idx < ARRAY_SIZE(_allow_wl_areas);
+		     area_idx++) {
+			if (strncmp((void *)((uintptr_t)cmdBuf +
+					     (uintptr_t)HEADER_SIZE +
+					     strlen("efusew ")),
+				    _allow_wl_areas[area_idx],
+				    strlen(_allow_wl_areas[area_idx])) == 0) {
+				area_idx += CVI_EFUSE_AREA_LAST + 1;
+
+				NOTICE("area_idx = %d\n", area_idx);
+				if (area_idx >=
+				    CVI_EFUSE_LOCK_WRITE_HASH0_PUBLIC) {
+					efuse_locked = CVI_EFUSE_IsWriteLocked(
+						area_idx);
+					NOTICE("CVI_EFUSE_IsWriteLocked %d\n",
+					       efuse_locked);
+				} else {
+					efuse_locked =
+						CVI_EFUSE_IsLocked(area_idx);
+					NOTICE("CVI_EFUSE_IsLocked %d\n",
+					       efuse_locked);
+				}
+
+				if (efuse_locked > 0)
+					ack_result[0] = ACK_PASS;
+				break;
+			}
+		}
+
+		// Read efuse data from corresponding area
+		for (area_idx = 0; area_idx < ARRAY_SIZE(_allow_areas);
+		     area_idx++) {
+			if (strncmp((void *)((uintptr_t)cmdBuf +
+					     (uintptr_t)HEADER_SIZE +
+					     strlen("efusew ")),
+				    _allow_areas[area_idx],
+				    strlen(_allow_areas[area_idx])) == 0) {
+				NOTICE("area_idx = %d\n", area_idx);
+				switch (area_idx) {
+				case CVI_EFUSE_AREA_USER:
+					area_size = 40;
+					break;
+				case CVI_EFUSE_AREA_DEVICE_ID:
+					area_size = 8;
+					break;
+				case CVI_EFUSE_AREA_HASH0_PUBLIC:
+					area_size = 32;
+					break;
+				case CVI_EFUSE_AREA_LOADER_EK:
+					area_size = 16;
+					break;
+				case CVI_EFUSE_AREA_DEVICE_EK:
+					area_size = 16;
+					break;
+				default:
+					NOTICE("efuse area %d\n", area_idx);
+					break;
+				}
+
+				memset(read_buf, 0, sizeof(read_buf));
+				memset(ack_result, ACK_FAIL, ack_len);
+				ack_result[0] = ACK_PASS;
+
+				CVI_EFUSE_Read(area_idx, read_buf, area_size);
+				for (i = 0; i < area_size; i++)
+					INFO("efuse_data[%d] = %x\n", i,
+					     read_buf[i]);
+				for (i = 0; i < length; i++)
+					INFO("cmdBuf[%d] = %x\n", i, cmdBuf[i]);
+
+				// Verify results
+				data_offset = HEADER_SIZE + strlen("efusew ") +
+					      strlen(_allow_areas[area_idx]) +
+					      1;
+				INFO("data_offset %x\n", data_offset);
+				for (i = 0; i < (length - data_offset) / 2;
+				     i++) {
+					uint8_t data;
+
+					data = ahex2int(
+						cmdBuf[data_offset + i * 2],
+						cmdBuf[data_offset + i * 2 + 1]);
+					INFO("data = %x; read_buf = %x\n", data,
+					     read_buf[i]);
+					if (data != read_buf[i]) {
+						NOTICE("ERROR err_byte_idx = %x\n",
+						       i);
+						NOTICE("ERROR write_byte = %x\n",
+						       data);
+						NOTICE("ERROR efuse_byte = %x\n",
+						       read_buf[i]);
+						ack_result[0] = ACK_FAIL;
+						ack_result[1] = i;
+						ack_result[2] = data;
+						ack_result[3] = read_buf[i];
+						break;
+					}
+				}
+				break;
+			}
+		}
+	}
+}
+
+static void efuser_cmd(uint32_t length, uint8_t *read_buf, uint8_t buf_len)
+{
+	uint8_t i;
+
+	if (strncmp((void *)((uintptr_t)cmdBuf + (uintptr_t)HEADER_SIZE),
+		    "efuser ", strlen("efuser ")) == 0) {
+		char cmd[128] = { '\0' };
+		uint8_t area_idx = 0;
+		uint8_t area_size = 0;
+#ifdef CONFIG_HW_WATCHDOG
+		hw_watchdog_disable();
+#endif
+		strlcpy(cmd,
+			(void *)((uintptr_t)cmdBuf + (uintptr_t)HEADER_SIZE),
+			min((uint32_t)(length - HEADER_SIZE),
+			    (uint32_t)sizeof(cmd)));
+		NOTICE("run command: %s\n", cmd);
+		run_command(cmd, 0);
+
+		// Read efuse data from corresponding area
+		for (area_idx = 0; area_idx < ARRAY_SIZE(_allow_areas);
+		     area_idx++) {
+			if (strncmp((void *)((uintptr_t)cmdBuf +
+					     (uintptr_t)HEADER_SIZE +
+					     strlen("efuser ")),
+				    _allow_areas[area_idx],
+				    strlen(_allow_areas[area_idx])) == 0) {
+				NOTICE("area_idx = %d\n", area_idx);
+				switch (area_idx) {
+				case CVI_EFUSE_AREA_USER:
+					area_size = 40;
+					break;
+				case CVI_EFUSE_AREA_DEVICE_ID:
+					area_size = 8;
+					break;
+				case CVI_EFUSE_AREA_HASH0_PUBLIC:
+					area_size = 32;
+					break;
+				case CVI_EFUSE_AREA_LOADER_EK:
+					area_size = 16;
+					break;
+				case CVI_EFUSE_AREA_DEVICE_EK:
+					area_size = 16;
+					break;
+				default:
+					NOTICE("efuse area %d\n", area_idx);
+					break;
+				}
+
+				memset(read_buf, 0, buf_len);
+				CVI_EFUSE_Read(area_idx, read_buf, area_size);
+				for (i = 0; i < area_size; i++)
+					INFO("efuse_data[%d] = %x\n", i,
+					     read_buf[i]);
+				break;
+			}
+		}
+
+		for (area_idx = 0; area_idx < ARRAY_SIZE(_allow_wl_areas);
+		     area_idx++) {
+			if (strncmp((void *)((uintptr_t)cmdBuf +
+					     (uintptr_t)HEADER_SIZE +
+					     strlen("efuser ")),
+				    _allow_wl_areas[area_idx],
+				    strlen(_allow_wl_areas[area_idx])) == 0) {
+				area_idx += CVI_EFUSE_AREA_LAST + 1;
+				NOTICE("area_idx = %d\n", area_idx);
+
+				memset(read_buf, 0, buf_len);
+				if (area_idx >=
+				    CVI_EFUSE_LOCK_WRITE_HASH0_PUBLIC) {
+					read_buf[0] = CVI_EFUSE_IsWriteLocked(
+						area_idx);
+					NOTICE("CVI_EFUSE_IsWriteLocked %d\n",
+					       read_buf[0]);
+				} else {
+					read_buf[0] =
+						CVI_EFUSE_IsLocked(area_idx);
+					NOTICE("CVI_EFUSE_IsLocked %d\n",
+					       read_buf[0]);
+				}
+				break;
+			}
+		}
+	}
+}
+#endif // USB_RW_EFUSE
+
+static void bulkOutCmplMain(struct usb_ep *ep, struct usb_request *req)
+{
+	struct usb_gadget *gadget = drv_obj.gadget;
+	uint64_t dest_addr = 0x0;
+	uint32_t i = 0;
+	uint16_t crc = 0;
+	struct usb_msg *msg = (struct usb_msg *)req->buf;
+	struct usb_msg_s2d *msg_s2d = (struct usb_msg_s2d *)req->buf;
+	struct usb_msg_d2s *msg_d2s = (struct usb_msg_d2s *)req->buf;
+	uint32_t length =
+		((uint32_t)msg->header.len_hi << 8) | msg->header.len_low;
+	func *jump_fun;
+#if USB_RW_EFUSE // Mark_to_do
+	uint8_t read_buf[128];
+	uint8_t ack_result[16];
+	uint32_t sn_hi, sn_lo;
+#endif // USB_RW_EFUSE
+#ifdef CONFIG_NAND_SUPPORT
+	char cmd[255] = { '\0' };
+	static char prevExtra[EXTRA_FLAG_SIZE + 1] = { '\0' };
+#endif
+
+	if (req->status == -ESHUTDOWN)
+		return;
+
+	dest_addr = ((uint64_t)(msg->header.addr4) << 32) |
+		    ((uint64_t)(msg->header.addr3) << 24) |
+		    ((uint64_t)(msg->header.addr2) << 16) |
+		    ((uint64_t)(msg->header.addr1) << 8) |
+		    ((uint64_t)(msg->header.addr0));
+
+	if (length == 0 && dest_addr == 0) {
+		VERBOSE("buffer zero\n");
+		resetOutReq();
+		return;
+	}
+	/* dest_addr += GLOBAL_MEM_START_ADDR; */
+	switch (msg->header.token) {
+	case CVI_USB_INFO:
+		/* INFO("CVI_USB_INFO\n"); */
+		sendInReq(length, CVI_USB_INFO, bulkResetOutReq, NULL, 0);
+		return;
+	case CVI_USB_S2D:
+		/* INFO("CVI_USB_S2D, addr = 0x%lx, len = 0x%lx\n",dest_addr, msg_s2d->size); */
+		sendInReq(length, CVI_USB_S2D, bulkCmplEmpty, NULL, 0);
+		if (dest_addr >= GLOBAL_MEM_START_ADDR)
+			resetOutReqS2D(dest_addr, msg_s2d->size,
+				       bulkResetOutReq);
+		else
+			sramOutReqS2D(dest_addr, msg_s2d->size);
+		return;
+	case CVI_USB_D2S:
+		{
+			/* INFO("CVI_USB_D2S\n"); */
+
+			if (dest_addr)
+				sendInReqD2S(dest_addr, msg_d2s->size, bulkResetOutReq);
+			else
+			{
+				unsigned char sendbuf[8];
+
+				uint64_t image_addr = CVIMMAP_ION_ADDR;
+				for (int i=0; i<sizeof(sendbuf); i++)
+				{
+					sendbuf[i] = (image_addr & 0xff);
+					image_addr >>= 8;
+				}
+
+				sendInReqD2S((uint64_t)sendbuf, sizeof(sendbuf), bulkResetOutReq);
+			}
+
+			return;
+		}
+	case CVI_USB_NONE:
+		// INFO("CVI_USB_NONE, addr = 0x%llx, len = 0x%x\n", dest_addr, length);
+		memcpy((void *)dest_addr, cmdBuf + HEADER_SIZE,
+		       length - HEADER_SIZE);
+#ifdef CONFIG_HW_WATCHDOG
+		WATCHDOG_RESET();
+#endif
+		sendInReq(length, CVI_USB_NONE, bulkResetOutReq, NULL, 0);
+		return;
+	case CVI_USB_JUMP:
+		jump_fun = (func *)dest_addr;
+		NOTICE("CVI_USB_JUMP to %llx\n", dest_addr);
+		if (gadget && gadget->ops && gadget->ops->pullup)
+			gadget->ops->pullup(gadget, 0);
+		NOTICE("stop USB port\n");
+		jump_fun();
+		NOTICE("CVI_USB_JUMP back\n");
+		resetOutReq();
+		break;
+	case CVI_USB_PROGRAM:
+#ifdef CONFIG_NAND_SUPPORT
+		// Erase partition first
+		if (strncmp((char *)((uintptr_t)HEADER_ADDR + 20), prevExtra,
+			    EXTRA_FLAG_SIZE)) {
+			strlcpy(prevExtra,
+				(char *)((uintptr_t)HEADER_ADDR + 20),
+				EXTRA_FLAG_SIZE);
+			snprintf(cmd, 255, "nand erase.part -y %s", prevExtra);
+			pr_debug("%s\n", cmd);
+			run_command(cmd, 0);
+		}
+#endif
+		/* INFO("CVI_USB_PROGRAM\n"); */
+		_prgImage((void *)UPDATE_ADDR, 0x40, NULL);
+		sendInReq(length, CVI_USB_PROGRAM, bulkResetOutReq, NULL, 0);
+		NOTICE("CVI_USB_PROGRAM done\n");
+		return;
+	case CVI_USB_RESET_ARM:
+		NOTICE("CVI_USB_RESET_ARM\n");
+		break;
+	case CVI_USB_BREAK:
+		INFO("CVI_USB_BREAK\n");
+		set_config_break(1);
+		break;
+	case CVI_USB_KEEP_DL:
+		NOTICE("CVI_USB_KEEP_DL\n");
+		crc = crc16_ccitt(0, cmdBuf, length);
+		if (crc == 0xB353) {
+			flagEnterDL = 1;
+			NOTICE("flagEnterDL %d\n", flagEnterDL);
+		} else {
+			flagEnterDL = 0;
+			NOTICE("MAGIC NUM NOT MATCH\n");
+			NOTICE("flagEnterDL %d\n", flagEnterDL);
+		}
+		break;
+	case CVI_USB_PRG_CMD:
+		NOTICE("CVI_USB_PRG_CMD\n");
+		for (i = 0; i < ARRAY_SIZE(_allow_cmds); i++) {
+			if (strncmp((void *)((uintptr_t)cmdBuf +
+						  (uintptr_t)HEADER_SIZE),
+					 _allow_cmds[i],
+					 strlen(_allow_cmds[i])) == 0) {
+				char cmd[255] = { '\0' };
+
+				strncpy(cmd,
+					(void *)((uintptr_t)cmdBuf +
+						 (uintptr_t)HEADER_SIZE),
+					min(length - HEADER_SIZE,
+					    (uint32_t)254));
+				NOTICE("run command: %s\n", cmd);
+				run_command(cmd, 0);
+				break;
+			}
+		}
+		sendInReq(length, CVI_USB_PRG_CMD, bulkResetOutReq, NULL, 0);
+		break;
+
+#if USB_RW_EFUSE // Mark_to_do
+	case CVI_USB_EFUSEW:
+		NOTICE("CVI_USB_EFUSEW_CMD\n");
+		efusew_cmd(length, ack_result, sizeof(ack_result));
+		sendInReq(length, CVI_USB_EFUSEW, bulkResetOutReq, ack_result,
+			  sizeof(ack_result));
+		break;
+
+	case CVI_USB_EFUSER:
+		NOTICE("CVI_USB_EFUSER\n");
+		efuser_cmd(length, read_buf, sizeof(read_buf));
+		sendInReq(length, CVI_USB_EFUSER, bulkResetOutReq, read_buf,
+			  40);
+		break;
+
+	case CVI_USB_READ_SN:
+		NOTICE("CVI_USB_READ_SN\n");
+#ifdef CONFIG_HW_WATCHDOG
+		hw_watchdog_disable();
+#endif
+		sn_hi = readl(GP_REG4);
+		sn_lo = readl(GP_REG5);
+		ack_result[0] = (sn_hi >> 24) & 0xFF;
+		ack_result[1] = (sn_hi >> 16) & 0xFF;
+		ack_result[2] = (sn_hi >> 8) & 0xFF;
+		ack_result[3] = (sn_hi >> 0) & 0xFF;
+		ack_result[4] = (sn_lo >> 24) & 0xFF;
+		ack_result[5] = (sn_lo >> 16) & 0xFF;
+		ack_result[6] = (sn_lo >> 8) & 0xFF;
+		ack_result[7] = (sn_lo >> 0) & 0xFF;
+		NOTICE("0x%x%x\n", sn_hi, sn_lo);
+		sendInReq(length, CVI_USB_READ_SN, bulkResetOutReq, ack_result,
+			  sizeof(ack_result));
+		break;
+#endif // USB_RW_EFUSE
+	case CVI_USB_REBOOT:
+		NOTICE("CVI_USB_REBOOT\n");
+		// software_root_reset(); // Mark_to_do
+		mmio_setbits_32(TOP_BASE + 0x8, 0x4); // wdt reset enable
+		mmio_write_32(WATCHDOG_BASE + 0x4,
+			      0x20); // Set timeout range reigster
+		mmio_write_32(WATCHDOG_BASE + 0xc,
+			      0x76); // Counter restart register
+		mmio_write_32(WATCHDOG_BASE,
+			      0x13); // Response mode and enable WDT
+		break;
+
+	default:
+		VERBOSE("token not defined:[%d]\n", msg->header.token);
+		resetOutReq();
+		break;
+	}
+}
+
+/* ACM control ... data handling is delegated to tty library code.
+ * The main task of this function is to activate and deactivate
+ * that code based on device state; track parameters like line
+ * speed, handshake state, and so on; and issue notifications.
+ */
+
+static void acm_complete_set_line_coding(struct usb_ep *ep,
+					 struct usb_request *req)
+{
+	struct usb_cdc_line_coding *value = req->buf;
+
+	acm->port_line_coding = *value;
+	VERBOSE("acm data transfer complete\n");
+}
+
+static void print_ep0_buf(uint32_t length)
+{
+	int i;
+
+	for (i = 0; i < length; i++)
+		VERBOSE("%02X ", ep0Buff[i]);
+	VERBOSE(" %c\n", ' ');
+}
+
+static int bind(struct usb_gadget *gadget)
+{
+	NOTICE("%s()\n", __func__);
+	if (drv_obj.gadget) {
+		NOTICE("gadget already %s\n", __func__);
+		return 0;
+	}
+	drv_obj.gadget = gadget;
+
+	return 0;
+}
+
+static void unbind(struct usb_gadget *gadget)
+{
+	NOTICE("%s()\n", __func__);
+	drv_obj.gadget = NULL;
+}
+
+static int setup(struct usb_gadget *gadget, const CH9_UsbSetup *ctrl)
+{
+	/* get device reference */
+	int length = 0;
+	uint16_t status_value[2];
+	struct CH9_UsbDeviceDescriptor *devDesc;
+	CH9_UsbEndpointDescriptor *endpointEpInDesc, *endpointEpOutDesc,
+		*endpointEpInDesc2;
+	CH9_UsbSetup TmpCtrl;
+
+	*(status_value + 0) = 0;
+	*(status_value + 1) = 0;
+
+	TmpCtrl.bRequest = ctrl->bRequest;
+	TmpCtrl.bmRequestType = ctrl->bmRequestType;
+	TmpCtrl.wIndex = le16ToCpu(ctrl->wIndex);
+	TmpCtrl.wLength = le16ToCpu(ctrl->wLength);
+	TmpCtrl.wValue = le16ToCpu(ctrl->wValue);
+
+	VERBOSE("Speed: %d\n", gadget->speed);
+	VERBOSE("bRequest: %02X\n", TmpCtrl.bRequest);
+	VERBOSE("bRequestType: %02X\n", TmpCtrl.bmRequestType);
+	VERBOSE("wIndex: %04X\n", TmpCtrl.wIndex);
+	VERBOSE("wValue: %04X\n", TmpCtrl.wValue);
+	VERBOSE("wLength: %04X\n", TmpCtrl.wLength);
+
+	ep0Req->buf = ep0Buff;
+	ep0Req->dma = (uintptr_t)ep0Buff;
+	ep0Req->complete = reqComplete;
+
+	switch (gadget->speed) {
+	case CH9_USB_SPEED_FULL:
+		endpointEpInDesc = &acm_fs_in_desc;
+		endpointEpOutDesc = &acm_fs_out_desc;
+		endpointEpInDesc2 = &acm_fs_notify_desc;
+		devDesc = &devHsDesc;
+		break;
+
+	case CH9_USB_SPEED_HIGH:
+		endpointEpInDesc = &acm_hs_in_desc;
+		endpointEpOutDesc = &acm_hs_out_desc;
+		endpointEpInDesc2 = &acm_fs_notify_desc;
+		devDesc = &devHsDesc;
+		break;
+
+	default:
+		VERBOSE("Unknown speed: %d\n", gadget->speed);
+		return 1;
+	}
+
+	switch (ctrl->bmRequestType & CH9_USB_REQ_TYPE_MASK) {
+	case CH9_USB_REQ_TYPE_STANDARD:
+
+		switch (TmpCtrl.bRequest) {
+		case CH9_USB_REQ_GET_DESCRIPTOR:
+			VERBOSE("GET DESCRIPTOR %c\n", ' ');
+			if ((TmpCtrl.bmRequestType & CH9_REQ_RECIPIENT_MASK) ==
+			    CH9_USB_REQ_RECIPIENT_INTERFACE) {
+				switch (TmpCtrl.wValue >> 8) {
+				default:
+					return -1;
+				}
+			} else if ((TmpCtrl.bmRequestType &
+				    CH9_REQ_RECIPIENT_MASK) ==
+				   CH9_USB_REQ_RECIPIENT_DEVICE) {
+				switch (TmpCtrl.wValue >> 8) {
+				case CH9_USB_DT_DEVICE:
+					length = CH9_USB_DS_DEVICE;
+					if (cvi_usb_vid != 0) {
+						NOTICE("Patch VID %x\n",
+						       cvi_usb_vid);
+						devDesc->idVendor =
+							cpuToLe16(cvi_usb_vid);
+					}
+					if (cvi_usb_pid != 0) {
+						NOTICE("Patch PID %x\n",
+						       cvi_usb_pid);
+						devDesc->idProduct =
+							cpuToLe16(cvi_usb_pid);
+					}
+					memmove(ep0Buff, devDesc, 18);
+					VERBOSE("DevDesc[0] = %d\n",
+						devDesc->bLength);
+					print_ep0_buf(length);
+					break;
+
+				case CH9_USB_DT_CONFIGURATION: {
+					uint8_t *ptr =
+						&ep0Buff[CH9_USB_DS_CONFIGURATION];
+					uint16_t acmDescLen =
+						(uint16_t)getDescAcm(
+							gadget->speed, ptr);
+
+					length = le16ToCpu(
+						acmDescLen +
+						CH9_USB_DS_CONFIGURATION);
+					ConfDesc.wTotalLength =
+						cpuToLe16(length);
+					memmove(ep0Buff, &ConfDesc,
+						CH9_USB_DS_CONFIGURATION);
+					print_ep0_buf(length);
+					break;
+				}
+
+				case CH9_USB_DT_STRING: {
+					uint8_t descIndex =
+						(uint8_t)(TmpCtrl.wValue &
+							  0xFF);
+					char *strDesc;
+
+					VERBOSE("StringDesc %c\n", ' ');
+					switch (descIndex) {
+					case 0:
+						strDesc = (char *)&languageDesc;
+						length = strDesc[0];
+						VERBOSE("language %c\n", ' ');
+						break;
+
+					case 1:
+						strDesc = (char *)&vendorDesc;
+						length = strDesc[0];
+						VERBOSE("vendor %c\n", ' ');
+						break;
+
+					case 2:
+						strDesc = (char *)&productDesc;
+						length = strDesc[0];
+						VERBOSE("product %c\n", ' ');
+						break;
+
+					case 3:
+						strDesc = (char *)&serialDesc;
+						length = strDesc[0];
+						VERBOSE("serial %c\n", ' ');
+						break;
+
+					default:
+						return -1;
+					}
+					memmove(ep0Buff, strDesc, length);
+					break;
+				}
+
+				case CH9_USB_DT_BOS: {
+					int offset = 0;
+
+					length =
+						le16ToCpu(bosDesc.wTotalLength);
+
+					memmove(ep0Buff, &bosDesc,
+						CH9_USB_DS_BOS);
+					offset += CH9_USB_DS_BOS;
+					memmove(&ep0Buff[offset],
+						&capabilityExtDesc,
+						CH9_USB_DS_DEVICE_CAPABILITY_20);
+				}
+					print_ep0_buf(length);
+					VERBOSE("BosDesc %c\n", ' ');
+					break;
+
+				case CH9_USB_DT_DEVICE_QUALIFIER:
+					length = CH9_USB_DS_DEVICE_QUALIFIER;
+					memmove(ep0Buff, &qualifierDesc,
+						length);
+					break;
+
+				case CH9_USB_DT_OTHER_SPEED_CONFIGURATION: {
+					uint8_t *ptr =
+						&ep0Buff[CH9_USB_DS_CONFIGURATION];
+					uint16_t acmDescLen =
+						(uint16_t)getDescAcm(
+							gadget->speed, ptr);
+
+					length = le16ToCpu(
+						acmDescLen +
+						CH9_USB_DS_CONFIGURATION);
+					ConfDesc.wTotalLength =
+						cpuToLe16(length);
+					memmove(ep0Buff, &ConfDesc,
+						CH9_USB_DS_CONFIGURATION);
+					print_ep0_buf(length);
+					break;
+				}
+
+				default:
+					return -1;
+
+				} /* switch */
+			} /* if */
+			break;
+
+		case CH9_USB_REQ_SET_CONFIGURATION: {
+			struct usb_ep *ep;
+			struct list_head *list;
+
+			VERBOSE("SET CONFIGURATION(%d)\n",
+				le16ToCpu(TmpCtrl.wValue));
+			if (TmpCtrl.wValue > 1)
+				return -1; /* no such configuration */
+			/* unconfigure device */
+			if (TmpCtrl.wValue == 0) {
+				configValue = 0;
+				for (list = gadget->ep_list.next;
+				     list != &gadget->ep_list;
+				     list = list->next) {
+					ep = (struct usb_ep *)list;
+					if (ep->name)
+						ep->ops->disable(ep);
+				}
+				return 0;
+			}
+
+			/* device already configured */
+			if (configValue == 1 && TmpCtrl.wValue == 1)
+				return 0;
+
+			/* configure device */
+			configValue = (uint8_t)TmpCtrl.wValue;
+
+			for (list = gadget->ep_list.next;
+			     list != &gadget->ep_list; list = list->next) {
+				ep = (struct usb_ep *)list;
+				if (ep->name &&
+				    (!strcmp(ep->name, "ep1in-bulk"))) {
+					ep->ops->enable(ep, endpointEpInDesc);
+					VERBOSE("enable EP IN\n");
+					break;
+				}
+			}
+			for (list = gadget->ep_list.next;
+			     list != &gadget->ep_list; list = list->next) {
+				ep = (struct usb_ep *)list;
+				if ((ep->name &&
+				     !strcmp(ep->name, "ep2out-bulk"))) {
+					ep->ops->enable(ep, endpointEpOutDesc);
+					VERBOSE("enable EP OUT\n");
+					break;
+				}
+			}
+			for (list = gadget->ep_list.next;
+			     list != &gadget->ep_list; list = list->next) {
+				ep = (struct usb_ep *)list;
+				if ((ep->name &&
+				     !strcmp(ep->name, "ep3in-int"))) {
+					ep->ops->enable(ep, endpointEpInDesc2);
+					break;
+					VERBOSE("enable EP Notify\n");
+				}
+			}
+
+			/*Code control  Self powered feature of USB*/
+			if (ConfDesc.bmAttributes &
+			    CH9_USB_CONFIG_SELF_POWERED) {
+				if (gadget->ops->set_selfpowered) {
+					gadget->ops->set_selfpowered(gadget, 1);
+				}
+			} else {
+				if (gadget->ops->set_selfpowered) {
+					gadget->ops->set_selfpowered(gadget, 0);
+				}
+			}
+		}
+			return 0;
+
+		case CH9_USB_REQ_GET_CONFIGURATION:
+			length = 1;
+			memmove(ep0Buff, &configValue, length);
+			/* VERBOSE("CH9_USB_REQ_GET_CONFIGURATION %c\n", ' '); */
+			break;
+
+		default:
+			return -1;
+		}
+		break;
+
+	case CH9_USB_REQ_TYPE_CLASS: {
+		/* SET_LINE_CODING ... just read and save what the host sends */
+		switch (TmpCtrl.bRequest) {
+		case USB_CDC_REQ_SET_LINE_CODING:
+			length = TmpCtrl.wLength;
+			ep0Req->complete = acm_complete_set_line_coding;
+			VERBOSE("USB_CDC_REQ_SET_LINE_CODING %d\n", length);
+			set_acm_config(1);
+			break;
+		case USB_CDC_REQ_SET_CONTROL_LINE_STATE:
+			acm->port_handshake_bits = TmpCtrl.wValue;
+			set_acm_config(1);
+			VERBOSE("USB_CDC_REQ_SET_CONTROL_LINE_STATE %c\n", ' ');
+			break;
+		case USB_CDC_REQ_GET_LINE_CODING:
+			length = TmpCtrl.wLength;
+			memmove(ep0Buff, &acm->port_line_coding, length);
+			/* ep0Req->complete = acm_complete_get_line_coding; */
+			VERBOSE("USB_CDC_REQ_GET_LINE_CODING %d\n", length);
+			set_acm_config(1);
+			break;
+		}
+		break;
+	}
+	}
+
+	if (length > 0) {
+		ep0Req->length =
+			TmpCtrl.wLength < length ? TmpCtrl.wLength : length;
+
+		cvi_cache_flush(ep0Req->dma, ep0Req->length);
+		gadget->ep0->ops->queue(gadget->ep0, ep0Req);
+	}
+	return 0;
+}
+
+static void get_unicode_string(char *target, const char *src)
+{
+	size_t src_len = strlen(src) * 2;
+	int i;
+
+	*target++ = src_len + 2;
+	*target++ = CH9_USB_DT_STRING;
+
+	if (src_len > 100)
+		src_len = 100;
+	for (i = 0; i < src_len; i += 2) {
+		*target++ = *src++;
+		*target++ = 0;
+	}
+}
+
+static struct usb_gadget_driver g_driver = {
+	.function = "TTY",
+	.speed = CH9_USB_SPEED_HIGH,
+	.bind = bind,
+	.unbind = unbind,
+	.setup = setup,
+	.reset = reset,
+	.disconnect = disconnect,
+	.suspend = suspend,
+	.resume = resume,
+	.req_mem_alloc = requestMemAlloc,
+	.req_mem_free = requestMemFree,
+};
+
+int acm_app_init(void)
+{
+	struct usb_ep *ep0 = drv_obj.gadget->ep0;
+
+	/*  set unicode strings */
+	get_unicode_string(vendorDesc, USB_MANUFACTURER_STRING);
+	get_unicode_string(productDesc, USB_PRODUCT_STRING);
+	get_unicode_string(serialDesc, USB_SERIAL_NUMBER_STRING);
+
+	/*  align buffers to modulo8 address */
+	ep0Buff = ep0BuffAlloc;
+	bulkBuf = bulkBufAlloc;
+	cmdBuf = cmdBufAlloc;
+
+	memset(ep0BuffAlloc, 0x00, EP0_SIZE);
+	memset(bulkBufAlloc, 0x00, BUF_SIZE);
+	memset(cmdBufAlloc, 0x00, BUF_SIZE);
+
+	/* allocate request for ep0 */
+	ep0Req = ep0->ops->alloc_request(ep0);
+
+	/* Change descriptor for maxSpeed == HS only Device*/
+	/* For USB2.0 we have to modified wTotalLength of BOS descriptor*/
+	if (drv_obj.gadget->max_speed < CH9_USB_SPEED_SUPER) {
+		bosDesc.wTotalLength = cpuToLe16(
+			CH9_USB_DS_BOS + CH9_USB_DS_DEVICE_CAPABILITY_20);
+		bosDesc.bNumDeviceCaps = 1;
+		devHsDesc.bcdUSB = cpuToLe16(BCD_USB_HS_ONLY);
+	}
+
+	/* acm init */
+	acm = (struct f_acm *)acm_buf;
+	acm->port_line_coding.dwDTERate = 921600;
+	acm->port_line_coding.bCharFormat = USB_CDC_1_STOP_BITS;
+	acm->port_line_coding.bParityType = USB_CDC_NO_PARITY;
+	acm->port_line_coding.bDataBits = 8;
+	acm->port_handshake_bits = 0;
+	/* VERBOSE("acm size %X\n", sizeof(struct f_acm)); */
+	return 0;
+}
+
+#ifdef BUILD_ATF
+uint8_t usb_phy_det_connection(void)
+{
+	uint8_t phy_det_connected = 0;
+	uint32_t cvi_usb_phy_config = 0;
+
+	cvi_usb_phy_config = plat_cvi_gpio_read(BIT_MASK_GPIO_USB_PHY_DET_OFF);
+	if (cvi_usb_phy_config == 0) {
+		phy_det_connected = 1;
+		NOTICE("by pass USB phy detection\n");
+	} else {
+		mmio_clrbits_32(GPIO_BASE + 0x4, 1 << 4);
+		phy_det_connected =
+			(mmio_read_32(GPIO_BASE + 0x50) & (1 << 4)) >> 4;
+		INFO("phy_det_connected %d\n", phy_det_connected);
+	}
+
+	return phy_det_connected;
+}
+#endif
+
+#ifndef BUILD_ATF
+uint32_t plat_cvi_gpio_read(uint32_t mask)
+{
+	NOTICE("Overwrite fip_src to FIP_SRC_USB\n");
+	return FIP_SRC_USB;
+}
+#endif
+
+#if defined(USB_PHY_DETECTION)
+uint8_t usb_vbus_det(void)
+{
+	uint8_t vbus;
+	uint32_t save_pinmux;
+
+	save_pinmux = mmio_read_32(PINMUX_USB_VBUS_DET);
+	mmio_write_32(PINMUX_USB_VBUS_DET, 0);
+	vbus = (!!(mmio_read_32(REG_TOP_CONF_INFO) & BIT_TOP_CONF_INFO_VBUS));
+	mmio_write_32(PINMUX_USB_VBUS_DET, save_pinmux);
+
+	return vbus;
+}
+#endif
+
+void acm_patch_id(unsigned short vid, unsigned short pid)
+{
+	cvi_usb_vid = vid;
+	cvi_usb_pid = pid;
+}
+
+/* ACM entry */
+int acm_app(void)
+{
+	struct usb_gadget *gadget;
+	uint32_t res = 0; /* keeps result of operation on driver */
+	struct list_head *list; // used in for_each loop
+	struct usb_ep *ep;
+	int fip_src = FIP_SRC_MEMMAP;
+	uint32_t ts = 0;
+#ifdef BUILD_ATF
+	uint8_t phy_det_connected = 0;
+
+	phy_det_connected = usb_phy_det_connection();
+
+	if (phy_det_connected == 0) {
+		NOTICE("USB cable is not connected\n");
+		return res;
+	}
+#endif
+
+#if defined(USB_PHY_DETECTION)
+	{
+		uint32_t cnt = 50;
+
+		INFO("waiting for connection ...\n");
+		/* debounce */
+		while (cnt--) {
+			if (!usb_vbus_det())
+				cnt = 50;
+			mdelay(1);
+		}
+		INFO("detect vbus ...\n");
+	}
+#endif
+	init_param();
+	acm_mem_init();
+	print_buf_addr();
+	fip_src = plat_cvi_gpio_read(0);
+	NOTICE("fip_src %d\n", fip_src);
+	if (fip_src == FIP_SRC_USB)
+		flagEnterDL = 1;
+	else
+		flagEnterDL = 0;
+#ifdef USB_IRQ_MODE
+	request_irq(USB_DEV_INTR0, AcmIsr, 0, NULL, NULL);
+	request_irq(USB_DEV_INTR1, AcmIsr, 0, NULL, NULL);
+#endif
+	drv_obj.plat.handler = (void *)handler;
+	drv_obj.plat.size = HANDLER_SIZE;
+	drv_obj.plat.ctrl_req = (void *)setup_buf;
+	res = cvi_udc_probe(&drv_obj.plat);
+	if (res != 0) {
+		goto error;
+	}
+
+	/* bind the gadget object here. */
+	if (cviusb_gadget_register_driver(&g_driver) < 0) {
+		NOTICE("Gadget Register Fail\n");
+		goto error;
+	}
+	gadget = drv_obj.gadget;
+	if (!gadget) {
+		NOTICE("Gadget object not existed!\n");
+		goto error;
+	}
+
+	acm_app_init();
+
+	VERBOSE("Initializing OK! %d\n", __LINE__);
+
+	ts = get_timer(0);
+	VERBOSE("ts: %u\n", get_timer(ts));
+
+	gadget->ops->pullup(gadget, 1);
+unconfigured:
+	while (!get_acm_config()) {
+#ifndef USB_IRQ_MODE
+		AcmIsr();
+#endif
+		if (get_timer(ts) > 1000 && flagEnterDL == 0) {
+			NOTICE("Enumeration failed\n");
+			acm_mem_release();
+			return 0;
+		}
+	}
+	NOTICE("USB enumeration done\n");
+
+	mem_alloc_cnt = 1;
+	/* find IN endpoint */
+	for (list = gadget->ep_list.next; list != &gadget->ep_list;
+	     list = list->next) {
+		ep = (struct usb_ep *)list;
+		if (ep->desc && (ep->desc->bEndpointAddress == BULK_EP_IN)) {
+			bulkInReq = ep->ops->alloc_request(ep);
+			epIn = ep;
+		} else if (ep->desc &&
+			   (ep->desc->bEndpointAddress == BULK_EP_OUT)) {
+			bulkOutReq = ep->ops->alloc_request(ep);
+			epOut = ep;
+		} else if (ep->desc &&
+			   (ep->desc->bEndpointAddress == BULK_EP_NOTIFY)) {
+			IntInReq = ep->ops->alloc_request(ep);
+			epInNotify = ep;
+		}
+	}
+
+	current_speed = gadget->speed;
+	switch (current_speed) {
+	case CH9_USB_SPEED_FULL:
+		transfer_size = 64;
+		break;
+	case CH9_USB_SPEED_HIGH:
+		transfer_size = 512;
+		break;
+	case CH9_USB_SPEED_SUPER:
+		transfer_size = 1024;
+		break;
+	default:
+		VERBOSE("Test error\n");
+		acm_mem_release();
+		return -1;
+	}
+
+	VERBOSE("OUT DATA TRANSFER size :%d\n", transfer_size);
+	clearReq(bulkOutReq);
+	bulkOutReq->buf = cmdBuf;
+	bulkOutReq->dma = (uintptr_t)cmdBuf;
+	bulkOutReq->complete = bulkOutCmplMain;
+	bulkOutReq->length = transfer_size;
+	cvi_cache_flush(bulkOutReq->dma, bulkOutReq->length);
+
+	VERBOSE("IN DATA TRANSFER\n");
+	clearReq(bulkInReq);
+	bulkInReq->buf = bulkBuf;
+	bulkInReq->dma = (uintptr_t)bulkBuf;
+	bulkInReq->complete = bulkResetOutReq;
+	bulkInReq->length = transfer_size;
+	cvi_cache_flush(bulkInReq->dma, bulkInReq->length);
+
+	epOut->ops->queue(epOut, bulkOutReq);
+	NOTICE("connection speed: %d\n", gadget->speed);
+	ts = get_timer(0);
+	VERBOSE("ts: %u\n", get_timer(ts));
+
+	while (1) {
+#ifndef USB_IRQ_MODE
+		AcmIsr();
+#endif
+		if (!get_acm_config())
+			goto unconfigured;
+		if (get_config_break())
+			break;
+		if (flagEnterDL == 0) {
+			if (get_timer(ts) > 1000) {
+				NOTICE("wait data timeout\n");
+				break;
+			}
+		}
+	}
+	NOTICE("Leave transfer loop\n");
+	gadget->ops->pullup(gadget, 0);
+	cviusb_gadget_unregister_driver(&g_driver);
+	acm_mem_release();
+	NOTICE("USB stop\n");
+	return 0;
+
+error:
+	ERROR("Error %u\n", res);
+	return res;
+}
diff --git a/drivers/cvi_usb/utask/test/README b/drivers/cvi_usb/utask/test/README
new file mode 100644
index 000000000..5140c6725
--- /dev/null
+++ b/drivers/cvi_usb/utask/test/README
@@ -0,0 +1,3 @@
+1. To run this script, please install python 2.7, pyusb and libusb-1.0 first.
+2. Boot into u-boot, type "cvi_utask" to start the cvi_usb task.
+3. Execute the test script to start the memory copy test.
diff --git a/drivers/cvi_usb/utask/test/utask_memcpy.py b/drivers/cvi_usb/utask/test/utask_memcpy.py
new file mode 100755
index 000000000..b777ce7ef
--- /dev/null
+++ b/drivers/cvi_usb/utask/test/utask_memcpy.py
@@ -0,0 +1,686 @@
+#!/usr/bin/env python2
+import os
+import re
+import usb.core
+import usb.util
+import sys
+import time
+import platform
+from array import array
+import random
+
+# Define
+SUCCESS = 0
+FAIL = 1
+
+HEADER_SIZE = 8
+
+CVI_USB_NONE      = 0
+CVI_USB_INFO      = 1
+CVI_USB_VERBOSE   = 2
+CVI_USB_JUMP      = 3
+CVI_USB_BREAK     = 4
+CVI_USB_KEEP_DL   = 5
+CVI_USB_PRG_CMD   = 6
+CVI_USB_RESET_ARM = 7
+CVI_USB_TEST_THERMAL_SENSOR = 8
+CVI_USB_TEST_EMMC = 9
+
+# Global variables
+header = array('B')
+data = array('B')
+ret = array('B')
+bulk_command = array('B')
+ser_cmd = array('B')
+pkt_cnt = 0
+filesize = 0
+ioTime = 0
+rom_vidpid = 'VID:PID=0559:1000'
+prg_vidpid = 'VID:PID=30B1:1000'
+verify_vidpid = 'VID:PID='
+emmc_timeout = 0
+
+# Table of CRC constants - implements x^16+x^12+x^5+1
+crc16_tab = [
+    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
+    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
+    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
+    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
+    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
+    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
+    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
+    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
+    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
+    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
+    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
+    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
+    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
+    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
+    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
+    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
+    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
+    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
+    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
+    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
+    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
+    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
+    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
+    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
+    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
+    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
+    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
+    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
+    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
+    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
+]
+
+def crc16_ccitt(HexData):
+    cksum = int("0", 16)
+    for i in range(len(HexData)):
+        cksum = crc16_tab[((cksum >> 8) ^ HexData[i]) & 0xff] ^ ((cksum << 8) & 0xff00)
+    return cksum
+
+def close_device(device):
+    progress_symbol = ['---', ' \\', ' \\', ' |', ' |', ' |', ' |', ' /', ' /']
+    Found = -1
+    i = 0
+    while Found == -1:
+        i = i + 1
+        sys.stdout.write("Waiting for re-connect: %s    \r" % (progress_symbol[i%len(progress_symbol)]))
+        sys.stdout.flush()
+        if device is not None:
+            try:
+                active = device.is_kernel_driver_active(1)
+                if active is False:
+                    try:
+                        device.attach_kernel_driver(1)
+                        print("attach kernel driver\n")
+                        return
+                    except usb.USBError as e:
+                        time.sleep(0.05)
+                        continue
+                else:
+                    break
+            except usb.USBError as e:
+                if '[Errno 19]' in str(e):
+                    # device is no longer connected
+                    return
+                else:
+                    print("get active err %s\n" %(e))
+                    time.sleep(0.05)
+                    continue
+        else:
+            print("close a non-open device. \n")
+            break
+
+def get_vid(vid_pid):
+    vid = vid_pid.replace('VID:PID=', "")
+    vid = vid.split(':', 1)[0]
+    return int(vid, 16)
+
+def get_pid(vid_pid):
+    pid = vid_pid.replace('VID:PID=', "")
+    pid = pid.split(':', 1)[1]
+    return int(pid, 16)
+
+def serial_query(vid_pid_list, timeout=0):
+    global device
+    global epOut
+    global epIn
+    progress_symbol = ['---', ' \\', ' \\', ' |', ' |', ' |', ' |', ' /', ' /']
+    found = -1
+    device = None
+    i = 0
+    query_time = time.time()
+    while(found == -1):
+        i = i + 1
+        sys.stdout.write("Waiting for CV1835 USB port: %s    \r" % (progress_symbol[i%len(progress_symbol)]))
+        sys.stdout.flush()
+        for vid_pid in vid_pid_list:
+            device = usb.core.find(idVendor=get_vid(vid_pid), idProduct=get_pid(vid_pid))
+            if device is not None:
+                found = 1
+                break
+        if device is None:
+            if timeout != 0 and ((time.time() - query_time) > timeout):
+                sys.stdout.write("Query device timeout!       \n" )
+                sys.stdout.flush()
+                sys.exit(-1)
+            time.sleep(0.05)
+        else:
+            break
+
+    i = 0
+    found = -1
+    while(found == -1):
+        i = i + 1
+        try:
+            cfg = device.get_active_configuration()
+        except (NotImplementedError, usb.USBError):
+            sys.stdout.write("Waiting for LibUSB hooked:   %s    \r" %  (progress_symbol[i%len(progress_symbol)]))
+            sys.stdout.flush()
+            time.sleep(0.05)
+            continue
+        except usb.USBError as e:
+            continue
+        found = 1
+        # detach the linux kernel driver.
+        osName = platform.system()
+        if osName == 'Linux':
+            if device.is_kernel_driver_active(1) is True:
+                device.detach_kernel_driver(1)
+        elif osName == 'Windows':
+            # Set line state
+            device.ctrl_transfer(0x21, 0x22, 0, 0, 0)
+            # Set line code
+            lineCode = [0x00, 0x10, 0x0E, 0x00, 0x00, 0x00, 0x08]
+            assert device.ctrl_transfer(0x21, 0x20, 0, 0, lineCode) == len(lineCode)
+        else:
+            sys.stdout.write("Cannot support OS %s\n" %(osName))
+            sys.stdout.flush()
+            sys.exit(-1)
+
+        intf = cfg[(1,0)]
+        epOut = usb.util.find_descriptor(
+                intf,
+                # match the first OUT endpoint
+                custom_match = \
+                lambda e: \
+                usb.util.endpoint_direction(e.bEndpointAddress) == \
+                usb.util.ENDPOINT_OUT)
+        epIn =  usb.util.find_descriptor(
+                intf,
+                # match the first OUT endpoint
+                custom_match = \
+                lambda e: \
+                usb.util.endpoint_direction(e.bEndpointAddress) == \
+                usb.util.ENDPOINT_IN)
+    return device
+
+def serial_write(command, recv_ack, delay_ms):
+    global ret
+    global pkt_cnt
+    global filesize
+    global ioTime
+
+    start_time = time.time()
+    try:
+        #time.sleep(0.001 * delay_ms)
+        #if pkt_cnt < 2 and filesize != 128:
+        #    time.sleep(0.3)
+        epOut.write(command)
+    except usb.USBError as e:
+        print ("Write data timeout %s\n" %e)
+
+    ioTime = ioTime + (time.time() - start_time)
+
+    if recv_ack == 1:
+        cmd_crc = crc16_ccitt(command)
+        # print ("cmd_crc %x" % cmd_crc)
+
+        start_time = time.time()
+        try:
+            ret = epIn.read(16);
+        except usb.USBError as e:
+            print ("Read ACK timeout")
+        ioTime = ioTime + (time.time() - start_time)
+        ret_crc = (ret[2])*256 + (ret[3])
+        #print ("ret_crc %x" % ret_crc)
+
+        if ret_crc == cmd_crc:
+            pkt_cnt += 1
+            # sys.stdout.write("Packet count: %d   \r" % pkt_cnt)
+            sys.stdout.write("[Working] %d%%    \r" % ((pkt_cnt * (512 - HEADER_SIZE) * 100) / filesize))
+            sys.stdout.flush()
+            return SUCCESS
+        else:
+            print ("ACK_CRC_ERROR")
+            return FAIL
+    else:
+        return SUCCESS
+
+def usb_send_file(filename, dest_addr, delay_ms):
+    global header
+    global data
+    global bulk_command
+    global pkt_cnt
+    global filesize
+    global ioTime
+
+    ioTime = 0
+    start_time = time.time()
+    complete_cnt = 0
+    pkt_cnt = 0
+    filesize = 0
+    while (complete_cnt < 1): # For stress test
+        complete_cnt = complete_cnt + 1
+        last_pos = 0
+        tx_len = 512
+        content_file = open(filename, 'rb')
+        content_size = os.path.getsize(filename)
+        filesize = content_size
+        print ("%s is %d bytes" % (filename, content_size))
+        print ("Send to address 0x%x" % dest_addr)
+
+        while (content_size > 0):
+            del header[:]
+            del data[:]
+            del bulk_command[:]
+
+            content_file.seek(last_pos)
+            if (content_size < tx_len - HEADER_SIZE):
+                data.fromfile(content_file, content_size)
+                tx_len = content_size + HEADER_SIZE
+            else:
+                data.fromfile(content_file, tx_len - HEADER_SIZE)
+            last_pos = content_file.tell()
+
+            #if filename == 'cvi_dl_magic.bin':
+            #    header.append(CVI_USB_KEEP_DL)
+            #else:
+            header.append(CVI_USB_NONE)
+            header.append((tx_len >> 8) & 0xFF)
+            header.append((tx_len & 0xFF))
+            header.append((dest_addr >> 32) & 0xFF)
+            header.append((dest_addr >> 24) & 0xFF)
+            header.append((dest_addr >> 16) & 0xFF)
+            header.append((dest_addr >> 8)  & 0xFF)
+            header.append(dest_addr & 0xFF)
+
+            bulk_command = header + data
+            send_ok = serial_write(bulk_command, 1, delay_ms)
+
+            if send_ok == 0:
+                dest_addr += tx_len - HEADER_SIZE
+                content_size -= tx_len - HEADER_SIZE
+            else:
+                last_pos -= tx_len - HEADER_SIZE
+
+        # print ("complete_cnt %d" % complete_cnt)
+        print ("--- %s Seconds ---" % round(time.time() - start_time, 2 ))
+        print ("--- %s Seconds ---" % str(ioTime))
+    return
+
+def _usb_send_req(command, recv_ack, delay_ms):
+    global pkt_cnt
+    global filesize
+    global ioTime
+
+    start_time = time.time()
+    try:
+        #time.sleep(0.001 * delay_ms)
+        #if pkt_cnt < 2 and filesize != 128:
+        #    time.sleep(0.3)
+        epOut.write(command, timeout=0)
+    except usb.USBError as e:
+        print ("Write data timeout: %s\n", e)
+
+    ioTime = ioTime + (time.time() - start_time)
+
+    if recv_ack == 1:
+        cmd_crc = crc16_ccitt(command)
+        # print ("cmd_crc %x" % cmd_crc)
+
+        start_time = time.time()
+        try:
+            rsp = epIn.read(16, timeout=0);
+        except usb.USBError as e:
+            print ("Read ACK timeout: %s\n", e)
+        ioTime = ioTime + (time.time() - start_time)
+        ret_crc = (rsp[2])*256 + (rsp[3])
+        #print ("ret_crc %x" % ret_crc)
+
+        if ret_crc == cmd_crc:
+            return rsp
+        else:
+            print ("ACK_CRC_ERROR")
+            return None
+    else:
+        return None
+
+def usb_send_req_data(token, address, reqLen, ack, data=None):
+    global ser_cmd
+    del ser_cmd[:]
+    ser_cmd.append(token) # command
+    ser_cmd.append(0) # high byte of packet size
+    ser_cmd.append(reqLen) # low byte of packet size
+    ser_cmd.append((address >> 32) & 0xFF) # 5 bytes for destination address
+    ser_cmd.append((address >> 24) & 0xFF)
+    ser_cmd.append((address >> 16) & 0xFF)
+    ser_cmd.append((address >> 8)  & 0xFF)
+    ser_cmd.append((address & 0xFF))
+    if data is not None:
+        ser_cmd = ser_cmd + data
+    else:
+        print("data is empty!\n")
+        return
+    if ack != 0:
+        return _usb_send_req(ser_cmd, 1, 0)
+    else:
+        return serial_write(ser_cmd, 0, 0)
+
+def usb_send_req(token, address, reqLen, ack):
+    del ser_cmd[:]
+    ser_cmd.append(token) # command
+    ser_cmd.append(0) # high byte of packet size
+    ser_cmd.append(reqLen) # low byte of packet size
+    ser_cmd.append((address >> 32) & 0xFF) # 5 bytes for destination address
+    ser_cmd.append((address >> 24) & 0xFF)
+    ser_cmd.append((address >> 16) & 0xFF)
+    ser_cmd.append((address >> 8)  & 0xFF)
+    ser_cmd.append((address & 0xFF))
+
+    if ack != 0:
+        return _usb_send_req(ser_cmd, 1, 0)
+    else:
+        return serial_write(ser_cmd, 0, 0)
+#========================================================================
+# New protocol of prg.bin
+#========================================================================
+USB_MSG_S2D_SIZE    = 16
+USB_MSG_D2S_SIZE    = 16
+CVI_USB_RUNTIME      = 0x80
+CVI_USB_S2D          = 0x81
+CVI_USB_D2S          = 0x82
+USB_BULK_MAX_SIZE   = 0x400000
+
+MSG_TOKEN_OFFSET    = 0
+
+RSP_CRC16_HI_OFFSET = 2
+RSP_CRC16_LO_OFFSET = 3
+RSP_TOKEN_OFFSET    = 6
+
+def protocol_msg_send(message, length, response):
+    global ioTime
+
+    start_time = time.time()
+    try:
+        #time.sleep(0.001 * delay_ms)
+        #if pkt_cnt < 2 and filesize != 128:
+        #    time.sleep(0.3)
+        epOut.write(message, timeout=0)
+    except usb.USBError as e:
+        print ("Write data fail!")
+        return FAIL
+
+    ioTime = ioTime + (time.time() - start_time)
+
+    if response == 1:
+        start_time = time.time()
+        try:
+            ret = epIn.read(16);
+        except usb.USBError as e:
+            print ("message response fail %s\n" %e)
+        ioTime = ioTime + (time.time() - start_time)
+
+        cmd_crc = crc16_ccitt(message)
+        # print ("cmd_crc %x" % cmd_crc)
+
+        ret_crc = (ret[RSP_CRC16_HI_OFFSET])*256 + (ret[RSP_CRC16_LO_OFFSET])
+        #print ("ret_crc %x" % ret_crc)
+
+        if ret_crc == cmd_crc:
+            if message[MSG_TOKEN_OFFSET] != ret[RSP_TOKEN_OFFSET]:
+                sys.stdout.write("Token: exp 0x%x get 0x%x\n" % (message[MSG_TOKEN_OFFSET], ret[RSP_TOKEN_OFFSET]))
+                sys.stdout.flush()
+            else:
+                # sys.stdout.write("Packet count: %d   \r" % pkt_cnt)
+                #sys.stdout.write("[Working] %d%%    \r" % ((pkt_cnt * (512 - HEADER_SIZE) * 100) / filesize))
+                #sys.stdout.flush()
+                return SUCCESS
+        else:
+            sys.stdout.write("ACK_CRC_ERROR\n")
+            sys.stdout.flush()
+            return FAIL
+    else:
+        return SUCCESS
+
+def protocol_msg_fill_header(message, token, addr, reqLen, dataSize):
+
+    message.append(token) # command
+    message.append((reqLen >> 8) & 0xFF) # high byte of packet size
+    message.append(reqLen & 0xFF) # low byte of packet size
+    message.append((addr >> 32) & 0xFF) # 5 bytes for destination address
+    message.append((addr >> 24) & 0xFF)
+    message.append((addr >> 16) & 0xFF)
+    message.append((addr >> 8)  & 0xFF)
+    message.append((addr & 0xFF))
+    if dataSize != 0:
+        message.append((dataSize & 0xFF))
+        message.append((dataSize >> 8 & 0xFF))
+        message.append((dataSize >> 16 & 0xFF))
+        message.append((dataSize >> 24 & 0xFF))
+        message.append((dataSize >> 32 & 0xFF))
+        message.append((dataSize >> 40 & 0xFF))
+        message.append((dataSize >> 48 & 0xFF))
+        message.append((dataSize >> 56 & 0xFF))
+    return
+
+def protocol_usb_write(dataBuf):
+    try:
+        epOut.write(dataBuf, timeout=0)
+    except usb.USBError as e:
+        print ("Write data Fail %s" %e)
+        return FAIL
+    return SUCCESS
+
+def protocol_usb_read(length):
+    try:
+        return epIn.read(length, timeout=0)
+    except usb.USBError as e:
+        print ("Read data Fail %s" %e)
+        return None
+
+def protocol_msg_s2d_once(addr, dataBuf, length):
+    msg = []
+    protocol_msg_fill_header(msg, CVI_USB_S2D, addr, USB_MSG_S2D_SIZE, length)
+    if protocol_msg_send(msg, USB_MSG_S2D_SIZE, 1) == FAIL:
+        return FAIL
+    else:
+        return protocol_usb_write(dataBuf)
+
+def protocol_msg_d2s_once(addr, length):
+    msg = []
+    protocol_msg_fill_header(msg, CVI_USB_D2S, addr, USB_MSG_D2S_SIZE, length)
+    if protocol_msg_send(msg, USB_MSG_D2S_SIZE, 0) == FAIL:
+        return FAIL
+    else:
+        return protocol_usb_read(length)
+
+def protocol_msg_s2d(addr, dataBuf, length):
+    left = length
+    start = 0
+    stop = 0
+    tmpBuf = []
+    while (left > 0):
+        len_once = 0
+        if left <= USB_BULK_MAX_SIZE:
+            len_once = left
+        else:
+            len_once = USB_BULK_MAX_SIZE
+        stop = start + len_once
+        tmpBuf = dataBuf[start:stop]
+        if protocol_msg_s2d_once(addr, tmpBuf, len_once) == FAIL:
+            print("s2d failed at address:0x%x offset:0x%x len:%d\n" %(addr, start, len_once))
+            return FAIL
+        else:
+            addr = addr + len_once
+            start = start + len_once
+            left = left - len_once
+    return SUCCESS
+
+def protocol_msg_d2s(addr, length):
+    left = length
+    tmpBuf = array('B', [])
+    while (left > 0):
+        len_once = 0
+        if left <= USB_BULK_MAX_SIZE:
+            len_once = left
+        else:
+            len_once = USB_BULK_MAX_SIZE
+        oriLen = len(tmpBuf)
+        tmpBuf = tmpBuf + protocol_msg_d2s_once(addr, len_once)
+        newLen = len(tmpBuf)
+        if (newLen-oriLen) != len_once:
+            print("d2s size mismatch at address:0x%x oriLen=%d newLen=%d len_once=%d" %(addr, oriLen, newLen, len_once))
+            return None
+        else:
+            addr = addr + len_once
+            left = left - len_once
+    return tmpBuf
+
+def protocol_send_file(filename, dest_addr):
+    global ioTime
+
+    complete_cnt = 0
+    while (complete_cnt < 1): # For stress test
+        tmp_addr = dest_addr
+        ioTime = 0
+        start_time = time.time()
+
+        complete_cnt = complete_cnt + 1
+        last_pos = 0
+        tx_len = USB_BULK_MAX_SIZE
+        content_file = open(filename, 'rb')
+        content_size = os.path.getsize(filename)
+        file_size = content_size
+        print ("%s is %d bytes" % (filename, content_size))
+        print ("Send to address 0x%x" % tmp_addr)
+
+        while (content_size > 0):
+            #data = []
+            del data[:]
+
+            content_file.seek(last_pos)
+            if (content_size < tx_len):
+                data.fromfile(content_file, content_size)
+                tx_len = content_size
+            else:
+                data.fromfile(content_file, tx_len)
+            last_pos = content_file.tell()
+
+            send_ok = protocol_msg_s2d_once(tmp_addr, data, tx_len)
+
+            if send_ok == 0:
+                tmp_addr += tx_len
+                content_size -= tx_len
+                sys.stdout.write("[Working] %d%%    \r" % (((file_size - content_size) * 100) / file_size))
+                sys.stdout.flush()
+            else:
+                last_pos -= tx_len
+
+        # print ("complete_cnt %d" % complete_cnt)
+        print ("--- %s Seconds ---" % round(time.time() - start_time, 2 ))
+        print ("--- %s Seconds ---" % str(ioTime))
+    return
+
+#==============================================================
+# Main()
+#===============================================================
+def wait_for_reconnect(cnt_seconed):
+    progress_symbol = ['---', ' \\', ' \\', ' |', ' |', ' |', ' |', ' /', ' /']
+    while cnt_seconed > 0:
+        cnt_seconed = cnt_seconed - 1
+        sys.stdout.write("Waiting for re-connect: %s    \r" % (progress_symbol[cnt_seconed%len(progress_symbol)]))
+        sys.stdout.flush()
+        time.sleep(1)
+
+def vidpid_string(vid_str, pid_str):
+    global verify_vidpid
+
+    vid_str = vid_str.replace("0x", "")
+    pid_str = pid_str.replace("0x", "")
+    while len(vid_str) < 4:
+        vid_str = '0' + vid_str
+    while len(pid_str) < 4:
+        pid_str = '0' + pid_str
+    verify_vidpid = verify_vidpid + vid_str + ':' + pid_str
+
+def usb_emmc_dl_veirfy():
+    print("veirfy id = %s" %verify_vidpid)
+    vidpid_list = [verify_vidpid]
+    serial_query(vidpid_list, emmc_timeout)
+
+def show_usage():
+    sys.stdout.write("usage- python [script] vvid=[vid] vpid=[pid]\n")
+    sys.stdout.write("       [script] : %s \n" %__file__)
+    sys.stdout.write("       [vvid]   : reconnect vid if emmc dl complete check enable \n")
+    sys.stdout.write("       [vpid]   : reconnect pid if emmc dl complete check enable \n")
+    sys.stdout.write("       [timeout]: verify timeout (second) from emmc programming to kerel start \n")
+    sys.stdout.write("                  0 means wait forever (default)  \n")
+    sys.stdout.flush()
+
+def parse_arg():
+    global emmc_timeout
+    vid = ''
+    pid = ''
+    for i in range(1, len(sys.argv)):
+        if 'vvid' in sys.argv[i]:
+            vid = sys.argv[i]
+            vid = vid.replace('vvid=', '')
+        if 'vpid' in sys.argv[i]:
+            pid = sys.argv[i]
+            pid = pid.replace('vpid=', '')
+        if 'timeout' in sys.argv[i]:
+            s = sys.argv[i]
+            s = s.replace('timeout=', "")
+            emmc_timeout = int(s)
+            print("emmc timeout = %d s" %emmc_timeout)
+        if 'usage' in sys.argv[i]:
+            show_usage()
+            sys.exit(0)
+
+    if len(vid) != 0 and len(pid) != 0:
+        vidpid_string(vid, pid)
+    else:
+        if len(vid) != 0:
+            sys.stdout.write("pid is not appointed! \n")
+            sys.stdout.flush()
+            show_usage()
+            sys.exit(-1)
+        if len(pid) != 0:
+            sys.stdout.write("vid is not appointed! \n")
+            sys.stdout.flush()
+            show_usage()
+            sys.exit(-1)
+
+if __name__ == '__main__':
+    target_address = 0x110000000
+    pattern_size = 16*1024*1024
+    step = 64
+    test_cnt = 100
+    copy_size = 13
+    # device enumeration
+    vidpid_list = [prg_vidpid]
+    serial_query(vidpid_list)
+    # generate random list for write
+    data_w = array('B',[random.randint(0, 255) for _ in range(pattern_size)])
+    data_r = array('B',[])
+    while test_cnt > 0:
+        del data_r
+        total_time = time.time()
+        # send data
+        if protocol_msg_s2d(target_address, data_w, copy_size) == FAIL:
+            usb_send_req(CVI_USB_BREAK, 0, 8, 0)
+            sys.exit(-1)
+        # read data
+        data_r = protocol_msg_d2s(target_address, copy_size)
+        total_time = round(time.time() - total_time, 5 )
+        # data verification
+        if len(data_r) != copy_size:
+            print("expect %d but receive %d\n" %(copy_size, len(data_r)))
+            usb_send_req(CVI_USB_BREAK, 0, 8, 0)
+            sys.exit(-2)
+        if data_w[:copy_size] != data_r:
+            print("data mismatched!\n")
+            usb_send_req(CVI_USB_BREAK, 0, 8, 0)
+            sys.exit(-3)
+        test_cnt = test_cnt - 1
+        copy_size = (copy_size + step) % pattern_size
+        print ("Test Success!")
+        print ("--- %s Seconds ---\n" % total_time)
+
+    # leave cvi_usb
+    usb_send_req(CVI_USB_BREAK, 0, 8, 0)
diff --git a/drivers/gpio/dwapb_gpio.c b/drivers/gpio/dwapb_gpio.c
index e6e919444..b1d43fd2d 100644
--- a/drivers/gpio/dwapb_gpio.c
+++ b/drivers/gpio/dwapb_gpio.c
@@ -8,7 +8,6 @@
 #include <common.h>
 #include <log.h>
 #include <malloc.h>
-#include <asm/arch/gpio.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <dm.h>
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 1569e8c44..0bb2368c0 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -527,6 +527,32 @@ config MMC_SDHCI_BCMSTB
 
 	  If unsure, say N.
 
+config MMC_SDHCI_CVITEK
+	bool "SDHCI support for the CVITEK SD/SDIO/eMMC controller"
+	depends on BLK && DM_MMC
+	depends on MMC_SDHCI
+	depends on OF_CONTROL
+	help
+	  This selects the CVITEK SD/SDIO/eMMC driver.
+
+	  If you have a controller with this interface,
+	  say Y here.
+
+	  If unsure, say N.
+
+config MMC_SDHCI_CVITEK_WIFI
+	bool "Support for the Wifi over SDIO"
+	depends on MMC_SDHCI_CVITEK
+	help
+	  This enable pinmux to support Wifi over SDIO. While one
+	  select Yes. Then pinmux will be seleted to use WIFI SDIO.
+	  If one select No, then pinmux will be used to other
+	  funciton.
+
+	  If you want to support Wifi over SDIO, say Y here.
+
+	  If unsure, say N.
+
 config MMC_SDHCI_CADENCE
 	bool "SDHCI support for the Cadence SD/SDIO/eMMC controller"
 	depends on BLK && DM_MMC
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index dde6cd563..d5b9adee9 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -78,3 +78,9 @@ obj-$(CONFIG_RENESAS_SDHI)		+= tmio-common.o renesas-sdhi.o
 obj-$(CONFIG_MMC_BCM2835)		+= bcm2835_sdhost.o
 obj-$(CONFIG_MMC_MTK)			+= mtk-sd.o
 obj-$(CONFIG_MMC_SDHCI_F_SDH30)		+= f_sdh30.o
+ifeq ($(CONFIG_MMC_SDHCI_CVITEK), y)
+obj-$(CONFIG_TARGET_CVITEK_CV1835) += cvitek/sdhci-cv183x.o
+obj-$(CONFIG_TARGET_CVITEK_CV1822) += cvitek/sdhci-cv182x.o
+obj-$(CONFIG_TARGET_CVITEK_CV181X) += cvitek/sdhci-cv181x.o
+obj-$(CONFIG_TARGET_CVITEK_CV180X) += cvitek/sdhci-cv180x.o
+endif
diff --git a/drivers/mmc/cvitek/sdhci-cv180x.c b/drivers/mmc/cvitek/sdhci-cv180x.c
new file mode 100644
index 000000000..781cd91cf
--- /dev/null
+++ b/drivers/mmc/cvitek/sdhci-cv180x.c
@@ -0,0 +1,657 @@
+/*
+ * Copyright (C) 2016 Socionext Inc.
+ *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/sizes.h>
+#include <linux/libfdt.h>
+#include <reset.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+#define MMC_TYPE_MMC  0       /* MMC card */
+#define MMC_TYPE_SD   1       /* SD card */
+#define MMC_TYPE_SDIO 2       /* SDIO card */
+
+#ifdef DEBUG
+#define pr_debug(fmt, ...) \
+	printf(fmt, ##__VA_ARGS__)
+#endif
+
+struct cvi_sdhci_plat {
+	struct mmc_config cfg;
+	struct mmc mmc;
+};
+
+struct cvi_sdhci_host {
+	struct sdhci_host host;
+	int pll_index;
+	int pll_reg;
+	int no_1_8_v;
+	int is_64_addressing;
+	int reset_tx_rx_phy;
+	uint32_t mmc_fmax_freq;
+	uint32_t mmc_fmin_freq;
+	struct reset_ctl reset_ctl;
+};
+
+struct cvi_sdhci_driver_data {
+	const struct sdhci_ops *ops;
+	int index;
+};
+
+static void cvi_emmc_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_EMMC_CLK_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CLK_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_RSTN_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_RSTN_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_CMD_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CMD_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT1_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT1_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT0_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT0_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT2_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT2_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT3_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT3_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+}
+
+static void cvi_sdio1_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_SDIO1_CLK_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CLK_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_CMD_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CMD_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT1_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT1_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT0_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT0_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT2_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT2_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT3_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT3_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+}
+
+static void cvi_sdio0_pad_setting(bool reset)
+{
+	if (reset) {
+		mmio_clrsetbits_32(REG_SDIO0_PWR_EN_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_PWR_EN_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+	} else {
+		mmio_clrsetbits_32(REG_SDIO0_PWR_EN_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_PWR_EN_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+	}
+}
+
+static void cvi_sdio0_pad_function(bool bunplug)
+{
+	/* Name                unplug plug
+	 * PAD_SDIO0_CD        SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN    SDIO0  SDIO0
+	 * PAD_SDIO0_CLK       XGPIO  SDIO0
+	 * PAD_SDIO0_CMD       XGPIO  SDIO0
+	 * PAD_SDIO0_D0        XGPIO  SDIO0
+	 * PAD_SDIO0_D1        XGPIO  SDIO0
+	 * PAD_SDIO0_D2        XGPIO  SDIO0
+	 * PAD_SDIO0_D3        XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	mmio_write_32(PAD_SDIO0_CD_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_PWR_EN_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_CLK_REG, val);
+	mmio_write_32(PAD_SDIO0_CMD_REG, val);
+	mmio_write_32(PAD_SDIO0_D0_REG, val);
+	mmio_write_32(PAD_SDIO0_D1_REG, val);
+	mmio_write_32(PAD_SDIO0_D2_REG, val);
+	mmio_write_32(PAD_SDIO0_D3_REG, val);
+}
+
+static int cvi_ofdata_to_platdata(struct udevice *dev)
+{
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int node = dev_of_offset(dev);
+	int rtc_sdio1 = fdtdec_get_uint(gd->fdt_blob, node, "rtc_sdio1", 0);
+
+	host->name = strdup(dev->name);
+	host->ioaddr = (void *)devfdt_get_addr(dev);
+	host->bus_width = fdtdec_get_int(gd->fdt_blob, node, "bus-width", 4);
+	host->max_clk = fdtdec_get_uint(gd->fdt_blob, node, "src-frequency", 0);
+
+	cvi_host->mmc_fmin_freq = fdtdec_get_uint(gd->fdt_blob, node, "min-frequency", 200000);
+	cvi_host->mmc_fmax_freq = fdtdec_get_uint(gd->fdt_blob, node, "max-frequency", 0);
+	cvi_host->is_64_addressing = fdtdec_get_bool(gd->fdt_blob, node, "64_addressing");
+	cvi_host->reset_tx_rx_phy = fdtdec_get_bool(gd->fdt_blob, node, "reset_tx_rx_phy");
+	cvi_host->no_1_8_v = fdtdec_get_bool(gd->fdt_blob, node, "no-1-8-v");
+	cvi_host->pll_index = fdtdec_get_uint(gd->fdt_blob, node, "pll_index", 0);
+	cvi_host->pll_reg = fdtdec_get_uint(gd->fdt_blob, node, "pll_reg", 0);
+
+	if (cvi_host->no_1_8_v)
+		host->quirks |= SDHCI_QUIRK_NO_1_8_V;
+
+	if (rtc_sdio1) {
+		// set rtc sdio1 related register
+		writel(0x1, (unsigned int *)0x03000248);
+		writel(0x10, (unsigned int *)0x0502501c);
+		writel(0xfffffffc, (unsigned int *)0x05025030);
+		//writel(0x0, 0x0502507c);
+	}
+
+	if (host->ioaddr == (void *)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cvi_sdhci_bind(struct udevice *dev)
+{
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+
+	pr_debug("[hq] %s\n", __func__);
+	return sdhci_bind(dev, &plat->mmc, &plat->cfg);
+}
+
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+static void cvi_mmc_set_tap(struct sdhci_host *host, u16 tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, 0, CVI_SDHCI_VENDOR_OFFSET);
+	sdhci_writel(host, BIT(8) | tap << 16, CVI_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+int cvi_general_execute_tuning(struct mmc *mmc, u8 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE + 1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE + 1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(mmc->dev);
+	struct sdhci_host *host = &cvi_host->host;
+
+	u32 norm_stat_en_b, err_stat_en_b;
+	u32 norm_signal_en_b, ctl2;
+
+	norm_stat_en_b = sdhci_readw(host, SDHCI_INT_ENABLE);
+	err_stat_en_b = sdhci_readw(host, SDHCI_ERR_INT_STATUS_EN);
+	norm_signal_en_b = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("mmc%d : SDHCI_ERR_INT_STATUS 0x%x\n", host->index, reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+		     SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+		     SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_writew(host, BIT(2), CVI_SDHCI_VENDOR_OFFSET);
+		cvi_mmc_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("mmc%d : tuning result:	  0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 tuning_result[0], tuning_result[1],
+		 tuning_result[2], tuning_result[3]);
+	pr_debug("mmc%d : rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 rx_lead_lag_result[0], rx_lead_lag_result[1],
+		 rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("mmc%d : tuning graph:      %s\n", host->index, tuning_graph);
+	pr_debug("mmc%d : rx_lead_lag graph: %s\n", host->index, rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size / 2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if (rx_lead_lag_phase == 1 && cur_window_size > 0) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if (cur_window_idx != -1 && cur_window_size > 0) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("mmc%d : MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n",
+		 host->index, max_window_idx, max_window_size, final_tap);
+	pr_debug("mmc%d : RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n",
+		 host->index, max_lead_lag_idx, max_lead_lag_size, rate);
+
+	cvi_mmc_set_tap(host, final_tap);
+	//cvi_host->final_tap = final_tap;
+	ret = mmc_send_tuning(host->mmc, opcode, NULL);
+	printf("mmc%d : finished tuning, code:%d\n", host->index, final_tap);
+
+	ctl2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctl2 &= ~SDHCI_CTRL_EXEC_TUNING;
+	sdhci_writew(host, ctl2, SDHCI_HOST_CONTROL2);
+
+	sdhci_writew(host, norm_stat_en_b, SDHCI_INT_ENABLE);
+	sdhci_writel(host, norm_signal_en_b, SDHCI_SIGNAL_ENABLE);
+	sdhci_writew(host, err_stat_en_b, SDHCI_ERR_INT_STATUS_EN);
+
+	return ret;
+}
+#endif
+
+static void cvi_general_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s-%d MMC%d : ctrl_2 = 0x%04x\n", __func__, __LINE__, host->index, ctrl_2);
+
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) & ~(BIT(1)),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) | BIT(16),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			     CVI_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, (BIT(8) | ((0 & 0x7F) << 16)), CVI_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) | BIT(1),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) | BIT(16),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_PHY_CONFIG) | BIT(0),
+			     CVI_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_SDHCI_PHY_TX_RX_DLY);
+	}
+
+	pr_debug("reg_0x24C = 0x%08x, reg_200 = 0x%08x\n",
+		 sdhci_readl(host, CVI_SDHCI_PHY_CONFIG),
+		 sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET));
+	pr_debug("reg_0x240 = 0x%08x, reg_0x248 = 0x%08x\n",
+		 sdhci_readl(host, CVI_SDHCI_PHY_TX_RX_DLY),
+		 sdhci_readl(host, CVI_SDHCI_PHY_DLY_STS));
+}
+
+#ifdef CONFIG_MMC_UHS_SUPPORT
+static void cvi_sd_voltage_switch(struct mmc *mmc)
+{
+	pr_debug("%s-%d\n", __func__, __LINE__);
+
+	//enable SDIO0_CLK[7:5] to set CLK max strengh
+	mmio_setbits_32(REG_SDIO0_CLK_PAD_REG, BIT(7) | BIT(6) | BIT(5));
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xB);
+
+	//wait 1ms
+	mdelay(1);
+}
+#endif
+
+int cvi_get_cd(struct sdhci_host *host)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	pr_debug("%s reg = 0x08%x\n", __func__, reg);
+	if (reg & SDHCI_CARD_PRESENT) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static int cvi_sdhci_probe(struct udevice *dev)
+{
+	struct cvi_sdhci_driver_data *drv_data =
+				(struct cvi_sdhci_driver_data *)dev_get_driver_data(dev);
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int ret;
+
+	pr_debug("%s-%d: mmc%d probe\n", __func__, __LINE__, host->index);
+	ret = reset_get_by_name(dev, "sdhci", &cvi_host->reset_ctl);
+	if (ret) {
+		pr_debug("warning: reset_get_by_name failed\n");
+	} else {
+		// Try to solve 1.8 to 3.3v converter HW issue
+		ret = reset_assert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed assert reset\n", __func__);
+			return ret;
+		}
+
+		ret = reset_deassert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed deassert reset\n", __func__);
+			return ret;
+		}
+	}
+
+	upriv->mmc = &plat->mmc;
+	host->mmc = &plat->mmc;
+	host->mmc->priv = host;
+	host->mmc->dev = dev;
+	host->ops = drv_data->ops;
+	host->index = drv_data->index;
+	pr_debug("host %p, mmc %p, priv %p\n", host, host->mmc, host->mmc->priv);
+
+	ret = sdhci_setup_cfg(&plat->cfg, host, cvi_host->mmc_fmax_freq, cvi_host->mmc_fmin_freq);
+
+	if (ret)
+		return ret;
+
+	if (host->index == MMC_TYPE_MMC) {
+		cvi_emmc_pad_setting();
+		sdhci_writew(host, sdhci_readw(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | 0x1 << 0,
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+	} else if (host->index == MMC_TYPE_SD) {
+		if (host->ops && host->ops->get_cd) {
+			int present = host->ops->get_cd(host);
+
+			if (present == 1) {
+				//Voltage switching flow (3.3)
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0x9);
+				cvi_sdio0_pad_function(false);
+				cvi_sdio0_pad_setting(false);
+			} else {
+				//Voltage close flow
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xE);
+				cvi_sdio0_pad_function(true);
+				cvi_sdio0_pad_setting(true);
+			}
+		}
+	} else if (host->index == MMC_TYPE_SDIO) {
+		cvi_sdio1_pad_setting();
+		mmio_write_32(0x03000248, 1); // enable rtc2ap_ahb;
+	} else {
+		printf("wrong host index : %d !!\n", host->index);
+		return -ENXIO;
+	}
+
+	ret = sdhci_probe(dev);
+
+	if (host->max_clk == MMC_MAX_CLOCK) {
+		pr_debug("set IP clock to 375Mhz\n");
+		mmio_write_32(cvi_host->pll_reg, MMC_MAX_CLOCK_DIV_VALUE);
+
+		pr_debug("Be sure to switch clock source to PLL\n");
+		mmio_clrbits_32(CLOCK_BYPASS_SELECT_REGISTER, BIT(cvi_host->pll_index));
+		pr_debug("XTAL->PLL reg = 0x%x\n", mmio_read_32(CLOCK_BYPASS_SELECT_REGISTER));
+
+		pr_debug("eMMC/SD CLK is %d in FPGA_ASIC\n", host->max_clk);
+	}
+
+	if (cvi_host->is_64_addressing) {
+		sdhci_writew(host, sdhci_readw(host, SDHCI_HOST_CONTROL2)
+				| SDHCI_HOST_VER4_ENABLE | SDHCI_HOST_ADDRESSING,
+				SDHCI_HOST_CONTROL2);
+	}
+
+	if (cvi_host->reset_tx_rx_phy) {
+		/* Default value */
+		sdhci_writel(host, 2, CVI_SDHCI_VENDOR_OFFSET);
+		sdhci_writel(host, 0x01000100, CVI_SDHCI_PHY_TX_RX_DLY);
+		sdhci_writel(host, 00000001, SDHCI_PHY_CONFIG);
+	}
+
+	return ret;
+}
+
+const struct sdhci_ops cvi_sdhci_emmc_ops = {
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+	.reset = cvi_general_reset,
+};
+
+const struct sdhci_ops cvi_sdhci_sd_ops = {
+	.get_cd = cvi_get_cd,
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+#ifdef CONFIG_MMC_UHS_SUPPORT
+	.voltage_switch = cvi_sd_voltage_switch,
+#endif
+	.reset = cvi_general_reset,
+};
+
+static const struct cvi_sdhci_driver_data sdhci_cvi_emmc_drvdata = {
+	.ops = &cvi_sdhci_emmc_ops,
+	.index = MMC_TYPE_MMC,
+};
+
+static const struct cvi_sdhci_driver_data sdhci_cvi_sd_drvdata = {
+	.ops = &cvi_sdhci_sd_ops,
+	.index = MMC_TYPE_SD,
+};
+
+static const struct udevice_id cvi_sdhci_match[] = {
+	{
+		.compatible = "cvitek,cv180x-emmc",
+		.data = (ulong)&sdhci_cvi_emmc_drvdata,
+	},
+	{
+		.compatible = "cvitek,cv180x-sd",
+		.data = (ulong)&sdhci_cvi_sd_drvdata,
+	},
+	{ }
+};
+
+U_BOOT_DRIVER(cvi_sdhci) = {
+	.name = "cvi_sdhci",
+	.id = UCLASS_MMC,
+	.of_match = cvi_sdhci_match,
+	.of_to_plat = cvi_ofdata_to_platdata,
+	.bind = cvi_sdhci_bind,
+	.probe = cvi_sdhci_probe,
+	.priv_auto = sizeof(struct cvi_sdhci_host),
+	.plat_auto = sizeof(struct cvi_sdhci_plat),
+	.ops = &sdhci_ops,
+};
diff --git a/drivers/mmc/cvitek/sdhci-cv181x.c b/drivers/mmc/cvitek/sdhci-cv181x.c
new file mode 100644
index 000000000..83561a20c
--- /dev/null
+++ b/drivers/mmc/cvitek/sdhci-cv181x.c
@@ -0,0 +1,672 @@
+/*
+ * Copyright (C) 2016 Socionext Inc.
+ *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/sizes.h>
+#include <linux/libfdt.h>
+#include <reset.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+#define MMC_TYPE_MMC  0       /* MMC card */
+#define MMC_TYPE_SD   1       /* SD card */
+#define MMC_TYPE_SDIO 2       /* SDIO card */
+
+#ifdef DEBUG
+#define pr_debug(fmt, ...) \
+	printf(fmt, ##__VA_ARGS__)
+#endif
+
+struct cvi_sdhci_plat {
+	struct mmc_config cfg;
+	struct mmc mmc;
+};
+
+struct cvi_sdhci_host {
+	struct sdhci_host host;
+	int pll_index;
+	int pll_reg;
+	int no_1_8_v;
+	int is_64_addressing;
+	int reset_tx_rx_phy;
+	uint32_t mmc_fmax_freq;
+	uint32_t mmc_fmin_freq;
+	struct reset_ctl reset_ctl;
+};
+
+struct cvi_sdhci_driver_data {
+	const struct sdhci_ops *ops;
+	int index;
+};
+
+static void cvi_emmc_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_EMMC_CLK_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CLK_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_RSTN_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_RSTN_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_CMD_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CMD_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT1_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT1_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT0_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT0_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT2_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT2_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT3_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT3_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+}
+
+static void cvi_sdio1_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_SDIO1_CLK_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CLK_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_CMD_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CMD_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT1_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT1_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT0_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT0_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT2_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT2_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT3_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT3_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+}
+
+static void cvi_sdio0_pad_setting(bool reset)
+{
+	if (reset) {
+		mmio_clrsetbits_32(REG_SDIO0_PWR_EN_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_PWR_EN_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+	} else {
+		mmio_clrsetbits_32(REG_SDIO0_PWR_EN_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_PWR_EN_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+	}
+}
+
+static void cvi_sdio0_pad_function(bool bunplug)
+{
+	/* Name                unplug plug
+	 * PAD_SDIO0_CD        SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN    SDIO0  SDIO0
+	 * PAD_SDIO0_CLK       XGPIO  SDIO0
+	 * PAD_SDIO0_CMD       XGPIO  SDIO0
+	 * PAD_SDIO0_D0        XGPIO  SDIO0
+	 * PAD_SDIO0_D1        XGPIO  SDIO0
+	 * PAD_SDIO0_D2        XGPIO  SDIO0
+	 * PAD_SDIO0_D3        XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	mmio_write_32(PAD_SDIO0_CD_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_PWR_EN_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_CLK_REG, val);
+	mmio_write_32(PAD_SDIO0_CMD_REG, val);
+	mmio_write_32(PAD_SDIO0_D0_REG, val);
+	mmio_write_32(PAD_SDIO0_D1_REG, val);
+	mmio_write_32(PAD_SDIO0_D2_REG, val);
+	mmio_write_32(PAD_SDIO0_D3_REG, val);
+}
+
+static int cvi_ofdata_to_platdata(struct udevice *dev)
+{
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int node = dev_of_offset(dev);
+	int rtc_sdio1 = fdtdec_get_uint(gd->fdt_blob, node, "rtc_sdio1", 0);
+
+	host->name = strdup(dev->name);
+	host->ioaddr = (void *)devfdt_get_addr(dev);
+	host->bus_width = fdtdec_get_int(gd->fdt_blob, node, "bus-width", 4);
+	host->max_clk = fdtdec_get_uint(gd->fdt_blob, node, "src-frequency", 0);
+
+	cvi_host->mmc_fmin_freq = fdtdec_get_uint(gd->fdt_blob, node, "min-frequency", 200000);
+	cvi_host->mmc_fmax_freq = fdtdec_get_uint(gd->fdt_blob, node, "max-frequency", 0);
+	cvi_host->is_64_addressing = fdtdec_get_bool(gd->fdt_blob, node, "64_addressing");
+	cvi_host->reset_tx_rx_phy = fdtdec_get_bool(gd->fdt_blob, node, "reset_tx_rx_phy");
+	cvi_host->no_1_8_v = fdtdec_get_bool(gd->fdt_blob, node, "no-1-8-v");
+	cvi_host->pll_index = fdtdec_get_uint(gd->fdt_blob, node, "pll_index", 0);
+	cvi_host->pll_reg = fdtdec_get_uint(gd->fdt_blob, node, "pll_reg", 0);
+
+	if (cvi_host->no_1_8_v)
+		host->quirks |= SDHCI_QUIRK_NO_1_8_V;
+
+	if (rtc_sdio1) {
+		// set rtc sdio1 related register
+		writel(0x1, (unsigned int *)0x03000248);
+		writel(0x10, (unsigned int *)0x0502501c);
+		writel(0xfffffffc, (unsigned int *)0x05025030);
+		//writel(0x0, 0x0502507c);
+	}
+
+	if (host->ioaddr == (void *)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cvi_sdhci_bind(struct udevice *dev)
+{
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+
+	pr_debug("[hq] %s\n", __func__);
+	return sdhci_bind(dev, &plat->mmc, &plat->cfg);
+}
+
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+static void cvi_mmc_set_tap(struct sdhci_host *host, u16 tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(BIT(2))), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host,
+		     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(1))),
+		     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, BIT(8) | tap << 16, CVI_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | BIT(2), SDHCI_CLOCK_CONTROL);
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+int cvi_general_execute_tuning(struct mmc *mmc, u8 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE + 1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE + 1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(mmc->dev);
+	struct sdhci_host *host = &cvi_host->host;
+
+	u32 norm_stat_en_b, err_stat_en_b;
+	u32 norm_signal_en_b, ctl2;
+
+	norm_stat_en_b = sdhci_readw(host, SDHCI_INT_ENABLE);
+	err_stat_en_b = sdhci_readw(host, SDHCI_ERR_INT_STATUS_EN);
+	norm_signal_en_b = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("mmc%d : SDHCI_ERR_INT_STATUS 0x%x\n", host->index, reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+		     SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+		     SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		cvi_mmc_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("mmc%d : tuning result:	  0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 tuning_result[0], tuning_result[1],
+		 tuning_result[2], tuning_result[3]);
+	pr_debug("mmc%d : rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 rx_lead_lag_result[0], rx_lead_lag_result[1],
+		 rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("mmc%d : tuning graph:      %s\n", host->index, tuning_graph);
+	pr_debug("mmc%d : rx_lead_lag graph: %s\n", host->index, rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size / 2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("mmc%d : MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", host->index, max_window_idx, max_window_size, final_tap);
+	pr_debug("mmc%d : RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", host->index, max_lead_lag_idx, max_lead_lag_size, rate);
+
+	cvi_mmc_set_tap(host, final_tap);
+	//cvi_host->final_tap = final_tap;
+	ret = mmc_send_tuning(host->mmc, opcode, NULL);
+	printf("mmc%d : finished tuning, code:%d\n", host->index, final_tap);
+
+	ctl2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctl2 &= ~SDHCI_CTRL_EXEC_TUNING;
+	sdhci_writew(host, ctl2, SDHCI_HOST_CONTROL2);
+
+	sdhci_writew(host, norm_stat_en_b, SDHCI_INT_ENABLE);
+	sdhci_writel(host, norm_signal_en_b, SDHCI_SIGNAL_ENABLE);
+	sdhci_writew(host, err_stat_en_b, SDHCI_ERR_INT_STATUS_EN);
+
+	return ret;
+}
+#endif
+
+static void cvi_general_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+
+	if (host->index == MMC_TYPE_MMC) {
+		//reg_0x200[0] = 1 for mmc
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+	}
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s-%d MMC%d : ctrl_2 = 0x%04x\n", __func__, __LINE__, host->index, ctrl_2);
+
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		if (host->index == MMC_TYPE_SDIO) {
+			//reg_0x200[16] = 1 for sd1
+			sdhci_writel(host,
+				     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+				     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		}
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			     CVI_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, (BIT(8) | ((0 & 0x7F) << 16)), CVI_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		if (host->index == MMC_TYPE_SDIO) {
+			//reg_0x200[16] = 1 for sd1
+			sdhci_writel(host,
+				     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+				     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		}
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_PHY_CONFIG) | BIT(0),
+			     CVI_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_SDHCI_PHY_TX_RX_DLY);
+	}
+
+}
+
+#ifdef CONFIG_MMC_UHS_SUPPORT
+static void cvi_sd_voltage_switch(struct mmc *mmc)
+{
+	pr_debug("%s-%d\n", __func__, __LINE__);
+
+	//enable SDIO0_CLK[7:5] to set CLK max strengh
+	mmio_setbits_32(REG_SDIO0_CLK_PAD_REG, BIT(7) | BIT(6) | BIT(5));
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xB);
+
+	//wait 1ms
+	mdelay(1);
+}
+#endif
+
+int cvi_get_cd(struct sdhci_host *host)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	pr_debug("%s reg = 0x08%x\n", __func__, reg);
+	if (reg & SDHCI_CARD_PRESENT) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static int cvi_sdhci_probe(struct udevice *dev)
+{
+	struct cvi_sdhci_driver_data *drv_data =
+				(struct cvi_sdhci_driver_data *)dev_get_driver_data(dev);
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int ret;
+
+	pr_debug("%s-%d: mmc%d probe\n", __func__, __LINE__, host->index);
+	ret = reset_get_by_name(dev, "sdhci", &cvi_host->reset_ctl);
+	if (ret) {
+		pr_debug("warning: reset_get_by_name failed\n");
+	} else {
+		// Try to solve 1.8 to 3.3v converter HW issue
+		ret = reset_assert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed assert reset\n", __func__);
+			return ret;
+		}
+
+		ret = reset_deassert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed deassert reset\n", __func__);
+			return ret;
+		}
+	}
+
+	upriv->mmc = &plat->mmc;
+	host->mmc = &plat->mmc;
+	host->mmc->priv = host;
+	host->mmc->dev = dev;
+	host->ops = drv_data->ops;
+	host->index = drv_data->index;
+	pr_debug("host %p, mmc %p, priv %p\n", host, host->mmc, host->mmc->priv);
+
+	ret = sdhci_setup_cfg(&plat->cfg, host, cvi_host->mmc_fmax_freq, cvi_host->mmc_fmin_freq);
+
+	if (ret)
+		return ret;
+
+
+	if (host->index == MMC_TYPE_MMC) {
+		cvi_emmc_pad_setting();
+		sdhci_writel(host, sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+	} else if (host->index == MMC_TYPE_SD) {
+		if (host->ops && host->ops->get_cd) {
+			int present = host->ops->get_cd(host);
+
+			if (present == 1) {
+				//Voltage switching flow (3.3)
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0x9);
+				cvi_sdio0_pad_function(false);
+				cvi_sdio0_pad_setting(false);
+			} else {
+				//Voltage close flow
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xE);
+				cvi_sdio0_pad_function(true);
+				cvi_sdio0_pad_setting(true);
+			}
+		}
+	} else if (host->index == MMC_TYPE_SDIO) {
+		cvi_sdio1_pad_setting();
+	} else {
+		printf("wrong host index : %d !!\n", host->index);
+		return -ENXIO;
+	}
+
+	ret = sdhci_probe(dev);
+
+	if (host->max_clk == MMC_MAX_CLOCK) {
+		pr_debug("set IP clock to 375Mhz\n");
+		mmio_write_32(cvi_host->pll_reg, MMC_MAX_CLOCK_DIV_VALUE);
+
+		pr_debug("Be sure to switch clock source to PLL\n");
+		mmio_clrbits_32(CLOCK_BYPASS_SELECT_REGISTER, BIT(cvi_host->pll_index));
+		pr_debug("XTAL->PLL reg = 0x%x\n", mmio_read_32(CLOCK_BYPASS_SELECT_REGISTER));
+
+		pr_debug("eMMC/SD CLK is %d in FPGA_ASIC\n", host->max_clk);
+	}
+
+	if (cvi_host->is_64_addressing) {
+		sdhci_writew(host, sdhci_readw(host, SDHCI_HOST_CONTROL2)
+				| SDHCI_HOST_VER4_ENABLE | SDHCI_HOST_ADDRESSING,
+				SDHCI_HOST_CONTROL2);
+	}
+
+	if (cvi_host->reset_tx_rx_phy) {
+		/* Default value */
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1) | BIT(8) | BIT(9),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		sdhci_writel(host, 0x01000100, CVI_SDHCI_PHY_TX_RX_DLY);
+		sdhci_writel(host, 00000001, SDHCI_PHY_CONFIG);
+	}
+
+	return ret;
+}
+
+const struct sdhci_ops cvi_sdhci_emmc_ops = {
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+	.reset = cvi_general_reset,
+};
+
+const struct sdhci_ops cvi_sdhci_sd_ops = {
+	.get_cd = cvi_get_cd,
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+#ifdef CONFIG_MMC_UHS_SUPPORT
+	.voltage_switch = cvi_sd_voltage_switch,
+#endif
+	.reset = cvi_general_reset,
+};
+
+static const struct cvi_sdhci_driver_data sdhci_cvi_emmc_drvdata = {
+	.ops = &cvi_sdhci_emmc_ops,
+	.index = MMC_TYPE_MMC,
+};
+
+static const struct cvi_sdhci_driver_data sdhci_cvi_sd_drvdata = {
+	.ops = &cvi_sdhci_sd_ops,
+	.index = MMC_TYPE_SD,
+};
+
+static const struct cvi_sdhci_driver_data sdhci_cvi_sdio_drvdata = {
+	.ops = &cvi_sdhci_sd_ops,
+	.index = MMC_TYPE_SDIO,
+};
+
+static const struct udevice_id cvi_sdhci_match[] = {
+	{
+		.compatible = "cvitek,cv181x-emmc",
+		.data = (ulong)&sdhci_cvi_emmc_drvdata,
+	},
+	{
+		.compatible = "cvitek,cv181x-sd",
+		.data = (ulong)&sdhci_cvi_sd_drvdata,
+	},
+	{
+		.compatible = "cvitek,cv181x-sdio",
+		.data = (ulong)&sdhci_cvi_sdio_drvdata,
+	},
+	{ }
+};
+
+U_BOOT_DRIVER(cvi_sdhci) = {
+	.name = "cvi_sdhci",
+	.id = UCLASS_MMC,
+	.of_match = cvi_sdhci_match,
+	.of_to_plat = cvi_ofdata_to_platdata,
+	.bind = cvi_sdhci_bind,
+	.probe = cvi_sdhci_probe,
+	.priv_auto = sizeof(struct cvi_sdhci_host),
+	.plat_auto = sizeof(struct cvi_sdhci_plat),
+	.ops = &sdhci_ops,
+};
diff --git a/drivers/mmc/cvitek/sdhci-cv182x.c b/drivers/mmc/cvitek/sdhci-cv182x.c
new file mode 100644
index 000000000..82be2c86b
--- /dev/null
+++ b/drivers/mmc/cvitek/sdhci-cv182x.c
@@ -0,0 +1,632 @@
+/*
+ * Copyright (C) 2016 Socionext Inc.
+ *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/sizes.h>
+#include <linux/libfdt.h>
+#include <reset.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+#ifdef DEBUG
+#define pr_debug(fmt, ...) \
+	printf(fmt, ##__VA_ARGS__)
+#endif
+
+struct cvi_sdhci_plat {
+	struct mmc_config cfg;
+	struct mmc mmc;
+};
+
+struct cvi_sdhci_host {
+	struct sdhci_host host;
+	int pll_index;
+	int pll_reg;
+	int has_phy;
+	int no_1_8_v;
+	int is_64_addressing;
+	int reset_tx_rx_phy;
+	uint32_t mmc_init_freq;
+	uint32_t mmc_trans_freq;
+	struct reset_ctl reset_ctl;
+};
+
+static void cvi_emmc_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_EMMC_CLK_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CLK_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_RSTN_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_RSTN_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_CMD_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CMD_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT1_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT1_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT0_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT0_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT2_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT2_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT3_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT3_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+}
+
+static void cvi_sdio1_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_SDIO1_CLK_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CLK_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_CMD_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CMD_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT1_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT1_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT0_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT0_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT2_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT2_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT3_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT3_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+}
+
+static void cvi_sdio0_pad_setting(bool reset)
+{
+	if (reset) {
+		mmio_clrsetbits_32(REG_SDIO0_PWR_EN_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_PWR_EN_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+	} else {
+		mmio_clrsetbits_32(REG_SDIO0_PWR_EN_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_PWR_EN_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+	}
+}
+
+static void cvi_sdio0_pad_function(bool bunplug)
+{
+	/* Name                unplug plug
+	 * PAD_SDIO0_CD        SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN    SDIO0  SDIO0
+	 * PAD_SDIO0_CLK       XGPIO  SDIO0
+	 * PAD_SDIO0_CMD       XGPIO  SDIO0
+	 * PAD_SDIO0_D0        XGPIO  SDIO0
+	 * PAD_SDIO0_D1        XGPIO  SDIO0
+	 * PAD_SDIO0_D2        XGPIO  SDIO0
+	 * PAD_SDIO0_D3        XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	mmio_write_32(PAD_SDIO0_CD_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_PWR_EN_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_CLK_REG, val);
+	mmio_write_32(PAD_SDIO0_CMD_REG, val);
+	mmio_write_32(PAD_SDIO0_D0_REG, val);
+	mmio_write_32(PAD_SDIO0_D1_REG, val);
+	mmio_write_32(PAD_SDIO0_D2_REG, val);
+	mmio_write_32(PAD_SDIO0_D3_REG, val);
+}
+
+static int cvi_ofdata_to_platdata(struct udevice *dev)
+{
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int node = dev_of_offset(dev);
+	int rtc_sdio1 = fdtdec_get_uint(gd->fdt_blob, node, "rtc_sdio1", 0);
+
+	host->name = strdup(dev->name);
+	host->ioaddr = (void *)devfdt_get_addr(dev);
+	host->bus_width = fdtdec_get_int(gd->fdt_blob, node, "bus-width", 4);
+	host->index = fdtdec_get_uint(gd->fdt_blob, node, "index", 0);
+	host->max_clk = fdtdec_get_uint(gd->fdt_blob, node, "max-frequency", 0);
+
+	cvi_host->mmc_init_freq = fdtdec_get_uint(gd->fdt_blob, node, "mmc_init_freq", 200000);
+	cvi_host->mmc_trans_freq = fdtdec_get_uint(gd->fdt_blob, node, "mmc_trans_freq", 0);
+	cvi_host->is_64_addressing = fdtdec_get_bool(gd->fdt_blob, node, "64_addressing");
+	cvi_host->reset_tx_rx_phy = fdtdec_get_bool(gd->fdt_blob, node, "reset_tx_rx_phy");
+	cvi_host->has_phy = fdtdec_get_bool(gd->fdt_blob, node, "has_phy");
+	cvi_host->no_1_8_v = fdtdec_get_bool(gd->fdt_blob, node, "no-1-8-v");
+	cvi_host->pll_index = fdtdec_get_uint(gd->fdt_blob, node, "pll_index", 0);
+	cvi_host->pll_reg = fdtdec_get_uint(gd->fdt_blob, node, "pll_reg", 0);
+
+	if (cvi_host->no_1_8_v)
+		host->quirks |= SDHCI_QUIRK_NO_1_8_V;
+
+	if (rtc_sdio1) {
+		// set rtc sdio1 related register
+		writel(0x1, 0x03000248);
+		writel(0x10, 0x0502501c);
+		writel(0xfffffffc, 0x05025030);
+		//writel(0x0, 0x0502507c);
+	}
+
+	if (host->ioaddr == (void *)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cvi_sdhci_bind(struct udevice *dev)
+{
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+
+	pr_debug("[hq] %s\n", __func__);
+	return sdhci_bind(dev, &plat->mmc, &plat->cfg);
+}
+
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+static void cvi_mmc_set_tap(struct sdhci_host *host, u16 tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, 0, CVI_SDHCI_VENDOR_OFFSET);
+	sdhci_writel(host, BIT(8) | tap << 16, CVI_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+int cvi_general_execute_tuning(struct mmc *mmc, u8 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE + 1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE + 1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(mmc->dev);
+	struct sdhci_host *host = &cvi_host->host;
+
+	u32 norm_stat_en_b, err_stat_en_b;
+	u32 norm_signal_en_b, ctl2;
+
+	norm_stat_en_b = sdhci_readw(host, SDHCI_INT_ENABLE);
+	err_stat_en_b = sdhci_readw(host, SDHCI_ERR_INT_STATUS_EN);
+	norm_signal_en_b = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("mmc%d : SDHCI_ERR_INT_STATUS 0x%x\n", host->index, reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+		     SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+		     SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_writew(host, BIT(2), CVI_SDHCI_VENDOR_OFFSET);
+		cvi_mmc_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("mmc%d : tuning result:	  0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 tuning_result[0], tuning_result[1],
+		 tuning_result[2], tuning_result[3]);
+	pr_debug("mmc%d : rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 rx_lead_lag_result[0], rx_lead_lag_result[1],
+		 rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("mmc%d : tuning graph:      %s\n", host->index, tuning_graph);
+	pr_debug("mmc%d : rx_lead_lag graph: %s\n", host->index, rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size / 2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("mmc%d : MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", host->index, max_window_idx, max_window_size, final_tap);
+	pr_debug("mmc%d : RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", host->index, max_lead_lag_idx, max_lead_lag_size, rate);
+
+	cvi_mmc_set_tap(host, final_tap);
+	//cvi_host->final_tap = final_tap;
+	ret = mmc_send_tuning(host->mmc, opcode, NULL);
+	printf("mmc%d : finished tuning, code:%d\n", host->index, final_tap);
+
+	ctl2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctl2 &= ~SDHCI_CTRL_EXEC_TUNING;
+	sdhci_writew(host, ctl2, SDHCI_HOST_CONTROL2);
+
+	sdhci_writew(host, norm_stat_en_b, SDHCI_INT_ENABLE);
+	sdhci_writel(host, norm_signal_en_b, SDHCI_SIGNAL_ENABLE);
+	sdhci_writew(host, err_stat_en_b, SDHCI_ERR_INT_STATUS_EN);
+
+	return ret;
+}
+#endif
+
+static void cvi_general_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s-%d MMC%d : ctrl_2 = 0x%04x\n", __func__, __LINE__, host->index, ctrl_2);
+
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) & ~(BIT(1)),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) | BIT(16),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			     CVI_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, (BIT(8) | ((0 & 0x7F) << 16)), CVI_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) | BIT(1),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET) | BIT(16),
+			     CVI_SDHCI_VENDOR_OFFSET);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			     sdhci_readl(host, CVI_SDHCI_PHY_CONFIG) | BIT(0),
+			     CVI_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_SDHCI_PHY_TX_RX_DLY);
+	}
+
+	pr_debug("reg_0x24C = 0x%08x, reg_200 = 0x%08x\n",
+		 sdhci_readl(host, CVI_SDHCI_PHY_CONFIG),
+		 sdhci_readl(host, CVI_SDHCI_VENDOR_OFFSET));
+	pr_debug("reg_0x240 = 0x%08x, reg_0x248 = 0x%08x\n",
+		 sdhci_readl(host, CVI_SDHCI_PHY_TX_RX_DLY),
+		 sdhci_readl(host, CVI_SDHCI_PHY_DLY_STS));
+}
+
+#ifdef CONFIG_MMC_UHS_SUPPORT
+static void cvi_sd_voltage_switch(struct mmc *mmc)
+{
+	pr_debug("%s-%d\n", __func__, __LINE__);
+
+	//enable SDIO0_CLK[7:5] to set CLK max strengh
+	mmio_setbits_32(REG_SDIO0_CLK_PAD_REG, BIT(7) | BIT(6) | BIT(5));
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xB);
+
+	//wait 1ms
+	mdelay(1);
+}
+#endif
+
+int cvi_get_cd(struct sdhci_host *host)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	pr_debug("%s reg = 0x08%x\n", __func__, reg);
+	if (reg & SDHCI_CARD_PRESENT) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static const struct sdhci_ops cvi_sdhci_ops = {
+	.get_cd	= cvi_get_cd,
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+#ifdef CONFIG_MMC_UHS_SUPPORT
+	.voltage_switch = cvi_sd_voltage_switch,
+#endif
+	.reset = cvi_general_reset,
+};
+
+static const struct sdhci_ops cvi_sdhci_emmc_ops = {
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+	.reset = cvi_general_reset,
+};
+
+static int cvi_sdhci_probe(struct udevice *dev)
+{
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int ret;
+
+	pr_debug("%s-%d: mmc%d probe\n", __func__, __LINE__, host->index);
+	ret = reset_get_by_name(dev, "sdhci", &cvi_host->reset_ctl);
+	if (ret) {
+		pr_debug("warning: reset_get_by_name failed\n");
+	} else {
+		// Try to solve 1.8 to 3.3v converter HW issue
+		ret = reset_assert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed assert reset\n", __func__);
+			return ret;
+		}
+
+		ret = reset_deassert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed deassert reset\n", __func__);
+			return ret;
+		}
+	}
+
+	upriv->mmc = &plat->mmc;
+	host->mmc = &plat->mmc;
+	host->mmc->priv = host;
+	host->mmc->dev = dev;
+	pr_debug("host %p, mmc %p, priv %p\n", host, host->mmc, host->mmc->priv);
+
+	ret = sdhci_setup_cfg(&plat->cfg, host, cvi_host->mmc_trans_freq, cvi_host->mmc_init_freq);
+
+	if (ret)
+		return ret;
+
+
+	if (host->index == 0) {
+		host->ops = &cvi_sdhci_emmc_ops;
+		cvi_emmc_pad_setting();
+		sdhci_writew(host, sdhci_readw(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | 0x1 << 0,
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+	} else if (host->index == 1) {
+		host->ops = &cvi_sdhci_ops;
+		if (host->ops && host->ops->get_cd) {
+			int present = host->ops->get_cd(host);
+
+			if (present == 1) {
+				//Voltage switching flow (3.3)
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0x9);
+				cvi_sdio0_pad_function(false);
+				cvi_sdio0_pad_setting(false);
+			} else {
+				//Voltage close flow
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xE);
+				cvi_sdio0_pad_function(true);
+				cvi_sdio0_pad_setting(true);
+			}
+		}
+	} else if (host->index == 2) {
+		pr_debug("sdio1 probe\n");
+		cvi_sdio1_pad_setting();
+		mmio_write_32(0x03000248, 1); // enable rtc2ap_ahb;
+	} else {
+		printf("wrong host index : %d !!\n", host->index);
+		return -ENXIO;
+	}
+
+	ret = sdhci_probe(dev);
+
+	if (host->max_clk == MMC_MAX_CLOCK) {
+		pr_debug("set IP clock to 375Mhz\n");
+		mmio_write_32(cvi_host->pll_reg, MMC_MAX_CLOCK_DIV_VALUE);
+
+		pr_debug("Be sure to switch clock source to PLL\n");
+		mmio_clrbits_32(CLOCK_BYPASS_SELECT_REGISTER, BIT(cvi_host->pll_index));
+		pr_debug("XTAL->PLL reg = 0x%x\n", mmio_read_32(CLOCK_BYPASS_SELECT_REGISTER));
+
+		pr_debug("eMMC/SD CLK is %d in FPGA_ASIC\n", host->max_clk);
+	}
+
+	if (cvi_host->is_64_addressing) {
+		sdhci_writew(host, sdhci_readw(host, SDHCI_HOST_CONTROL2)
+				| SDHCI_HOST_VER4_ENABLE | SDHCI_HOST_ADDRESSING,
+				SDHCI_HOST_CONTROL2);
+	}
+
+	if (cvi_host->reset_tx_rx_phy) {
+		/* Default value */
+		sdhci_writel(host, 2, CVI_SDHCI_VENDOR_OFFSET);
+		sdhci_writel(host, 0x01000100, CVI_SDHCI_PHY_TX_RX_DLY);
+		sdhci_writel(host, 00000001, SDHCI_PHY_CONFIG);
+	}
+
+	return ret;
+}
+
+static const struct udevice_id cvi_sdhci_match[] = {
+	{ .compatible = "cvitek,synopsys-sdhc" },
+	{ /* sentinel */ }
+};
+
+U_BOOT_DRIVER(cvi_sdhci) = {
+	.name = "cvi_sdhci",
+	.id = UCLASS_MMC,
+	.of_match = cvi_sdhci_match,
+	.of_to_plat = cvi_ofdata_to_platdata,
+	.bind = cvi_sdhci_bind,
+	.probe = cvi_sdhci_probe,
+	.priv_auto = sizeof(struct cvi_sdhci_host),
+	.plat_auto = sizeof(struct cvi_sdhci_plat),
+	.ops = &sdhci_ops,
+};
diff --git a/drivers/mmc/cvitek/sdhci-cv183x.c b/drivers/mmc/cvitek/sdhci-cv183x.c
new file mode 100644
index 000000000..386fb4612
--- /dev/null
+++ b/drivers/mmc/cvitek/sdhci-cv183x.c
@@ -0,0 +1,698 @@
+/*
+ * Copyright (C) 2016 Socionext Inc.
+ *   Author: Masahiro Yamada <yamada.masahiro@socionext.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/sizes.h>
+#include <linux/libfdt.h>
+#include <reset.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+#ifdef DEBUG
+#define pr_debug(fmt, ...) \
+	printf(fmt, ##__VA_ARGS__)
+#endif
+
+struct cvi_sdhci_plat {
+	struct mmc_config cfg;
+	struct mmc mmc;
+};
+
+struct cvi_sdhci_host {
+	struct sdhci_host host;
+	int pll_index;
+	int pll_reg;
+	int has_phy;
+	int no_1_8_v;
+	int is_64_addressing;
+	int reset_tx_rx_phy;
+	uint32_t mmc_init_freq;
+	uint32_t mmc_trans_freq;
+	struct reset_ctl reset_ctl;
+};
+
+static void cvi_emmc_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_EMMC_CLK_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CLK_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_RSTN_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_RSTN_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_CMD_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_CMD_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT1_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT1_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT0_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT0_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT2_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT2_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_EMMC_DAT3_PAD_REG, REG_EMMC_PAD_CLR_MASK, REG_EMMC_DAT3_PAD_VALUE << REG_EMMC_PAD_SHIFT);
+}
+
+static void cvi_sdio1_pad_setting(void)
+{
+	mmio_clrsetbits_32(REG_SDIO1_CLK_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CLK_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_CMD_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_CMD_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT1_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT1_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT0_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT0_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT2_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT2_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+
+	mmio_clrsetbits_32(REG_SDIO1_DAT3_PAD_REG, REG_SDIO1_PAD_CLR_MASK,
+			   REG_SDIO1_DAT3_PAD_VALUE << REG_SDIO1_PAD_SHIFT);
+}
+
+static void cvi_sdio0_pad_setting(bool reset)
+{
+	if (reset) {
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_RESET << REG_SDIO0_PAD_SHIFT);
+
+	} else {
+		mmio_clrsetbits_32(REG_SDIO0_CD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CLK_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CLK_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_CMD_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_CMD_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT1_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT1_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT0_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT0_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT2_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT2_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+
+		mmio_clrsetbits_32(REG_SDIO0_DAT3_PAD_REG, REG_SDIO0_PAD_CLR_MASK,
+				   REG_SDIO0_DAT3_PAD_VALUE << REG_SDIO0_PAD_SHIFT);
+	}
+}
+
+static void cvi_sdio0_pad_function(bool bunplug)
+{
+	/* Name                unplug plug
+	 * PAD_SDIO0_CD        SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN    SDIO0  SDIO0
+	 * PAD_SDIO0_CLK       XGPIO  SDIO0
+	 * PAD_SDIO0_CMD       XGPIO  SDIO0
+	 * PAD_SDIO0_D0        XGPIO  SDIO0
+	 * PAD_SDIO0_D1        XGPIO  SDIO0
+	 * PAD_SDIO0_D2        XGPIO  SDIO0
+	 * PAD_SDIO0_D3        XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	mmio_write_32(PAD_SDIO0_CD_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_PWR_EN_REG, 0x0);
+	mmio_write_32(PAD_SDIO0_CLK_REG, val);
+	mmio_write_32(PAD_SDIO0_CMD_REG, val);
+	mmio_write_32(PAD_SDIO0_D0_REG, val);
+	mmio_write_32(PAD_SDIO0_D1_REG, val);
+	mmio_write_32(PAD_SDIO0_D2_REG, val);
+	mmio_write_32(PAD_SDIO0_D3_REG, val);
+}
+
+static int cvi_ofdata_to_platdata(struct udevice *dev)
+{
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int node = dev_of_offset(dev);
+	int rtc_sdio1 = fdtdec_get_uint(gd->fdt_blob, node, "rtc_sdio1", 0);
+
+	host->name = strdup(dev->name);
+	host->ioaddr = (void *)devfdt_get_addr(dev);
+	host->bus_width = fdtdec_get_int(gd->fdt_blob, node, "bus-width", 4);
+	host->index = fdtdec_get_uint(gd->fdt_blob, node, "index", 0);
+	host->max_clk = fdtdec_get_uint(gd->fdt_blob, node, "max-frequency", 0);
+
+	cvi_host->mmc_init_freq = fdtdec_get_uint(gd->fdt_blob, node, "mmc_init_freq", 200000);
+	cvi_host->mmc_trans_freq = fdtdec_get_uint(gd->fdt_blob, node, "mmc_trans_freq", 0);
+	cvi_host->is_64_addressing = fdtdec_get_bool(gd->fdt_blob, node, "64_addressing");
+	cvi_host->reset_tx_rx_phy = fdtdec_get_bool(gd->fdt_blob, node, "reset_tx_rx_phy");
+	cvi_host->has_phy = fdtdec_get_bool(gd->fdt_blob, node, "has_phy");
+	cvi_host->no_1_8_v = fdtdec_get_bool(gd->fdt_blob, node, "no-1-8-v");
+	cvi_host->pll_index = fdtdec_get_uint(gd->fdt_blob, node, "pll_index", 0);
+	cvi_host->pll_reg = fdtdec_get_uint(gd->fdt_blob, node, "pll_reg", 0);
+
+	if (cvi_host->no_1_8_v)
+		host->quirks |= SDHCI_QUIRK_NO_1_8_V;
+
+	if (rtc_sdio1) {
+		// set rtc sdio1 related register
+		writel(0x1, 0x03000248);
+		writel(0x10, 0x0502501c);
+		writel(0xfffffffc, 0x05025030);
+		//writel(0x0, 0x0502507c);
+	}
+
+	if (host->ioaddr == (void *)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cvi_sdhci_bind(struct udevice *dev)
+{
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+
+	pr_debug("[hq] %s\n", __func__);
+	return sdhci_bind(dev, &plat->mmc, &plat->cfg);
+}
+
+/* TODO */
+static int cvi_sdhci_phy_init(struct cvi_sdhci_host *cvi_host)
+{
+	struct sdhci_host *host = &cvi_host->host;
+
+	// Asset reset of phy
+	sdhci_writel(host, sdhci_readl(host, SDHCI_P_PHY_CNFG) & ~(1 << PHY_CNFG_PHY_RSTN), SDHCI_P_PHY_CNFG);
+
+	// Set PAD_SN PAD_SP
+	sdhci_writel(host, (1 << PHY_CNFG_PHY_PWRGOOD) | (0x9 << PHY_CNFG_PAD_SP) | (0x8 << PHY_CNFG_PAD_SN), SDHCI_P_PHY_CNFG);
+
+	// Set CMDPAD
+	sdhci_writew(host, (0x2 << PAD_CNFG_RXSEL) | (1 << PAD_CNFG_WEAKPULL_EN) |
+			(0x3 << PAD_CNFG_TXSLEW_CTRL_P) | (0x2 << PAD_CNFG_TXSLEW_CTRL_N), SDHCI_P_CMDPAD_CNFG);
+
+	// Set DATAPAD
+	sdhci_writew(host, (0x2 << PAD_CNFG_RXSEL) | (1 << PAD_CNFG_WEAKPULL_EN) |
+			(0x3 << PAD_CNFG_TXSLEW_CTRL_P) | (0x2 << PAD_CNFG_TXSLEW_CTRL_N), SDHCI_P_DATPAD_CNFG);
+
+	// Set CLKPAD
+	sdhci_writew(host, (0x2 << PAD_CNFG_RXSEL) | (0x3 << PAD_CNFG_TXSLEW_CTRL_P) | (0x2 << PAD_CNFG_TXSLEW_CTRL_N),
+		     SDHCI_P_CLKPAD_CNFG);
+
+	// Set STB_PAD
+	sdhci_writew(host, (0x2 << PAD_CNFG_RXSEL) | (0x2 << PAD_CNFG_WEAKPULL_EN) |
+			(0x3 << PAD_CNFG_TXSLEW_CTRL_P) | (0x2 << PAD_CNFG_TXSLEW_CTRL_N), SDHCI_P_STBPAD_CNFG);
+
+	// Set RSTPAD
+	sdhci_writew(host, (0x2 << PAD_CNFG_RXSEL) | (1 << PAD_CNFG_WEAKPULL_EN) |
+			(0x3 << PAD_CNFG_TXSLEW_CTRL_P) | (0x2 << PAD_CNFG_TXSLEW_CTRL_N), SDHCI_P_RSTNPAD_CNFG);
+
+	// Set SDCLKDL_CNFG, EXTDLY_EN = 1, fix delay
+	sdhci_writeb(host, (1 << SDCLKDL_CNFG_EXTDLY_EN), SDHCI_P_SDCLKDL_CNFG);
+
+	// Add 70 * 10 ps = 0.7ns
+	sdhci_writeb(host, 0xA, SDHCI_P_SDCLKDL_DC);
+
+	if (host->index == 1) {
+		// Set SMPLDL_CNFG, Bypass
+		sdhci_writeb(host, (1 << SMPLDL_CNFG_BYPASS_EN), SDHCI_P_SMPLDL_CNFG);
+	} else {
+		// Set SMPLDL_CNFG, INPSEL_CNFG = 0x2
+		sdhci_writeb(host, (0x2 << SMPLDL_CNFG_INPSEL_CNFG), SDHCI_P_SMPLDL_CNFG);
+	}
+
+	// Set ATDL_CNFG, tuning clk not use for init
+	sdhci_writeb(host, (2 << ATDL_CNFG_INPSEL_CNFG), SDHCI_P_ATDL_CNFG);
+
+	// Deasset reset of phy
+	sdhci_writel(host, sdhci_readl(host, SDHCI_P_PHY_CNFG) | (1 << PHY_CNFG_PHY_RSTN), SDHCI_P_PHY_CNFG);
+
+	return 0;
+}
+
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+static void cvi_mmc_set_tap(struct sdhci_host *host, u16 tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writew(host, 0, CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writew(host, 0x18, CVI_SDHCI_VENDOR_A_CTRL_R);
+	sdhci_writel(host, sdhci_readl(host, SDHCI_RX_DELAY_LINE) | 0x300000, SDHCI_RX_DELAY_LINE);
+	sdhci_writew(host, tap, CVI_SDHCI_VENDOR_A_STAT_R);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+int cvi_general_execute_tuning(struct mmc *mmc, u8 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE + 1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE + 1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(mmc->dev);
+	struct sdhci_host *host = &cvi_host->host;
+
+	u32 norm_stat_en_b, err_stat_en_b;
+	u32 norm_signal_en_b, ctl2;
+
+	norm_stat_en_b = sdhci_readw(host, SDHCI_INT_ENABLE);
+	err_stat_en_b = sdhci_readw(host, SDHCI_ERR_INT_STATUS_EN);
+	norm_signal_en_b = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_writel(host, 0x0, CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("mmc%d : SDHCI_ERR_INT_STATUS 0x%x\n", host->index, reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+		     SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+		     sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+		     SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("mmc%d : host ctrl2 0x%x\n", host->index, reg);
+
+	/* Set ATR_CTRL_R.SW_TNE_EN=1 */
+	reg = sdhci_readl(host, CVI_SDHCI_VENDOR_A_CTRL_R);
+	pr_debug("mmc%d : A ctrl 0x%x\n", host->index, reg);
+	sdhci_writel(host,
+		     sdhci_readl(host, CVI_SDHCI_VENDOR_A_CTRL_R) | (0x1 << 4),
+		     CVI_SDHCI_VENDOR_A_CTRL_R);
+	reg = sdhci_readl(host, CVI_SDHCI_VENDOR_A_CTRL_R);
+	pr_debug("mmc%d : A ctrl 0x%x\n", host->index, reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		cvi_mmc_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, 0x312) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("mmc%d : tuning result:	  0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 tuning_result[0], tuning_result[1],
+		 tuning_result[2], tuning_result[3]);
+	pr_debug("mmc%d : rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n", host->index,
+		 rx_lead_lag_result[0], rx_lead_lag_result[1],
+		 rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("mmc%d : tuning graph:      %s\n", host->index, tuning_graph);
+	pr_debug("mmc%d : rx_lead_lag graph: %s\n", host->index, rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size / 2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("mmc%d : MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", host->index, max_window_idx, max_window_size, final_tap);
+	pr_debug("mmc%d : RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", host->index, max_lead_lag_idx, max_lead_lag_size, rate);
+
+	cvi_mmc_set_tap(host, final_tap);
+	//cvi_host->final_tap = final_tap;
+	ret = mmc_send_tuning(host->mmc, opcode, NULL);
+	printf("mmc%d : finished tuning, code:%d\n", host->index, final_tap);
+
+	ctl2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctl2 &= ~SDHCI_CTRL_EXEC_TUNING;
+	sdhci_writew(host, ctl2, SDHCI_HOST_CONTROL2);
+
+	sdhci_writew(host, norm_stat_en_b, SDHCI_INT_ENABLE);
+	sdhci_writel(host, norm_signal_en_b, SDHCI_SIGNAL_ENABLE);
+	sdhci_writew(host, err_stat_en_b, SDHCI_ERR_INT_STATUS_EN);
+
+	return ret;
+}
+#endif
+
+static void cvi_general_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s-%d MMC%d : ctrl_2 = 0x%04x\n", __func__, __LINE__, host->index, ctrl_2);
+
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x508[0] = 0
+		sdhci_writew(host,
+			     sdhci_readw(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(0))),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x30C[21:20] = 3
+		sdhci_writel(host,
+			     sdhci_readl(host, SDHCI_RX_DELAY_LINE) | (BIT(21) | BIT(20)),
+			     SDHCI_RX_DELAY_LINE);
+		//reg_0x31C[22:16] = 0, reg_0x31C[11:10] = 0
+		sdhci_writel(host, sdhci_readl(host, SDHCI_TX_DELAY_LINE) & (~(0x7F0C00)), SDHCI_TX_DELAY_LINE);
+		//reg_0x544[6:0] = tap
+		sdhci_writew(host, 0 & 0x7F, CVI_SDHCI_VENDOR_A_STAT_R);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x508[0] = 1
+		sdhci_writew(host,
+			     sdhci_readw(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			     CVI_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x30C[21:20] = 0
+		sdhci_writel(host,
+			     sdhci_readl(host, SDHCI_RX_DELAY_LINE) & (~(BIT(21) | BIT(20))),
+			     SDHCI_RX_DELAY_LINE);
+		//reg_0x31C[22:16] = 0, reg_0x31C[11:10] = 0
+		sdhci_writel(host, sdhci_readl(host, SDHCI_TX_DELAY_LINE) & (~(0x7F0C00)), SDHCI_TX_DELAY_LINE);
+		//reg_0x544[6:0] = 0
+		sdhci_writew(host,
+			     sdhci_readw(host, CVI_SDHCI_VENDOR_A_STAT_R) & (~(0x7F)),
+			     CVI_SDHCI_VENDOR_A_STAT_R);
+	}
+	pr_debug("reg_0x508 = 0x%08x, reg_0x30C = 0x%08x\n",
+		 sdhci_readl(host, CVI_SDHCI_VENDOR_MSHC_CTRL_R), sdhci_readl(host, SDHCI_RX_DELAY_LINE));
+	pr_debug("reg_0x31C = 0x%08x, reg_0x544 = 0x%08x\n",
+		 sdhci_readl(host, SDHCI_TX_DELAY_LINE), sdhci_readl(host, CVI_SDHCI_VENDOR_A_STAT_R));
+}
+
+#ifdef CONFIG_MMC_UHS_SUPPORT
+static void cvi_sd_voltage_switch(struct mmc *mmc)
+{
+	pr_debug("%s-%d\n", __func__, __LINE__);
+
+	//enable SDIO0_CLK[7:5] to set CLK max strengh
+	mmio_setbits_32(REG_SDIO0_CLK_PAD_REG, BIT(7) | BIT(6) | BIT(5));
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xB);
+
+	//set SDIO0 PAD to 1.8V mode
+	//=>  0x03000018[5:4] = 2'b11  ,( reg_sd0_ms_ow=1. reg_sd0_ms_sw=0) => MS overwrite to 1 (1.8v mode)
+	mmio_setbits_32(0x3000018, BIT(4) | BIT(5));
+
+	//wait 1ms
+	mdelay(1);
+}
+#endif
+
+int cvi_get_cd(struct sdhci_host *host)
+{
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	pr_debug("%s reg = 0x08%x\n", __func__, reg);
+	if (reg & SDHCI_CARD_PRESENT) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static const struct sdhci_ops cvi_sdhci_ops = {
+	.get_cd	= cvi_get_cd,
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+#ifdef CONFIG_MMC_UHS_SUPPORT
+	.voltage_switch = cvi_sd_voltage_switch,
+#endif
+	.reset = cvi_general_reset,
+};
+
+static const struct sdhci_ops cvi_sdhci_emmc_ops = {
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.platform_execute_tuning = cvi_general_execute_tuning,
+#endif
+	.reset = cvi_general_reset,
+};
+
+static int cvi_sdhci_probe(struct udevice *dev)
+{
+	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(dev);
+	struct cvi_sdhci_plat *plat = dev_get_plat(dev);
+	struct cvi_sdhci_host *cvi_host = dev_get_priv(dev);
+	struct sdhci_host *host = &cvi_host->host;
+	int ret;
+
+	pr_debug("%s-%d: mmc%d probe\n", __func__, __LINE__, host->index);
+	ret = reset_get_by_name(dev, "sdhci", &cvi_host->reset_ctl);
+	if (ret) {
+		pr_debug("warning: reset_get_by_name failed\n");
+	} else {
+		// Try to solve 1.8 to 3.3v converter HW issue
+		ret = reset_assert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed assert reset\n", __func__);
+			return ret;
+		}
+
+		ret = reset_deassert(&cvi_host->reset_ctl);
+		if (ret) {
+			printf("%s failed deassert reset\n", __func__);
+			return ret;
+		}
+	}
+
+	upriv->mmc = &plat->mmc;
+	host->mmc = &plat->mmc;
+	host->mmc->priv = host;
+	host->mmc->dev = dev;
+	pr_debug("host %p, mmc %p, priv %p\n", host, host->mmc, host->mmc->priv);
+
+	ret = sdhci_setup_cfg(&plat->cfg, host, cvi_host->mmc_trans_freq, cvi_host->mmc_init_freq);
+
+	if (ret)
+		return ret;
+
+
+	if (host->index == 0) {
+		host->ops = &cvi_sdhci_emmc_ops;
+		cvi_emmc_pad_setting();
+		sdhci_writew(host, sdhci_readw(host, CVI_SDHCI_VENDOR_EMMC_CTRL_R) | 0x1 << 0,
+			     CVI_SDHCI_VENDOR_EMMC_CTRL_R);
+	} else if (host->index == 1) {
+		host->ops = &cvi_sdhci_ops;
+		if (host->ops && host->ops->get_cd) {
+			int present = host->ops->get_cd(host);
+
+			//set SDIO0 PAD to 3.3V mode
+			//=>  0x03000018[5:4] = 2'b01
+			mmio_setbits_32(0x3000018, BIT(4));
+			pr_debug("SDIO0 PAD 0x%x\n", mmio_read_32(0x3000018));
+
+			if (present == 1) {
+				//Voltage switching flow (3.3)
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0x9);
+				cvi_sdio0_pad_function(false);
+				cvi_sdio0_pad_setting(false);
+			} else {
+				//Voltage close flow
+				//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+				mmio_write_32(TOP_BASE + REG_TOP_SD_PWRSW_CTRL, 0xE);
+				cvi_sdio0_pad_function(true);
+				cvi_sdio0_pad_setting(true);
+			}
+		}
+	} else if (host->index == 2) {
+		pr_debug("sdio1 probe\n");
+		cvi_sdio1_pad_setting();
+	} else {
+		printf("wrong host index : %d !!\n", host->index);
+		return -ENXIO;
+	}
+
+	ret = sdhci_probe(dev);
+
+	if (cvi_host->has_phy) {
+		cvi_sdhci_phy_init(cvi_host);
+	}
+
+	if (host->max_clk == MMC_MAX_CLOCK) {
+		// set IP clock to 375Mhz
+		pr_debug("set IP clock to 375Mhz\n");
+		mmio_write_32(cvi_host->pll_reg, MMC_MAX_CLOCK_DIV_VALUE);
+
+		pr_debug("Be sure to switch clock source to PLL\n");
+		mmio_clrbits_32(CLOCK_BYPASS_SELECT_REGISTER, BIT(cvi_host->pll_index));
+		pr_debug("XTAL->PLL reg = 0x%x\n", mmio_read_32(CLOCK_BYPASS_SELECT_REGISTER));
+
+		pr_debug("eMMC/SD CLK is %d in FPGA_ASIC\n", host->max_clk);
+	}
+
+	if (cvi_host->is_64_addressing) {
+		sdhci_writew(host, sdhci_readw(host, SDHCI_HOST_CONTROL2)
+				| SDHCI_HOST_VER4_ENABLE | SDHCI_HOST_ADDRESSING,
+				SDHCI_HOST_CONTROL2);
+	}
+
+	if (cvi_host->reset_tx_rx_phy) {
+		pr_debug("set tx rx src sel to 0 ======================\n");
+		sdhci_writel(host, 0, SDHCI_RX_DELAY_LINE);
+		sdhci_writel(host, 0, SDHCI_TX_DELAY_LINE);
+	}
+
+	return ret;
+}
+
+static const struct udevice_id cvi_sdhci_match[] = {
+	{ .compatible = "cvitek,synopsys-sdhc" },
+	{ /* sentinel */ }
+};
+
+U_BOOT_DRIVER(cvi_sdhci) = {
+	.name = "cvi_sdhci",
+	.id = UCLASS_MMC,
+	.of_match = cvi_sdhci_match,
+	.of_to_plat = cvi_ofdata_to_platdata,
+	.bind = cvi_sdhci_bind,
+	.probe = cvi_sdhci_probe,
+	.priv_auto = sizeof(struct cvi_sdhci_host),
+	.plat_auto = sizeof(struct cvi_sdhci_plat),
+	.ops = &sdhci_ops,
+};
diff --git a/drivers/mmc/mmc-uclass.c b/drivers/mmc/mmc-uclass.c
index 3ee92d03c..8bfbef8ef 100644
--- a/drivers/mmc/mmc-uclass.c
+++ b/drivers/mmc/mmc-uclass.c
@@ -111,7 +111,7 @@ int mmc_getcd(struct mmc *mmc)
 	return dm_mmc_get_cd(mmc->dev);
 }
 
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 static int dm_mmc_execute_tuning(struct udevice *dev, uint opcode)
 {
 	struct dm_mmc_ops *ops = mmc_get_ops(dev);
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index d3babbfeb..6fc8a1859 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -26,6 +26,13 @@
 #include <div64.h>
 #include "mmc_private.h"
 
+#ifdef DEBUG
+#define debug(fmt, args...)			\
+	printf("%s,%d"fmt, __func__, __LINE__, ##args)
+#define pr_debug(fmt, ...) \
+	printf(fmt, ##__VA_ARGS__)
+#endif
+
 #define DEFAULT_CMD6_TIMEOUT_MS  500
 
 static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
@@ -166,12 +173,18 @@ static uint mmc_mode2freq(struct mmc *mmc, enum bus_mode mode)
 	      [SD_HS]		= 50000000,
 	      [MMC_HS_52]	= 52000000,
 	      [MMC_DDR_52]	= 52000000,
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	      [UHS_SDR12]	= 25000000,
 	      [UHS_SDR25]	= 50000000,
 	      [UHS_SDR50]	= 100000000,
 	      [UHS_DDR50]	= 50000000,
-	      [UHS_SDR104]	= 208000000,
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	      [UHS_SDR104]	= 200000000,
+#endif
+#endif
+#ifdef CONFIG_MMC_HS200_SUPPORT
 	      [MMC_HS_200]	= 200000000,
+#endif
 	      [MMC_HS_400]	= 200000000,
 	      [MMC_HS_400_ES]	= 200000000,
 	};
@@ -194,6 +207,24 @@ static int mmc_select_mode(struct mmc *mmc, enum bus_mode mode)
 	return 0;
 }
 
+#ifdef CONFIG_MMC_UHS_SUPPORT
+int dm_mmc_set_voltage(struct udevice *dev)
+{
+	struct dm_mmc_ops *ops = mmc_get_ops(dev);
+
+	if (!ops->set_voltage)
+		return -EIO;
+
+	ops->set_voltage(dev);
+	return 0;
+}
+
+int mmc_set_voltage(struct mmc *mmc)
+{
+	return dm_mmc_set_voltage(mmc->dev);
+}
+#endif
+
 #if !CONFIG_IS_ENABLED(DM_MMC)
 int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 {
@@ -325,7 +356,7 @@ int mmc_set_blocklen(struct mmc *mmc, int len)
 				   MMC_QUIRK_RETRY_SET_BLOCKLEN, 4);
 }
 
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 static const u8 tuning_blk_pattern_4bit[] = {
 	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
 	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
@@ -526,7 +557,7 @@ static int mmc_go_idle(struct mmc *mmc)
 	return 0;
 }
 
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
 {
 	struct mmc_cmd cmd;
@@ -555,7 +586,7 @@ static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
 	 * after the response of cmd11, but wait 100 us to be sure
 	 */
 	err = mmc_wait_dat0(mmc, 0, 100);
-	if (err == -ENOSYS)
+	if (err == -EIO)
 		udelay(100);
 	else if (err)
 		return -ETIMEDOUT;
@@ -566,6 +597,9 @@ static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
 	 */
 	mmc_set_clock(mmc, mmc->clock, MMC_CLK_DISABLE);
 
+	//wait 1ms
+	mdelay(1);
+
 	err = mmc_set_signal_voltage(mmc, signal_voltage);
 	if (err)
 		return err;
@@ -579,7 +613,7 @@ static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
 	 * dat[0:3] low. Wait for at least 1 ms according to spec
 	 */
 	err = mmc_wait_dat0(mmc, 1, 1000);
-	if (err == -ENOSYS)
+	if (err == -EIO)
 		udelay(1000);
 	else if (err)
 		return -ETIMEDOUT;
@@ -653,12 +687,13 @@ static int sd_send_op_cond(struct mmc *mmc, bool uhs_en)
 
 	mmc->ocr = cmd.response[0];
 
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	if (uhs_en && !(mmc_host_is_spi(mmc)) && (cmd.response[0] & 0x41000000)
 	    == 0x41000000) {
 		err = mmc_switch_voltage(mmc, MMC_SIGNAL_VOLTAGE_180);
 		if (err)
 			return err;
+
 	}
 #endif
 
@@ -875,7 +910,7 @@ static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode,
 	case MMC_DDR_52:
 		speed_bits = EXT_CSD_TIMING_HS;
 		break;
-#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+#ifdef CONFIG_MMC_HS200_SUPPORT
 	case MMC_HS_200:
 		speed_bits = EXT_CSD_TIMING_HS200;
 		break;
@@ -954,7 +989,7 @@ static int mmc_get_capabilities(struct mmc *mmc)
 	cardtype = ext_csd[EXT_CSD_CARD_TYPE];
 	mmc->cardtype = cardtype;
 
-#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+#ifdef CONFIG_MMC_HS200_SUPPORT
 	if (cardtype & (EXT_CSD_CARD_TYPE_HS200_1_2V |
 			EXT_CSD_CARD_TYPE_HS200_1_8V)) {
 		mmc->card_caps |= MMC_MODE_HS200;
@@ -1283,7 +1318,7 @@ static int sd_get_capabilities(struct mmc *mmc)
 	ALLOC_CACHE_ALIGN_BUFFER(__be32, switch_status, 16);
 	struct mmc_data data;
 	int timeout;
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	u32 sd3_bus_mode;
 #endif
 
@@ -1360,7 +1395,7 @@ static int sd_get_capabilities(struct mmc *mmc)
 	if (__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED)
 		mmc->card_caps |= MMC_CAP(SD_HS);
 
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	/* Version before 3.0 don't support UHS modes */
 	if (mmc->version < SD_VERSION_3)
 		return 0;
@@ -1399,7 +1434,7 @@ static int sd_set_card_speed(struct mmc *mmc, enum bus_mode mode)
 	case SD_HS:
 		speed = HIGH_SPEED_BUS_SPEED;
 		break;
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	case UHS_SDR12:
 		speed = UHS_SDR12_BUS_SPEED;
 		break;
@@ -1563,7 +1598,7 @@ static inline int bus_width(uint cap)
 }
 
 #if !CONFIG_IS_ENABLED(DM_MMC)
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 static int mmc_execute_tuning(struct mmc *mmc, uint opcode)
 {
 	return -ENOTSUPP;
@@ -1644,12 +1679,12 @@ void mmc_dump_capabilities(const char *text, uint caps)
 struct mode_width_tuning {
 	enum bus_mode mode;
 	uint widths;
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 	uint tuning;
 #endif
 };
 
-#if CONFIG_IS_ENABLED(MMC_IO_VOLTAGE)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 int mmc_voltage_to_mv(enum mmc_voltage voltage)
 {
 	switch (voltage) {
@@ -1669,6 +1704,8 @@ static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
 		return 0;
 
 	mmc->signal_voltage = signal_voltage;
+
+	err = mmc_set_voltage(mmc);
 	err = mmc_set_ios(mmc);
 	if (err)
 		pr_debug("unable to set voltage (err %d)\n", err);
@@ -1684,8 +1721,8 @@ static inline int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
 
 #if !CONFIG_IS_ENABLED(MMC_TINY)
 static const struct mode_width_tuning sd_modes_by_pref[] = {
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_UHS_SUPPORT
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 	{
 		.mode = UHS_SDR104,
 		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
@@ -1709,7 +1746,7 @@ static const struct mode_width_tuning sd_modes_by_pref[] = {
 		.mode = SD_HS,
 		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
 	},
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	{
 		.mode = UHS_SDR12,
 		.widths = MMC_MODE_4BIT | MMC_MODE_1BIT,
@@ -1732,7 +1769,7 @@ static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
 	int err;
 	uint widths[] = {MMC_MODE_4BIT, MMC_MODE_1BIT};
 	const struct mode_width_tuning *mwt;
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	bool uhs_en = (mmc->ocr & OCR_S18R) ? true : false;
 #else
 	bool uhs_en = false;
@@ -1757,8 +1794,8 @@ static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
 	}
 
 	/* Restrict card's capabilities by what the host can do */
-	caps = card_caps & mmc->host_caps;
-
+	//caps = card_caps & mmc->host_caps;
+	caps = mmc->host_caps;
 	if (!uhs_en)
 		caps &= ~UHS_CAPS;
 
@@ -1788,7 +1825,7 @@ static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
 				mmc_set_clock(mmc, mmc->tran_speed,
 						MMC_CLK_ENABLE);
 
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 				/* execute tuning if needed */
 				if (mwt->tuning && !mmc_host_is_spi(mmc)) {
 					err = mmc_execute_tuning(mmc,
@@ -1918,12 +1955,14 @@ static const struct mode_width_tuning mmc_modes_by_pref[] = {
 		.tuning = MMC_CMD_SEND_TUNING_BLOCK_HS200
 	},
 #endif
-#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
+#ifdef CONFIG_MMC_HS200_SUPPORT
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 	{
 		.mode = MMC_HS_200,
 		.widths = MMC_MODE_8BIT | MMC_MODE_4BIT,
 		.tuning = MMC_CMD_SEND_TUNING_BLOCK_HS200
 	},
+#endif
 #endif
 	{
 		.mode = MMC_DDR_52,
@@ -2166,7 +2205,7 @@ static int mmc_select_mode_and_width(struct mmc *mmc, uint card_caps)
 				mmc_select_mode(mmc, mwt->mode);
 				mmc_set_clock(mmc, mmc->tran_speed,
 					      MMC_CLK_ENABLE);
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 
 				/* execute tuning if needed */
 				if (mwt->tuning) {
diff --git a/drivers/mmc/sdhci.c b/drivers/mmc/sdhci.c
index 03bfd9d18..b105fa864 100644
--- a/drivers/mmc/sdhci.c
+++ b/drivers/mmc/sdhci.c
@@ -22,6 +22,13 @@
 #include <phys2bus.h>
 #include <power/regulator.h>
 
+#ifdef DEBUG
+#define debug(fmt, args...)			\
+	printf("%s,%d"fmt, __func__, __LINE__, ##args)
+#define pr_debug(fmt, ...) \
+	printf(fmt, ##__VA_ARGS__)
+#endif
+
 static void sdhci_reset(struct sdhci_host *host, u8 mask)
 {
 	unsigned long timeout;
@@ -38,6 +45,9 @@ static void sdhci_reset(struct sdhci_host *host, u8 mask)
 		timeout--;
 		udelay(1000);
 	}
+
+	if (host->ops && host->ops->reset)
+		host->ops->reset(host, mask);
 }
 
 static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
@@ -106,7 +116,15 @@ static void sdhci_prepare_dma(struct sdhci_host *host, struct mmc_data *data,
 
 	if (host->flags & USE_SDMA) {
 		dma_addr = dev_phys_to_bus(mmc_to_dev(host->mmc), host->start_addr);
-		sdhci_writel(host, dma_addr, SDHCI_DMA_ADDRESS);
+		if (sdhci_readw(host, SDHCI_HOST_CONTROL2) & SDHCI_HOST_VER4_ENABLE) {
+			sdhci_writel(host, dma_addr, SDHCI_ADMA_ADDRESS);
+			sdhci_writel(host, (dma_addr >> 32), SDHCI_ADMA_ADDRESS_HI);
+			sdhci_writel(host, data->blocks, SDHCI_DMA_ADDRESS);
+			sdhci_writew(host, 0, SDHCI_BLOCK_COUNT);
+		} else {
+			sdhci_writel(host, dma_addr, SDHCI_DMA_ADDRESS);
+			sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
+		}
 	}
 #if CONFIG_IS_ENABLED(MMC_SDHCI_ADMA)
 	else if (host->flags & (USE_ADMA | USE_ADMA64)) {
@@ -166,7 +184,12 @@ static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data)
 				start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
 				start_addr = dev_phys_to_bus(mmc_to_dev(host->mmc),
 							     start_addr);
-				sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+				if (sdhci_readw(host, SDHCI_HOST_CONTROL2) & SDHCI_HOST_VER4_ENABLE) {
+					sdhci_writel(host, start_addr, SDHCI_ADMA_ADDRESS);
+					sdhci_writel(host, (start_addr >> 32), SDHCI_ADMA_ADDRESS_HI);
+				} else {
+					sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+				}
 			}
 		}
 		if (timeout-- > 0)
@@ -184,7 +207,6 @@ static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data)
 
 	return 0;
 }
-
 /*
  * No command will be sent by driver if card is busy, so driver must wait
  * for card ready state.
@@ -196,6 +218,12 @@ static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data)
 #define SDHCI_CMD_DEFAULT_TIMEOUT		100
 #define SDHCI_READ_STATUS_TIMEOUT		1000
 
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+void *aligned_buffer = (void *)CONFIG_FIXED_SDHCI_ALIGNED_BUFFER;
+#else
+void *aligned_buffer;
+#endif
+
 #ifdef CONFIG_DM_MMC
 static int sdhci_send_command(struct udevice *dev, struct mmc_cmd *cmd,
 			      struct mmc_data *data)
@@ -289,12 +317,10 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
 				data->blocksize),
 				SDHCI_BLOCK_SIZE);
-		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
 		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
 	} else if (cmd->resp_type & MMC_RSP_BUSY) {
 		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
 	}
-
 	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
 	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
 	start = get_timer(0);
@@ -320,8 +346,9 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 	} else
 		ret = -1;
 
-	if (!ret && data)
+	if (!ret && data) {
 		ret = sdhci_transfer_data(host, data);
+	}
 
 	if (host->quirks & SDHCI_QUIRK_WAIT_SEND_CMD)
 		udelay(1000);
@@ -343,7 +370,7 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 		return -ECOMM;
 }
 
-#if defined(CONFIG_DM_MMC) && defined(MMC_SUPPORTS_TUNING)
+#if defined(CONFIG_DM_MMC) && defined(CONFIG_MMC_SUPPORTS_TUNING)
 static int sdhci_execute_tuning(struct udevice *dev, uint opcode)
 {
 	int err;
@@ -367,6 +394,7 @@ int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
 	unsigned int div, clk = 0, timeout;
 	int ret;
 
+	pr_debug("mmc%d : Set clock %d, host->max_clk %d\n", host->index, clock, host->max_clk);
 	/* Wait max 20 ms */
 	timeout = 200;
 	while (sdhci_readl(host, SDHCI_PRESENT_STATE) &
@@ -437,10 +465,15 @@ int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
 	if (host->ops && host->ops->set_clock)
 		host->ops->set_clock(host, div);
 
+	pr_debug("mmc%d : clk div 0x%x\n", host->index, div);
+
 	clk |= (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
 	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
 		<< SDHCI_DIVIDER_HI_SHIFT;
 	clk |= SDHCI_CLOCK_INT_EN;
+
+	pr_debug("mmc%d : 0x2c clk reg 0x%x\n", host->index, clk);
+
 	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 
 	/* Wait max 20 ms */
@@ -522,99 +555,116 @@ void sdhci_set_uhs_timing(struct sdhci_host *host)
 	sdhci_writew(host, reg, SDHCI_HOST_CONTROL2);
 }
 
-static void sdhci_set_voltage(struct sdhci_host *host)
+static int sdhci_card_busy(struct udevice *dev, int state, int timeout_us)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+	struct sdhci_host *host = mmc->priv;
+	int ret = -ETIMEDOUT;
+	bool dat0_high;
+	bool target_dat0_high = !!state;
+
+	timeout_us = DIV_ROUND_UP(timeout_us, 10); /* check every 10 us. */
+	while (timeout_us--) {
+		dat0_high = !!(sdhci_readl(host, SDHCI_PRESENT_STATE) & BIT(20));
+		if (dat0_high == target_dat0_high) {
+			ret = 0;
+			break;
+		}
+		udelay(10);
+	}
+	return ret;
+}
+
+#ifdef CONFIG_MMC_UHS_SUPPORT
+static void sdhci_set_voltage(struct udevice *dev)
 {
-	if (IS_ENABLED(CONFIG_MMC_IO_VOLTAGE)) {
-		struct mmc *mmc = (struct mmc *)host->mmc;
-		u32 ctrl;
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+	struct sdhci_host *host = mmc->priv;
+	u32 ctrl;
 
-		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 
-		switch (mmc->signal_voltage) {
-		case MMC_SIGNAL_VOLTAGE_330:
+	switch (mmc->signal_voltage) {
+	case MMC_SIGNAL_VOLTAGE_330:
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
-			if (mmc->vqmmc_supply) {
-				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, false)) {
-					pr_err("failed to disable vqmmc-supply\n");
-					return;
-				}
+		if (mmc->vqmmc_supply) {
+			if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, false)) {
+				pr_debug("failed to disable vqmmc-supply\n");
+				return;
+			}
 
-				if (regulator_set_value(mmc->vqmmc_supply, 3300000)) {
-					pr_err("failed to set vqmmc-voltage to 3.3V\n");
-					return;
-				}
+			if (regulator_set_value(mmc->vqmmc_supply, 3300000)) {
+				pr_debug("failed to set vqmmc-voltage to 3.3V\n");
+				return;
+			}
 
-				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, true)) {
-					pr_err("failed to enable vqmmc-supply\n");
-					return;
-				}
+			if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, true)) {
+				pr_debug("failed to enable vqmmc-supply\n");
+				return;
 			}
+		}
 #endif
-			if (IS_SD(mmc)) {
-				ctrl &= ~SDHCI_CTRL_VDD_180;
-				sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
-			}
+		if (IS_SD(mmc)) {
+			ctrl &= ~SDHCI_CTRL_VDD_180;
+			sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+		}
 
-			/* Wait for 5ms */
-			mdelay(5);
+		/* Wait for 5ms */
+		mdelay(5);
 
-			/* 3.3V regulator output should be stable within 5 ms */
-			if (IS_SD(mmc)) {
-				if (ctrl & SDHCI_CTRL_VDD_180) {
-					pr_err("3.3V regulator output did not become stable\n");
-					return;
-				}
+		/* 3.3V regulator output should be stable within 5 ms */
+		if (IS_SD(mmc)) {
+			if (ctrl & SDHCI_CTRL_VDD_180) {
+				pr_debug("3.3V regulator output did not become stable\n");
+				return;
 			}
+		}
 
-			break;
-		case MMC_SIGNAL_VOLTAGE_180:
+		break;
+	case MMC_SIGNAL_VOLTAGE_180:
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
-			if (mmc->vqmmc_supply) {
-				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, false)) {
-					pr_err("failed to disable vqmmc-supply\n");
-					return;
-				}
+		if (mmc->vqmmc_supply) {
+			if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, false)) {
+				pr_debug("failed to disable vqmmc-supply\n");
+				return;
+			}
 
-				if (regulator_set_value(mmc->vqmmc_supply, 1800000)) {
-					pr_err("failed to set vqmmc-voltage to 1.8V\n");
-					return;
-				}
+			if (regulator_set_value(mmc->vqmmc_supply, 1800000)) {
+				pr_debug("failed to set vqmmc-voltage to 1.8V\n");
+				return;
+			}
 
-				if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, true)) {
-					pr_err("failed to enable vqmmc-supply\n");
-					return;
-				}
+			if (regulator_set_enable_if_allowed(mmc->vqmmc_supply, true)) {
+				pr_debug("failed to enable vqmmc-supply\n");
+				return;
 			}
+		}
 #endif
-			if (IS_SD(mmc)) {
-				ctrl |= SDHCI_CTRL_VDD_180;
-				sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
-			}
+		if (IS_SD(mmc)) {
+			ctrl |= SDHCI_CTRL_VDD_180;
+			sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+		}
 
-			/* Wait for 5 ms */
-			mdelay(5);
+		if (host->ops && host->ops->voltage_switch)
+			host->ops->voltage_switch(mmc);
 
-			/* 1.8V regulator output has to be stable within 5 ms */
-			if (IS_SD(mmc)) {
-				if (!(ctrl & SDHCI_CTRL_VDD_180)) {
-					pr_err("1.8V regulator output did not become stable\n");
-					return;
-				}
+		/* 1.8V regulator output has to be stable within 5 ms */
+		if (IS_SD(mmc)) {
+			ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+			if (!(ctrl & SDHCI_CTRL_VDD_180)) {
+				pr_debug("1.8V regulator output did not become stable\n");
+				return;
 			}
-
-			break;
-		default:
-			/* No signal voltage switch required */
-			return;
 		}
-	}
-}
 
-void sdhci_set_control_reg(struct sdhci_host *host)
-{
-	sdhci_set_voltage(host);
+		break;
+	default:
+		/* No signal voltage switch required */
+		return;
+	}
 	sdhci_set_uhs_timing(host);
 }
+#endif
 
 #ifdef CONFIG_DM_MMC
 static int sdhci_set_ios(struct udevice *dev)
@@ -628,14 +678,10 @@ static int sdhci_set_ios(struct mmc *mmc)
 	struct sdhci_host *host = mmc->priv;
 	bool no_hispd_bit = false;
 
-	if (host->ops && host->ops->set_control_reg)
-		host->ops->set_control_reg(host);
-
-	if (mmc->clock != host->clock)
-		sdhci_set_clock(mmc, mmc->clock);
-
 	if (mmc->clk_disable)
 		sdhci_set_clock(mmc, 0);
+	else if (mmc->clock != host->clock)
+		sdhci_set_clock(mmc, mmc->clock);
 
 	/* Set bus width */
 	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
@@ -714,10 +760,20 @@ static int sdhci_init(struct mmc *mmc)
 	}
 #endif
 
-	sdhci_set_power(host, fls(mmc->cfg->voltages) - 1);
+	if (host->ops && host->ops->get_cd) {
+		int present = host->ops->get_cd(host);
 
-	if (host->ops && host->ops->get_cd)
-		host->ops->get_cd(host);
+		if (present == 1) {
+			sdhci_set_power(host, fls(mmc->cfg->voltages) - 1);
+			mdelay(5);
+		} else if (present == 0) {
+			sdhci_set_power(host, (unsigned short)-1);
+			mdelay(30);
+		}
+	} else {
+		sdhci_set_power(host, fls(mmc->cfg->voltages) - 1);
+		mdelay(5);
+	}
 
 	/* Enable only interrupts served by the SD controller */
 	sdhci_writel(host, SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK,
@@ -785,8 +841,12 @@ const struct dm_mmc_ops sdhci_ops = {
 	.set_ios	= sdhci_set_ios,
 	.get_cd		= sdhci_get_cd,
 	.deferred_probe	= sdhci_deferred_probe,
-#ifdef MMC_SUPPORTS_TUNING
-	.execute_tuning	= sdhci_execute_tuning,
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
+	.execute_tuning = sdhci_execute_tuning,
+#endif
+	.wait_dat0 = sdhci_card_busy,
+#ifdef CONFIG_MMC_UHS_SUPPORT
+	.set_voltage = sdhci_set_voltage,
 #endif
 };
 #else
@@ -803,11 +863,11 @@ int sdhci_setup_cfg(struct mmc_config *cfg, struct sdhci_host *host,
 	u32 caps, caps_1 = 0;
 #if CONFIG_IS_ENABLED(DM_MMC)
 	u64 dt_caps, dt_caps_mask;
-
 	dt_caps_mask = dev_read_u64_default(host->mmc->dev,
 					    "sdhci-caps-mask", 0);
 	dt_caps = dev_read_u64_default(host->mmc->dev,
 				       "sdhci-caps", 0);
+
 	caps = ~lower_32_bits(dt_caps_mask) &
 	       sdhci_readl(host, SDHCI_CAPABILITIES);
 	caps |= lower_32_bits(dt_caps);
@@ -924,6 +984,10 @@ int sdhci_setup_cfg(struct mmc_config *cfg, struct sdhci_host *host,
 		caps_1 &= ~(SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_SDR50 |
 			    SDHCI_SUPPORT_DDR50);
 
+	if (host->quirks & SDHCI_QUIRK_NO_1_8_V)
+		caps_1 &= ~(SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_SDR50 |
+			    SDHCI_SUPPORT_DDR50);
+
 	if (caps_1 & (SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_SDR50 |
 		      SDHCI_SUPPORT_DDR50))
 		cfg->host_caps |= MMC_CAP(UHS_SDR12) | MMC_CAP(UHS_SDR25);
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index a901ce551..425196e32 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -459,4 +459,12 @@ config SPL_NAND_SIMPLE
 	  expose the cmd_ctrl() interface.
 endif
 
+config NAND_FLASH_CVSNFC_V3
+	bool "Use cvitek nand flash driver version 3"
+	help
+	  CVITEK nand flash cvsnfc version 3 does not store system vector in
+	  nand flash block 0 and block 1.
+	  This version is optimized from the driver of cv182x.
+	  And it should speed up power on time while booting.
+
 endif   # if NAND
diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
index a5ed2c536..1d5a00cf1 100644
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_NAND_ECC_BCH) += nand_bch.o
 obj-$(CONFIG_NAND_ATMEL) += atmel_nand.o
 obj-$(CONFIG_NAND_ARASAN) += arasan_nfc.o
 obj-$(CONFIG_NAND_BRCMNAND) += brcmnand/
+obj-$(CONFIG_NAND_FLASH_CVSNFC) += cvitek/
 obj-$(CONFIG_NAND_DAVINCI) += davinci_nand.o
 obj-$(CONFIG_NAND_DENALI) += denali.o
 obj-$(CONFIG_NAND_DENALI_DT) += denali_dt.o
diff --git a/drivers/mtd/nand/raw/cvitek/Makefile b/drivers/mtd/nand/raw/cvitek/Makefile
new file mode 100644
index 000000000..449220feb
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/Makefile
@@ -0,0 +1,3 @@
+obj-y += cvsnfc_common.o
+cvsvfc-y += cvsnfc.o cvsnfc_spi_ids.o
+obj-$(CONFIG_NAND_FLASH_CVSNFC)	+= cvsvfc.o
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc.c b/drivers/mtd/nand/raw/cvitek/cvsnfc.c
new file mode 100644
index 000000000..ce1b96da8
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc.c
@@ -0,0 +1,1810 @@
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <malloc.h>
+//#include <match_table.h>
+#include <linux/mtd/nand.h>
+#include <cvsnfc_common.h>
+#include <cvsnfc_spi_ids.h>
+#include <cvsnfc.h>
+#include <watchdog.h>
+
+#ifdef CONFIG_ARCH_MMU
+#include <asm/cache-cp15.h>
+#endif
+
+#if CONFIG_IS_ENABLED(RISCV)
+#include <asm/cache.h>
+#endif
+
+//#define CVSNFC_DEBUG
+#ifdef CVSNFC_DEBUG
+#define DEBUG_ERASE	1
+#define DEBUG_WRITE	1
+#define DEBUG_READ	1
+#define DEBUG_DMA	1
+#define DEBUG_REG	1
+#define DEBUG_CMD_FLOW	1
+#define DEBUG_ECC	1
+#else
+#define DEBUG_ERASE	0
+#define DEBUG_WRITE	0
+#define DEBUG_READ	0
+#define DEBUG_DMA	0
+#define DEBUG_REG	0
+#define DEBUG_CMD_FLOW	0
+#define DEBUG_ECC	0
+#endif
+
+#ifdef DEBUG_WRITE_TWICE
+uint8_t dbg_pg_buf[MAX_PAGE_SIZE + MAX_SPARE_SIZE];
+#endif
+
+static int cvsnfc_dev_ready(struct mtd_info *mtd);
+//static void cvsnfc_ctrl_ecc(struct mtd_info *mtd, bool enable);
+static void  cvsnfc_setup_intr(struct cvsnfc_host *host);
+
+static struct cvsnfc_host snfc_host = {
+	.chip = NULL,
+};
+
+/*****************************************************************************/
+void cvsnfc_register_dump(void)
+{
+	if (DEBUG_REG) {
+		int ix;
+		void __iomem *regbase = (void __iomem *)CONFIG_CVSNFC_REG_BASE_ADDRESS;
+
+		printf("Register dump:");
+		for (ix = 0; ix <= 0x7C; ix += 0x04) {
+			if (!(ix & 0x0F))
+				printf("\n0x%08lX: ", (uintptr_t)(regbase + ix));
+			printf("%08X ", readl(regbase + ix));
+		}
+		printf("\n");
+	}
+}
+
+/*****************************************************************************/
+/* Send set/get features command to SPI Nand flash */
+#define DEBUG_SPI_NAND_DRV 0
+
+void spi_feature_op(struct cvsnfc_host *host, int op, int fe, unsigned int *val)
+{
+	if (op == GET_OP) {
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 1 << TRX_DATA_SIZE_SHIFT | 1 << TRX_CMD_CONT_SIZE_SHIFT);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, fe << 8 | SPI_NAND_CMD_GET_FEATURE);
+
+		cvsnfc_setup_intr(host);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+		CVSNFC_CMD_WAIT_CPU_FINISH(host);
+		CVSNFC_CLEAR_INT(host);
+
+		*val = cvsfc_read(host, REG_SPI_NAND_RX_DATA) & 0xff;
+		if (DEBUG_CMD_FLOW)
+			pr_info("cvsnfc: get feature [%#x]<==[%#x]\n", fe, *val);
+	} else {
+		uint32_t fe_set = fe | (*val << 8);
+
+		if (DEBUG_CMD_FLOW)
+			pr_info("cvsnfc: set feature [%#x] = [%#x]\n", fe, *val);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 2 << TRX_CMD_CONT_SIZE_SHIFT);
+		cvsfc_write(host,  REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_RW);
+		cvsfc_write(host,  REG_SPI_NAND_TRX_CMD0, (fe_set << TRX_CMD_CONT0_SHIFT) | SPI_NAND_CMD_SET_FEATURE);
+
+		cvsnfc_setup_intr(host);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+		CVSNFC_CMD_WAIT_CPU_FINISH(host);
+		CVSNFC_CLEAR_INT(host);
+	}
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_pageprog(struct cvsnfc_host *host)
+{
+	unsigned char pages_per_block_shift;
+	unsigned int val, block_num, block_num_h, page_num;
+	struct cvsnfc_op *spi = host->spi;
+	struct nand_chip *chip = host->chip;
+#ifdef CVSNFC_SUPPORT_REG_WRITE
+	const char *op_type = "reg";
+#else
+	const char *op_type = "dma";
+#endif
+
+	if (DEBUG_WRITE)
+		pr_info("* Enter %s page program!\n", op_type);
+
+	val = spi->driver->wait_ready(spi);
+	if (val) {
+		printf("%s: %s page program wait ready fail! status[%#x]\n",
+		       __func__, op_type, val);
+		return;
+	}
+
+	if (spi->driver->write_enable(spi)) {
+		printf("%s %s page program write enable failed!\n", __func__,
+		       op_type);
+		return;
+	}
+
+	host->set_system_clock(spi->write, ENABLE);
+
+	val = CVSNFC_INT_CLR_ALL;
+	cvsfc_write(host, CVSNFC_INT_CLR, val);
+	if (DEBUG_WRITE)
+		pr_info("  Set REG INT_CLR[0x14]%#x\n", val);
+
+	val = CVSNFC_OP_CFG_MEM_IF_TYPE(spi->write->iftype);
+	cvsfc_write(host, CVSNFC_OP_CFG, val);
+
+	if (DEBUG_WRITE)
+		pr_info("  Set REG OP_CFG[0x28]%#x\n", val);
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+	val = CVSNFC_ADDRH_SET(block_num_h);
+	cvsfc_write(host, CVSNFC_ADDRH, val);
+	if (DEBUG_WRITE)
+		pr_info("  Set REG ADDRH[0x2c]%#x\n", val);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	val = ((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT)
+	     | ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT);
+	cvsfc_write(host, CVSNFC_ADDRL, val);
+
+	if (DEBUG_WRITE)
+		pr_info("  Set REG ADDRL[0x30]%#x\n", val);
+
+#ifndef CVSNFC_SUPPORT_REG_WRITE
+	val = CVSNFC_DMA_CTRL_ALL_ENABLE;
+	cvsfc_write(host, CVSNFC_DMA_CTRL, val);
+	if (DEBUG_WRITE)
+		pr_info("  Set REG DMA_CTRL[0x3c]%#x\n", val);
+
+	val = host->dma_buffer;
+	cvsfc_write(host, CVSNFC_DMA_SADDR_D, val);
+	if (DEBUG_WRITE)
+		pr_info("  Set REG DMA_SADDR_D[0x40]%#x\n", val);
+
+	val = host->dma_oob;
+	cvsfc_write(host, CVSNFC_DMA_SADDR_OOB, val);
+	if (DEBUG_WRITE)
+		pr_info("  Set REG DMA_SADDR_OOB[%#x]%#x\n",
+			 CVSNFC_DMA_SADDR_OOB, val);
+#ifdef CONFIG_ARCH_MMU
+	dcache_clean_range((unsigned int)host->dma_buffer,
+			   (unsigned int)(host->dma_buffer +
+			   host->pagesize + host->oobsize));
+#endif
+
+#endif
+
+	val = CVSNFC_OP_CTRL_WR_OPCODE(spi->write->cmd)
+		| CVSNFC_OP_CTRL_CS_OP(host->cmd_option.chipselect)
+#ifdef CVSNFC_SUPPORT_REG_WRITE
+		| CVSNFC_OP_CTRL_OP_TYPE(OP_TYPE_REG)
+#else
+		| CVSNFC_OP_CTRL_OP_TYPE(OP_TYPE_DMA)
+#endif
+		| CVSNFC_OP_CTRL_RW_OP(RW_OP_WRITE)
+		| CVSNFC_OP_CTRL_OP_READY;
+	cvsfc_write(host, CVSNFC_OP_CTRL, val);
+	if (DEBUG_WRITE)
+		pr_info("  Set REG OP_CTRL[0x34]%#x\n", val);
+
+	CVSNFC_DMA_WAIT_INT_FINISH(host);
+
+	if (DEBUG_WRITE) {
+		val = spi->driver->wait_ready(spi);
+
+		if (val & STATUS_P_FAIL_MASK)
+			printf("cvsnfc: %s page program failed! status[%#x]\n",
+			       op_type, val);
+	}
+
+	if (DEBUG_WRITE)
+		pr_info("* End %s page program!\n", op_type);
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_readstart(struct cvsnfc_host *host)
+{
+	unsigned char pages_per_block_shift, only_oob = 0;
+	unsigned short wrap = 0;
+	unsigned int val, block_num, block_num_h, page_num, addr_of = 0;
+	struct cvsnfc_op *spi = host->spi;
+	struct nand_chip *chip = host->chip;
+
+#ifdef CVSNFC_SUPPORT_REG_READ
+	char *op_type = "reg";
+#else
+	char *op_type = "dma";
+#endif
+
+	if (DEBUG_READ)
+		pr_info("* Enter %s page read start!\n", op_type);
+
+	if ((host->addr_value[0] == host->cache_addr_value[0]) &&
+	    (host->addr_value[1] == host->cache_addr_value[1])) {
+		if (DEBUG_READ)
+			pr_info("* %s page read cache hit! addr1[%#x], addr0[%#x]\n",
+				 op_type, host->addr_value[1], host->addr_value[0]);
+		return;
+	}
+
+	val = spi->driver->wait_ready(spi);
+	if (val) {
+		printf("%s: %s read wait ready fail! status[%#x]\n", __func__,
+		       op_type, val);
+		return;
+	}
+
+	host->set_system_clock(spi->read, ENABLE);
+
+	val = CVSNFC_INT_CLR_ALL;
+	cvsfc_write(host, CVSNFC_INT_CLR, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG INT_CLR[0x14]%#x\n", val);
+
+	if (host->cmd_option.last_cmd == NAND_CMD_READOOB) {
+		only_oob = 1;
+		host->cmd_option.op_config =
+				CVSNFC_OP_CFG_RD_OP_SEL(RD_OP_READ_OOB);
+	} else
+		host->cmd_option.op_config =
+				CVSNFC_OP_CFG_RD_OP_SEL(RD_OP_READ_PAGE);
+
+	val = host->cmd_option.op_config
+		| CVSNFC_OP_CFG_MEM_IF_TYPE(spi->read->iftype)
+		| CVSNFC_OP_CFG_DUMMY_ADDR_NUM(spi->read->dummy);
+	cvsfc_write(host, CVSNFC_OP_CFG, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG OP_CFG[0x28]%#x\n", val);
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+
+	val = CVSNFC_ADDRH_SET(block_num_h);
+	cvsfc_write(host, CVSNFC_ADDRH, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG ADDRH[0x2c]%#x\n", val);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	if (only_oob)
+		switch (host->ecctype) {
+		case NAND_ECC_8BIT:
+			addr_of = REG_CNT_ECC_8BIT_OFFSET;
+			break;
+		case NAND_ECC_16BIT:
+			addr_of = REG_CNT_ECC_16BIT_OFFSET;
+			break;
+		case NAND_ECC_24BIT:
+			addr_of = REG_CNT_ECC_24BIT_OFFSET;
+			break;
+		case NAND_ECC_0BIT:
+		default:
+			break;
+		}
+
+	val = (((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT)
+		| ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT)
+		| ((wrap & REG_CNT_WRAP_MASK) << REG_CNT_WRAP_SHIFT)
+		| (addr_of & REG_CNT_ECC_OFFSET_MASK));
+	cvsfc_write(host, CVSNFC_ADDRL, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG ADDRL[0x30]%#x\n", val);
+
+#ifndef CVSNFC_SUPPORT_REG_READ
+	val = CVSNFC_DMA_CTRL_ALL_ENABLE;
+	cvsfc_write(host, CVSNFC_DMA_CTRL, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG DMA_CTRL[0x3c]%#x\n", val);
+
+	val = host->dma_buffer;
+	cvsfc_write(host, CVSNFC_DMA_SADDR_D, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG DMA_SADDR_D[0x40]%#x\n", val);
+
+	val = host->dma_oob;
+	cvsfc_write(host, CVSNFC_DMA_SADDR_OOB, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG DMA_SADDR_OOB[%#x]%#x\n",
+			 CVSNFC_DMA_SADDR_OOB, val);
+
+#ifdef CONFIG_ARCH_MMU
+	dcache_inv_range((unsigned int)host->dma_buffer,
+			 (unsigned int)(host->dma_buffer +
+			 host->pagesize + host->oobsize));
+#endif
+
+#endif
+
+	val = CVSNFC_OP_CTRL_RD_OPCODE(spi->read->cmd)
+		| CVSNFC_OP_CTRL_CS_OP(host->cmd_option.chipselect)
+#ifdef CVSNFC_SUPPORT_REG_READ
+		| CVSNFC_OP_CTRL_OP_TYPE(OP_TYPE_REG)
+#else
+		| CVSNFC_OP_CTRL_OP_TYPE(OP_TYPE_DMA)
+#endif
+		| CVSNFC_OP_CTRL_RW_OP(RW_OP_READ)
+		| CVSNFC_OP_CTRL_OP_READY;
+	cvsfc_write(host, CVSNFC_OP_CTRL, val);
+	if (DEBUG_READ)
+		pr_info("  Set REG OP_CTRL[0x34]%#x\n", val);
+
+	CVSNFC_DMA_WAIT_INT_FINISH(host);
+
+	host->cache_addr_value[0] = host->addr_value[0];
+	host->cache_addr_value[1] = host->addr_value[1];
+
+	if (DEBUG_READ)
+		pr_info("* End %s page read start!\n", op_type);
+}
+
+/*****************************************************************************/
+void cvsnfc_send_cmd_erase(struct cvsnfc_host *host)
+{
+	unsigned int val;
+	struct cvsnfc_op *spi = host->spi;
+	uint32_t row_addr = host->addr_value[1];
+	uint32_t r_row_addr = ((row_addr & 0xff0000) >> 16) | (row_addr & 0xff00)
+			    | ((row_addr & 0xff) << 16);
+
+	if (DEBUG_ERASE) {
+		printf("* Enter send cmd erase\n");
+		printf("%s row_addr 0x%x\n", __func__, host->addr_value[1]);
+	}
+	if (spi->driver->select_die) {
+		unsigned int die_id =
+			row_addr / (host->diesize / host->pagesize);
+
+		spi->driver->select_die(spi, die_id);
+	}
+
+	val = spi->driver->wait_ready(spi);
+	if (val) {
+		printf("cvsnfc: erase wait ready fail! status[%#x]\n", val);
+		return;
+	}
+
+	if (spi->driver->write_enable(spi)) {
+		printf("%s erase write enable failed\n", __func__);
+		return;
+	}
+
+	if (DEBUG_ERASE) {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &val);
+		pr_info("  Get feature addr[0xC0], val[%#x]\n", val);
+	}
+
+	if (DEBUG_ERASE) {
+		pr_info("%s row_addr 0x%x\n", __func__, host->addr_value[1]);
+		pr_info("r_row_addr 0x%x\n", r_row_addr);
+	}
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 3 << TRX_CMD_CONT_SIZE_SHIFT); // 3 bytes for 24-bit row address
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, (r_row_addr << TRX_CMD_CONT0_SHIFT) | SPI_NAND_CMD_BLOCK_ERASE);
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+
+	val = spi->driver->wait_ready(spi);
+	if (val & STATUS_E_FAIL_MASK)
+		printf("cvsnfc: erase failed! status[%#x]\n", val);
+
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_status(struct cvsnfc_host *host)
+{
+	unsigned int regval, addr = 0;
+
+	if ((host->cmd_option.last_cmd == NAND_CMD_ERASE1) ||
+	    (host->cmd_option.last_cmd == NAND_CMD_PAGEPROG))
+		addr = PROTECTION_ADDR;
+	else
+		addr = STATUS_ADDR;
+
+	spi_feature_op(host, GET_OP, addr, &regval);
+
+	if (DEBUG_ERASE || DEBUG_WRITE)
+		pr_info("cvsnfc: %s get %#x status[%#x]\n",
+			 ((host->cmd_option.last_cmd == NAND_CMD_ERASE1)  ? "erase" : "write"),
+			addr, regval);
+}
+
+void  cvsnfc_setup_intr(struct cvsnfc_host *host)
+{
+	cvsfc_write(host, REG_SPI_NAND_INT_EN, 0x1f1);
+	cvsfc_write(host, REG_SPI_NAND_INT_CLR, BITS_SPI_NAND_INT_CLR_ALL);
+	cvsfc_write(host, REG_SPI_NAND_INT_MASK, 0);
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_readid(struct cvsnfc_host *host)
+{
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0x00030001);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_READ_ID);
+	//cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL, BIT_REG_BOOT_PRD);
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_reset(struct cvsnfc_host *host)
+{
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_RESET);
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+}
+
+/*****************************************************************************/
+static uint8_t cvsnfc_read_byte(struct mtd_info *mtd)
+{
+	unsigned char value = 0;
+	struct nand_chip *chip = mtd->priv;
+	static unsigned int data;
+
+	struct cvsnfc_host *host = chip->priv;
+
+	if ((host->offset % 4) == 0) {
+		data = cvsfc_read(host, REG_SPI_NAND_RX_DATA);
+		pr_info("cvsnfc_read_byte read data 0x%x, offset %d\n", data, host->offset);
+	}
+
+	if (host->cmd_option.last_cmd == NAND_CMD_READID) {
+		unsigned char off = host->offset % 4;
+
+		value = (data & (0xff << (off * 8))) >> (off * 8);
+		pr_info("read id off %d, value 0x%x\n", host->offset, value);
+
+		host->offset++;
+
+		if (host->cmd_option.date_num == host->offset) {
+			host->cmd_option.last_cmd = 0;
+			host->offset = 0;
+		}
+
+		return value;
+	}
+
+	if ((host->cmd_option.last_cmd == NAND_CMD_ERASE1) ||
+	    (host->cmd_option.last_cmd == NAND_CMD_PAGEPROG)) {
+		return value;
+	}
+
+	if (host->cmd_option.last_cmd == NAND_CMD_ERASE2) {
+		return value;
+	}
+
+	if (host->cmd_option.command == NAND_CMD_STATUS) {
+		return value;
+	}
+
+	if (host->cmd_option.last_cmd == NAND_CMD_READOOB) {
+		return value;
+	}
+
+	host->offset++;
+
+	pr_info("%s return\n", __func__);
+
+	return 0;// FIXME : readb(host->buffer + host->column + host->offset - 1);
+}
+
+/*****************************************************************************/
+static u16 cvsnfc_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+
+	host->offset += 2;
+	return readw(host->buffer + host->column + host->offset - 2);
+}
+
+/*****************************************************************************/
+static void cvsnfc_write_buf(struct mtd_info *mtd,
+			     const uint8_t *buf, int len)
+{
+}
+
+/*****************************************************************************/
+static void cvsnfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+}
+
+/*****************************************************************************/
+static void cvsnfc_select_chip(struct mtd_info *mtd, int chipselect)
+{
+}
+
+static void cvsnfc_cmdfunc(struct mtd_info *mtd, unsigned int cmd, int col,
+			   int page)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("=> %s, r 0x%p\n", __func__, __builtin_return_address(0));
+
+	switch (cmd) {
+	case NAND_CMD_PAGEPROG:
+		break;
+	case NAND_CMD_STATUS:
+		host->offset = 0;
+
+		break;
+	case NAND_CMD_READID:
+		host->offset = 0;
+		host->cmd_option.last_cmd = cmd;
+		host->cmd_option.date_num = MAX_ID_LEN;
+		host->send_cmd_readid(host); // cvsnfc_send_cmd_readid
+		break;
+	case NAND_CMD_PARAM:
+
+		break;
+	case NAND_CMD_READ0:
+	case NAND_CMD_SEQIN:
+		break;
+	case NAND_CMD_RESET:
+		/* resets a specific device connected to the core */
+		host->cmd_option.last_cmd = cmd;
+//		cvsnfc_send_cmd_reset(host);
+//		cvsnfc_dev_ready(mtd);
+
+		break;
+	case NAND_CMD_READOOB:
+		break;
+	case NAND_CMD_RNDOUT:
+		break;
+	case NAND_CMD_ERASE1:
+		host->addr_value[0] = 0;
+		host->addr_value[1] = page;
+		host->cmd_option.last_cmd = cmd;
+		host->send_cmd_erase(host); //cvsnfc_send_cmd_erase
+		break;
+	case NAND_CMD_ERASE2:
+		break;
+	default:
+		pr_info("unsupported command received 0x%x\n", cmd);
+		break;
+	}
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("<= %s, exit\n", __func__);
+}
+
+/*****************************************************************************/
+static void cvsnfc_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	unsigned char cmd;
+	int is_cache_invalid = 1;
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("%s\n", __func__);
+
+	if (ctrl & NAND_ALE) {
+		unsigned int addr_value = 0;
+		unsigned int addr_offset = 0;
+
+		if (ctrl & NAND_CTRL_CHANGE) {
+			host->addr_cycle = 0x0;
+			host->addr_value[0] = 0x0;
+			host->addr_value[1] = 0x0;
+		}
+		addr_offset = host->addr_cycle << 3;
+
+		if (host->addr_cycle >= CVSNFC_ADDR_CYCLE_MASK) {
+			addr_offset = (host->addr_cycle -
+					CVSNFC_ADDR_CYCLE_MASK) << 3;
+			addr_value = 1;
+		}
+
+		host->addr_value[addr_value] |=
+			((dat & 0xff) << addr_offset);
+
+		host->addr_cycle++;
+	}
+
+	if ((ctrl & NAND_CLE) && (ctrl & NAND_CTRL_CHANGE)) {
+		cmd = dat & 0xff;
+		host->cmd_option.command = cmd;
+		switch (cmd) {
+		case NAND_CMD_PAGEPROG:
+			host->offset = 0;
+			host->send_cmd_pageprog(host);
+			break;
+
+		case NAND_CMD_READSTART:
+			is_cache_invalid = 0;
+			if (host->addr_value[0] == host->pagesize)
+				host->cmd_option.last_cmd = NAND_CMD_READOOB;
+			host->send_cmd_readstart(host);
+			break;
+
+		case NAND_CMD_ERASE2:
+			host->cmd_option.last_cmd = cmd;
+			host->send_cmd_erase(host);
+			break;
+
+		case NAND_CMD_READID:
+			memset((unsigned char *)(chip->IO_ADDR_R), 0, MAX_ID_LEN);
+			host->cmd_option.last_cmd = cmd;
+			host->cmd_option.date_num = MAX_ID_LEN;
+			host->send_cmd_readid(host);
+			break;
+
+		case NAND_CMD_STATUS:
+			host->send_cmd_status(host);
+			break;
+
+		case NAND_CMD_SEQIN:
+			break;
+
+		case NAND_CMD_ERASE1:
+			break;
+
+		case NAND_CMD_READ0:
+			host->cmd_option.last_cmd = cmd;
+			break;
+
+		case NAND_CMD_RESET:
+			host->send_cmd_reset(host);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if ((dat == NAND_CMD_NONE) && host->addr_cycle) {
+		if (host->cmd_option.command == NAND_CMD_SEQIN ||
+		    host->cmd_option.command == NAND_CMD_READ0 ||
+		    host->cmd_option.command == NAND_CMD_READID) {
+			host->offset = 0x0;
+			host->column = (host->addr_value[0] & 0xffff);
+		}
+	}
+
+	if (is_cache_invalid) {
+		host->cache_addr_value[0] = ~0;
+		host->cache_addr_value[1] = ~0;
+	}
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("%s exit\n", __func__);
+}
+
+/*****************************************************************************/
+static int cvsnfc_waitfunc(struct mtd_info *mtd, struct nand_chip *this)
+{
+	unsigned int regval;
+	unsigned int deadline = 0;
+	struct cvsnfc_host *host = this->priv;
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("=>%s\n", __func__);
+
+	do {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &regval);
+
+		if (!(regval & STATUS_OIP_MASK))
+			return NAND_STATUS_READY;
+
+		udelay(1);
+	} while (deadline++ < (40 << 5));
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("Wait spi nand flash ready timeout.\n");
+
+	return NAND_STATUS_FAIL;
+}
+
+/*****************************************************************************/
+static int cvsnfc_dev_ready(struct mtd_info *mtd)
+{
+	unsigned int regval;
+	unsigned int deadline = 0;
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+
+	do {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &regval);
+		if (!(regval & STATUS_OIP_MASK))
+			return 1;
+		//udelay(1);
+	} while (deadline++ < (40 << 5));
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("Wait spi nand flash ready timeout.\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+ * 'host->epm' only use the first oobfree[0] field, it looks very simple, But...
+ */
+static struct nand_ecclayout nand_ecc_default = {
+	.oobfree = {{2, 30} }
+};
+
+/*****************************************************************************/
+static struct nand_config_info cvsnfc_spi_nand_config_table[] = {
+	{NAND_PAGE_4K,	NAND_ECC_24BIT,	200,		&nand_ecc_default},
+	{NAND_PAGE_4K,	NAND_ECC_16BIT,	144,		&nand_ecc_default},
+	{NAND_PAGE_4K,	NAND_ECC_8BIT,	128/*88*/,	&nand_ecc_default},
+	{NAND_PAGE_4K,	NAND_ECC_0BIT,	32,		&nand_ecc_default},
+
+	{NAND_PAGE_2K,	NAND_ECC_24BIT,	128/*116*/,	&nand_ecc_default},
+	{NAND_PAGE_2K,	NAND_ECC_16BIT,	88,		&nand_ecc_default},
+	{NAND_PAGE_2K,	NAND_ECC_8BIT,	64/*60*/,	&nand_ecc_default},
+	{NAND_PAGE_2K,	NAND_ECC_0BIT,	32,		&nand_ecc_default},
+
+	{0, 0, 0, NULL},
+};
+
+/*****************************************************************************/
+/* used the best correct arithmetic. */
+struct nand_config_info *cvsnfc_get_best_ecc(struct mtd_info *mtd)
+{
+	struct nand_config_info *best = NULL;
+	struct nand_config_info *info = cvsnfc_spi_nand_config_table;
+
+	for (; info->layout; info++) {
+		if (nandpage_type2size(info->pagetype) != mtd->writesize)
+			continue;
+
+		if (mtd->oobsize < info->oobsize)
+			continue;
+
+		if (!best || (best->ecctype < info->ecctype))
+			best = info;
+	}
+
+	if (!best)
+		pr_info("Driver does not support the pagesize (%d) and oobsize(%d).\n",
+			 mtd->writesize, mtd->oobsize);
+
+	return best;
+}
+
+/*****************************************************************************/
+/* force the pagesize and ecctype */
+struct nand_config_info *cvsnfc_force_ecc(struct mtd_info *mtd, int pagetype,
+					  int ecctype, char *cfgmsg, int allow_pagediv)
+{
+	int pagesize;
+	struct nand_config_info *fit = NULL;
+	struct nand_config_info *info = cvsnfc_spi_nand_config_table;
+
+	if (DEBUG_ECC)
+		printf("pagetype %d, ecctype %d\n", pagetype, ecctype);
+
+	// NAND_PAGE_2K, NAND_ECC_8BIT
+	for (; info->layout; info++) {
+		if (info->pagetype == pagetype && info->ecctype == ecctype) {
+			if (DEBUG_ECC)
+				printf("pagetype %d, ecctype %d\n", pagetype, ecctype);
+			fit = info;
+			break;
+		}
+	}
+
+	if (!fit) {
+		cvsnfc_register_dump();
+		return NULL;
+	}
+
+	pagesize = nandpage_type2size(pagetype);
+
+	if (DEBUG_ECC)
+		printf("pagesize %d, mtd->writesize %d\n", pagesize, mtd->writesize);
+
+	if ((pagesize != mtd->writesize) &&
+	    (pagesize > mtd->writesize || !allow_pagediv)) {
+		cvsnfc_register_dump();
+		return NULL;
+	}
+
+	if (DEBUG_ECC)
+		printf("fit->oobsize %d, mtd->oobsize %d\n", fit->oobsize, mtd->oobsize);
+
+	if (fit->oobsize > mtd->oobsize)
+		return NULL;
+
+	return fit;
+}
+
+/*****************************************************************************/
+int cvsnfc_ecc_probe(struct mtd_info *mtd, struct nand_chip *chip,
+		     struct nand_flash_dev_ex *flash_dev_ex)
+{
+	char *start_type = "unknown";
+	struct nand_config_info *best = NULL;
+	struct cvsnfc_host *host = chip->priv;
+	unsigned int pagetype, ecctype;
+
+
+#ifdef CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+
+	pagetype = nandpage_size2type(mtd->writesize);
+	ecctype = NAND_ECC_8BIT; // FIXME!!
+
+	best = cvsnfc_force_ecc(mtd, pagetype, ecctype, "hardware config", 0);
+	start_type = "Hardware";
+
+#endif /* CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC */
+
+	if (!best)
+		DBG_BUG(ERSTR_HARDWARE
+			"Please configure SPI Nand Flash pagesize and ecctype!\n");
+
+	if (DEBUG_ECC)
+		printf("best->oobsize %d best->ecctype %d\n", best->oobsize, best->ecctype);
+
+	if (best->ecctype != NAND_ECC_0BIT)
+		mtd->oobsize = best->oobsize;
+
+	if (flash_dev_ex->oobsize > mtd->oobsize)
+		mtd->oobsize = flash_dev_ex->oobsize;
+
+	if (DEBUG_ECC)
+		printf("mtd->oobsize %d\n", mtd->oobsize);
+
+	chip->ecc.layout = best->layout;
+
+	host->ecctype  = NAND_ECC_8BIT;
+	host->pagesize = mtd->writesize;
+	host->oobsize  = mtd->oobsize;
+	host->block_page_cnt = (mtd->erasesize / mtd->writesize);
+	host->block_page_mask = ((mtd->erasesize / mtd->writesize) - 1);
+
+	pr_info("host->block_page_cnt %d\n", host->block_page_cnt);
+	pr_info("host->block_page_mask %d\n", host->block_page_mask);
+
+	host->dma_oob = host->dma_buffer + host->pagesize;
+
+	host->bbm = (unsigned char *)(host->buffer + host->pagesize
+			+ HINFC_BAD_BLOCK_POS);
+
+	host->epm = (unsigned short *)(host->buffer + host->pagesize
+			+ chip->ecc.layout->oobfree[0].offset + 28);
+
+	if (mtd->writesize > SPI_NAND_MAX_PAGESIZE ||
+	    mtd->oobsize > SPI_NAND_MAX_OOBSIZE) {
+		pr_info("Driver does not support this Nand Flash.\n");
+		pr_info("Please increase SPI_NAND_MAX_PAGESIZE and SPI_NAND_MAX_OOBSIZE.\n");
+	}
+
+	flash_dev_ex->start_type = start_type;
+	flash_dev_ex->ecctype = host->ecctype;
+
+	return 0;
+}
+
+static int spi_nand_read_page(struct cvsnfc_host *host, int page)
+{
+	int row_addr = page;
+	int r_row_addr = ((row_addr & 0xff0000) >> 16) | (row_addr & 0xff00) | ((row_addr & 0xff) << 16);
+
+	if (DEBUG_READ)
+		pr_info("%s row_addr 0x%x\n", __func__, row_addr);
+
+	if (DEBUG_READ)
+		pr_info("%s r_row_addr 0x%x\n", __func__, r_row_addr);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0 << TRX_DATA_SIZE_SHIFT | 3 << TRX_CMD_CONT_SIZE_SHIFT);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_row_addr << TRX_CMD_CONT0_SHIFT | SPI_NAND_CMD_PAGE_READ_TO_CACHE);
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+
+	cvsnfc_dev_ready(host->mtd);
+
+	if (DEBUG_READ)
+		pr_info("<=%s\n", __func__);
+
+	//flush_dcache_all();
+
+	return 0;
+}
+
+/*
+ * spi_nand user guide v0.3.docx
+ * 5.4 : Write Command with DMA Data
+ *
+ * rw : 0 for read, 1 for write
+ */
+static void spi_nand_rw_dma_setup(struct cvsnfc_host *host, const uint8_t *buf, int len, int rw)
+{
+	int ch = 0;
+	void __iomem *remap_base = (void __iomem *)CVI_SYSDMA_REMAP_BASE;
+
+	if (DEBUG_DMA)
+		pr_info("%s: buf %p, len %d, %s, dmabase %p\n", __func__, buf, len,
+			 rw == 1 ? "dma write" : "dma read", host->dmabase);
+
+	writel(0x00000003, host->dmabase + 0x010);
+	writel(0x00000f00, host->dmabase + 0x018);
+
+	writel((len / 4) - 1, host->dmabase + (0x110 + ch * (0x100)));
+	writel(0x000f0792, host->dmabase + (0x11C + ch * (0x100)));
+
+	if (rw) {
+//		// for dma write
+		writel(((uintptr_t)buf) & 0xFFFFFFFF, host->dmabase + 0x100 + ch * (0x100));
+		writel(((uintptr_t)buf) >> 32, host->dmabase + 0x104 + ch * (0x100));
+
+		if (DEBUG_DMA)
+			pr_info("w0x100: 0x%x\n", readl(host->dmabase + 0x100 + ch * (0x100)));
+		if (DEBUG_DMA)
+			pr_info("w0x104: 0x%x\n", readl(host->dmabase + 0x104 + ch * (0x100)));
+
+		writel((uintptr_t)host->regbase + 0x800, host->dmabase + 0x108 + ch * (0x100));
+		writel(0, host->dmabase + 0x10C + ch * (0x100));
+
+		if (DEBUG_DMA)
+			pr_info("w0x108: 0x%x\n", readl(host->dmabase + 0x108 + ch * (0x100)));
+		if (DEBUG_DMA)
+			pr_info("w0x10C: 0x%x\n", readl(host->dmabase + 0x10C + ch * (0x100)));
+
+		writel(0x00045441, host->dmabase + 0x118 + ch * (0x100));
+		writel(0x00000001, host->dmabase + 0x124 + ch * (0x100)); // [0:2] = 1 : MEM_TO_PER_DMAC, PER dst = 0
+
+		writel(0x26 << (ch * 8), remap_base); //PER dst => remap chx
+		uint32_t val = readl(remap_base) | 0x80000000; // update bit
+
+		writel(val, remap_base); // set sdma remap update bit
+
+		if (DEBUG_DMA)
+			pr_info("w0x03000154: 0x%x\n", readl(remap_base));
+
+		flush_dcache_range((unsigned long)buf, (unsigned long)(buf + len));
+	} else {
+		// for dma read
+		writel((uintptr_t)host->regbase + 0xC00, host->dmabase + 0x100 + ch * (0x100));
+		writel(0, host->dmabase + 0x104 + ch * (0x100));
+
+		if (DEBUG_DMA)
+			pr_info("r0x100: 0x%x\n", readl(host->dmabase + 0x100 + ch * (0x100)));
+		if (DEBUG_DMA)
+			pr_info("r0x104: 0x%x\n", readl(host->dmabase + 0x104 + ch * (0x100)));
+
+		writel(((uintptr_t)buf) & 0xFFFFFFFF, host->dmabase + 0x108 + ch * (0x100));
+		writel(((uintptr_t)buf) >> 32, host->dmabase + 0x10C + ch * (0x100));
+
+		if (DEBUG_DMA)
+			pr_info("r0x108: 0x%x\n", readl(host->dmabase + 0x108 + ch * (0x100)));
+		if (DEBUG_DMA)
+			pr_info("r0x10C: 0x%x\n", readl(host->dmabase + 0x10C + ch * (0x100)));
+
+		writel(0x00046214, host->dmabase + 0x118 + ch * (0x100));
+		writel(0x00000002, host->dmabase + 0x124 + ch * (0x100)); // [0:2] = 2 : PER_TO_MEM_DMAC, PER src = 0
+
+		writel(0x26 << (ch * 8), remap_base); //PER src => remap chx
+		uint32_t val = readl(remap_base) | 0x80000000; // update bit
+
+		writel(val, remap_base); // set sdma remap update bit
+
+		if (DEBUG_DMA)
+			pr_info("r0x03000154: 0x%x\n", readl(remap_base));
+	}
+
+	//flush_dcache_range((unsigned long)buf, (unsigned long)(buf + len));
+
+	writel(0, host->dmabase + 0x120 + ch * (0x100));
+	writel(0x00000101, host->dmabase + 0x018);
+}
+
+static void spi_nand_set_read_from_cache_mode(struct cvsnfc_host *host, uint32_t mode, uint32_t r_col_addr)
+{
+	switch (mode) {
+	case SPI_NAND_READ_FROM_CACHE_MODE_X1:
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_DMA_EN | BIT_REG_TRX_DUMMY_HIZ);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_col_addr << TRX_CMD_CONT0_SHIFT |
+			    SPI_NAND_CMD_READ_FROM_CACHE);
+		break;
+	case SPI_NAND_READ_FROM_CACHE_MODE_X2:
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_DMA_EN |
+			    SPI_NAND_CTRL3_IO_TYPE_X2_MODE | BIT_REG_TRX_DUMMY_HIZ);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_col_addr << TRX_CMD_CONT0_SHIFT |
+			    SPI_NAND_CMD_READ_FROM_CACHEX2);
+
+		break;
+	case SPI_NAND_READ_FROM_CACHE_MODE_X4:
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_DMA_EN |
+			    SPI_NAND_CTRL3_IO_TYPE_X4_MODE | BIT_REG_TRX_DUMMY_HIZ);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_col_addr << TRX_CMD_CONT0_SHIFT |
+			    SPI_NAND_CMD_READ_FROM_CACHEX4);
+		break;
+	default:
+		pr_err("unsupport mode!\n");
+		break;
+	}
+}
+
+static int parse_status_info(struct cvsnfc_host *host)
+{
+	uint32_t statusc0 = 0;
+	uint8_t ecc_sts = 0;
+	int ret;
+
+	spi_feature_op(host, GET_OP, host->nand_chip_info->ecc_status_offset, &statusc0);
+	ecc_sts = (statusc0 & host->nand_chip_info->ecc_status_mask) >> host->nand_chip_info->ecc_status_shift;
+
+	if (ecc_sts == 0) {
+		pr_debug("ECC pass!!\n");
+		ret = 0;
+	} else if (ecc_sts == host->nand_chip_info->ecc_status_uncorr_val) {
+		pr_info("%s statusc0 0x%x\n", __func__, statusc0);
+		pr_info("ECC_UNCORR!!\n");
+		ret = -EBADMSG;
+	} else {
+		pr_debug("%s statusc0 0x%x\n", __func__, statusc0);
+		pr_debug("ECC Corr!!\n");
+		ret = 1;
+	}
+
+	return ret;
+}
+
+static int spi_nand_read_from_cache(struct cvsnfc_host *host, int col_addr, int len, void *buf)
+{
+
+	int ret = 0;
+	int r_col_addr = ((col_addr & 0xff00) >> 8) | ((col_addr & 0xff) << 8);
+
+	if (DEBUG_READ)
+		pr_info("=>%s\n", __func__);
+
+	if (DEBUG_READ)
+		pr_info("%s col_addr 0x%x, len %d\n", __func__, col_addr, len);
+
+	spi_nand_rw_dma_setup(host, buf, len, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, len << TRX_DATA_SIZE_SHIFT | 3 << TRX_CMD_CONT_SIZE_SHIFT);
+
+	//here might be changed to use 4 bit mode if support QE bit
+	if (host->nand_chip_info->flags & FLAGS_ENABLE_X4_BIT)
+		spi_nand_set_read_from_cache_mode(host, SPI_NAND_READ_FROM_CACHE_MODE_X4, r_col_addr);
+	else if (host->nand_chip_info->flags & FLAGS_ENABLE_X2_BIT)
+		spi_nand_set_read_from_cache_mode(host, SPI_NAND_READ_FROM_CACHE_MODE_X2, r_col_addr);
+	else
+		spi_nand_set_read_from_cache_mode(host, SPI_NAND_READ_FROM_CACHE_MODE_X1, r_col_addr);
+
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0,
+		    cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	flush_dcache_range((unsigned long)buf, (unsigned long)(buf + len));
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_WAIT_DMA_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+
+	ret = parse_status_info(host);
+
+	return ret;
+}
+
+//extern void bbt_dump_buf(char *s, void *buf, int len);
+#define SPI_NAND_PLANE_BIT_OFFSET	BIT(12)
+
+int cvsnfc_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+		     uint8_t *buf, int bytes, int page)
+{
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t col_addr = 0;
+	struct cvsnfc_op *spi = host->spi;
+	int ret = 0;
+
+	if (DEBUG_READ)
+		printf("=>%s, page 0x%x\n", __func__, page);
+
+	if (spi->driver->select_die) {
+		unsigned int die_id = page / (host->diesize / host->pagesize);
+
+		spi->driver->select_die(spi, die_id);
+	}
+
+	//cvsnfc_ctrl_ecc(mtd, 1);
+
+	spi_nand_read_page(host, page);
+
+	uint32_t blk_idx = page / host->block_page_cnt;
+
+	if (DEBUG_READ)
+		pr_info("%s, blk_idx %d, page 0x%x, chip->options 0x%x\n",
+			 __func__, blk_idx, page, chip->options);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		if (DEBUG_READ)
+			pr_info("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	ret = spi_nand_read_from_cache(host, col_addr, mtd->writesize, buf);
+
+	if (ret == -EBADMSG) {
+		pr_info("%s : ECC status ECC_UNCORR on page 0x%x, block %d\n", __func__, page, blk_idx);
+	}
+
+	return ret;
+}
+
+static void cv_spi_nand_adjust_freq(struct cvsnfc_host *host, uint8_t sck_l, uint8_t sck_h, uint16_t max_freq)
+{
+	uint32_t val;
+
+	switch (max_freq) {
+	case SPI_NAND_FREQ_XTAL: /* use XTAL, 25/4 = 6.25Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) | BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		val |= SPI_NAND_SET_SCK_L(1) | SPI_NAND_SET_SCK_H(0);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_23MHz: /* use FPLL, 187.5/8 = 23.4375Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		if ((sck_l + sck_h) != 6)
+			val |= SPI_NAND_SET_SCK_L(3) | SPI_NAND_SET_SCK_H(3);
+		else
+			val |= SPI_NAND_SET_SCK_L(sck_l) | SPI_NAND_SET_SCK_H(sck_h);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_26MHz: /* use FPLL, 187.5/7 = 26.7857Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		if ((sck_l + sck_h) != 5)
+			val |= SPI_NAND_SET_SCK_L(3) | SPI_NAND_SET_SCK_H(2);
+		else
+			val |= SPI_NAND_SET_SCK_L(sck_l) | SPI_NAND_SET_SCK_H(sck_h);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_31MHz: /* use FPLL, 187.5/6 = 31.25Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		if ((sck_l + sck_h) != 4)
+			val |= SPI_NAND_SET_SCK_L(2) | SPI_NAND_SET_SCK_H(2);
+		else
+			val |= SPI_NAND_SET_SCK_L(sck_l) | SPI_NAND_SET_SCK_H(sck_h);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_37MHz: /* use FPLL, 187.5/5 = 37.5Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		if ((sck_l + sck_h) != 3)
+			val |= SPI_NAND_SET_SCK_L(2) | SPI_NAND_SET_SCK_H(1);
+		else
+			val |= SPI_NAND_SET_SCK_L(sck_l) | SPI_NAND_SET_SCK_H(sck_h);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_46MHz: /* use FPLL, 187.5/4 = 46.875Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		if ((sck_l + sck_h) != 2)
+			val |= SPI_NAND_SET_SCK_L(1) | SPI_NAND_SET_SCK_H(1);
+		else
+			val |= SPI_NAND_SET_SCK_L(sck_l) | SPI_NAND_SET_SCK_H(sck_h);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_62MHz: /* use FPLL, 187.5/3 = 62.5Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		if ((sck_l + sck_h) != 1)
+			val |= SPI_NAND_SET_SCK_L(1) | SPI_NAND_SET_SCK_H(0);
+		else
+			val |= SPI_NAND_SET_SCK_L(sck_l) | SPI_NAND_SET_SCK_H(sck_h);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	case SPI_NAND_FREQ_93MHz: /* use FPLL, 187.5/2 = 93.75Mhz */
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL,
+			    (cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL) & ~BIT_REG_BOOT_PRD));
+
+		val = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1) & ~BIT_REG_NAND_SCK_MASK;
+
+		val |= SPI_NAND_SET_SCK_L(0) | SPI_NAND_SET_SCK_H(0);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, val);
+		break;
+	default:
+		break;
+	}
+}
+
+#define PATTERN1_OFFSET 0
+#define PATTERN2_OFFSET 8
+
+int spi_nand_adjust_max_freq(struct cvsnfc_host *host, uint32_t *pattern1, uint32_t *pattern2)
+{
+	uint dly_ow_val, rsp_pos_sel, dly_line_sel;
+	int ori_boot_ctl;
+	int ori_trx_ctl;
+	int val1, val2;
+	unsigned char header_buf[32];
+	struct cvsnfc_dly_param_grp dly_grp[10];
+	unsigned int dly_grp_idx;
+	unsigned int dly_param[128]; /* the range of dly_line_sel is 0 ~ 127 */
+	unsigned int dly_param_idx;
+	unsigned int old_dly_param;
+	unsigned int max_count;
+	unsigned int select_grp;
+
+	dly_ow_val = 1; /* fix with 1 clk*/
+	rsp_pos_sel = 0; /* fix to select nagetive edge */
+	max_count = 0;
+	select_grp = 0;
+
+	ori_boot_ctl = cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL);
+	ori_trx_ctl = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1);
+
+	val1 = ori_boot_ctl & ~BIT_REG_RSP_DLY_MASK;
+	host->nand_chip_info->max_freq = SPI_NAND_FREQ_93MHz;
+
+	printf("Tuning SPINAND run on maximum speed...\n");
+
+freq_retry:
+	dly_grp_idx = 0;
+	dly_param_idx = 0;
+	old_dly_param = 0;
+
+	memset(&dly_grp, 0x0, sizeof(struct cvsnfc_dly_param_grp) * 10);
+
+	cv_spi_nand_adjust_freq(host, host->nand_chip_info->sck_l, host->nand_chip_info->sck_h,
+				host->nand_chip_info->max_freq);
+
+	for (dly_line_sel = 0; dly_line_sel < 128; dly_line_sel++) {
+		val2 = val1;
+		unsigned int nand_id;
+
+		val2 = (BIT_REG_RSP_DLY_OW_EN | (dly_ow_val << 8) | (rsp_pos_sel << 12) | (dly_line_sel << 16));
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL, val2);
+
+		cvsnfc_send_cmd_readid(host);
+
+		nand_id = cvsfc_read(host, REG_SPI_NAND_RX_DATA);
+
+		if (!memcmp(&nand_id, host->nand_chip_info->id, host->nand_chip_info->id_len)) {
+			int ret;
+
+			memset(header_buf, 0x0, 0x20);
+			ret = spi_nand_read_from_cache(host, 0, 0x20, header_buf); /* read first 32 bytes */
+			if (ret == -EBADMSG) {
+				printf("%s : ECC status ECC_UNCORR\n", __func__);
+			}
+			if (!memcmp(header_buf + PATTERN1_OFFSET, pattern1, 4) &&
+			    !memcmp(header_buf + PATTERN2_OFFSET, pattern2, 4)) {
+				if (dly_param_idx == 0 && dly_grp_idx == 0) {
+					dly_grp[dly_grp_idx].start = dly_param_idx;
+					dly_grp[dly_grp_idx].count = 1;
+				} else if ((val2 - old_dly_param) == 0x10000) {
+					dly_grp[dly_grp_idx].count++;
+				} else {
+					dly_grp_idx++;
+					dly_grp[dly_grp_idx].start = dly_param_idx;
+					dly_grp[dly_grp_idx].count = 1;
+				}
+
+				old_dly_param = val2;
+				dly_param[dly_param_idx] = cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL);
+				dly_param_idx++;
+			}
+		}
+	}
+
+	pr_info("dly_param_idx=%d, dly_grp_idx=%d\n", dly_param_idx, dly_grp_idx);
+	if (dly_param_idx != 0) { /* at least find 1 parameter */
+		for (int i = 0; i <= dly_grp_idx; i++) {
+
+			if (dly_grp[i].count > max_count) {
+				select_grp = i;
+				max_count = dly_grp[i].count;
+			}
+			pr_info("dly_param[%d].start=%d, count=%d\n", i, dly_grp[i].start, dly_grp[i].count);
+		}
+
+		cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL, dly_param[dly_grp[select_grp].start + (max_count / 2)]);
+		return 0;
+	}
+
+	if (dly_param_idx == 0 && host->nand_chip_info->max_freq != 0) {
+		if (host->nand_chip_info->max_freq > 0) {
+			host->nand_chip_info->max_freq--;
+			goto freq_retry;
+		}
+	}
+
+	/* Can't find an suitable parameter for this frequency, use original one */
+	cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL, ori_boot_ctl);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, ori_trx_ctl);
+
+	return -EINVAL;
+}
+
+void cvsnfc_ctrl_ecc(struct mtd_info *mtd, bool enable)
+{
+	unsigned int status = 0;
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+
+	if (DEBUG_CMD_FLOW)
+		pr_info("%s %s ecc\n", __func__, (enable) ? "enable" : "disable");
+
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &status);
+
+	if (enable) {
+		status = status | (SPI_NAND_FEATURE0_ECC_EN);
+		spi_feature_op(host, SET_OP, FEATURE_ADDR, &status);
+	} else {	//disable ecc
+		status = status & ~(SPI_NAND_FEATURE0_ECC_EN);
+		spi_feature_op(host, SET_OP, FEATURE_ADDR, &status);
+	}
+}
+
+static int read_oob_data(struct mtd_info *mtd, uint8_t *buf, int page)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t col_addr = mtd->writesize;
+	uint32_t blk_idx = page / host->block_page_cnt;
+	struct cvsnfc_op *spi = host->spi;
+	int ret = 0;
+
+	if (DEBUG_READ)
+		pr_info("%s, page 0x%x, buf %p, mtd->oobsize %d\n", __func__,
+			 page, buf, mtd->oobsize);
+
+	if (spi->driver->select_die) {
+		unsigned int die_id = page / (host->diesize / host->pagesize);
+
+		spi->driver->select_die(spi, die_id);
+	}
+
+	cvsnfc_ctrl_ecc(mtd, 0);
+
+	spi_nand_read_page(host, page);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		pr_info("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	ret = spi_nand_read_from_cache(host, col_addr, mtd->oobsize, buf);
+
+	if (DEBUG_READ) {
+		bbt_dump_buf("1oob data:", buf, 16);
+	}
+
+	cvsnfc_ctrl_ecc(mtd, 1);
+
+	if (ret != 0) {
+		printf("%s : ECC status ret %d page 0x%x\n", __func__, ret, page);
+	}
+
+	return ret;
+}
+
+static int cvsnfc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			   int page)
+{
+	if (DEBUG_READ)
+		printf("%s\n", __func__);
+
+	return read_oob_data(mtd, chip->oob_poi, page);
+}
+
+int cvsnfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			 uint8_t *buf, int oob_required, int page)
+{
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t col_addr = 0;
+	uint32_t blk_idx = page / host->block_page_cnt;
+	struct cvsnfc_op *spi = host->spi;
+
+	if (DEBUG_READ)
+		pr_info("%s, page 0x%x\n", __func__, page);
+
+	if (spi->driver->select_die) {
+		unsigned int die_id = page / (host->diesize / host->pagesize);
+
+		spi->driver->select_die(spi, die_id);
+	}
+
+	cvsnfc_ctrl_ecc(mtd, 0);
+
+	spi_nand_read_page(host, page);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		if (DEBUG_READ)
+			pr_info("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	spi_nand_read_from_cache(host, col_addr, mtd->writesize + mtd->oobsize, buf);
+
+	if (DEBUG_READ)
+		bbt_dump_buf("read raw page:", buf, mtd->writesize + mtd->oobsize);
+
+	cvsnfc_ctrl_ecc(mtd, 1);
+
+	return 0;
+}
+
+static int cvsnfc_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
+			       u32 data_offs, u32 readlen, u8 *buf, int page)
+{
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t col_addr = 0;
+	struct cvsnfc_op *spi = host->spi;
+	int ret = 0;
+
+	if (DEBUG_READ)
+		pr_info("=>%s, page 0x%x, data_offs %d, readlen %d\n",
+			 __func__, page, data_offs, readlen);
+
+	if (spi->driver->select_die) {
+		unsigned int die_id = page / (host->diesize / host->pagesize);
+
+		spi->driver->select_die(spi, die_id);
+	}
+
+	//cvsnfc_ctrl_ecc(mtd, 1);
+
+	spi_nand_read_page(host, page);
+
+	uint32_t blk_idx = page / host->block_page_cnt;
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		pr_info("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	ret = spi_nand_read_from_cache(host, col_addr, mtd->writesize, host->buffer);
+
+	if (ret != 0) {
+		printf("%s : ECC status ret %d page 0x%x\n", __func__, ret, page);
+	}
+
+	if (DEBUG_READ)
+		bbt_dump_buf("data:", buf, 16);
+
+	memcpy(buf, host->buffer, host->pagesize);
+
+	if (DEBUG_READ)
+		pr_info("<=%s\n", __func__);
+
+	return 0;
+}
+
+static uint8_t spi_nand_prog_load(struct cvsnfc_host *host, const uint8_t *buf,
+				  size_t size, uint32_t col_addr, uint32_t qe)
+{
+	uint8_t cmd = qe ? SPI_NAND_CMD_PROGRAM_LOADX4 : SPI_NAND_CMD_PROGRAM_LOAD;
+	uint32_t r_col_addr = ((col_addr & 0xff00) >> 8) | ((col_addr & 0xff) << 8);
+	uint32_t ctrl3 = 0;
+
+	if (DEBUG_WRITE)
+		pr_info("=>%s size %ld, col_addr 0x%x, r_col_addr 0x%x,  qe %d\n",
+			 __func__, size, col_addr, r_col_addr, qe);
+
+	spi_nand_rw_dma_setup(host, buf, size, 1);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, (size << TRX_DATA_SIZE_SHIFT) | 2 << TRX_CMD_CONT_SIZE_SHIFT);
+
+	ctrl3 = qe ? (BIT_REG_TRX_RW | BIT_REG_TRX_DMA_EN | SPI_NAND_CTRL3_IO_TYPE_X4_MODE) :
+		      (BIT_REG_TRX_RW | BIT_REG_TRX_DMA_EN);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, ctrl3);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, cmd | (r_col_addr << TRX_CMD_CONT0_SHIFT));
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_WAIT_DMA_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+
+	if (DEBUG_WRITE)
+		pr_info("<=%s\n", __func__);
+
+	return 0;
+}
+
+static int spi_nand_prog_exec(struct cvsnfc_host *host, uint32_t row_addr)
+{
+	uint32_t r_row_addr = ((row_addr & 0xff0000) >> 16) | (row_addr & 0xff00) | ((row_addr & 0xff) << 16);
+
+	if (DEBUG_WRITE)
+		pr_info("row_addr 0x%x\n", row_addr);
+
+	if (DEBUG_WRITE)
+		pr_info("r_row_addr 0x%x\n", r_row_addr);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 3 << TRX_CMD_CONT_SIZE_SHIFT);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_PROGRAM_EXECUTE | (r_row_addr << TRX_CMD_CONT0_SHIFT));
+	cvsfc_write(host, REG_SPI_NAND_RSP_POLLING, 0xff00ff);
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+
+	cvsnfc_dev_ready(host->mtd);
+
+	if (DEBUG_WRITE)
+		pr_info("<=%s\n", __func__);
+
+	return 0;
+}
+
+static int write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		      const uint8_t *buf, int oob_required, int page)
+{
+	struct cvsnfc_host *host = chip->priv;
+	struct cvsnfc_op *spi = host->spi;
+	uint32_t col_addr = 0;
+
+	if (DEBUG_WRITE)
+		printf("=>%s, buf %p, page 0x%x\n", __func__, buf, page);
+
+	if (spi->driver->select_die) {
+		unsigned int die_id = page / (host->diesize / host->pagesize);
+
+		spi->driver->select_die(spi, die_id);
+	}
+
+	if (spi->driver->write_enable(spi)) {
+		printf("%s write enable failed!\n", __func__);
+		return -1;
+	}
+
+	uint32_t row_addr = page;
+	uint32_t blk_idx = page /  host->block_page_cnt;
+
+	if (DEBUG_WRITE)
+		pr_info("blk idx %d\n", blk_idx);
+
+	cvsnfc_ctrl_ecc(mtd, 1);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		if (DEBUG_WRITE)
+			pr_info("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	spi_nand_prog_load(host, buf, host->pagesize, col_addr, 0);
+
+	WATCHDOG_RESET();
+
+	spi_nand_prog_exec(host, row_addr);
+
+	if (DEBUG_WRITE)
+		pr_info("<=%s\n", __func__);
+
+	return 0;
+}
+
+int cvsnfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		      const uint8_t *buf, int oob_required, int page)
+{
+	/*
+	 * for regular page writes, we let HW handle all the ECC
+	 * data written to the device.
+	 */
+
+#ifdef DEBUG_WRITE_TWICE
+	struct cvsnfc_host *host = chip->priv;
+
+	if (host->flags & FLAGS_SUPPORT_W_TWICE_DEBUG) {
+		int status = cvsnfc_read_page_raw(mtd, chip, dbg_pg_buf, 0, page);
+		u32 page_size = mtd->writesize;
+		u32 spare_size = mtd->oobsize;
+		u32 offset = page_size + (spare_size / 2);
+		u32 i = 0;
+		u32 write_twice = 0;
+
+		if (status) {
+			printf("read status %d\n", status);
+			assert(0);
+		}
+
+		u8 *mark = (u8 *)&dbg_pg_buf[offset];
+
+		for (i = 0; i < spare_size / 2; i++) {
+			if (mark[i] != 0xff) {
+				write_twice = 1;
+				printf("offset %d, mark 0x%x\n", i, mark[i]);
+			}
+		}
+
+		if (write_twice) {
+			printf("%s pg 0x%x already programmed\n", __func__, page);
+			return 0;
+		}
+	}
+#endif
+
+	return write_page(mtd, chip, buf, oob_required, page);
+}
+
+/*****************************************************************************/
+void cvsnfc_nand_init(struct nand_chip *chip)
+{
+	struct cvsnfc_host *host = chip->priv;
+
+	cvsnfc_setup_intr(host);
+
+	chip->read_byte   = cvsnfc_read_byte;
+	chip->read_word   = cvsnfc_read_word;
+	chip->write_buf   = cvsnfc_write_buf;
+	chip->read_buf    = cvsnfc_read_buf;
+
+	chip->select_chip = cvsnfc_select_chip;
+	chip->cmdfunc = cvsnfc_cmdfunc;
+	chip->waitfunc = cvsnfc_waitfunc;
+	chip->cmd_ctrl    = cvsnfc_cmd_ctrl;
+	chip->dev_ready   = cvsnfc_dev_ready;
+
+	chip->chip_delay  = CVSNFC_CHIP_DELAY;
+
+	chip->options     = NAND_BROKEN_XD;// | NAND_BBT_SCANNED;
+
+	chip->bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;
+
+	chip->ecc.layout  = NULL;
+//	chip->ecc.mode    = NAND_ECC_NONE;
+
+	/* override the default read operations */
+	chip->ecc.size = 512; // FIXME!!
+	chip->ecc.strength = 8; // FIXME!!
+	chip->ecc.read_page = cvsnfc_read_page;
+	chip->ecc.read_oob = cvsnfc_read_oob;
+	chip->ecc.read_page_raw = cvsnfc_read_page_raw;
+	chip->ecc.read_subpage = cvsnfc_read_subpage;
+	chip->ecc.write_page = cvsnfc_write_page;
+
+	chip->options |= NAND_SUBPAGE_READ;
+
+	chip->ecc.mode = NAND_ECC_HW;
+	chip->ecc.bytes = 0;
+}
+
+/*****************************************************************************/
+int cvsnfc_host_init(struct cvsnfc_host *host)
+{
+	host->tx_iobase  = (void __iomem *)SPI_NAND_TX_DATA_BASE;
+	host->rx_iobase  = (void __iomem *)SPI_NAND_RX_DATA_BASE;
+	host->regbase = (void __iomem *)CONFIG_CVSNFC_REG_BASE_ADDRESS;
+	host->dmabase = (void __iomem *)0x04330000;
+
+	host->set_system_clock   = 0;// FIXME : cvsnfc_set_system_clock;
+
+	if (host->set_system_clock)
+		host->set_system_clock(NULL, ENABLE);
+
+	host->buforg = kmalloc((CVSNFC_BUFFER_LEN + CVSNFC_DMA_ALIGN),
+				GFP_KERNEL);
+
+//	if (!host->buforg) {
+//		pr_err("cvsnfc: Can't malloc memory for NAND driver.\n");
+//		return 1;
+//	}
+
+	/* 32 bytes alignment */
+	host->buffer = (char *)((uintptr_t)(host->buforg
+		+ CVSNFC_DMA_ALIGN - 1) & ~(CVSNFC_DMA_ALIGN - 1));
+	memset(host->buffer, 0xff, CVSNFC_BUFFER_LEN);
+
+	host->dma_buffer = (uintptr_t)host->buffer;
+
+	host->send_cmd_pageprog  = cvsnfc_send_cmd_pageprog;
+	host->send_cmd_status    = cvsnfc_send_cmd_status;
+	host->send_cmd_readstart = cvsnfc_send_cmd_readstart;
+	host->send_cmd_erase     = cvsnfc_send_cmd_erase;
+	host->send_cmd_readid    = cvsnfc_send_cmd_readid;
+	host->send_cmd_reset     = cvsnfc_send_cmd_reset;
+
+	spi_nand_ids_register();
+
+	cvsnfc_register_dump();
+
+	return 0;
+}
+
+struct cvsnfc_host *cvsnfc_get_host(void)
+{
+	return &snfc_host;
+}
+
+/*****************************************************************************/
+int board_nand_init(struct nand_chip *nand)
+{
+	struct cvsnfc_host *host = &snfc_host;
+	struct mtd_info *mtd = nand_to_mtd(nand);
+
+	if (host->chip)
+		return 0;
+
+	pr_info("Init SPI Nand Flash Controller ... ");
+
+	mtd->priv = nand;
+
+	memset((char *)host, 0, sizeof(struct cvsnfc_host));
+
+	host->chip = nand;
+	if (cvsnfc_host_init(host)) {
+		printf("cvsnfc: failed to allocate device buffer.\n");
+		host->chip = 0;
+		return -ENOMEM;
+	}
+
+	nand->priv = host;
+	cvsnfc_nand_init(nand);
+
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.bytes = 0;
+
+	spi_nand_ids_register();
+	nand_oob_resize = cvsnfc_ecc_probe;
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_common.c b/drivers/mtd/nand/raw/cvitek/cvsnfc_common.c
new file mode 100644
index 000000000..fdc1a9baa
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_common.c
@@ -0,0 +1,185 @@
+#include <common.h>
+#include <nand.h>
+#include <linux/mtd/nand.h>
+#include <cvsnfc_common.h>
+
+/*****************************************************************************/
+struct nand_flash_dev *(*nand_get_spl_flash_type)(
+	struct mtd_info *mtd,
+	struct nand_chip *chip,
+	struct nand_flash_dev_ex *flash_dev_ex) = NULL;
+
+int (*nand_oob_resize)(struct mtd_info *mtd, struct nand_chip *chip,
+		       struct nand_flash_dev_ex *flash_dev_ex) = NULL;
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->str;
+		table++;
+	}
+	return def;
+}
+
+/*****************************************************************************/
+#if defined(CONFIG_NAND_FLASH_CVSNFC)
+
+/*****************************************************************************/
+static struct match_type_str page2name[] = {
+	{ NAND_PAGE_512B, "512" },
+	{ NAND_PAGE_2K,   "2K" },
+	{ NAND_PAGE_4K,   "4K" },
+	{ NAND_PAGE_8K,   "8K" },
+	{ NAND_PAGE_16K,  "16K" },
+	{ NAND_PAGE_32K,  "32K" },
+};
+
+const char *nand_page_name(int type)
+{
+	return type2str(page2name, ARRAY_SIZE(page2name), type, "unknown");
+}
+
+/*****************************************************************************/
+static struct match_reg_type page2size[] = {
+	{ _512B, NAND_PAGE_512B },
+	{ _2K, NAND_PAGE_2K },
+	{ _4K, NAND_PAGE_4K },
+	{ _8K, NAND_PAGE_8K },
+	{ _16K, NAND_PAGE_16K },
+	{ _32K, NAND_PAGE_32K },
+};
+
+int reg2type(struct match_reg_type *table, int length, int reg, int def)
+{
+	while (length-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int type2reg(struct match_reg_type *table, int length, int type, int def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+
+int nandpage_size2type(int size)
+{
+	return reg2type(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+int nandpage_type2size(int size)
+{
+	return type2reg(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+#endif
+
+#if 0
+/*****************************************************************************/
+#define et_ecc_none	0x00
+#define et_ecc_4bit	0x02
+#define et_ecc_8bit	0x03
+#define et_ecc_24bit1k	0x04
+#define et_ecc_40bit1k	0x05
+#define et_ecc_64bit1k	0x06
+
+static struct match_reg_type ecc_yaffs_type_t[] = {
+	{et_ecc_none,		NAND_ECC_0BIT},
+	{et_ecc_4bit,		NAND_ECC_8BIT},
+	{et_ecc_8bit,		NAND_ECC_16BIT},
+	{et_ecc_24bit1k,	NAND_ECC_24BIT},
+	{et_ecc_40bit1k,	NAND_ECC_40BIT},
+	{et_ecc_64bit1k,	NAND_ECC_64BIT}
+};
+
+unsigned char match_ecc_type_to_yaffs(unsigned char type)
+{
+	return type2reg(ecc_yaffs_type_t, ARRAY_SIZE(ecc_yaffs_type_t), type,
+			et_ecc_4bit);
+}
+
+/*****************************************************************************/
+static struct match_t page_table[] = {
+	{NAND_PAGE_2K,	PAGE_SIZE_2KB,	"2K"},
+	{NAND_PAGE_4K,	PAGE_SIZE_4KB,	"4K"},
+	{NAND_PAGE_8K,	PAGE_SIZE_8KB,	"8K"},
+	{NAND_PAGE_16K,	PAGE_SIZE_16KB,	"16K"},
+};
+
+unsigned char match_page_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(page_table, ARRAY_SIZE(page_table), reg,
+			NAND_PAGE_2K);
+}
+
+unsigned char match_page_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(page_table, ARRAY_SIZE(page_table), type,
+			PAGE_SIZE_2KB);
+}
+
+const char *match_page_type_to_str(unsigned char type)
+{
+	return match_type_to_data(page_table, ARRAY_SIZE(page_table), type,
+			"unknown");
+}
+
+/*****************************************************************************/
+static struct match_t ecc_table[] = {
+	{NAND_ECC_0BIT,		ECC_TYPE_0BIT,	"none"},
+	{NAND_ECC_8BIT,		ECC_TYPE_8BIT,	"4bit/512"},
+	{NAND_ECC_16BIT,	ECC_TYPE_16BIT,	"8bit/512"},
+	{NAND_ECC_24BIT,	ECC_TYPE_24BIT,	"24bit/1K"},
+	{NAND_ECC_28BIT,	ECC_TYPE_28BIT,	"28bit/1K"},
+	{NAND_ECC_40BIT,	ECC_TYPE_40BIT,	"40bit/1K"},
+	{NAND_ECC_64BIT,	ECC_TYPE_64BIT,	"64bit/1K"},
+};
+
+unsigned char match_ecc_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(ecc_table, ARRAY_SIZE(ecc_table), reg,
+			NAND_ECC_8BIT);
+}
+
+unsigned char match_ecc_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(ecc_table, ARRAY_SIZE(ecc_table), type,
+			ECC_TYPE_8BIT);
+}
+
+const char *match_ecc_type_to_str(unsigned char type)
+{
+	return match_type_to_data(ecc_table, ARRAY_SIZE(ecc_table), type,
+			"unknown");
+}
+
+/*****************************************************************************/
+static struct match_t page_type_size_table[] = {
+	{NAND_PAGE_2K,	_2K,	NULL},
+	{NAND_PAGE_4K,	_4K,	NULL},
+	{NAND_PAGE_8K,	_8K,	NULL},
+	{NAND_PAGE_16K,	_16K,	NULL},
+};
+
+unsigned char match_page_size_to_type(unsigned int size)
+{
+	return match_reg_to_type(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), size, NAND_PAGE_2K);
+}
+
+unsigned int match_page_type_to_size(unsigned char type)
+{
+	return match_type_to_reg(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), type, _2K);
+}
+
+#endif
\ No newline at end of file
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c b/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c
new file mode 100644
index 000000000..fac3168c4
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c
@@ -0,0 +1,1529 @@
+#include <common.h>
+#include <linux/mtd/nand.h>
+#include "cvsnfc_spi_ids.h"
+#include "cvsnfc_common.h"
+#include "cvsnfc.h"
+#include <asm/io.h>
+#include <command.h>
+
+#define DEBUG_SPI_IDS 0
+
+/* ESMT spi nand don't support QE enable. */
+static int spi_nand_no_qe_enable(struct cvsnfc_op *spi)
+{
+	if (DEBUG_SPI_IDS)
+		printf("%s\n", __func__);
+
+	return 0;
+}
+
+/* register addr:0xb0
+ * QE bit pos:BIT(0)
+ *
+ */
+static int spi_nand_qe_enable(struct cvsnfc_op *spi)
+{
+	unsigned int regval = 0;
+	struct cvsnfc_host *host = (struct cvsnfc_host *)spi->host;
+
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &regval);
+	regval |= FEATURE_QE_ENABLE;
+	spi_feature_op(host, SET_OP, FEATURE_ADDR, &regval);
+
+	/* check it */
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &regval);
+	if (!(regval & FEATURE_QE_ENABLE))
+		return -1;
+
+	return 0;
+}
+
+/* status register addr is C0h. bit0 is OIP
+ * it indicates whether the device is busy
+ * bit1 is WEL, it indicates whether the device
+ * is set to internal write enable latch.
+ * block lock register addr is A0h
+ */
+static int spi_general_wait_ready(struct cvsnfc_op *spi)
+{
+	unsigned int regval = 0;
+	unsigned int deadline = 0;
+	struct cvsnfc_host *host = (struct cvsnfc_host *)spi->host;
+
+	if (DEBUG_SPI_IDS)
+		printf("%s\n", __func__);
+
+	do {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &regval);
+		if (!(regval & STATUS_OIP_MASK)) {
+			if ((host->cmd_option.last_cmd == NAND_CMD_ERASE2) &&
+			    (regval & STATUS_E_FAIL_MASK))
+				return regval;
+			if ((host->cmd_option.last_cmd == NAND_CMD_PAGEPROG) &&
+			    (regval & STATUS_P_FAIL_MASK))
+				return regval;
+			return 0;
+		}
+		udelay(1);
+	} while (deadline++ < (40 << 20));
+
+	if (DEBUG_SPI_IDS)
+		printf("cvsnfc: wait ready timeout.\n");
+
+	return 1;
+}
+
+/* Send write enable command to SPI Nand, status[C0H]:[2]bit WEL must be set 1 */
+static int spi_general_write_enable(struct cvsnfc_op *spi)
+{
+	unsigned int val = FEATURE_PROTECTION_NONE;
+	struct cvsnfc_host *host = (struct cvsnfc_host *)spi->host;
+
+	if (DEBUG_SPI_IDS)
+		printf("%s\n", __func__);
+	spi_feature_op(host, SET_OP, SPI_NAND_FEATURE_PROTECTION, &val);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0x0);
+	/* write enable */
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_WREN);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+	/* read and check WEL bit */
+	spi_feature_op(host, GET_OP, WRITE_ENABLE_STATUS_ADDR, &val);
+	if (!(val & STATUS_WEL_MASK)) {
+		printf("cvsnfc: write enable failed! val[%#x]\n", val);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int spi_nand_esmt_ecc_enable(struct cvsnfc_op *spi)
+{
+	return 0;
+}
+
+static int spi_nand_winbond_select_die(struct cvsnfc_op *spi, unsigned int id)
+{
+	struct cvsnfc_host *host = (struct cvsnfc_host *)spi->host;
+	static uint8_t pre_id = 0xff;
+
+	if (id == pre_id) {
+		return 0;
+	}
+
+	// Select Die
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0x1);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0,
+		    (id << TRX_CMD_CONT0_SHIFT) | 0xC2);
+
+	// Wait for completion
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0,
+		    cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) |
+			    BIT_REG_TRX_START);
+
+	CVSNFC_CMD_WAIT_CPU_FINISH(host);
+	CVSNFC_CLEAR_INT(host);
+
+	pre_id = id;
+	return 0;
+}
+
+static struct spi_nand_driver  spi_nand_driver_esmt = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_nand_no_qe_enable,
+	.ecc_enable = spi_nand_esmt_ecc_enable,
+};
+
+static struct spi_nand_driver spi_nand_driver_winbond_multi = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_nand_no_qe_enable,
+	.ecc_enable = spi_nand_esmt_ecc_enable,
+	.select_die = spi_nand_winbond_select_die,
+};
+
+static struct spi_nand_driver  spi_nand_driver_toshiba = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_nand_no_qe_enable,
+};
+
+static struct spi_nand_driver spi_nand_driver_gd = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_nand_qe_enable,
+};
+
+static struct spi_nand_driver spi_nand_driver_mxic = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_nand_qe_enable,
+};
+
+/*****************************************************************************/
+#define SPI_NAND_ID_TAB_VER		"1.3"
+
+struct cvsnfc_chip_info cvsnfc_spi_nand_flash_table[] = {
+
+	/* ESMT F50L1G41LB 1Gbit */
+	{
+		.name      = "F50L1G41LB",
+		.id        = {0xc8, 0x01},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+
+	},
+
+	/* ESMT F50L512M41A 512Mbit */
+	{
+		.name      = "F50L512M41A",
+		.id        = {0xc8, 0x20},
+		.id_len    = 2,
+		.chipsize  = _64M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* ESMT F50L1G41A 1Gbit */
+	{
+		.name      = "F50L1G41A",
+		.id        = {0xc8, 0x21},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* ESMT F50L1G41B 1Gbit */
+	{
+		.name      = "F50L1G41B",
+		.id        = {0xc8, 0x01},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* ESMT F50L2G41KA 2Gbit */
+	{
+		.name      = "F50L2G41KA",
+		.id        = {0xc8, 0x41},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* ESMT F50L2G41XA(2B) 3.3v 2Gbit */
+	{
+		.name	   = "F50L2G41XA",
+		.id	   = {0x2c, 0x24},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_SET_PLANE_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* ESMT F50L4G41XB 3.3v 2Gbit */
+	{
+		.name	   = "F50L4G41XB",
+		.id	   = {0x2c, 0x34},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* ESMT F50D1G41 1Gbit */
+	{
+		.name	   = "F50D1G41",
+		.id	   = {0xc8, 0x11},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_46MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD5F1GQ4UAYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ4UAYIG",
+		.id        = {0xc8, 0xf1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD5F1GQ4UBYIG 1Gbit */
+	{
+		.name      = "GD5F1GQ4UBYIG",
+		.id        = {0xc8, 0xd1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD 5F2GQ4UAYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ4UAYIG",
+		.id        = {0xc8, 0xf2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD 5F2GQ4UBYIG 2Gbit */
+	{
+		.name      = "GD5F2GQ4UBYIG",
+		.id        = {0xc8, 0xd2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD 5F4GQ4UAYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4UAYIG",
+		.id        = {0xc8, 0xf4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD 5F4GQ4UBYIG 4Gbit */
+	{
+		.name      = "GD5F4GQ4UBYIG",
+		.id        = {0xc8, 0xd4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD5F1GQ5UExxH 1Gbit */
+	{
+		.name	   = "GD5F1GQ5UExxH",
+		.id	   = {0xc8, 0x31},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD5F1GQ5UExxG 1Gbit */
+	{
+		.name	   = "GD5F1GQ5UExxG",
+		.id	   = {0xc8, 0x51},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD5F2GQ5UExxH 2Gbit */
+	{
+		.name	   = "GD5F2GQ5UExxH",
+		.id	   = {0xc8, 0x32},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD GD5F2GQ5RExxH 2Gbit */
+	{
+		.name	   = "GD5F2GQ5RExxH",
+		.id	   = {0xc8, 0x22},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD GD5F2GQ5UEYIH 2Gbit */
+	{
+		.name	   = "GD5F2GQ5UEYIH",
+		.id	   = {0xc8, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD GD5F4GQ6UEYIG 4Gbit */
+	{
+		.name	   = "GD5F4GQ6UEYIG",
+		.id	   = {0xc8, 0x55},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD GD5F1GM7 1Gbit */
+	{
+		.name	   = "GD5F1GM7UEYIG",
+		.id	   = {0xc8, 0x91},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* GD GD5F2GM7 2Gbit */
+	{
+		.name	   = "GD5F2GM7UEYIG",
+		.id	   = {0xc8, 0x92},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Micron MT29F1G01 */
+	{
+		.name      = "MT29F1G01",
+		.id        = {0x2c, 0x12},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_46MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Micron MT29F2G01 */
+	{
+		.name      = "MT29F2G01",
+		.id        = {0x2c, 0x22},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_46MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Micron MT29F4G01 */
+	{
+		.name      = "MT29F4G01",
+		.id        = {0x2c, 0x32},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_46MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Micron MT29F1G01ABAFDWB */
+	{
+		.name      = "MT29F1G01ABAFDWB",
+		.id        = {0x2c, 0x14},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* MXIC MX35LF1GE4AB, 1Gb, 3V */
+	{
+		.name	   = "MX35LF1GE4AB",
+		.id	   = {0xc2, 0x12},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_mxic,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* MXIC MX35LF2GE4AB 2Gbit */
+	{
+		.name      = "MX35LF2GE4AB",
+		.id        = {0xc2, 0x22},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_mxic,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/*  MXIC MX35LF2GE4AD 2Gbit */
+	{
+		.name      = "MX35LF2GE4AD",
+		.id        = {0xc2, 0x26, 0x03},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_mxic,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/*  MXIC MX35LF4GE4AD 4Gbit */
+	{
+		.name      = "MX35LF4GE4AD",
+		.id        = {0xc2, 0x37, 0x03},
+		.id_len    = 3,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_mxic,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* TOSHIBA TC58CVG2S0H 4Gbit */
+	{
+		.name      = "TC58CVG2S0HRAIJ",
+		.id        = {0x98, 0xed, 0x51},
+		.id_len    = 3,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_toshiba,
+		.flags = FLAGS_SUPPORT_W_TWICE_DEBUG | FLAGS_SET_QE_BIT
+				| FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* TOSHIBA TC58CVG1S3HRAIJ 2Gbit */
+	{
+
+		.name      = "TC58CVG1S3HRAIJ",
+		.id        = {0x98, 0xeb, 0x40},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_toshiba,
+		.flags = FLAGS_SUPPORT_W_TWICE_DEBUG | FLAGS_SET_QE_BIT
+				| FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* TOSHIBA TC58CVG0S3HRAIJ 2Gbit */
+	{
+
+		.name      = "TC58CVG0S3HRAIJ",
+		.id        = {0x98, 0xc2},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_toshiba,
+		.flags = FLAGS_SUPPORT_W_TWICE_DEBUG | FLAGS_SET_QE_BIT
+				| FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* TOSHIBA TC58CVG0S3HRAIJ 2Gbit */
+	{
+		.name      = "TC58CVG0S3HRAIJ",
+		.id        = {0x98, 0xe2},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_toshiba,
+		.flags = FLAGS_SUPPORT_W_TWICE_DEBUG | FLAGS_SET_QE_BIT
+				| FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Winbond W25N01GVxxIG 1Gbit */
+	{
+		.name      = "W25N01GVxxIG",
+		.id        = {0xef, 0xaa, 0x21},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Winbond W25M02GV 2Gbit */
+	{
+		.name      = "W25M02GV",
+		.id        = {0xef, 0xab, 0x21},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.diesize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_winbond_multi,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Winbond W25N04KV 4Gbit */
+	{
+		.name      = "W25N04KV",
+		.id        = {0xef, 0xaa, 0x23},
+		.id_len    = 3,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Winbond W25N01KVxxIR 1Gbit */
+	{
+		.name      = "W25N01KV",
+		.id        = {0xef, 0xae, 0x21},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* Winbond W25N02KV 2Gbit */
+	{
+		.name      = "W25N02KV",
+		.id        = {0xef, 0xaa, 0x22},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_esmt,
+		.flags = FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* XTX XT26G11C 1Gbit */
+	{
+		.name      = "XT26G11C",
+		.id        = {0x0b, 0x15},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* TOSHIBA TC58CVG1S3HxAIx 2Gbit */
+	{
+
+		.name      = "TC58CVG1S3HxAIx",
+		.id        = {0x98, 0xcb},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_toshiba,
+		.flags = FLAGS_SUPPORT_W_TWICE_DEBUG
+				| FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* DOSILICON DS35Q1GA-IB 1Gbit */
+	{
+		.name      = "DS35Q1GA-IB",
+		.id        = {0xe5, 0x71},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* DOSILICON DS35X1GBXXX 1Gbit */
+	{
+		.name      = "DS35Q1GB-IB",
+		.id        = {0xe5, 0xf1},		// 3.3V
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x70, /* bit 4 & 5 & 6*/
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 0,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* FORESEE F35SQA001G 1Gbit */
+	{
+		.name      = "F35SQA001G",
+		.id        = {0xcd, 0x71, 0x71},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	/* FORESEE F35SQA002G 2Gbit */
+	{
+		.name      = "F35SQA002G",
+		.id        = {0xcd, 0x72, 0x72},
+		.id_len    = 3,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	{
+		.name      = "HYF2GQ4UAACAE",
+		.id        = {0xC9, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.driver    = &spi_nand_driver_gd,
+		.flags = FLAGS_SET_QE_BIT | FLAGS_ENABLE_X2_BIT | FLAGS_ENABLE_X4_BIT,
+		.ecc_en_feature_offset = 0xb0, /* Configuration register */
+		.ecc_en_mask = 1 << 4, /* bit 4 */
+		.ecc_status_offset = 0xc0, /* Status register */
+		.ecc_status_mask = 0x30, /* bit 4 & 5 */
+		.ecc_status_shift = 4,
+		.ecc_status_uncorr_val = 0x2,
+		.sck_l = 1,
+		.sck_h = 1,
+		.max_freq = SPI_NAND_FREQ_62MHz,
+		.sample_param = 0x40001000,
+		.xtal_switch = 1,
+	},
+
+	{	.id_len    = 0,	},
+};
+
+static int do_spinand_show_support_list(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	char buf[128] = {0};
+	struct cvsnfc_chip_info *info = cvsnfc_spi_nand_flash_table;
+	uint32_t id, size, i;
+
+	printf("\t###################### nand flash list #########################\n\n");
+
+	sprintf(buf, "\t%-16s           %-12s		   %-4s\n", "NAME", "JEDEC_ID", "SIZE");
+	printf("%s\n", buf);
+	for (; info->name; info++) {
+		id = 0;
+		size = 0;
+
+		for (i = 0; i < info->id_len; i++)
+			id |= info->id[i] << (info->id_len - i - 1) * 8;
+
+		size = info->chipsize >> 20;
+		sprintf(buf, "\t%-16s           0x%-12x          %-4u M\n", info->name, id, size);
+		printf("%s\n", buf);
+	}
+	printf("\t###############################################################\n\n");
+	return 0;
+}
+
+U_BOOT_CMD(nandshow, 2, 0, do_spinand_show_support_list, "nandshow", "\nshow nand flash list\n");
+
+static inline unsigned int ANY_BP_ENABLE(unsigned int val)
+{
+	return ((PROTECTION_BP3_MASK & (val)) || (PROTECTION_BP2_MASK & (val)) ||
+		(PROTECTION_BP1_MASK & (val)) || (PROTECTION_BP0_MASK & (val)));
+}
+
+/*****************************************************************************/
+static void cvsnfc_spi_probe(struct cvsnfc_host *host,
+			     struct cvsnfc_chip_info *spi_dev)
+{
+	unsigned int regval;
+	struct cvsnfc_op *spi = host->spi;
+
+	if (DEBUG_SPI_IDS)
+		printf("%s\n", __func__);
+
+	spi->host = host;
+	spi->driver = spi_dev->driver;
+
+	spi_feature_op(host, GET_OP, PROTECTION_ADDR, &regval);
+
+	spi->driver->wait_ready(spi);
+
+	if (ANY_BP_ENABLE(regval)) {
+		regval &= ~ALL_BP_MASK;
+		spi_feature_op(host, SET_OP, PROTECTION_ADDR, &regval);
+
+
+		spi->driver->wait_ready(spi);
+		spi_feature_op(host, GET_OP, PROTECTION_ADDR, &regval);
+		if (ANY_BP_ENABLE(regval))
+			printf("%s write protection disable fail! val[%#x]\n",
+			       __func__, regval);
+	}
+}
+
+/*****************************************************************************/
+static void dump_nand_info(struct cvsnfc_chip_info *nandinfo)
+{
+	pr_info("====== SPI NAND INFO ======\n");
+
+	switch (nandinfo->id_len) {
+	case 2:
+		pr_info("model name: %s, MID=0x%x, DID=0x%x\n", nandinfo->name,
+			nandinfo->id[0], nandinfo->id[1]);
+		break;
+	case 3:
+		pr_info("model name: %s, MID=0x%x, DID=0x%x 0x%x\n", nandinfo->name,
+			nandinfo->id[0], nandinfo->id[1], nandinfo->id[2]);
+		break;
+	default:
+		pr_info("model name: %s with wrong id length\n", nandinfo->name);
+	}
+
+	pr_info("chip size=%lldMB, diesize=%lldMB, erase size=%dKB\n", (nandinfo->chipsize >> 20),
+		(nandinfo->diesize >> 20), (nandinfo->erasesize >> 10));
+
+	pr_info("page size=%dKB, oob size=%dB, badblock_pos=0x%x, flags=0x%x\n", (nandinfo->pagesize >> 10),
+		nandinfo->oobsize, nandinfo->badblock_pos, nandinfo->flags);
+
+	pr_info("ECC enable offset=0x%x, ECC_EN mask=0x%x, STATUS offset=0x%x, STATUS mask=0x%x\n",
+		nandinfo->ecc_en_feature_offset, nandinfo->ecc_en_mask, nandinfo->ecc_status_offset,
+		nandinfo->ecc_status_mask);
+	pr_info("STATUS shift=%d, STATUS valid_val=0x%x\n", nandinfo->ecc_status_shift,
+		nandinfo->ecc_status_uncorr_val);
+	pr_info("sck_l=%d, sck_h=%d, max_freq=0x%x, sample_param=0x%x\n", nandinfo->sck_l, nandinfo->sck_h,
+		nandinfo->max_freq, nandinfo->sample_param);
+	pr_info("xtal_switch=%d\n", nandinfo->xtal_switch);
+
+	pr_info("\n");
+}
+
+static struct nand_flash_dev *spi_nand_get_flash_info(struct mtd_info *mtd,
+						      struct nand_chip *chip,
+						      struct nand_flash_dev_ex *flash_dev_ex)
+{
+	struct cvsnfc_host *host = (struct cvsnfc_host *)chip->priv;
+	struct cvsnfc_chip_info *spi_dev = cvsnfc_spi_nand_flash_table;
+	unsigned char i = 0;
+	unsigned char *byte = flash_dev_ex->ids;
+	struct nand_flash_dev *flash_type = &flash_dev_ex->flash_dev;
+
+	host->flags = 0;
+
+	// find match device ID and assign correct parameter and ops
+	for (; spi_dev->id_len; spi_dev++) {
+
+		if (memcmp(byte, spi_dev->id, DEFAULT_ID_LEN))
+			continue;
+
+		if (spi_dev->id_len > DEFAULT_ID_LEN) {
+			if (!i) {
+				chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+				host->offset = DEFAULT_ID_LEN;
+				for (i = DEFAULT_ID_LEN;
+					i < spi_dev->id_len; i++)
+					byte[i] = chip->read_byte(mtd);
+			}
+
+			if (memcmp(byte, spi_dev->id, spi_dev->id_len))
+				continue;
+		}
+
+		flash_type->name = spi_dev->name;
+		flash_type->mfr_id = byte[0];
+		flash_type->dev_id = byte[1];
+		flash_type->pagesize  = spi_dev->pagesize;
+		flash_type->chipsize = spi_dev->chipsize >> 20;
+		flash_type->erasesize = spi_dev->erasesize;
+		host->diesize = spi_dev->diesize;
+
+		printf("Device ID : ");
+
+		for (int j = 0; j < spi_dev->id_len; j++)
+			printf("%#x ", byte[j]);
+
+		if (flash_type->name)
+			printf(" Model: %s", flash_type->name);
+		printf("\n");
+
+		pr_info("SPI NAND device support plane bit ! chip->options 0x%x\n", chip->options);
+
+		if (spi_dev->flags & FLAGS_SET_PLANE_BIT) {
+			printf("Device support plane bit\n");
+			host->flags |= FLAGS_SET_PLANE_BIT;
+		}
+
+		if (spi_dev->flags & FLAGS_CONTORL_WP_BIT) {
+			printf("Control wp pin\n");
+			host->flags |= FLAGS_CONTORL_WP_BIT;
+		}
+
+		if (spi_dev->flags & FLAGS_SUPPORT_W_TWICE_DEBUG) {
+			printf("Device support write twice debugging\n");
+			host->flags |= FLAGS_SUPPORT_W_TWICE_DEBUG;
+		}
+
+		flash_dev_ex->oobsize = spi_dev->oobsize;
+
+		if (host->mtd != mtd)
+			host->mtd = mtd;
+		cvsnfc_spi_probe(host, spi_dev);
+		host->nand_chip_info = spi_dev;
+
+		dump_nand_info(host->nand_chip_info);
+
+		if ((host->nand_chip_info->flags & FLAGS_SET_QE_BIT) && host->nand_chip_info->driver->qe_enable)
+			host->nand_chip_info->driver->qe_enable(host->spi);
+
+		return flash_type;
+	}
+
+	printf("unrecognized device id!!!\nDevice ID : ");
+	for (int j = 0; j < DEFAULT_ID_LEN; j++)
+		printf("%#x ", byte[j]);
+	printf("\n");
+	assert(0);
+
+	return NULL;
+}
+
+/*****************************************************************************/
+void spi_nand_ids_register(void)
+{
+	nand_get_spl_flash_type = spi_nand_get_flash_info;
+}
diff --git a/drivers/mtd/nand/raw/nand.c b/drivers/mtd/nand/raw/nand.c
index 026419e4e..b57ee5211 100644
--- a/drivers/mtd/nand/raw/nand.c
+++ b/drivers/mtd/nand/raw/nand.c
@@ -16,7 +16,7 @@
 
 int nand_curr_device = -1;
 
-static struct mtd_info *nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
+struct mtd_info *nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
 
 #ifndef CONFIG_SYS_NAND_SELF_INIT
 static struct nand_chip nand_chip[CONFIG_SYS_MAX_NAND_DEVICE];
diff --git a/drivers/mtd/nand/raw/nand_base.c b/drivers/mtd/nand/raw/nand_base.c
index b1fd77988..013971ff8 100644
--- a/drivers/mtd/nand/raw/nand_base.c
+++ b/drivers/mtd/nand/raw/nand_base.c
@@ -45,8 +45,11 @@
 #ifdef CONFIG_MTD_PARTITIONS
 #include <linux/mtd/partitions.h>
 #endif
+#include <malloc.h>
 #include <asm/io.h>
 #include <linux/errno.h>
+#include "cvsnfc.h"
+#include "cvsnfc_common.h"
 
 /* Define default oob placement schemes for large and small page devices */
 #ifndef CONFIG_SYS_NAND_DRIVER_ECC_LAYOUT
@@ -907,7 +910,7 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 
  	u32 timer = (CONFIG_SYS_HZ * timeo) / 1000;
  	u32 time_start;
- 
+
  	time_start = get_timer(0);
  	while (get_timer(time_start) < timer) {
 		if (chip->dev_ready) {
@@ -1112,35 +1115,6 @@ int nand_read_page_op(struct nand_chip *chip, unsigned int page,
 }
 EXPORT_SYMBOL_GPL(nand_read_page_op);
 
-/**
- * nand_read_param_page_op - Do a READ PARAMETER PAGE operation
- * @chip: The NAND chip
- * @page: parameter page to read
- * @buf: buffer used to store the data
- * @len: length of the buffer
- *
- * This function issues a READ PARAMETER PAGE operation.
- * This function does not select/unselect the CS line.
- *
- * Returns 0 on success, a negative error code otherwise.
- */
-static int nand_read_param_page_op(struct nand_chip *chip, u8 page, void *buf,
-				   unsigned int len)
-{
-	struct mtd_info *mtd = nand_to_mtd(chip);
-	unsigned int i;
-	u8 *p = buf;
-
-	if (len && !buf)
-		return -EINVAL;
-
-	chip->cmdfunc(mtd, NAND_CMD_PARAM, page, -1);
-	for (i = 0; i < len; i++)
-		p[i] = chip->read_byte(mtd);
-
-	return 0;
-}
-
 /**
  * nand_change_read_column_op - Do a CHANGE READ COLUMN operation
  * @chip: The NAND chip
@@ -2311,7 +2285,6 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 	int ret = 0;
 	uint32_t readlen = ops->len;
 	uint32_t oobreadlen = ops->ooblen;
-	uint32_t max_oobsize = mtd_oobavail(mtd, ops);
 
 	uint8_t *bufpoi, *oob, *buf;
 	int use_bufpoi;
@@ -2400,16 +2373,6 @@ read_retry:
 				memcpy(buf, chip->buffers->databuf + col, bytes);
 			}
 
-			if (unlikely(oob)) {
-				int toread = min(oobreadlen, max_oobsize);
-
-				if (toread) {
-					oob = nand_transfer_oob(chip,
-						oob, ops, toread);
-					oobreadlen -= toread;
-				}
-			}
-
 			if (chip->options & NAND_NEED_READRDY) {
 				/* Apply delay or wait for ready/busy pin */
 				if (!chip->dev_ready)
@@ -2771,9 +2734,9 @@ static int nand_read_oob(struct mtd_info *mtd, loff_t from,
 	}
 
 	if (!ops->datbuf)
-		ret = nand_do_read_oob(mtd, from, ops);
+		ret = nand_do_read_oob(mtd, from, ops); // read oob only
 	else
-		ret = nand_do_read_ops(mtd, from, ops);
+		ret = nand_do_read_ops(mtd, from, ops); // read both data & oob
 
 out:
 	nand_release_device(mtd);
@@ -3761,569 +3724,6 @@ static void nand_set_defaults(struct nand_chip *chip, int busw)
 		chip->buf_align = 1;
 }
 
-/* Sanitize ONFI strings so we can safely print them */
-static void sanitize_string(char *s, size_t len)
-{
-	ssize_t i;
-
-	/* Null terminate */
-	s[len - 1] = 0;
-
-	/* Remove non printable chars */
-	for (i = 0; i < len - 1; i++) {
-		if (s[i] < ' ' || s[i] > 127)
-			s[i] = '?';
-	}
-
-	/* Remove trailing spaces */
-	strim(s);
-}
-
-static u16 onfi_crc16(u16 crc, u8 const *p, size_t len)
-{
-	int i;
-	while (len--) {
-		crc ^= *p++ << 8;
-		for (i = 0; i < 8; i++)
-			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
-	}
-
-	return crc;
-}
-
-#ifdef CONFIG_SYS_NAND_ONFI_DETECTION
-/* Parse the Extended Parameter Page. */
-static int nand_flash_detect_ext_param_page(struct mtd_info *mtd,
-		struct nand_chip *chip, struct nand_onfi_params *p)
-{
-	struct onfi_ext_param_page *ep;
-	struct onfi_ext_section *s;
-	struct onfi_ext_ecc_info *ecc;
-	uint8_t *cursor;
-	int ret;
-	int len;
-	int i;
-
-	len = le16_to_cpu(p->ext_param_page_length) * 16;
-	ep = kmalloc(len, GFP_KERNEL);
-	if (!ep)
-		return -ENOMEM;
-
-	/* Send our own NAND_CMD_PARAM. */
-	ret = nand_read_param_page_op(chip, 0, NULL, 0);
-	if (ret)
-		goto ext_out;
-
-	/* Use the Change Read Column command to skip the ONFI param pages. */
-	ret = nand_change_read_column_op(chip,
-					 sizeof(*p) * p->num_of_param_pages,
-					 ep, len, true);
-	if (ret)
-		goto ext_out;
-
-	ret = -EINVAL;
-	if ((onfi_crc16(ONFI_CRC_BASE, ((uint8_t *)ep) + 2, len - 2)
-		!= le16_to_cpu(ep->crc))) {
-		pr_debug("fail in the CRC.\n");
-		goto ext_out;
-	}
-
-	/*
-	 * Check the signature.
-	 * Do not strictly follow the ONFI spec, maybe changed in future.
-	 */
-	if (strncmp((char *)ep->sig, "EPPS", 4)) {
-		pr_debug("The signature is invalid.\n");
-		goto ext_out;
-	}
-
-	/* find the ECC section. */
-	cursor = (uint8_t *)(ep + 1);
-	for (i = 0; i < ONFI_EXT_SECTION_MAX; i++) {
-		s = ep->sections + i;
-		if (s->type == ONFI_SECTION_TYPE_2)
-			break;
-		cursor += s->length * 16;
-	}
-	if (i == ONFI_EXT_SECTION_MAX) {
-		pr_debug("We can not find the ECC section.\n");
-		goto ext_out;
-	}
-
-	/* get the info we want. */
-	ecc = (struct onfi_ext_ecc_info *)cursor;
-
-	if (!ecc->codeword_size) {
-		pr_debug("Invalid codeword size\n");
-		goto ext_out;
-	}
-
-	chip->ecc_strength_ds = ecc->ecc_bits;
-	chip->ecc_step_ds = 1 << ecc->codeword_size;
-	ret = 0;
-
-ext_out:
-	kfree(ep);
-	return ret;
-}
-
-static int nand_setup_read_retry_micron(struct mtd_info *mtd, int retry_mode)
-{
-	struct nand_chip *chip = mtd_to_nand(mtd);
-	uint8_t feature[ONFI_SUBFEATURE_PARAM_LEN] = {retry_mode};
-
-	return chip->onfi_set_features(mtd, chip, ONFI_FEATURE_ADDR_READ_RETRY,
-			feature);
-}
-
-/*
- * Configure chip properties from Micron vendor-specific ONFI table
- */
-static void nand_onfi_detect_micron(struct nand_chip *chip,
-		struct nand_onfi_params *p)
-{
-	struct nand_onfi_vendor_micron *micron = (void *)p->vendor;
-
-	if (le16_to_cpu(p->vendor_revision) < 1)
-		return;
-
-	chip->read_retries = micron->read_retry_options;
-	chip->setup_read_retry = nand_setup_read_retry_micron;
-}
-
-/*
- * Check if the NAND chip is ONFI compliant, returns 1 if it is, 0 otherwise.
- */
-static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
-					int *busw)
-{
-	struct nand_onfi_params *p = &chip->onfi_params;
-	char id[4];
-	int i, ret, val;
-
-	/* Try ONFI for unknown chip or LP */
-	ret = nand_readid_op(chip, 0x20, id, sizeof(id));
-	if (ret || strncmp(id, "ONFI", 4))
-		return 0;
-
-	ret = nand_read_param_page_op(chip, 0, NULL, 0);
-	if (ret)
-		return 0;
-
-	for (i = 0; i < 3; i++) {
-		ret = nand_read_data_op(chip, p, sizeof(*p), true);
-		if (ret)
-			return 0;
-
-		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==
-				le16_to_cpu(p->crc)) {
-			break;
-		}
-	}
-
-	if (i == 3) {
-		pr_err("Could not find valid ONFI parameter page; aborting\n");
-		return 0;
-	}
-
-	/* Check version */
-	val = le16_to_cpu(p->revision);
-	if (val & (1 << 5))
-		chip->onfi_version = 23;
-	else if (val & (1 << 4))
-		chip->onfi_version = 22;
-	else if (val & (1 << 3))
-		chip->onfi_version = 21;
-	else if (val & (1 << 2))
-		chip->onfi_version = 20;
-	else if (val & (1 << 1))
-		chip->onfi_version = 10;
-
-	if (!chip->onfi_version) {
-		pr_info("unsupported ONFI version: %d\n", val);
-		return 0;
-	}
-
-	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
-	sanitize_string(p->model, sizeof(p->model));
-	if (!mtd->name)
-		mtd->name = p->model;
-
-	mtd->writesize = le32_to_cpu(p->byte_per_page);
-
-	/*
-	 * pages_per_block and blocks_per_lun may not be a power-of-2 size
-	 * (don't ask me who thought of this...). MTD assumes that these
-	 * dimensions will be power-of-2, so just truncate the remaining area.
-	 */
-	mtd->erasesize = 1 << (fls(le32_to_cpu(p->pages_per_block)) - 1);
-	mtd->erasesize *= mtd->writesize;
-
-	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
-
-	/* See erasesize comment */
-	chip->chipsize = 1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);
-	chip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;
-	chip->bits_per_cell = p->bits_per_cell;
-
-	if (onfi_feature(chip) & ONFI_FEATURE_16_BIT_BUS)
-		*busw = NAND_BUSWIDTH_16;
-	else
-		*busw = 0;
-
-	if (p->ecc_bits != 0xff) {
-		chip->ecc_strength_ds = p->ecc_bits;
-		chip->ecc_step_ds = 512;
-	} else if (chip->onfi_version >= 21 &&
-		(onfi_feature(chip) & ONFI_FEATURE_EXT_PARAM_PAGE)) {
-
-		/*
-		 * The nand_flash_detect_ext_param_page() uses the
-		 * Change Read Column command which maybe not supported
-		 * by the chip->cmdfunc. So try to update the chip->cmdfunc
-		 * now. We do not replace user supplied command function.
-		 */
-		if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
-			chip->cmdfunc = nand_command_lp;
-
-		/* The Extended Parameter Page is supported since ONFI 2.1. */
-		if (nand_flash_detect_ext_param_page(mtd, chip, p))
-			pr_warn("Failed to detect ONFI extended param page\n");
-	} else {
-		pr_warn("Could not retrieve ONFI ECC requirements\n");
-	}
-
-	if (p->jedec_id == NAND_MFR_MICRON)
-		nand_onfi_detect_micron(chip, p);
-
-	return 1;
-}
-#else
-static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
-					int *busw)
-{
-	return 0;
-}
-#endif
-
-/*
- * Check if the NAND chip is JEDEC compliant, returns 1 if it is, 0 otherwise.
- */
-static int nand_flash_detect_jedec(struct mtd_info *mtd, struct nand_chip *chip,
-					int *busw)
-{
-	struct nand_jedec_params *p = &chip->jedec_params;
-	struct jedec_ecc_info *ecc;
-	char id[5];
-	int i, val, ret;
-
-	/* Try JEDEC for unknown chip or LP */
-	ret = nand_readid_op(chip, 0x40, id, sizeof(id));
-	if (ret || strncmp(id, "JEDEC", sizeof(id)))
-		return 0;
-
-	ret = nand_read_param_page_op(chip, 0x40, NULL, 0);
-	if (ret)
-		return 0;
-
-	for (i = 0; i < 3; i++) {
-		ret = nand_read_data_op(chip, p, sizeof(*p), true);
-		if (ret)
-			return 0;
-
-		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 510) ==
-				le16_to_cpu(p->crc))
-			break;
-	}
-
-	if (i == 3) {
-		pr_err("Could not find valid JEDEC parameter page; aborting\n");
-		return 0;
-	}
-
-	/* Check version */
-	val = le16_to_cpu(p->revision);
-	if (val & (1 << 2))
-		chip->jedec_version = 10;
-	else if (val & (1 << 1))
-		chip->jedec_version = 1; /* vendor specific version */
-
-	if (!chip->jedec_version) {
-		pr_info("unsupported JEDEC version: %d\n", val);
-		return 0;
-	}
-
-	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
-	sanitize_string(p->model, sizeof(p->model));
-	if (!mtd->name)
-		mtd->name = p->model;
-
-	mtd->writesize = le32_to_cpu(p->byte_per_page);
-
-	/* Please reference to the comment for nand_flash_detect_onfi. */
-	mtd->erasesize = 1 << (fls(le32_to_cpu(p->pages_per_block)) - 1);
-	mtd->erasesize *= mtd->writesize;
-
-	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
-
-	/* Please reference to the comment for nand_flash_detect_onfi. */
-	chip->chipsize = 1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);
-	chip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;
-	chip->bits_per_cell = p->bits_per_cell;
-
-	if (jedec_feature(chip) & JEDEC_FEATURE_16_BIT_BUS)
-		*busw = NAND_BUSWIDTH_16;
-	else
-		*busw = 0;
-
-	/* ECC info */
-	ecc = &p->ecc_info[0];
-
-	if (ecc->codeword_size >= 9) {
-		chip->ecc_strength_ds = ecc->ecc_bits;
-		chip->ecc_step_ds = 1 << ecc->codeword_size;
-	} else {
-		pr_warn("Invalid codeword size\n");
-	}
-
-	return 1;
-}
-
-/*
- * nand_id_has_period - Check if an ID string has a given wraparound period
- * @id_data: the ID string
- * @arrlen: the length of the @id_data array
- * @period: the period of repitition
- *
- * Check if an ID string is repeated within a given sequence of bytes at
- * specific repetition interval period (e.g., {0x20,0x01,0x7F,0x20} has a
- * period of 3). This is a helper function for nand_id_len(). Returns non-zero
- * if the repetition has a period of @period; otherwise, returns zero.
- */
-static int nand_id_has_period(u8 *id_data, int arrlen, int period)
-{
-	int i, j;
-	for (i = 0; i < period; i++)
-		for (j = i + period; j < arrlen; j += period)
-			if (id_data[i] != id_data[j])
-				return 0;
-	return 1;
-}
-
-/*
- * nand_id_len - Get the length of an ID string returned by CMD_READID
- * @id_data: the ID string
- * @arrlen: the length of the @id_data array
-
- * Returns the length of the ID string, according to known wraparound/trailing
- * zero patterns. If no pattern exists, returns the length of the array.
- */
-static int nand_id_len(u8 *id_data, int arrlen)
-{
-	int last_nonzero, period;
-
-	/* Find last non-zero byte */
-	for (last_nonzero = arrlen - 1; last_nonzero >= 0; last_nonzero--)
-		if (id_data[last_nonzero])
-			break;
-
-	/* All zeros */
-	if (last_nonzero < 0)
-		return 0;
-
-	/* Calculate wraparound period */
-	for (period = 1; period < arrlen; period++)
-		if (nand_id_has_period(id_data, arrlen, period))
-			break;
-
-	/* There's a repeated pattern */
-	if (period < arrlen)
-		return period;
-
-	/* There are trailing zeros */
-	if (last_nonzero < arrlen - 1)
-		return last_nonzero + 1;
-
-	/* No pattern detected */
-	return arrlen;
-}
-
-/* Extract the bits of per cell from the 3rd byte of the extended ID */
-static int nand_get_bits_per_cell(u8 cellinfo)
-{
-	int bits;
-
-	bits = cellinfo & NAND_CI_CELLTYPE_MSK;
-	bits >>= NAND_CI_CELLTYPE_SHIFT;
-	return bits + 1;
-}
-
-/*
- * Many new NAND share similar device ID codes, which represent the size of the
- * chip. The rest of the parameters must be decoded according to generic or
- * manufacturer-specific "extended ID" decoding patterns.
- */
-static void nand_decode_ext_id(struct mtd_info *mtd, struct nand_chip *chip,
-				u8 id_data[8], int *busw)
-{
-	int extid, id_len;
-	/* The 3rd id byte holds MLC / multichip data */
-	chip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);
-	/* The 4th id byte is the important one */
-	extid = id_data[3];
-
-	id_len = nand_id_len(id_data, 8);
-
-	/*
-	 * Field definitions are in the following datasheets:
-	 * Old style (4,5 byte ID): Samsung K9GAG08U0M (p.32)
-	 * New Samsung (6 byte ID): Samsung K9GAG08U0F (p.44)
-	 * Hynix MLC   (6 byte ID): Hynix H27UBG8T2B (p.22)
-	 *
-	 * Check for ID length, non-zero 6th byte, cell type, and Hynix/Samsung
-	 * ID to decide what to do.
-	 */
-	if (id_len == 6 && id_data[0] == NAND_MFR_SAMSUNG &&
-			!nand_is_slc(chip) && id_data[5] != 0x00) {
-		/* Calc pagesize */
-		mtd->writesize = 2048 << (extid & 0x03);
-		extid >>= 2;
-		/* Calc oobsize */
-		switch (((extid >> 2) & 0x04) | (extid & 0x03)) {
-		case 1:
-			mtd->oobsize = 128;
-			break;
-		case 2:
-			mtd->oobsize = 218;
-			break;
-		case 3:
-			mtd->oobsize = 400;
-			break;
-		case 4:
-			mtd->oobsize = 436;
-			break;
-		case 5:
-			mtd->oobsize = 512;
-			break;
-		case 6:
-			mtd->oobsize = 640;
-			break;
-		case 7:
-		default: /* Other cases are "reserved" (unknown) */
-			mtd->oobsize = 1024;
-			break;
-		}
-		extid >>= 2;
-		/* Calc blocksize */
-		mtd->erasesize = (128 * 1024) <<
-			(((extid >> 1) & 0x04) | (extid & 0x03));
-		*busw = 0;
-	} else if (id_len == 6 && id_data[0] == NAND_MFR_HYNIX &&
-			!nand_is_slc(chip)) {
-		unsigned int tmp;
-
-		/* Calc pagesize */
-		mtd->writesize = 2048 << (extid & 0x03);
-		extid >>= 2;
-		/* Calc oobsize */
-		switch (((extid >> 2) & 0x04) | (extid & 0x03)) {
-		case 0:
-			mtd->oobsize = 128;
-			break;
-		case 1:
-			mtd->oobsize = 224;
-			break;
-		case 2:
-			mtd->oobsize = 448;
-			break;
-		case 3:
-			mtd->oobsize = 64;
-			break;
-		case 4:
-			mtd->oobsize = 32;
-			break;
-		case 5:
-			mtd->oobsize = 16;
-			break;
-		default:
-			mtd->oobsize = 640;
-			break;
-		}
-		extid >>= 2;
-		/* Calc blocksize */
-		tmp = ((extid >> 1) & 0x04) | (extid & 0x03);
-		if (tmp < 0x03)
-			mtd->erasesize = (128 * 1024) << tmp;
-		else if (tmp == 0x03)
-			mtd->erasesize = 768 * 1024;
-		else
-			mtd->erasesize = (64 * 1024) << tmp;
-		*busw = 0;
-	} else {
-		/* Calc pagesize */
-		mtd->writesize = 1024 << (extid & 0x03);
-		extid >>= 2;
-		/* Calc oobsize */
-		mtd->oobsize = (8 << (extid & 0x01)) *
-			(mtd->writesize >> 9);
-		extid >>= 2;
-		/* Calc blocksize. Blocksize is multiples of 64KiB */
-		mtd->erasesize = (64 * 1024) << (extid & 0x03);
-		extid >>= 2;
-		/* Get buswidth information */
-		*busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
-
-		/*
-		 * Toshiba 24nm raw SLC (i.e., not BENAND) have 32B OOB per
-		 * 512B page. For Toshiba SLC, we decode the 5th/6th byte as
-		 * follows:
-		 * - ID byte 6, bits[2:0]: 100b -> 43nm, 101b -> 32nm,
-		 *                         110b -> 24nm
-		 * - ID byte 5, bit[7]:    1 -> BENAND, 0 -> raw SLC
-		 */
-		if (id_len >= 6 && id_data[0] == NAND_MFR_TOSHIBA &&
-				nand_is_slc(chip) &&
-				(id_data[5] & 0x7) == 0x6 /* 24nm */ &&
-				!(id_data[4] & 0x80) /* !BENAND */) {
-			mtd->oobsize = 32 * mtd->writesize >> 9;
-		}
-
-	}
-}
-
-/*
- * Old devices have chip data hardcoded in the device ID table. nand_decode_id
- * decodes a matching ID table entry and assigns the MTD size parameters for
- * the chip.
- */
-static void nand_decode_id(struct mtd_info *mtd, struct nand_chip *chip,
-				struct nand_flash_dev *type, u8 id_data[8],
-				int *busw)
-{
-	int maf_id = id_data[0];
-
-	mtd->erasesize = type->erasesize;
-	mtd->writesize = type->pagesize;
-	mtd->oobsize = mtd->writesize / 32;
-	*busw = type->options & NAND_BUSWIDTH_16;
-
-	/* All legacy ID NAND are small-page, SLC */
-	chip->bits_per_cell = 1;
-
-	/*
-	 * Check for Spansion/AMD ID + repeating 5th, 6th byte since
-	 * some Spansion chips have erasesize that conflicts with size
-	 * listed in nand_ids table.
-	 * Data sheet (5 byte ID): Spansion S30ML-P ORNAND (p.39)
-	 */
-	if (maf_id == NAND_MFR_AMD && id_data[4] != 0x00 && id_data[5] == 0x00
-			&& id_data[6] == 0x00 && id_data[7] == 0x00
-			&& mtd->writesize == 512) {
-		mtd->erasesize = 128 * 1024;
-		mtd->erasesize <<= ((id_data[3] & 0x03) << 1);
-	}
-}
-
 /*
  * Set the bad block marker/indicator (BBM/BBI) patterns according to some
  * heuristic patterns using various detected parameters (e.g., manufacturer,
@@ -4366,32 +3766,6 @@ static inline bool is_full_id_nand(struct nand_flash_dev *type)
 	return type->id_len;
 }
 
-static bool find_full_id_nand(struct mtd_info *mtd, struct nand_chip *chip,
-		   struct nand_flash_dev *type, u8 *id_data, int *busw)
-{
-	if (!strncmp((char *)type->id, (char *)id_data, type->id_len)) {
-		mtd->writesize = type->pagesize;
-		mtd->erasesize = type->erasesize;
-		mtd->oobsize = type->oobsize;
-
-		chip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);
-		chip->chipsize = (uint64_t)type->chipsize << 20;
-		chip->options |= type->options;
-		chip->ecc_strength_ds = NAND_ECC_STRENGTH(type);
-		chip->ecc_step_ds = NAND_ECC_STEP(type);
-		chip->onfi_timing_mode_default =
-					type->onfi_timing_mode_default;
-
-		*busw = type->options & NAND_BUSWIDTH_16;
-
-		if (!mtd->name)
-			mtd->name = type->name;
-
-		return true;
-	}
-	return false;
-}
-
 /*
  * Get the flash and manufacturer id and lookup if the type is supported.
  */
@@ -4400,10 +3774,16 @@ struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 						  int *maf_id, int *dev_id,
 						  struct nand_flash_dev *type)
 {
-	int busw, ret;
+	int busw = 0;
+	int ret;
 	int maf_idx;
 	u8 id_data[8];
+	struct nand_flash_dev_ex flash_dev_ex;
 
+#if CONFIG_IS_ENABLED(RISCV)
+	if (!type)
+		type = malloc(sizeof(struct nand_flash_dev));
+#endif
 	/*
 	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
 	 * after power-up.
@@ -4442,54 +3822,32 @@ struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		return ERR_PTR(-ENODEV);
 	}
 
-	if (!type)
-		type = nand_flash_ids;
+	flash_dev_ex.ids[0] = *maf_id;
+	flash_dev_ex.ids[1] = *dev_id;
 
-	for (; type->name != NULL; type++) {
-		if (is_full_id_nand(type)) {
-			if (find_full_id_nand(mtd, chip, type, id_data, &busw))
-				goto ident_done;
-		} else if (*dev_id == type->dev_id) {
-			break;
-		}
-	}
+	//spi_nand_get_flash_info
+	if (nand_get_spl_flash_type &&
+	    nand_get_spl_flash_type(mtd, chip, &flash_dev_ex)) {
 
-	chip->onfi_version = 0;
-	if (!type->name || !type->pagesize) {
-		/* Check if the chip is ONFI compliant */
-		if (nand_flash_detect_onfi(mtd, chip, &busw))
-			goto ident_done;
+#if CONFIG_IS_ENABLED(RISCV)
+		memcpy(type, &flash_dev_ex.flash_dev, sizeof(struct nand_flash_dev));
+#else
+		type = &flash_dev_ex.flash_dev;
+#endif
+		if (!mtd->name)
+			mtd->name = type->name;
 
-		/* Check if the chip is JEDEC compliant */
-		if (nand_flash_detect_jedec(mtd, chip, &busw))
-			goto ident_done;
+		chip->chipsize = (uint64_t)type->chipsize << 20;
+		mtd->erasesize = type->erasesize;
+		mtd->writesize = type->pagesize;
+		mtd->oobsize   = flash_dev_ex.oobsize;
+		busw = (type->options & NAND_BUSWIDTH_16);
 	}
 
-	if (!type->name)
+	/* cvsnfc_ecc_probe */
+	if (nand_oob_resize && nand_oob_resize(mtd, chip, &flash_dev_ex))
 		return ERR_PTR(-ENODEV);
 
-	if (!mtd->name)
-		mtd->name = type->name;
-
-	chip->chipsize = (uint64_t)type->chipsize << 20;
-
-	if (!type->pagesize) {
-		/* Decode parameters from extended ID */
-		nand_decode_ext_id(mtd, chip, id_data, &busw);
-	} else {
-		nand_decode_id(mtd, chip, type, id_data, &busw);
-	}
-	/* Get chip options */
-	chip->options |= type->options;
-
-	/*
-	 * Check if chip is not a Samsung device. Do not clear the
-	 * options for chips which do not have an extended id.
-	 */
-	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
-		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
-ident_done:
-
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
@@ -4710,6 +4068,8 @@ int nand_scan_ident(struct mtd_info *mtd, int maxchips,
 		chip->select_chip(mtd, -1);
 	}
 
+	check_and_update_fip_bin();
+
 #ifdef DEBUG
 	if (i > 1)
 		pr_info("%d chips detected\n", i);
@@ -5036,6 +4396,7 @@ int nand_scan_tail(struct mtd_info *mtd)
 	 * If no default placement scheme is given, select an appropriate one.
 	 */
 	if (!ecc->layout && (ecc->mode != NAND_ECC_SOFT_BCH)) {
+		printf("mtd->oobsize %d\n", mtd->oobsize);
 		switch (mtd->oobsize) {
 #ifndef CONFIG_SYS_NAND_DRIVER_ECC_LAYOUT
 		case 8:
@@ -5048,6 +4409,7 @@ int nand_scan_tail(struct mtd_info *mtd)
 			ecc->layout = &nand_oob_64;
 			break;
 		case 128:
+		case 256:
 			ecc->layout = &nand_oob_128;
 			break;
 #endif
diff --git a/drivers/mtd/nand/raw/nand_bbt.c b/drivers/mtd/nand/raw/nand_bbt.c
index 911472e91..1cf432d92 100644
--- a/drivers/mtd/nand/raw/nand_bbt.c
+++ b/drivers/mtd/nand/raw/nand_bbt.c
@@ -79,6 +79,38 @@
 
 static int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
 
+void bbt_dump_buf(char *s, void *buf, int len)
+{
+	int i;
+	int line_counter = 0;
+	int sep_flag = 0;
+	int addr = 0;
+
+	printf("%s 0x%p\n", s, buf);
+
+	printf("%07x:\t", addr);
+
+	for (i = 0; i < len; i++) {
+		if (line_counter++ > 15) {
+			line_counter = 0;
+			sep_flag = 0;
+			addr += 16;
+			i--;
+			printf("\n%07x:\t", addr);
+			continue;
+		}
+
+		if (sep_flag++ > 1) {
+			sep_flag = 1;
+			printf(" ");
+		}
+
+		printf("%02x", *((char *)buf++));
+	}
+
+	printf("\n");
+}
+
 static inline uint8_t bbt_get_entry(struct nand_chip *chip, int block)
 {
 	uint8_t entry = chip->bbt[block >> BBT_ENTRY_SHIFT];
@@ -248,6 +280,10 @@ static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
 		totlen -= len;
 		from += len;
 	}
+
+	if (mtd->ecc_stats.badblocks)
+		pr_warn("bad block cnt %d\n", mtd->ecc_stats.badblocks);
+
 	return ret;
 }
 
diff --git a/drivers/mtd/spi/Kconfig b/drivers/mtd/spi/Kconfig
index f03fe05e3..851b0f3c5 100644
--- a/drivers/mtd/spi/Kconfig
+++ b/drivers/mtd/spi/Kconfig
@@ -2,8 +2,8 @@ menu "SPI Flash Support"
 
 config DM_SPI_FLASH
 	bool "Enable Driver Model for SPI flash"
-	depends on DM && DM_SPI
-	imply SPI_FLASH
+# 	depends on DM && DM_SPI
+#	imply SPI_FLASH
 	help
 	  Enable driver model for SPI flash. This SPI flash interface
 	  (spi_flash_probe(), spi_flash_write(), etc.) is then
@@ -28,6 +28,9 @@ config SPI_FLASH_SANDBOX
 
 config SPI_FLASH
 	bool "SPI Flash Core Interface support"
+	select DM
+	select DM_SPI
+	select DM_SPI_FLASH
 	select SPI_MEM
 	help
 	  Enable the SPI flash Core support. This will include basic
@@ -139,36 +142,43 @@ config SF_DUAL_FLASH
 
 config SPI_FLASH_ATMEL
 	bool "Atmel SPI flash support"
+	default y
 	help
 	  Add support for various Atmel SPI flash chips (AT45xxx and AT25xxx)
 
 config SPI_FLASH_EON
 	bool "EON SPI flash support"
+	default y
 	help
 	  Add support for various EON SPI flash chips (EN25xxx)
 
 config SPI_FLASH_GIGADEVICE
 	bool "GigaDevice SPI flash support"
+	default y
 	help
 	  Add support for various GigaDevice SPI flash chips (GD25xxx)
 
 config SPI_FLASH_ISSI
 	bool "ISSI SPI flash support"
+	default y
 	help
 	  Add support for various ISSI SPI flash chips (ISxxx)
 
 config SPI_FLASH_MACRONIX
 	bool "Macronix SPI flash support"
+	default y
 	help
 	  Add support for various Macronix SPI flash chips (MX25Lxxx)
 
 config SPI_FLASH_SPANSION
 	bool "Spansion SPI flash support"
+	default y
 	help
 	  Add support for various Spansion SPI flash chips (S25FLxxx)
 
 config SPI_FLASH_S28HS512T
 	bool "Cypress S28HS512T chip support"
+	default y
 	depends on SPI_FLASH_SPANSION
 	help
 	 Add support for the Cypress S28HS512T chip. This is a separate config
@@ -177,11 +187,13 @@ config SPI_FLASH_S28HS512T
 
 config SPI_FLASH_STMICRO
 	bool "STMicro SPI flash support"
+	default y
 	help
 	  Add support for various STMicro SPI flash chips (M25Pxxx and N25Qxxx)
 
 config SPI_FLASH_MT35XU
 	bool "Micron MT35XU chip support"
+	default y
 	depends on SPI_FLASH_STMICRO
 	help
 	 Add support for the Micron MT35XU chip. This is a separate config
@@ -190,22 +202,26 @@ config SPI_FLASH_MT35XU
 
 config SPI_FLASH_SST
 	bool "SST SPI flash support"
+	default y
 	help
 	  Add support for various SST SPI flash chips (SST25xxx)
 
 config SPI_FLASH_WINBOND
 	bool "Winbond SPI flash support"
+	default y
 	help
 	  Add support for various Winbond SPI flash chips (W25xxx)
 
 config SPI_FLASH_XMC
 	bool "XMC SPI flash support"
+	default y
 	help
 	  Add support for various XMC (Wuhan Xinxin Semiconductor
 	  Manufacturing Corp.) SPI flash chips (XM25xxx)
 
 config SPI_FLASH_XTX
 	bool "XTX SPI flash support"
+	default y
 	help
 	  Add support for various XTX (XTX Technology Limited)
 	  SPI flash chips (XT25xxx).
@@ -215,7 +231,7 @@ endif
 config SPI_FLASH_USE_4K_SECTORS
 	bool "Use small 4096 B erase sectors"
 	depends on SPI_FLASH
-	default y
+	default n
 	help
 	  Many flash memories support erasing small (4096 B) sectors. Depending
 	  on the usage this feature may provide performance gain in comparison
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
index d3ef69ec7..265c366f4 100644
--- a/drivers/mtd/spi/sf_internal.h
+++ b/drivers/mtd/spi/sf_internal.h
@@ -69,6 +69,7 @@ struct flash_info {
 #define SPI_NOR_HAS_SST26LOCK	BIT(15)	/* Flash supports lock/unlock via BPR */
 #define SPI_NOR_OCTAL_READ	BIT(16)	/* Flash supports Octal Read */
 #define SPI_NOR_OCTAL_DTR_READ	BIT(17)	/* Flash supports Octal DTR Read */
+
 };
 
 extern const struct flash_info spi_nor_ids[];
diff --git a/drivers/mtd/spi/spi-nor-core.c b/drivers/mtd/spi/spi-nor-core.c
index f1b4e5ea8..125e43b23 100644
--- a/drivers/mtd/spi/spi-nor-core.c
+++ b/drivers/mtd/spi/spi-nor-core.c
@@ -522,6 +522,16 @@ static int write_sr(struct spi_nor *nor, u8 val)
 	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1);
 }
 
+/*
+ * Write status register 1 byte
+ * Returns negative if error occurred.
+ */
+static int write_sr2(struct spi_nor *nor, u8 val)
+{
+	nor->cmd_buf[0] = val;
+	return nor->write_reg(nor, SPINOR_OP_WRSR2, nor->cmd_buf, 1);
+}
+
 /*
  * Set write enable latch with Write Enable command.
  * Returns negative if error occurred.
@@ -1315,6 +1325,8 @@ static const struct flash_info *spi_nor_read_id(struct spi_nor *nor)
 		return ERR_PTR(tmp);
 	}
 
+	printf("spinor id = %X %X %X\n", id[0], id[1], id[2]);
+
 	info = spi_nor_ids;
 	for (; info->name; info++) {
 		if (info->id_len) {
@@ -1714,44 +1726,77 @@ write_err:
 	return ret;
 }
 
-#if defined(CONFIG_SPI_FLASH_MACRONIX) || defined(CONFIG_SPI_FLASH_ISSI)
-/**
- * macronix_quad_enable() - set QE bit in Status Register.
- * @nor:	pointer to a 'struct spi_nor'
- *
- * Set the Quad Enable (QE) bit in the Status Register.
- *
- * bit 6 of the Status Register is the QE bit for Macronix like QSPI memories.
- *
- * Return: 0 on success, -errno otherwise.
+/*  read        : 0x05
+ *  write       : 0x01
+ *  write length: 1 byte
+ *  QE          : BIT(6)
  */
-static int macronix_quad_enable(struct spi_nor *nor)
+static int quad_enable_SR_bit6(struct spi_nor *nor)
 {
 	int ret, val;
 
 	val = read_sr(nor);
 	if (val < 0)
 		return val;
-	if (val & SR_QUAD_EN_MX)
+
+	/* return if QE has been set already */
+	if (val & BIT(6)) {
+		// TODO: check_and_update_fip_toc_header(flash);
 		return 0;
+	}
 
 	write_enable(nor);
+	write_sr(nor, val | BIT(6));
+	ret = spi_nor_wait_till_ready(nor);
+	if (ret)
+		return ret;
+
+	/* read SR and check it */
+	ret = read_sr(nor);
+	if (!(ret > 0 && (ret & BIT(6)))) {
+		dev_err(nor->dev, "SPINOR: SR1[6] QE bit was set failed!\n");
+		return -EINVAL;
+	}
+	// TODO: add else? check_and_update_fip_toc_header(flash);
+
+	return 0;
+}
+
+/*  read        : 0x35
+ *  write       : 0x31(write 1 byte)
+ *  write length: 1 bytes
+ *  QE          : BIT(1)
+ */
+static int quad_enable_SR2_bit1(struct spi_nor *nor)
+{
+	int ret;
 
-	write_sr(nor, val | SR_QUAD_EN_MX);
+	ret = read_cr(nor);
+	if (ret < 0)
+		return ret;
+
+	/* return if QE has been set already */
+	if (ret & BIT(1)) {
+		// TODO: check_and_update_fip_toc_header(flash);
+		return 0;
+	}
 
+	write_enable(nor);
+	write_sr2(nor, ret | BIT(1));
 	ret = spi_nor_wait_till_ready(nor);
 	if (ret)
 		return ret;
 
-	ret = read_sr(nor);
-	if (!(ret > 0 && (ret & SR_QUAD_EN_MX))) {
-		dev_err(nor->dev, "Macronix Quad bit not set\n");
+	/* read CR and check it */
+	ret = read_cr(nor);
+	if (!(ret >= 0 && (ret & BIT(1)))) {
+		dev_err(nor->dev, "SPINOR: SR2[1] QE bit was set failed!\n");
 		return -EINVAL;
 	}
+	// TODO: add else? check_and_update_fip_toc_header(flash);
 
 	return 0;
 }
-#endif
 
 #ifdef CONFIG_SPI_FLASH_SPANSION
 /**
@@ -1966,11 +2011,16 @@ spi_nor_set_pp_settings(struct spi_nor_pp_command *pp,
  * Return: 0 on success, -errno otherwise.
  */
 static int spi_nor_read_sfdp(struct spi_nor *nor, u32 addr,
-			     size_t len, void *buf)
+				size_t len, void *buf)
+
 {
 	u8 addr_width, read_opcode, read_dummy;
 	int ret;
-
+#ifdef CONFIG_CVITEK_SPI_FLASH
+	u8 pos, i;
+	u32 flag = 0;
+	char cmd[6] = {0};
+#endif
 	read_opcode = nor->read_opcode;
 	addr_width = nor->addr_width;
 	read_dummy = nor->read_dummy;
@@ -1979,6 +2029,7 @@ static int spi_nor_read_sfdp(struct spi_nor *nor, u32 addr,
 	nor->addr_width = 3;
 	nor->read_dummy = 8;
 
+#ifndef CONFIG_CVITEK_SPI_FLASH
 	while (len) {
 		ret = nor->read(nor, addr, len, (u8 *)buf);
 		if (!ret || ret > len) {
@@ -1993,6 +2044,24 @@ static int spi_nor_read_sfdp(struct spi_nor *nor, u32 addr,
 		len -= ret;
 	}
 	ret = 0;
+#else
+	pos = 0;
+	cmd[pos++] = nor->read_opcode;
+	for (i = 0; i < nor->addr_width; i++)
+		cmd[pos + i] = addr >> (8 * (nor->addr_width - i - 1));
+
+	pos += nor->addr_width;
+	/* handle dummy clk, always 1 byte dummy clk */
+	pos += 1;
+
+	ret = spi_xfer(nor->spi, pos * 8, cmd, NULL, flag | SPI_XFER_BEGIN);
+	if (ret)
+		goto read_err;
+
+	ret = spi_xfer(nor->spi, len * 8, NULL, buf, flag | SPI_XFER_END | SPI_XFER_CMD_DATA);
+	if (ret)
+		goto read_err;
+#endif
 
 read_err:
 	nor->read_opcode = read_opcode;
@@ -2013,6 +2082,7 @@ spi_nor_set_read_settings_from_bfpt(struct spi_nor_read_command *read,
 	read->num_wait_states = (half >> 0) & 0x1f;
 	read->opcode = (half >> 8) & 0xff;
 	read->proto = proto;
+	debug("opcode:%#x, dummy:%u\n", read->opcode, (read->num_mode_clocks + read->num_wait_states));
 }
 
 struct sfdp_bfpt_read {
@@ -2080,12 +2150,12 @@ static const struct sfdp_bfpt_read sfdp_bfpt_reads[] = {
 	},
 
 	/* Fast Read 4-4-4 */
-	{
-		SNOR_HWCAPS_READ_4_4_4,
-		BFPT_DWORD(5), BIT(4),	/* Supported bit */
-		BFPT_DWORD(7), 16,	/* Settings */
-		SNOR_PROTO_4_4_4,
-	},
+	//{
+	//	SNOR_HWCAPS_READ_4_4_4,
+	//	BFPT_DWORD(5), BIT(4),	/* Supported bit */
+	//	BFPT_DWORD(7), 16,	/* Settings */
+	//	SNOR_PROTO_4_4_4,
+	//},
 };
 
 struct sfdp_bfpt_erase {
@@ -2285,7 +2355,7 @@ static int spi_nor_parse_bfpt(struct spi_nor *nor,
 #endif
 #if defined(CONFIG_SPI_FLASH_MACRONIX) || defined(CONFIG_SPI_FLASH_ISSI)
 	case BFPT_DWORD15_QER_SR1_BIT6:
-		params->quad_enable = macronix_quad_enable;
+		params->quad_enable = quad_enable_SR_bit6;
 		break;
 #endif
 #if defined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)
@@ -2468,7 +2538,6 @@ static int spi_nor_parse_sfdp(struct spi_nor *nor,
 	if (le32_to_cpu(header.signature) != SFDP_SIGNATURE ||
 	    header.major != SFDP_JESD216_MAJOR)
 		return -EINVAL;
-
 	/*
 	 * Verify that the first and only mandatory parameter header is a
 	 * Basic Flash Parameter Table header as specified in JESD216.
@@ -2477,7 +2546,6 @@ static int spi_nor_parse_sfdp(struct spi_nor *nor,
 	if (SFDP_PARAM_HEADER_ID(bfpt_header) != SFDP_BFPT_ID ||
 	    bfpt_header->major != SFDP_JESD216_MAJOR)
 		return -EINVAL;
-
 	/*
 	 * Allocate memory then read all parameter headers with a single
 	 * Read SFDP command. These parameter headers will actually be parsed
@@ -2659,8 +2727,11 @@ static int spi_nor_init_params(struct spi_nor *nor,
 
 	/* Page Program settings. */
 	params->hwcaps.mask |= SNOR_HWCAPS_PP;
+	params->hwcaps.mask |= SNOR_HWCAPS_PP_1_1_4;
 	spi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP],
 				SPINOR_OP_PP, SNOR_PROTO_1_1_1);
+	spi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_1_1_4],
+				SPINOR_OP_PP_1_1_4, SNOR_PROTO_1_1_4);
 
 	/*
 	 * Since xSPI Page Program opcode is backward compatible with
@@ -2669,23 +2740,28 @@ static int spi_nor_init_params(struct spi_nor *nor,
 	spi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_8_8_8_DTR],
 				SPINOR_OP_PP, SNOR_PROTO_8_8_8_DTR);
 
-	if (info->flags & SPI_NOR_QUAD_READ) {
-		params->hwcaps.mask |= SNOR_HWCAPS_PP_1_1_4;
-		spi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_1_1_4],
-					SPINOR_OP_PP_1_1_4, SNOR_PROTO_1_1_4);
-	}
-
 	/* Select the procedure to set the Quad Enable bit. */
 	if (params->hwcaps.mask & (SNOR_HWCAPS_READ_QUAD |
 				   SNOR_HWCAPS_PP_QUAD)) {
 		switch (JEDEC_MFR(info)) {
-#if defined(CONFIG_SPI_FLASH_MACRONIX) || defined(CONFIG_SPI_FLASH_ISSI)
 		case SNOR_MFR_MACRONIX:
 		case SNOR_MFR_ISSI:
-			params->quad_enable = macronix_quad_enable;
+			params->quad_enable = quad_enable_SR_bit6;
 			break;
-#endif
-		case SNOR_MFR_ST:
+		case SNOR_MFR_EON:
+		case SNOR_MFR_GIGADEVICE:
+		case SNOR_MFR_WINBOND:
+		case SNOR_MFR_JUYANG:
+		case SNOR_MFR_ZBIT:
+		case SNOR_MFR_XMC:
+		case SNOR_MFR_XTX:
+		case SNOR_MFR_FM:
+		case SNOR_MFR_SPANSION:
+		case SNOR_MFR_BOYA:
+		case SNOR_MFR_PY:
+			params->quad_enable = quad_enable_SR2_bit1;
+			break;
+
 		case SNOR_MFR_MICRON:
 			break;
 
@@ -3777,6 +3853,12 @@ int spi_nor_scan(struct spi_nor *nor)
 	nor->page_size = params.page_size;
 	mtd->writebufsize = nor->page_size;
 
+	/* Set spi mode according to hwcaps */
+	if ((params.hwcaps.mask & SNOR_HWCAPS_READ_1_1_4) || (params.hwcaps.mask & SNOR_HWCAPS_READ_1_4_4))
+		spi->mode |= SPI_RX_QUAD;
+	if ((params.hwcaps.mask & SNOR_HWCAPS_PP_1_1_4) || (params.hwcaps.mask & SNOR_HWCAPS_PP_1_4_4))
+		spi->mode |= SPI_TX_QUAD;
+
 	/* Some devices cannot do fast-read, no matter what DT tells us */
 	if ((info->flags & SPI_NOR_NO_FR) || (spi->mode & SPI_RX_SLOW))
 		params.hwcaps.mask &= ~SNOR_HWCAPS_READ_FAST;
diff --git a/drivers/mtd/spi/spi-nor-ids.c b/drivers/mtd/spi/spi-nor-ids.c
index 4aef1ddd6..26eca45ce 100644
--- a/drivers/mtd/spi/spi-nor-ids.c
+++ b/drivers/mtd/spi/spi-nor-ids.c
@@ -9,8 +9,8 @@
 #include <common.h>
 #include <spi.h>
 #include <spi_flash.h>
-
 #include "sf_internal.h"
+#include <command.h>
 
 /* Exclude chip names for SPL to save space */
 #if !CONFIG_IS_ENABLED(SPI_FLASH_TINY)
@@ -63,308 +63,101 @@
  * old entries may be missing 4K flag.
  */
 const struct flash_info spi_nor_ids[] = {
-#ifdef CONFIG_SPI_FLASH_ATMEL		/* ATMEL */
-	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
-	{ INFO("at26df321",	0x1f4700, 0, 64 * 1024, 64, SECT_4K) },
-	{ INFO("at25df321a",	0x1f4701, 0, 64 * 1024, 64, SECT_4K) },
-
-	{ INFO("at45db011d",	0x1f2200, 0, 64 * 1024,   4, SECT_4K) },
-	{ INFO("at45db021d",	0x1f2300, 0, 64 * 1024,   8, SECT_4K) },
-	{ INFO("at45db041d",	0x1f2400, 0, 64 * 1024,   8, SECT_4K) },
-	{ INFO("at45db081d",	0x1f2500, 0, 64 * 1024,  16, SECT_4K) },
-	{ INFO("at45db161d",	0x1f2600, 0, 64 * 1024,  32, SECT_4K) },
-	{ INFO("at45db321d",	0x1f2700, 0, 64 * 1024,  64, SECT_4K) },
-	{ INFO("at45db641d",	0x1f2800, 0, 64 * 1024, 128, SECT_4K) },
-	{ INFO("at25sl321",	0x1f4216, 0, 64 * 1024,  64, SECT_4K) },
-	{ INFO("at26df081a", 	0x1f4501, 0, 64 * 1024,  16, SECT_4K) },
-#endif
-#ifdef CONFIG_SPI_FLASH_EON		/* EON */
-	/* EON -- en25xxx */
-	{ INFO("en25q32b",   0x1c3016, 0, 64 * 1024,   64, 0) },
-	{ INFO("en25q64",    0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
-	{ INFO("en25qh128",  0x1c7018, 0, 64 * 1024,  256, 0) },
-	{ INFO("en25s64",    0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
-#endif
-#ifdef CONFIG_SPI_FLASH_GIGADEVICE	/* GIGADEVICE */
-	/* GigaDevice */
-	{
-		INFO("gd25q16", 0xc84015, 0, 64 * 1024,  32,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("gd25q32", 0xc84016, 0, 64 * 1024,  64,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("gd25lq32", 0xc86016, 0, 64 * 1024, 64,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("gd25q64", 0xc84017, 0, 64 * 1024, 128,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("gd25lq64c", 0xc86017, 0, 64 * 1024, 128,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("gd25q128", 0xc84018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("gd25lq128", 0xc86018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-#endif
-#ifdef CONFIG_SPI_FLASH_ISSI		/* ISSI */
-	/* ISSI */
-	{ INFO("is25lq040b", 0x9d4013, 0, 64 * 1024,   8,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("is25lp032",	0x9d6016, 0, 64 * 1024,  64, 0) },
-	{ INFO("is25lp064",	0x9d6017, 0, 64 * 1024, 128, 0) },
-	{ INFO("is25lp128",  0x9d6018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ) },
-	{ INFO("is25lp256",  0x9d6019, 0, 64 * 1024, 512,
-			SECT_4K | SPI_NOR_DUAL_READ) },
-	{ INFO("is25wp032",  0x9d7016, 0, 64 * 1024,  64,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("is25wp064",  0x9d7017, 0, 64 * 1024, 128,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("is25wp128",  0x9d7018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("is25wp256",  0x9d7019, 0, 64 * 1024, 512,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_4B_OPCODES) },
-#endif
-#ifdef CONFIG_SPI_FLASH_MACRONIX	/* MACRONIX */
-	/* Macronix */
-	{ INFO("mx25l2005a",  0xc22012, 0, 64 * 1024,   4, SECT_4K) },
-	{ INFO("mx25l4005a",  0xc22013, 0, 64 * 1024,   8, SECT_4K) },
-	{ INFO("mx25l8005",   0xc22014, 0, 64 * 1024,  16, 0) },
-	{ INFO("mx25l1606e",  0xc22015, 0, 64 * 1024,  32, SECT_4K) },
-	{ INFO("mx25l3205d",  0xc22016, 0, 64 * 1024,  64, SECT_4K) },
-	{ INFO("mx25l6405d",  0xc22017, 0, 64 * 1024, 128, SECT_4K) },
-	{ INFO("mx25u2033e",  0xc22532, 0, 64 * 1024,   4, SECT_4K) },
-	{ INFO("mx25u1635e",  0xc22535, 0, 64 * 1024,  32, SECT_4K) },
-	{ INFO("mx25u3235f",  0xc22536, 0, 4 * 1024,  1024, SECT_4K) },
-	{ INFO("mx25u6435f",  0xc22537, 0, 64 * 1024, 128, SECT_4K) },
-	{ INFO("mx25l12805d", 0xc22018, 0, 64 * 1024, 256, SECT_4K) },
-	{ INFO("mx25u12835f", 0xc22538, 0, 64 * 1024, 256, SECT_4K) },
-	{ INFO("mx25l12855e", 0xc22618, 0, 64 * 1024, 256, 0) },
-	{ INFO("mx25l25635e", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("mx25u25635f", 0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
-	{ INFO("mx25v8035f",  0xc22314, 0, 64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("mx25r1635f",  0xc22815, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("mx25l25655e", 0xc22619, 0, 64 * 1024, 512, 0) },
-	{ INFO("mx66l51235l", 0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO("mx66u51235f", 0xc2253a, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO("mx66u2g45g",  0xc2253c, 0, 64 * 1024, 4096, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO("mx66l1g45g",  0xc2201b, 0, 64 * 1024, 2048, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("mx25l1633e", 0xc22415, 0, 64 * 1024,   32, SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES | SECT_4K) },
-	{ INFO("mx25r6435f", 0xc22817, 0, 64 * 1024,   128,  SECT_4K) },
-	{ INFO("mx66uw2g345g", 0xc2943c, 0, 64 * 1024, 4096, SECT_4K | SPI_NOR_OCTAL_READ | SPI_NOR_4B_OPCODES) },
-#endif
-
-#ifdef CONFIG_SPI_FLASH_STMICRO		/* STMICRO */
-	/* Micron */
-	{ INFO("n25q016a",	 0x20bb15, 0, 64 * 1024,   32, SECT_4K | SPI_NOR_QUAD_READ) },
-	{ INFO("n25q032",	 0x20ba16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ) },
-	{ INFO("n25q032a",	0x20bb16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ) },
-	{ INFO("n25q064",     0x20ba17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ) },
-	{ INFO("n25q064a",    0x20bb17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ) },
-	{ INFO("n25q128a11",  0x20bb18, 0, 64 * 1024,  256, SECT_4K | SPI_NOR_QUAD_READ) },
-	{ INFO("n25q128a13",  0x20ba18, 0, 64 * 1024,  256, SECT_4K | SPI_NOR_QUAD_READ) },
-	{ INFO6("mt25ql256a",    0x20ba19, 0x104400, 64 * 1024,  512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES | USE_FSR) },
-	{ INFO("n25q256a",    0x20ba19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_FSR) },
-	{ INFO6("mt25qu256a",  0x20bb19, 0x104400, 64 * 1024,  512, SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES | USE_FSR) },
-	{ INFO("n25q256ax1",  0x20bb19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_QUAD_READ | USE_FSR) },
-	{ INFO6("mt25qu512a",  0x20bb20, 0x104400, 64 * 1024, 1024,
-		 SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES |
-		 USE_FSR) },
-	{ INFO("n25q512a",    0x20bb20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
-	{ INFO6("mt25ql512a",  0x20ba20, 0x104400, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO("n25q512ax3",  0x20ba20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
-	{ INFO("n25q00",      0x20ba21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
-	{ INFO("n25q00a",     0x20bb21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
-	{ INFO("mt25ql01g",   0x21ba20, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
-	{ INFO("mt25qu02g",   0x20bb22, 0, 64 * 1024, 4096, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE) },
-#ifdef CONFIG_SPI_FLASH_MT35XU
-	{ INFO("mt35xu512aba", 0x2c5b1a, 0,  128 * 1024,  512, USE_FSR | SPI_NOR_OCTAL_READ | SPI_NOR_4B_OPCODES | SPI_NOR_OCTAL_DTR_READ) },
-#endif /* CONFIG_SPI_FLASH_MT35XU */
-	{ INFO("mt35xu02g",  0x2c5b1c, 0, 128 * 1024,  2048, USE_FSR | SPI_NOR_OCTAL_READ | SPI_NOR_4B_OPCODES) },
-#endif
-#ifdef CONFIG_SPI_FLASH_SPANSION	/* SPANSION */
-	/* Spansion/Cypress -- single (large) sector size only, at least
-	 * for the chips listed here (without boot sectors).
-	 */
-	{ INFO("s25sl032p",  0x010215, 0x4d00,  64 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("s25sl064p",  0x010216, 0x4d00,  64 * 1024, 128, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("s25fl256s0", 0x010219, 0x4d00, 256 * 1024, 128, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25fl256s1", 0x010219, 0x4d01,  64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO6("s25fl512s",  0x010220, 0x4d0080, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO6("s25fs512s",  0x010220, 0x4d0081, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25fl512s_256k",  0x010220, 0x4d00, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25fl512s_64k",  0x010220, 0x4d01, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25fl512s_512k", 0x010220, 0x4f00, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25sl12800", 0x012018, 0x0300, 256 * 1024,  64, 0) },
-	{ INFO("s25sl12801", 0x012018, 0x0301,  64 * 1024, 256, 0) },
-	{ INFO6("s25fl128s",  0x012018, 0x4d0180, 64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25fl129p0", 0x012018, 0x4d00, 256 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25fl129p1", 0x012018, 0x4d01,  64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR) },
-	{ INFO("s25sl008a",  0x010213,      0,  64 * 1024,  16, 0) },
-	{ INFO("s25sl016a",  0x010214,      0,  64 * 1024,  32, 0) },
-	{ INFO("s25sl032a",  0x010215,      0,  64 * 1024,  64, 0) },
-	{ INFO("s25sl064a",  0x010216,      0,  64 * 1024, 128, 0) },
-	{ INFO("s25fl116k",  0x014015,      0,  64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("s25fl164k",  0x014017,      0,  64 * 1024, 128, SECT_4K) },
-	{ INFO("s25fl208k",  0x014014,      0,  64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ) },
-	{ INFO("s25fl064l",  0x016017,      0,  64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO("s25fl128l",  0x016018,      0,  64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO6("s25hl512t",  0x342a1a, 0x0f0390, 256 * 1024, 256,
-		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES |
-		USE_CLSR) },
-	{ INFO6("s25hl01gt",  0x342a1b, 0x0f0390, 256 * 1024, 512,
-		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES |
-		USE_CLSR) },
-	{ INFO6("s25hl02gt",  0x342a1c, 0x0f0090, 256 * 1024, 1024,
-		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-	{ INFO6("s25hs512t",  0x342b1a, 0x0f0390, 256 * 1024, 256,
-		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES |
-		USE_CLSR) },
-	{ INFO6("s25hs01gt",  0x342b1b, 0x0f0390, 256 * 1024, 512,
-		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES |
-		USE_CLSR) },
-	{ INFO6("s25hs02gt",  0x342b1c, 0x0f0090, 256 * 1024, 1024,
-		SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
-#ifdef CONFIG_SPI_FLASH_S28HS512T
-	{ INFO("s28hs512t",  0x345b1a,      0, 256 * 1024, 256, SPI_NOR_OCTAL_DTR_READ) },
-#endif
-#endif
-#ifdef CONFIG_SPI_FLASH_SST		/* SST */
-	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
-	{ INFO("sst25vf040b", 0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
-	{ INFO("sst25vf080b", 0xbf258e, 0, 64 * 1024, 16, SECT_4K | SST_WRITE) },
-	{ INFO("sst25vf016b", 0xbf2541, 0, 64 * 1024, 32, SECT_4K | SST_WRITE) },
-	{ INFO("sst25vf032b", 0xbf254a, 0, 64 * 1024, 64, SECT_4K | SST_WRITE) },
-	{ INFO("sst25vf064c", 0xbf254b, 0, 64 * 1024, 128, SECT_4K) },
-	{ INFO("sst25wf512",  0xbf2501, 0, 64 * 1024,  1, SECT_4K | SST_WRITE) },
-	{ INFO("sst25wf010",  0xbf2502, 0, 64 * 1024,  2, SECT_4K | SST_WRITE) },
-	{ INFO("sst25wf020",  0xbf2503, 0, 64 * 1024,  4, SECT_4K | SST_WRITE) },
-	{ INFO("sst25wf020a", 0x621612, 0, 64 * 1024,  4, SECT_4K) },
-	{ INFO("sst25wf040b", 0x621613, 0, 64 * 1024,  8, SECT_4K) },
-	{ INFO("sst25wf040",  0xbf2504, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
-	{ INFO("sst25wf080",  0xbf2505, 0, 64 * 1024, 16, SECT_4K | SST_WRITE) },
-	{ INFO("sst26vf064b", 0xbf2643, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_HAS_SST26LOCK | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("sst26wf016",  0xbf2651, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_HAS_SST26LOCK) },
-	{ INFO("sst26wf032",  0xbf2622, 0, 64 * 1024,  64, SECT_4K | SPI_NOR_HAS_SST26LOCK) },
-	{ INFO("sst26wf064",  0xbf2643, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_HAS_SST26LOCK) },
-#endif
-#ifdef CONFIG_SPI_FLASH_STMICRO		/* STMICRO */
-	/* ST Microelectronics -- newer production may have feature updates */
-	{ INFO("m25p10",  0x202011,  0,  32 * 1024,   4, 0) },
-	{ INFO("m25p20",  0x202012,  0,  64 * 1024,   4, 0) },
-	{ INFO("m25p40",  0x202013,  0,  64 * 1024,   8, 0) },
-	{ INFO("m25p80",  0x202014,  0,  64 * 1024,  16, 0) },
-	{ INFO("m25p16",  0x202015,  0,  64 * 1024,  32, 0) },
-	{ INFO("m25p32",  0x202016,  0,  64 * 1024,  64, 0) },
-	{ INFO("m25p64",  0x202017,  0,  64 * 1024, 128, 0) },
-	{ INFO("m25p128", 0x202018,  0, 256 * 1024,  64, 0) },
-	{ INFO("m25pe16", 0x208015,  0, 64 * 1024, 32, SECT_4K) },
-	{ INFO("m25px16",    0x207115,  0, 64 * 1024, 32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("m25px64",    0x207117,  0, 64 * 1024, 128, 0) },
-#endif
-#ifdef CONFIG_SPI_FLASH_WINBOND		/* WINBOND */
-	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
-	{ INFO("w25p80", 0xef2014, 0x0,	64 * 1024,    16, 0) },
-	{ INFO("w25p16", 0xef2015, 0x0,	64 * 1024,    32, 0) },
-	{ INFO("w25p32", 0xef2016, 0x0,	64 * 1024,    64, 0) },
-	{ INFO("w25x05", 0xef3010, 0, 64 * 1024,  1,  SECT_4K) },
-	{ INFO("w25x40", 0xef3013, 0, 64 * 1024,  8,  SECT_4K) },
-	{ INFO("w25x16", 0xef3015, 0, 64 * 1024,  32, SECT_4K) },
-	{
-		INFO("w25q16dw", 0xef6015, 0, 64 * 1024,  32,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{ INFO("w25x32", 0xef3016, 0, 64 * 1024,  64, SECT_4K) },
-	{ INFO("w25q20cl", 0xef4012, 0, 64 * 1024,  4, SECT_4K) },
-	{ INFO("w25q20bw", 0xef5012, 0, 64 * 1024,  4, SECT_4K) },
-	{ INFO("w25q20ew", 0xef6012, 0, 64 * 1024,  4, SECT_4K) },
-	{ INFO("w25q32", 0xef4016, 0, 64 * 1024,  64, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{
-		INFO("w25q32dw", 0xef6016, 0, 64 * 1024,  64,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q32jv", 0xef7016, 0, 64 * 1024,  64,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q32jwm", 0xef8016, 0, 64 * 1024,  64,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{ INFO("w25x64", 0xef3017, 0, 64 * 1024, 128, SECT_4K) },
-	{
-		INFO("w25q64dw", 0xef6017, 0, 64 * 1024, 128,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q64jv", 0xef7017, 0, 64 * 1024, 128,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q128fw", 0xef6018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q128jv", 0xef7018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q256fw", 0xef6019, 0, 64 * 1024, 512,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{
-		INFO("w25q256jw", 0xef7019, 0, 64 * 1024, 512,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{ INFO("w25q80", 0xef5014, 0, 64 * 1024,  16, SECT_4K) },
-	{ INFO("w25q80bl", 0xef4014, 0, 64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("w25q16cl", 0xef4015, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("w25q64cv", 0xef4017, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("w25q128", 0xef4018, 0, 64 * 1024, 256,
-			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)
-	},
-	{ INFO("w25q256", 0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("w25m512jw", 0xef6119, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("w25m512jv", 0xef7119, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-#endif
-#ifdef CONFIG_SPI_FLASH_XMC
-	/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) */
-	{ INFO("XM25QH64A", 0x207017, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("XM25QH64C", 0x204017, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-	{ INFO("XM25QH128A", 0x207018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-#endif
-#ifdef CONFIG_SPI_FLASH_XTX
-	/* XTX Technology (Shenzhen) Limited */
-	{ INFO("xt25f128b", 0x0b4018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-#endif
+	/* The CVITEK Support List Of Spi Nor Flash */
+	{ INFO("JY25VQ128A", 0x1c4018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("JY25VQ64A", 0x4a4017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	/* Juyang 32M Nor Flash(JY25VQ256A) uses the same wafers as MXIC */
+	{ INFO("MX25L25645G", 0xc22019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("MX25L12835F", 0xc22018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("EN25QH128A", 0x1c7018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("EN25QX64A", 0x1c7117, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("EN25QX128A", 0x1c7118, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("EN25QH256A", 0x1c7019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
+	{ INFO("W25Q256JV-IQ", 0xef4019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("W25Q128JV-IQ", 0xef4018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("W25Q64JV-IQ", 0xef4017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("GD25Q128E", 0xc84018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("GD25Q256E", 0xc84019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("GD25Q64E", 0xc84017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("GD25LQ256D", 0xc86019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("XM25QH64C", 0x204017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("XM25QH128C", 0x204018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("XM25QH256C", 0x204019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	// N25Q256 N25L256
+	{ INFO("N25Q256", 0x20ba19, 0x0,  64 * 1024,   512,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("IS25LP064D", 0x9D6017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("IS25LP128F", 0x9d6018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("IS25LP256E", 0x9d6019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("KH25L6433FM2I", 0xc22017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	//{ INFO("KH25L12833FM2I", 0xc22018, 0x0, 64 * 1024, 256,
+	//      SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("ZB25VQ64B", 0x5E4017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("ZB25VQ128A", 0x5E4018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("S25FL128L", 0x016018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("S25FL256L", 0x016019, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("XT25F64F", 0x0B4017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("XT25F128F", 0x0B4018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("FM25Q64", 0xF83217, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("BY25Q128AS", 0x684018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("BY25Q256FS", 0x684919, 0x0, 64 * 1024, 512,
+		SPI_NOR_QUAD_READ | SECT_4K | SPI_NOR_4B_OPCODES) },
+	{ INFO("PY25Q128HA", 0x852018, 0x0, 64 * 1024, 256,
+		SPI_NOR_QUAD_READ | SECT_4K) },
+	{ INFO("P25Q64SH", 0x856017, 0x0, 64 * 1024, 128,
+		SPI_NOR_QUAD_READ | SECT_4K) },
 	{ },
 };
+
+static int do_spinor_show_support_list(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	char buf[128] = {0};
+	const struct flash_info *info = spi_nor_ids;
+	uint32_t id, size;
+
+	printf("\t###################### nor flash list #########################\n\n");
+	sprintf(buf, "\t%-16s		%-12s		%-6s\n", "NAME", "JEDEC_ID", "SIZE");
+	printf("%s\n", buf);
+	for (; info->name; info++) {
+		id = 0;
+		size = 0;
+		id = info->id[0] << 16 | info->id[1] << 8 | info->id[2];
+		size = (info->sector_size * info->n_sectors) >> 20;
+		sprintf(buf, "\t%-16s		0x%-6x		%-2u M\n", info->name, id, size);
+		printf("%s\n", buf);
+	}
+	printf("\t###############################################################\n\n");
+	return 0;
+}
+
+U_BOOT_CMD(norshow, 2, 0, do_spinor_show_support_list, "norshow", "\nshow nor flash list\n");
diff --git a/drivers/net/designware.c b/drivers/net/designware.c
index 5aaac603a..887fd462a 100644
--- a/drivers/net/designware.c
+++ b/drivers/net/designware.c
@@ -952,7 +952,7 @@ int designware_eth_of_to_plat(struct udevice *dev)
 static const struct udevice_id designware_eth_ids[] = {
 	{ .compatible = "allwinner,sun7i-a20-gmac" },
 	{ .compatible = "amlogic,meson6-dwmac" },
-	{ .compatible = "st,stm32-dwmac" },
+	{ .compatible = "cvitek,ethernet" },
 	{ .compatible = "snps,arc-dwmac-3.70a" },
 	{ }
 };
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 64d5ddf23..9b069c319 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -148,6 +148,14 @@ config PHY_CORTINA_ACCESS
 	help
 		Cortina Access Ethernet PHYs init process
 
+config PHY_CVITEK_CV182XA
+	bool "CVITEK CV182XA Ethernet PHYs support"
+	help
+	  Enable support for RMII PHYs manufactured by CVITEK
+	  Include driver for cv182xa.
+	  This is an internal ethernet phy.
+	  And support 100Mbs full duplex.
+
 config PHY_DAVICOM
 	bool "Davicom Ethernet PHYs support"
 
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 218b8c766..35080e58f 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_PHY_ATHEROS) += atheros.o
 obj-$(CONFIG_PHY_BROADCOM) += broadcom.o
 obj-$(CONFIG_PHY_CORTINA) += cortina.o
 obj-$(CONFIG_PHY_CORTINA_ACCESS) += ca_phy.o
+obj-$(CONFIG_PHY_CVITEK_CV182XA) += cv182xa.o
 obj-$(CONFIG_PHY_DAVICOM) += davicom.o
 obj-$(CONFIG_PHY_ET1011C) += et1011c.o
 obj-$(CONFIG_PHY_LXT) += lxt.o
diff --git a/drivers/net/phy/cv182xa.c b/drivers/net/phy/cv182xa.c
new file mode 100644
index 000000000..da631dc33
--- /dev/null
+++ b/drivers/net/phy/cv182xa.c
@@ -0,0 +1,349 @@
+/*
+ * CVITEK PHY drivers
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Copyright 2020 CVITEK, Inc.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <linux/bitops.h>
+#include <phy.h>
+#include "mmio.h"
+
+#define EPHY_EFUSE_VALID_BIT_BASE 0x03050120
+#define EPHY_EFUSE_TXECHORC_FLAG 0x00000100 // bit 8
+#define EPHY_EFUSE_TXITUNE_FLAG 0x00000200 // bit 9
+#define EPHY_EFUSE_TXRXTERM_FLAG 0x00000800 // bit 11
+
+#if defined(CVI_ETH_PHY_LOOPBACK)
+static int cv182xa_set_phy_loopback(struct phy_device *phydev, int mode)
+{
+	return 0
+}
+#endif
+
+static void cv182xa_ephy_init(void)
+{
+	uint32_t val = 0;
+
+	// set rg_ephy_apb_rw_sel 0x0804@[0]=1/APB by using APB interface
+	mmio_write_32(0x03009804, 0x0001);
+
+	/* do this in board.c */
+	// // Release 0x0800[0]=0/shutdown
+	// mmio_write_32(0x03009800, 0x0900);
+
+	// // Release 0x0800[2]=1/dig_rst_n, Let mii_reg can be accessabile
+	// mmio_write_32(0x03009800, 0x0904);
+
+	//mdelay(10);
+
+	// ANA INIT (PD/EN), switch to MII-page5
+	mmio_write_32(0x0300907c, 0x0500);
+	// Release ANA_PD p5.0x10@[13:8] = 6'b001100
+	mmio_write_32(0x03009040, 0x0c00);
+	// Release ANA_EN p5.0x10@[7:0] = 8'b01111110
+	mmio_write_32(0x03009040, 0x0c7e);
+
+	// Wait PLL_Lock, Lock_Status p5.0x12@[15] = 1
+	//mdelay(1);
+
+	// Release 0x0800[1] = 1/ana_rst_n
+	mmio_write_32(0x03009800, 0x0906);
+
+	// ANA INIT
+	// @Switch to MII-page5
+	mmio_write_32(0x0300907c, 0x0500);
+
+// Efuse register
+	// Set Double Bias Current
+	//Set rg_eth_txitune1  0x03009064 [15:8]
+	//Set rg_eth_txitune0  0x03009064 [7:0]
+	if ((mmio_read_32(EPHY_EFUSE_VALID_BIT_BASE) & EPHY_EFUSE_TXITUNE_FLAG) ==
+		EPHY_EFUSE_TXITUNE_FLAG) {
+		val = ((mmio_read_32(0x03051024) >> 24) & 0xFF) |
+				(((mmio_read_32(0x03051024) >> 16) & 0xFF) << 8);
+		mmio_clrsetbits_32(0x03009064, 0xFFFF, val);
+	} else
+		mmio_write_32(0x03009064, 0x5a5a);
+
+	// Set Echo_I
+	// Set rg_eth_txechoiadj 0x03009054  [15:8]
+	if ((mmio_read_32(EPHY_EFUSE_VALID_BIT_BASE) & EPHY_EFUSE_TXECHORC_FLAG) ==
+		EPHY_EFUSE_TXECHORC_FLAG) {
+		mmio_clrsetbits_32(0x03009054, 0xFF00, ((mmio_read_32(0x03051024) >> 8) & 0xFF) << 8);
+	} else
+		mmio_write_32(0x03009054, 0x0000);
+
+	//Set TX_Rterm & Echo_RC_Delay
+	// Set rg_eth_txrterm_p1  0x03009058 [11:8]
+	// Set rg_eth_txrterm     0x03009058  [7:4]
+	// Set rg_eth_txechorcadj 0x03009058  [3:0]
+	if ((mmio_read_32(EPHY_EFUSE_VALID_BIT_BASE) & EPHY_EFUSE_TXRXTERM_FLAG) ==
+		EPHY_EFUSE_TXRXTERM_FLAG) {
+		val = (((mmio_read_32(0x03051020) >> 28) & 0xF) << 4) |
+				(((mmio_read_32(0x03051020) >> 24) & 0xF) << 8);
+		mmio_clrsetbits_32(0x03009058, 0xFF0, val);
+	} else
+		mmio_write_32(0x03009058, 0x0bb0);
+
+// ETH_100BaseT
+	// Set Rise update
+	mmio_write_32(0x0300905c, 0x0c10);
+
+	// Set Falling phase
+	mmio_write_32(0x03009068, 0x0003);
+
+	// Set Double TX Bias Current
+	mmio_write_32(0x03009054, 0x0000);
+
+	// Switch to MII-page16
+	mmio_write_32(0x0300907c, 0x1000);
+
+	// Set MLT3 Positive phase code, Set MLT3 +0
+	mmio_write_32(0x03009068, 0x1000);
+	mmio_write_32(0x0300906c, 0x3020);
+	mmio_write_32(0x03009070, 0x5040);
+	mmio_write_32(0x03009074, 0x7060);
+
+	// Set MLT3 +I
+	mmio_write_32(0x03009058, 0x1708);
+	mmio_write_32(0x0300905c, 0x3827);
+	mmio_write_32(0x03009060, 0x5748);
+	mmio_write_32(0x03009064, 0x7867);
+
+	// Switch to MII-page17
+	mmio_write_32(0x0300907c, 0x1100);
+
+	// Set MLT3 Negative phase code, Set MLT3 -0
+	mmio_write_32(0x03009040, 0x9080);
+	mmio_write_32(0x03009044, 0xb0a0);
+	mmio_write_32(0x03009048, 0xd0c0);
+	mmio_write_32(0x0300904c, 0xf0e0);
+
+	// Set MLT3 -I
+	mmio_write_32(0x03009050, 0x9788);
+	mmio_write_32(0x03009054, 0xb8a7);
+	mmio_write_32(0x03009058, 0xd7c8);
+	mmio_write_32(0x0300905c, 0xf8e7);
+
+	// @Switch to MII-page5
+	mmio_write_32(0x0300907c, 0x0500);
+
+	// En TX_Rterm
+	mmio_write_32(0x03009040, (0x0001 | mmio_read_32(0x03009040)));
+
+//	Link Pulse
+	// Switch to MII-page10
+	mmio_write_32(0x0300907c, 0x0a00);
+
+	// Set Link Pulse
+	// mmio_write_32(0x03009040, 0x3e00);
+	// mmio_write_32(0x03009044, 0x7864);
+	// mmio_write_32(0x03009048, 0x6470);
+	// mmio_write_32(0x0300904c, 0x5f62);
+	// mmio_write_32(0x03009050, 0x5a5a);
+	// mmio_write_32(0x03009054, 0x5458);
+	// mmio_write_32(0x03009058, 0xb23a);
+	// mmio_write_32(0x0300905c, 0x94a0);
+	// mmio_write_32(0x03009060, 0x9092);
+	// mmio_write_32(0x03009064, 0x8a8e);
+	// mmio_write_32(0x03009068, 0x8688);
+	// mmio_write_32(0x0300906c, 0x8484);
+	// mmio_write_32(0x03009070, 0x0082);
+
+	// from sean
+	// Fix err: the status is still linkup when removed the network cable.
+	mmio_write_32(0x03009040, 0x2000);
+	mmio_write_32(0x03009044, 0x3832);
+	mmio_write_32(0x03009048, 0x3132);
+	mmio_write_32(0x0300904c, 0x2d2f);
+	mmio_write_32(0x03009050, 0x2c2d);
+	mmio_write_32(0x03009054, 0x1b2b);
+	mmio_write_32(0x03009058, 0x94a0);
+	mmio_write_32(0x0300905c, 0x8990);
+	mmio_write_32(0x03009060, 0x8788);
+	mmio_write_32(0x03009064, 0x8485);
+	mmio_write_32(0x03009068, 0x8283);
+	mmio_write_32(0x0300906c, 0x8182);
+	mmio_write_32(0x03009070, 0x0081);
+
+// TP_IDLE
+	// Switch to MII-page11
+	mmio_write_32(0x0300907c, 0x0b00);
+
+// Set TP_IDLE
+	mmio_write_32(0x03009040, 0x5252);
+	mmio_write_32(0x03009044, 0x5252);
+	mmio_write_32(0x03009048, 0x4B52);
+	mmio_write_32(0x0300904c, 0x3D47);
+	mmio_write_32(0x03009050, 0xAA99);
+	mmio_write_32(0x03009054, 0x989E);
+	mmio_write_32(0x03009058, 0x9395);
+	mmio_write_32(0x0300905C, 0x9091);
+	mmio_write_32(0x03009060, 0x8E8F);
+	mmio_write_32(0x03009064, 0x8D8E);
+	mmio_write_32(0x03009068, 0x8C8C);
+	mmio_write_32(0x0300906C, 0x8B8B);
+	mmio_write_32(0x03009070, 0x008A);
+
+// ETH 10BaseT Data
+	// Switch to MII-page13
+	mmio_write_32(0x0300907c, 0x0d00);
+
+	mmio_write_32(0x03009040, 0x1E0A);
+	mmio_write_32(0x03009044, 0x3862);
+	mmio_write_32(0x03009048, 0x1E62);
+	mmio_write_32(0x0300904c, 0x2A08);
+	mmio_write_32(0x03009050, 0x244C);
+	mmio_write_32(0x03009054, 0x1A44);
+	mmio_write_32(0x03009058, 0x061C);
+
+	// Switch to MII-page14
+	mmio_write_32(0x0300907c, 0x0e00);
+
+	mmio_write_32(0x03009040, 0x2D30);
+	mmio_write_32(0x03009044, 0x3470);
+	mmio_write_32(0x03009048, 0x0648);
+	mmio_write_32(0x0300904c, 0x261C);
+	mmio_write_32(0x03009050, 0x3160);
+	mmio_write_32(0x03009054, 0x2D5E);
+
+	// Switch to MII-page15
+	mmio_write_32(0x0300907c, 0x0f00);
+
+	mmio_write_32(0x03009040, 0x2922);
+	mmio_write_32(0x03009044, 0x366E);
+	mmio_write_32(0x03009048, 0x0752);
+	mmio_write_32(0x0300904c, 0x2556);
+	mmio_write_32(0x03009050, 0x2348);
+	mmio_write_32(0x03009054, 0x0C30);
+
+	// Switch to MII-page16
+	mmio_write_32(0x0300907c, 0x1000);
+
+	mmio_write_32(0x03009040, 0x1E08);
+	mmio_write_32(0x03009044, 0x3868);
+	mmio_write_32(0x03009048, 0x1462);
+	mmio_write_32(0x0300904c, 0x1A0E);
+	mmio_write_32(0x03009050, 0x305E);
+	mmio_write_32(0x03009054, 0x2F62);
+
+// LED PAD MUX
+	mmio_write_32(0x030010e0, 0x05);
+	mmio_write_32(0x030010e4, 0x05);
+	//(SD1_CLK selphy)
+	mmio_write_32(0x050270b0, 0x11111111);
+	//(SD1_CMD selphy)
+	mmio_write_32(0x050270b4, 0x11111111);
+
+// LED
+	// Switch to MII-page1
+	mmio_write_32(0x0300907c, 0x0100);
+
+	// select LED_LNK/SPD/DPX out to LED_PAD
+	mmio_write_32(0x03009068, (mmio_read_32(0x03009068) & ~0x0f00));
+
+	/* do this in board.c */
+	// // @Switch to MII-page0
+	// mmio_write_32(0x0300907c, 0x0000);
+
+	// // PHY_ID
+	// mmio_write_32(0x03009008, 0x0043);
+	// mmio_write_32(0x0300900c, 0x5649);
+
+	// Switch to MII-page19
+	mmio_write_32(0x0300907c, 0x1300);
+	mmio_write_32(0x03009058, 0x0012);
+	// set agc max/min swing
+	mmio_write_32(0x0300905C, 0x6848);
+
+	// Switch to MII-page18
+	mmio_write_32(0x0300907c, 0x1200);
+	// p18.0x12, lpf
+	mmio_write_32(0x03009048, 0x0808);
+	mmio_write_32(0x0300904C, 0x0808);
+// hpf
+//sean
+	mmio_write_32(0x03009050, 0x32f8);
+	mmio_write_32(0x03009054, 0xf8dc);
+
+	// Switch to MII-page0
+	mmio_write_32(0x0300907c, 0x0000);
+	// EPHY start auto-neg procedure
+	mmio_write_32(0x03009800, 0x090e);
+
+	// from jinyu.zhao
+	/* EPHY is configured as half-duplex after reset, but we need force full-duplex */
+	mmio_write_32(0x03009000, (mmio_read_32(0x03009000) | 0x100));
+
+	// switch to MDIO control by ETH_MAC
+	mmio_write_32(0x03009804, 0x0000);
+}
+
+/* CVITEK cv182xa */
+static int cv182xa_config(struct phy_device *phydev)
+{
+	//phy_reset(phydev);
+
+	cv182xa_ephy_init();/* config cvitek cv182xa eth internal phy on ASIC board */
+
+	genphy_config(phydev);
+
+#if defined(CVI_ETH_PHY_LOOPBACK)
+	cv182xa_set_phy_loopback(phydev, LOOPBACK_PCS2MAC);
+#endif
+
+	return 0;
+}
+
+static int cv182xa_parse_status(struct phy_device *phydev)
+{
+	int mii_reg;
+
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+	if (mii_reg & (BMSR_100FULL | BMSR_100HALF))
+		phydev->speed = SPEED_100;
+	else
+		phydev->speed = SPEED_10;
+
+	if (mii_reg & (BMSR_10FULL | BMSR_100FULL))
+		phydev->duplex = DUPLEX_FULL;
+	else
+		phydev->duplex = DUPLEX_HALF;
+
+	return 0;
+}
+
+static int cv182xa_startup(struct phy_device *phydev)
+{
+	int ret;
+
+	/* Read the Status (2x to make sure link is right) */
+	ret = genphy_update_link(phydev);
+	if (ret)
+		return ret;
+
+	return cv182xa_parse_status(phydev);
+}
+
+/* Support for cv182xa PHYs */
+static struct phy_driver cv182xa_driver = {
+	.name = "CVITEK CV182XA",
+	.uid = 0x00435649,
+	.mask = 0xffffffff,
+	.features = PHY_BASIC_FEATURES,
+	.config = &cv182xa_config,
+	.startup = &cv182xa_startup,
+	.shutdown = &genphy_shutdown,
+};
+
+int phy_cv182xa_init(void)
+{
+	phy_register(&cv182xa_driver);
+
+	return 0;
+}
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 69acb6946..4faef8d59 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -505,6 +505,9 @@ int phy_init(void)
 #ifdef CONFIG_PHY_CORTINA_ACCESS
 	phy_cortina_access_init();
 #endif
+#ifdef CONFIG_PHY_CVITEK_CV182XA
+	phy_cv182xa_init();
+#endif
 #ifdef CONFIG_PHY_DAVICOM
 	phy_davicom_init();
 #endif
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index cf7f4c684..82a27e9aa 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -9,6 +9,17 @@ config DM_PWM
 	  frequency/period can be controlled along with the proportion of that
 	  time that the signal is high.
 
+config PWM_CVITEK
+	bool "Enable support for cvitek PWM"
+	depends on DM_PWM
+	help
+	  This PWM is found cvitek SoCs.
+	  Internal 30-BIT counter, output cycle and high/low level beats can be matched.
+	  Supports up to 50MHz or 74.25mhz output, and down to about 0.093Hz.
+	  Support continuous output and fixed number of pulse output two modes.
+	  Support 4 channel PWM synchronous output, 4 channel PWM output
+	  can be adjusted by configuring the register.
+
 config PWM_CROS_EC
 	bool "Enable support for the Chrome OS EC PWM"
 	depends on DM_PWM
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 10d244bfb..66746edc7 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -10,6 +10,7 @@
 
 obj-$(CONFIG_DM_PWM)		+= pwm-uclass.o
 
+obj-$(CONFIG_PWM_CVITEK)	+= cvitek_pwm.o
 obj-$(CONFIG_PWM_CROS_EC)	+= cros_ec_pwm.o
 obj-$(CONFIG_PWM_EXYNOS)	+= exynos_pwm.o
 obj-$(CONFIG_PWM_IMX)		+= pwm-imx.o pwm-imx-util.o
diff --git a/drivers/pwm/cvitek_pwm.c b/drivers/pwm/cvitek_pwm.c
new file mode 100644
index 000000000..d010210e9
--- /dev/null
+++ b/drivers/pwm/cvitek_pwm.c
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2022 cvitek All rights reserved.
+ * Author: jinyu zhao <jinyu.zhaok@cvitek.com>
+ *
+ * cvitek PWM driver for U-Boot
+ */
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <pwm.h>
+#include <asm/io.h>
+#include <log.h>
+
+#define CVITEK_PWM_CLK_MHZ 100
+
+enum {
+	CHANNEL0 = 0,
+	CHANNEL1,
+	CHANNEL2,
+	CHANNEL3,
+	MAX_CHANNEL,
+};
+
+struct cvitek_pwm_regs {
+	unsigned int hlperiod0;/* 0x00 */
+	unsigned int period0;/* 0x04 */
+	unsigned int hlperiod1;/* 0x08 */
+	unsigned int period1;/* 0x0c */
+	unsigned int hlperiod2;/* 0x10 */
+	unsigned int period2;/* 0x14 */
+	unsigned int hlperiod3;/* 0x18 */
+	unsigned int period3;/* 0x1c */
+	unsigned int reserved_1[8];
+	unsigned int polarity;/* 0x40 */
+	unsigned int pwmstart;/* 0x44 */
+	unsigned int pwmdone;/* 0x48 */
+	unsigned int pwmupdate;/* 0x4c */
+	unsigned int pcount0;/* 0x50 */
+	unsigned int pcount1;/* 0x54 */
+	unsigned int pcount2;/* 0x58 */
+	unsigned int pcount3;/* 0x5c */
+	unsigned int pulsecount0;/* 0x60 */
+	unsigned int pulsecount1;/* 0x64 */
+	unsigned int pulsecount2;/* 0x68 */
+	unsigned int pulsecount3;/* 0x6c */
+	unsigned int reserved_2[4];
+	unsigned int shiftcount0;/* 0x80 */
+	unsigned int shiftcount1;/* 0x84 */
+	unsigned int shiftcount2;/* 0x88 */
+	unsigned int shiftcount3;/* 0x8c */
+	unsigned int shiftstart;/* 0x90 */
+	unsigned int reserved_3[15];
+	unsigned int pwm_oe;/* 0xd0 */
+};
+
+struct pwm_chip_priv {
+	const char *chip_name;
+	struct udevice *dev;		/* Device, NULL for invalid pwm */
+	void __iomem	*base;
+	int pwm_base;			/* this device pwm base number */
+	int pwm_count;
+	unsigned long flags;
+};
+
+static int cvitek_pwm_set_config(struct udevice *dev, uint channel, uint period_ns, uint duty_ns)
+{
+	struct pwm_chip_priv *chip = dev_get_priv(dev);
+	struct cvitek_pwm_regs *regs = (struct cvitek_pwm_regs *)chip->base;
+	unsigned int period_val, hlperiod_val;
+
+	if (channel < 0 || channel >= chip->pwm_count)
+		return -EINVAL;
+	if (duty_ns <= 0)
+		duty_ns = 1;
+	if (duty_ns >= period_ns)
+		duty_ns = period_ns - 1;
+
+	period_val = CVITEK_PWM_CLK_MHZ * period_ns / 1000;
+	hlperiod_val = CVITEK_PWM_CLK_MHZ * (period_ns - duty_ns) / 1000;
+
+	switch (channel) {
+	case CHANNEL0:
+		/* set duty cycles */
+		writel(hlperiod_val, &regs->hlperiod0);
+		/* set period cycles */
+		writel(period_val, &regs->period0);
+		break;
+	case CHANNEL1:
+		/* set duty cycles */
+		writel(hlperiod_val, &regs->hlperiod1);
+		/* set period cycles */
+		writel(period_val, &regs->period1);
+		break;
+	case CHANNEL2:
+		/* set duty cycles */
+		writel(hlperiod_val, &regs->hlperiod2);
+		/* set period cycles */
+		writel(period_val, &regs->period2);
+		break;
+	case CHANNEL3:
+		/* set duty cycles */
+		writel(hlperiod_val, &regs->hlperiod3);
+		/* set period cycles */
+		writel(period_val, &regs->period3);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int cvitek_pwm_set_enable(struct udevice *dev, uint channel, bool enable)
+{
+	struct pwm_chip_priv *chip = dev_get_priv(dev);
+	struct cvitek_pwm_regs *regs = (struct cvitek_pwm_regs *)chip->base;
+	unsigned int value;
+
+	if (channel < 0 || channel >= chip->pwm_count)
+		return -EINVAL;
+
+	value = readl(&regs->pwm_oe);
+	writel(value | (0x1 << channel), &regs->pwm_oe);
+
+	value = readl(&regs->pwmstart);
+	writel(value & ~(0x1 << channel), &regs->pwmstart);
+
+	/* enable pwmstart */
+	if (enable)
+		writel(value | (0x1 << channel), &regs->pwmstart);
+
+	return 0;
+}
+
+static int cvitek_pwm_set_invert(struct udevice *dev, uint channel, bool polarity)
+{
+	struct pwm_chip_priv *chip = dev_get_priv(dev);
+	struct cvitek_pwm_regs *regs = (struct cvitek_pwm_regs *)chip->base;
+	unsigned int value;
+
+	if (channel < 0 || channel >= chip->pwm_count)
+		return -EINVAL;
+
+	value = readl(&regs->polarity);
+	/* polarity: default high level output */
+	value = polarity ? value | (0x1 << channel) :
+				value & ~(0x1 << channel);
+	writel(value, &regs->polarity);
+
+	return 0;
+}
+
+static const struct pwm_ops cvitek_pwm_ops = {
+	.set_config	= cvitek_pwm_set_config,
+	.set_enable	= cvitek_pwm_set_enable,
+	.set_invert	= cvitek_pwm_set_invert,
+};
+
+static int cvitek_pwm_probe(struct udevice *dev)
+{
+	struct pwm_chip_priv *chip = dev_get_priv(dev);
+	const char *name;
+	fdt_addr_t base;
+
+	base = dev_read_addr(dev);
+	if (base == FDT_ADDR_T_NONE) {
+		pr_err("Can't get the PWM register base address\n");
+		return -ENXIO;
+	}
+
+	chip->base = (void *)base;
+	chip->pwm_count = MAX_CHANNEL;
+
+	/* Ensure that we have a base for each bank */
+	name = dev_read_name(dev);
+	if (!name)
+		return -ENOENT;
+
+	chip->pwm_base = dev->seq_ * chip->pwm_count;
+	if (chip->pwm_base < 0)
+		return -ENOENT;
+
+	return 0;
+}
+
+static const struct udevice_id cvitek_pwm_ids[] = {
+	{ .compatible = "cvitek,cvi-pwm" },
+	{ }
+};
+
+U_BOOT_DRIVER(pwm_cvitek) = {
+	.name		= "pwm_cvitek",
+	.id		= UCLASS_PWM,
+	.of_match	= cvitek_pwm_ids,
+	.ops		= &cvitek_pwm_ops,
+	.probe		= cvitek_pwm_probe,
+	.priv_auto	= sizeof(struct pwm_chip_priv),
+};
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index d07e9a28a..2c6f0b194 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -452,6 +452,15 @@ config XILINX_SPI
 	  For more info on Xilinx SPI Register Definitions and Overview
 	  see driver file - drivers/spi/xilinx_spi.c
 
+config CVI_SPIF
+	bool "Cvitek SPI driver"
+	depends on SPI_MEM
+	help
+		Enable the Cvitek SPIF driver. This driver can be used to
+		access the SPI NOR flash on platforms embedding this Cvitek
+		SPIF IP core.
+		see driver file - drivers/spi/cvi-spif.c
+
 config ZYNQ_SPI
 	bool "Zynq SPI driver"
 	help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index d2f24bcce..22db8978a 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -71,3 +71,4 @@ obj-$(CONFIG_XILINX_SPI) += xilinx_spi.o
 obj-$(CONFIG_ZYNQ_SPI) += zynq_spi.o
 obj-$(CONFIG_ZYNQ_QSPI) += zynq_qspi.o
 obj-$(CONFIG_ZYNQMP_GQSPI) += zynqmp_gqspi.o
+obj-$(CONFIG_CVI_SPIF) += cvi_spif.o
\ No newline at end of file
diff --git a/drivers/spi/cvi_spif.c b/drivers/spi/cvi_spif.c
new file mode 100644
index 000000000..d1710766e
--- /dev/null
+++ b/drivers/spi/cvi_spif.c
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cvi_spif.c
+ *
+ * Description: Cvitek SPI NOR flash driver
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/io.h>
+#include <spi_flash.h>
+#include "cvi_spif.h"
+#include <spi-mem.h>
+#include <dm.h>
+#include <linux/delay.h>
+#include <mmio.h>
+#include <linux/mtd/spi-nor.h>
+
+// #define DEBUG
+
+static int cvitek_spi_probe(struct udevice *bus)
+{
+	struct cvitek_spi_priv *priv = dev_get_priv(bus);
+
+	priv->ctrl_base = (typeof(priv->ctrl_base))dev_read_addr_ptr(bus);
+	priv->sck = dev_read_u32_default(bus, "sck_mhz", 50) * CLK_1MHZ;
+	priv->max_hz = dev_read_u32_default(bus, "spi-max-frequency", 0);
+
+	if (priv->ctrl_base == 0)
+		return -EINVAL;
+	return 0;
+}
+
+static unsigned int match_value_for_read(u8 read_cmd)
+{
+	int i;
+	uint32_t val;
+
+	for (i = 0; i < sizeof(dmmr_reg_set); i++) {
+		if (read_cmd == dmmr_reg_set[i].read_cmd) {
+			val = dmmr_reg_set[i].reg_set;
+			val &= ~(0xf << 16);
+			val |= ((dmmr_reg_set[i].dummy_clock & 0xf) << 16);
+			return val;
+		}
+	}
+	return dmmr_reg_set[0].reg_set;
+}
+
+static void cvitek_set_sf_clk(unsigned long spi_base, uint32_t sck_div)
+{
+	uint32_t ctrl;
+
+	/* disable DMMR */
+	mmio_write_8(spi_base + REG_SPI_DMMR, 0);
+
+	ctrl = mmio_read_32(spi_base + REG_SPI_CTRL);
+	ctrl &= ~BIT_SPI_CTRL_SCK_DIV_MASK;
+	ctrl |= sck_div;
+	mmio_write_32(spi_base + REG_SPI_CTRL, ctrl);
+
+	if (sck_div >= SPI_CLK_30M) /* if sck <= 30MHz */
+		mmio_write_16(spi_base + REG_SPI_DLY_CTRL, BIT_SPI_DLY_CTRL_CET);
+	else /* if sck > 30MHz */
+		mmio_write_16(spi_base + REG_SPI_DLY_CTRL, BIT_SPI_DLY_CTRL_CET | BIT_SPI_DLY_CTRL_NEG_SAMPLE);
+}
+
+static void cvitek_enable_mmap(struct cvitek_spi_priv *priv, u8 read_cmd, u8 dummy_clk)
+{
+	uint32_t val;
+
+	/* disable DMMR */
+	mmio_write_32(priv->ctrl_base + REG_SPI_DMMR, 0);
+
+	/* backup register settings */
+	priv->orig_tran_csr = mmio_read_32(priv->ctrl_base + REG_SPI_TRAN_CSR);
+
+	/* CE control by HW */
+	mmio_write_32(priv->ctrl_base + REG_SPI_CE_CTRL, 0);
+
+	/* set TRANS_CSR according to read cmd */
+	val = match_value_for_read(read_cmd);
+	if (dummy_clk) {
+		val &= ~(0xf << 16);
+		val |= ((dummy_clk & 0xf) << 16);
+	}
+	mmio_write_32(priv->ctrl_base + REG_SPI_TRAN_CSR, val);
+
+	/* set spinor clock */
+	cvitek_set_sf_clk(priv->ctrl_base, priv->sck_div);
+
+	/* enable DMMR */
+	mmio_write_32(priv->ctrl_base + REG_SPI_DMMR, 1);
+}
+
+static void cvitek_disable_mmap(struct cvitek_spi_priv *priv)
+{
+	/* restore register settings */
+	mmio_write_32(priv->ctrl_base + REG_SPI_CE_CTRL, 0x3);
+	mmio_write_32(priv->ctrl_base + REG_SPI_TRAN_CSR, priv->orig_tran_csr);
+}
+
+static uint8_t cvitek_spi_data_out_tran(struct cvitek_spi_priv *priv, struct spi_flash *flash,
+					unsigned long spi_base, const uint8_t *src_buf,
+					uint32_t data_bytes, unsigned long flags)
+{
+	uint32_t tran_csr = 0;
+	uint32_t xfer_size, off;
+	uint32_t wait = 0;
+	int i;
+	struct spi_slave *spi = flash->spi;
+
+	debug("cvitek_spi_data_out_tran(): flags 0x%lx, opcode 0x%x, spi->mode 0x%x\n",
+	      flags, flash->program_opcode, spi->mode);
+
+	if (data_bytes > 65535) {
+		printf("data out overflow, should be less than 65535 bytes(%d)\n", data_bytes);
+		return -1;
+	}
+
+	cvitek_set_sf_clk(priv->ctrl_base, priv->sck_div);
+
+	/* init TRANS_CSR (offset: 0x10) */
+	tran_csr = mmio_read_16(spi_base + REG_SPI_TRAN_CSR);
+	tran_csr &= ~(BIT_SPI_TRAN_CSR_TRAN_MODE_MASK
+		| BIT_SPI_TRAN_CSR_BUS_WIDTH_MASK
+		| BIT_SPI_TRAN_CSR_ADDR_BYTES_MASK
+		| BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_MASK
+		| BIT_SPI_TRAN_CSR_WITH_CMD);
+	tran_csr |= BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_8_BYTE;
+	tran_csr |= BIT_SPI_TRAN_CSR_TRAN_MODE_TX;
+
+	if (flags & SPI_XFER_USER_DATA && !(flags & SPI_XFER_BEGIN)) {
+		if (spi->mode & SPI_TX_QUAD)
+			tran_csr |= BIT_SPI_TRAN_CSR_BUS_WIDTH_4_BIT;
+		else
+			tran_csr |= BIT_SPI_TRAN_CSR_BUS_WIDTH_1_BIT;
+	}
+
+	mmio_write_32(spi_base + REG_SPI_FIFO_PT, 0);
+
+	/* issue tran */
+	mmio_write_16(spi_base + REG_SPI_TRAN_NUM, data_bytes);
+	tran_csr |= BIT_SPI_TRAN_CSR_GO_BUSY;
+
+	debug("cvitek_spi_data_out_tran tran_csr 0x%x\n", tran_csr);
+
+	mmio_write_16(spi_base + REG_SPI_TRAN_CSR, tran_csr);
+
+	while ((mmio_read_8(spi_base + REG_SPI_INT_STS) & BIT_SPI_INT_WR_FIFO) == 0)
+		;
+
+	/* fill data */
+	off = 0;
+	while (off < data_bytes) {
+		if (data_bytes - off >= SPI_MAX_FIFO_DEPTH)
+			xfer_size = SPI_MAX_FIFO_DEPTH;
+		else
+			xfer_size = data_bytes - off;
+
+		wait = 0;
+		while ((mmio_read_8(spi_base + REG_SPI_FIFO_PT) & 0xF) != 0) {
+			wait++;
+			udelay(1);
+			if (wait > 3000) { // 3ms
+				printf("wait to write FIFO timeout\n");
+				return -1;
+			}
+		}
+
+		/*
+		 * odd thing, if we use mmio_write_8, the BIT_SPI_INT_WR_FIFO bit can't
+		 * be cleared after transfer done. and BIT_SPI_INT_RD_FIFO bit will not
+		 * be set even when REG_SPI_FIFO_PT shows non-zero value.
+		 */
+		for (i = 0; i < xfer_size; i++)
+			mmio_write_8(spi_base + REG_SPI_FIFO_PORT, *(src_buf + off + i));
+
+		off += xfer_size;
+	}
+
+	/* wait tran done */
+	while ((mmio_read_8(spi_base + REG_SPI_INT_STS) & BIT_SPI_INT_TRAN_DONE) == 0)
+		;
+	mmio_write_32(spi_base + REG_SPI_FIFO_PT, 0);
+
+	/* clear interrupts */
+	mmio_write_8(spi_base + REG_SPI_INT_STS, mmio_read_8(spi_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_TRAN_DONE);
+	mmio_write_8(spi_base + REG_SPI_INT_STS, mmio_read_8(spi_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_WR_FIFO);
+	return 0;
+}
+
+static int cvitek_spi_data_in_tran(struct cvitek_spi_priv *priv, struct spi_flash *flash,
+				   unsigned long spi_base, uint8_t *dst_buf, int data_bytes,
+				   unsigned long flags)
+{
+	uint32_t i, xfer_size, off, tran_csr = 0;
+
+	/* disable DMMR (offset: 0xC) */
+	mmio_write_32(priv->ctrl_base + REG_SPI_DMMR, 0);
+
+	/* init TRANS_CSR (offset: 0x10) */
+	tran_csr = mmio_read_16(spi_base + REG_SPI_TRAN_CSR);
+	tran_csr &= ~(BIT_SPI_TRAN_CSR_TRAN_MODE_MASK
+			| BIT_SPI_TRAN_CSR_ADDR_BYTES_MASK
+			| BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_MASK
+			| BIT_SPI_TRAN_CSR_WITH_CMD);
+	tran_csr |= BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_8_BYTE;
+	tran_csr |= BIT_SPI_TRAN_CSR_TRAN_MODE_RX;
+
+	/* Lower down spi clock with no-addr cmd */
+	if (flags & SPI_XFER_CMD_DATA)
+		cvitek_set_sf_clk(priv->ctrl_base, SPI_CLK_30M);
+	else
+		cvitek_set_sf_clk(priv->ctrl_base, priv->sck_div);
+
+	/* flush FIFO after tran */
+	mmio_write_32(spi_base + REG_SPI_FIFO_PT, 0);
+
+	/* issue tran */
+	mmio_write_16(spi_base + REG_SPI_TRAN_NUM, data_bytes);
+	tran_csr |= BIT_SPI_TRAN_CSR_GO_BUSY;
+	mmio_write_16(spi_base + REG_SPI_TRAN_CSR, tran_csr);
+
+	while ((mmio_read_8(spi_base + REG_SPI_INT_STS) & BIT_SPI_INT_RD_FIFO) == 0 &&
+	       (mmio_read_8(spi_base + REG_SPI_INT_STS) & BIT_SPI_INT_TRAN_DONE) == 0)
+		;
+
+	/* get data */
+	off = 0;
+	while (off < data_bytes) {
+		if (data_bytes - off >= SPI_MAX_FIFO_DEPTH)
+			xfer_size = SPI_MAX_FIFO_DEPTH;
+		else
+			xfer_size = data_bytes - off;
+
+		while ((mmio_read_8(spi_base + REG_SPI_FIFO_PT) & 0xF) < xfer_size)
+			;
+		for (i = 0; i < xfer_size; i++)
+			*(dst_buf + off + i) = mmio_read_8(spi_base + REG_SPI_FIFO_PORT);
+
+		off += xfer_size;
+	}
+
+	/* wait tran done */
+	while ((mmio_read_8(spi_base + REG_SPI_INT_STS) & BIT_SPI_INT_TRAN_DONE) == 0)
+		;
+	/* flush FIFO after tran */
+	mmio_write_8(spi_base + REG_SPI_FIFO_PT, 0);
+
+	/* write 0 to clear interrupts */
+	mmio_write_8(spi_base + REG_SPI_INT_STS, mmio_read_8(spi_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_TRAN_DONE);
+	mmio_write_8(spi_base + REG_SPI_INT_STS, mmio_read_8(spi_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_RD_FIFO);
+
+	return 0;
+}
+
+void dump_mem(const void *start_addr, int len)
+{
+	unsigned int *curr_p = (unsigned int *)start_addr;
+	unsigned char *curr_ch_p;
+	int _16_fix_num = len / 16;
+	int tail_num = len % 16;
+	char buf[16];
+	int i, j;
+
+	if (!curr_p || len == 0) {
+		printf("nothing to dump!\n");
+		return;
+	}
+
+	printf("Base: %p\n", start_addr);
+	// Fix section
+	for (i = 0; i < _16_fix_num; i++) {
+		printf("%03X: %08X %08X %08X %08X\n",
+		       i * 16, *curr_p, *(curr_p + 1), *(curr_p + 2), *(curr_p + 3));
+		curr_p += 4;
+	}
+
+	// Tail section
+	if (tail_num > 0) {
+		curr_ch_p = (unsigned char *)curr_p;
+		for (j = 0; j < tail_num; j++) {
+			buf[j] = *curr_ch_p;
+			curr_ch_p++;
+		}
+		for (; j < 16; j++)
+			buf[j] = 0;
+		curr_p = (unsigned int *)buf;
+		printf("%03X: %08X %08X %08X %08X\n",
+		       i * 16, *curr_p, *(curr_p + 1), *(curr_p + 2), *(curr_p + 3));
+	}
+}
+
+static int cvitek_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			   const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct cvitek_spi_priv *priv = dev_get_priv(bus);
+	struct spi_flash *flash = dev_get_uclass_priv(dev);
+
+	/* assume spi core configured to do 8 bit transfers */
+	unsigned int bytes = bitlen / 8;
+
+	debug("bitlen:%d flags:%lx dir:%s\n", bitlen, flags, (dout) ? "out" : "in");
+
+	if (flags & SPI_XFER_MMAP) {
+		debug("opcode:%#x, dummy:%u\n", flash->read_opcode, flash->read_dummy);
+		cvitek_enable_mmap(priv, flash->read_opcode, flash->read_dummy);
+		return 0;
+	} else if (flags & SPI_XFER_MMAP_END) {
+		cvitek_disable_mmap(priv);
+		return 0;
+	}
+
+	if (bitlen == 0)
+		goto done;
+
+	if (bitlen % 8) {
+		printf("xfer bit length not a multiple of 8 bits\n");
+		flags |= SPI_XFER_END;
+		goto done;
+	}
+
+	if (flags & SPI_XFER_BEGIN)
+		mmio_write_8(priv->ctrl_base + REG_SPI_CE_CTRL, 0x2);
+
+	if (dout) {
+#ifdef DEBUG
+		dump_mem(dout, bytes);
+#endif
+		cvitek_spi_data_out_tran(priv, flash, priv->ctrl_base, dout, bytes, flags);
+	}
+	if (din) {
+		cvitek_spi_data_in_tran(priv, flash, priv->ctrl_base, din, bytes, flags);
+
+#ifdef DEBUG
+		dump_mem(din, (bytes > 256) ? 256 : bytes);
+#endif
+	}
+
+done:
+	if (flags & SPI_XFER_END)
+		mmio_write_8(priv->ctrl_base + REG_SPI_CE_CTRL, 0x3);
+	return 0;
+}
+
+static int cvitek_spi_set_speed(struct udevice *bus, uint speed)
+{
+	int tmp;
+
+	struct cvitek_spi_priv *priv = dev_get_priv(bus);
+
+	priv->freq = priv->max_hz;	/* don't care input speed */
+	tmp = priv->sck / (priv->freq * 2) - 1;
+
+	if (tmp > 0)
+		priv->sck_div = priv->sck / (priv->freq * 2) - 1;
+	else
+		priv->sck_div = SPI_CLK_30M;	/* default value, 30MHz */
+
+
+	debug("%s: %d Hz, sck_div: %d\n", __func__, priv->freq, priv->sck_div);
+
+	cvitek_set_sf_clk(priv->ctrl_base, priv->sck_div);
+
+	return 0;
+}
+
+static int cvitek_spi_set_mode(struct udevice *bus, uint mode)
+{
+	struct cvitek_spi_priv *priv = dev_get_priv(bus);
+	uint32_t ctrl;
+
+	mode = mode & 0x3;
+	if (mode == 1 || mode == 2)
+		mode = 0;
+
+	debug("[%s %d]===> set spi nor mode:%u\n", __func__, __LINE__, mode);
+	ctrl = mmio_read_32(priv->ctrl_base + REG_SPI_CTRL);
+	ctrl &= ~(BIT_SPI_CTRL_CPHA | BIT_SPI_CTRL_CPOL);
+	ctrl |= mode << 12;
+	mmio_write_32(priv->ctrl_base + REG_SPI_CTRL, ctrl);
+	priv->mode = mode;
+
+	return 0;
+}
+
+#if 0
+static bool cvitek_spi_supports_op(struct spi_slave *slave,
+				 const struct spi_mem_op *op)
+{
+	debug("%s\n", __func__);
+	return true;
+}
+
+static int cvitek_spi_adjust_op_size(struct spi_slave *slave,
+				   struct spi_mem_op *op)
+{
+	debug("%s\n", __func__);
+	return 0;
+}
+#endif
+
+static int cvitek_spi_exec_op(struct spi_slave *slave,
+			    const struct spi_mem_op *op)
+{
+	int ret = 0;
+	struct udevice *bus = slave->dev->parent;
+	struct cvitek_spi_priv *priv = dev_get_priv(bus);
+
+	/* Only optimize read path. */
+	if (!op->data.nbytes || op->data.dir != SPI_MEM_DATA_IN ||
+	    !op->addr.nbytes || op->addr.nbytes > 4) {
+		if (!op->addr.nbytes)
+			cvitek_set_sf_clk(priv->ctrl_base, SPI_CLK_30M);
+		else
+			cvitek_set_sf_clk(priv->ctrl_base, priv->sck_div);
+
+		return -ENOTSUPP;
+	}
+
+	ret = spi_xfer(slave, 0, NULL, NULL, SPI_XFER_MMAP);
+	memcpy(op->data.buf.in, (void *)(priv->ctrl_base + op->addr.val), op->data.nbytes);
+	ret = spi_xfer(slave, 0, NULL, NULL, SPI_XFER_MMAP_END);
+	return ret;
+}
+
+static const struct spi_controller_mem_ops cvitek_spi_mem_ops = {
+	// .supports_op = cvitek_spi_supports_op,
+	.exec_op = cvitek_spi_exec_op,
+	// .adjust_op_size = cvitek_spi_adjust_op_size,
+};
+
+static const struct dm_spi_ops cvitek_spi_ops = {
+	.xfer		= cvitek_spi_xfer,
+	.mem_ops	= &cvitek_spi_mem_ops,
+	.set_speed	= cvitek_spi_set_speed,
+	.set_mode	= cvitek_spi_set_mode,
+};
+
+static const struct udevice_id cvitek_spi_ids[] = {
+	{ .compatible = "cvitek,cvi-spif" },
+	{ }
+};
+
+U_BOOT_DRIVER(cvitek_spi) = {
+	.name	= "cvitek_spi",
+	.id	= UCLASS_SPI,
+	.of_match = cvitek_spi_ids,
+	.ops	= &cvitek_spi_ops,
+	.priv_auto	= sizeof(struct cvitek_spi_priv),
+	.probe	= cvitek_spi_probe,
+};
diff --git a/drivers/spi/cvi_spif.h b/drivers/spi/cvi_spif.h
new file mode 100755
index 000000000..0d379e2c5
--- /dev/null
+++ b/drivers/spi/cvi_spif.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cvi_spif.h
+ *
+ * Description: Cvitek SPI NOR flash driver header
+ */
+
+#ifndef __CVI_SPIF_H__
+#define __CVI_SPIF_H__
+
+/* spi register definitions */
+#define REG_SPI_CTRL			0x00
+#define REG_SPI_CE_CTRL			0x04
+#define REG_SPI_DLY_CTRL		0x08
+#define REG_SPI_DMMR			0x0C
+#define REG_SPI_TRAN_CSR		0x10
+#define REG_SPI_TRAN_NUM		0x14
+#define REG_SPI_FIFO_PORT		0x18
+#define REG_SPI_FIFO_PT			0x20
+#define REG_SPI_INT_STS			0x28
+#define REG_SPI_INT_EN			0x2C
+#define REG_SPI_OPT			0x30
+
+/* spi-nor commands */
+#define SPI_CMD_WREN            0x06
+#define SPI_CMD_WRDI            0x04
+#define SPI_CMD_RDID            0x9F
+#define SPI_CMD_RDSR            0x05
+#define SPI_CMD_WRSR            0x01
+#define SPI_CMD_READ            0x03
+#define SPI_CMD_FAST_READ       0x0B
+#define SPI_CMD_PP              0x02
+#define SPI_CMD_SE              0x20
+#define SPI_CMD_BE              0xD8
+#define SPI_CMD_CE              0xC7
+
+/* spi-nor status register */
+#define SPI_STATUS_WIP          BIT(0)
+#define SPI_STATUS_WEL          BIT(1)
+#define SPI_STATUS_BP0          BIT(2)
+#define SPI_STATUS_BP1          BIT(3)
+#define SPI_STATUS_BP2          BIT(4)
+#define SPI_STATUS_BP3          BIT(5)
+#define SPI_STATUS_TP           BIT(6)
+#define SPI_STATUS_SRWD         BIT(7)
+
+/* register bit definition */
+#define BIT_SPI_CTRL_CPHA		BIT(12)
+#define BIT_SPI_CTRL_CPOL		BIT(13)
+#define BIT_SPI_CTRL_HOLD_OL	BIT(14)
+#define BIT_SPI_CTRL_WP_OL		BIT(15)
+#define BIT_SPI_CTRL_FL			BIT(16)
+#define BIT_SPI_CTRL_LSBF		BIT(20)
+#define BIT_SPI_CTRL_SRST		BIT(21)
+#define BIT_SPI_CTRL_SCK_DIV_SHIFT		0
+#define BIT_SPI_CTRL_FRAME_LEN_SHIFT	16
+#define BIT_SPI_CTRL_SCK_DIV_MASK		0x7FF // [10:0]
+#define BIT_SPI_CE_CTRL_CEMANUAL		BIT(0)
+#define BIT_SPI_CE_CTRL_CEMANUAL_EN		BIT(1)
+#define BIT_SPI_DMMR_EN                 BIT(0)
+
+#define BIT_SPI_TRAN_CSR_TRAN_MODE_RX				BIT(0)
+#define BIT_SPI_TRAN_CSR_TRAN_MODE_TX				BIT(1)
+#define BIT_SPI_TRAN_CSR_CNTNS_READ				BIT(2)
+#define BIT_SPI_TRAN_CSR_FAST_MODE				BIT(3)
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_1_BIT			0x0
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_2_BIT			0x10
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_4_BIT			0x20
+#define BIT_SPI_TRAN_CSR_DMA_EN					BIT(6)
+#define BIT_SPI_TRAN_CSR_MISO_LEVEL				BIT(7)
+#define BIT_SPI_TRAN_CSR_ADDR_BYTES_NO_ADDR			0
+#define BIT_SPI_TRAN_CSR_WITH_CMD				BIT(11)
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_1_BYTE			0x0
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_2_BYTE			0x1000
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_4_BYTE			0x2000
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_8_BYTE			0x3000
+#define BIT_SPI_TRAN_CSR_GO_BUSY				BIT(15)
+#define BIT_SPI_TRAN_CSR_TRAN_MODE_MASK				0x3
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_MASK				0x30
+#define BIT_SPI_TRAN_CSR_ADDR_BYTES_MASK			0x700
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_MASK			0x3000
+#define BIT_SPI_TRAN_CSR_DUMMY_MASK				0xF0000
+#define BIT_SPI_TRAN_CSR_4BADDR_MASK				BIT(20)
+#define BIT_SPI_TRAN_CSR_4BCMD_MASK				BIT(21)
+#define BIT_SPI_DLY_CTRL_CET					(3 << 8)
+#define BIT_SPI_DLY_CTRL_NEG_SAMPLE				BIT(14)
+
+#define BIT_SPI_INT_TRAN_DONE               BIT(0)
+#define BIT_SPI_INT_RD_FIFO                 BIT(2)
+#define BIT_SPI_INT_WR_FIFO                 BIT(3)
+#define BIT_SPI_INT_RX_FRAME                BIT(4)
+#define BIT_SPI_INT_TX_FRAME                BIT(5)
+
+#define BIT_SPI_INT_TRAN_DONE_EN            BIT(0)
+#define BIT_SPI_INT_RD_FIFO_EN              BIT(2)
+#define BIT_SPI_INT_WR_FIFO_EN              BIT(3)
+#define BIT_SPI_INT_RX_FRAME_EN             BIT(4)
+#define BIT_SPI_INT_TX_FRAME_EN             BIT(5)
+
+/* general definition */
+#define SPI_FLASH_BLOCK_SIZE             256
+#define SPI_TRAN_CSR_ADDR_BYTES_SHIFT    8
+#define SPI_MAX_FIFO_DEPTH               8
+#define SPI_CLK_75M             1
+#define SPI_CLK_50M             2
+#define SPI_CLK_37M             3
+#define SPI_CLK_30M             4
+#define SPI_CLK_15M             9
+#define CLK_1MHZ				1000000
+
+/* struct */
+struct cvi_spif_regs {
+	unsigned int spi_ctrl;	/* 0x00 */
+	unsigned int ce_ctrl;	/* 0x04 */
+	unsigned int dly_ctrl;	/* 0x08 */
+	unsigned int dmmr;		/* 0x0C */
+	unsigned int tran_csr;	/* 0x10 */
+	unsigned int tran_num;	/* 0x14 */
+	unsigned int ff_port;	/* 0x18 */
+	unsigned int rsvd;		/* 0x1C */
+	unsigned int ff_pt;		/* 0x20 */
+	unsigned int rsvd1;		/* 0x24 */
+	unsigned int int_sts;	/* 0x28 */
+	unsigned int int_en;	/* 0x2C */
+};
+
+struct cvitek_spi_priv {
+	unsigned long ctrl_base;
+	unsigned int freq;
+	unsigned int mode;
+	unsigned int sck_div;
+	unsigned int sck;
+	struct cvi_spif_regs *regs;
+	unsigned int max_hz;
+	unsigned int orig_tran_csr;
+
+#define CMD_HAS_ADR		BIT(24)
+#define CMD_HAS_DUMMY	BIT(25)
+#define CMD_HAS_DATA	BIT(26)
+};
+
+struct dmmr_reg_t {
+	uint8_t read_cmd;
+	uint32_t dummy_clock;
+	uint32_t reg_set;
+};
+
+const struct dmmr_reg_t dmmr_reg_set[16] = {
+	{0x03, 0x0, 0x003B81},
+	{0x0B, 0x8, 0x003B89},
+	{0x3B, 0x8, 0x003B91},
+	{0xBB, 0x4, 0x003B99},
+	{0x6B, 0x8, 0x003BA1},
+	{0xEB, 0x6, 0x003BA9},
+	{0x13, 0x0, 0x303C81},
+	{0x0C, 0x8, 0x303C89},
+	{0x3C, 0x8, 0x303C91},
+	{0xBC, 0x4, 0x303C99},
+	{0x6C, 0x8, 0x303CA1},
+	{0xEC, 0x6, 0x303CA9},
+	{0x0, 0x0, 0x0}
+};
+
+#endif	/* __CVI_SPIF_H__ */
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index 9c1ede1b6..98a630029 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -20,6 +20,7 @@
 #include <spi.h>
 #include <spi.h>
 #include <spi-mem.h>
+#include <linux/mtd/spi-nor.h>
 #include <dm/device_compat.h>
 #endif
 
@@ -411,19 +412,33 @@ int spi_mem_exec_op(struct spi_slave *slave, const struct spi_mem_op *op)
 	flag = SPI_XFER_BEGIN;
 	/* Make sure to set END bit if no tx or rx data messages follow */
 	if (!tx_buf && !rx_buf)
-		flag |= SPI_XFER_END;
+		flag |= (SPI_XFER_END | SPI_XFER_CMD_DATA);
 
 	ret = spi_xfer(slave, op_len * 8, op_buf, NULL, flag);
 	if (ret)
 		return ret;
 
 	/* 2nd transfer: rx or tx data path */
-	if (tx_buf || rx_buf) {
+	if (!tx_buf || rx_buf) {
 		ret = spi_xfer(slave, op->data.nbytes * 8, tx_buf,
-			       rx_buf, SPI_XFER_END);
-		if (ret)
-			return ret;
+			       rx_buf, SPI_XFER_END | SPI_XFER_CMD_DATA);
+	} else if (tx_buf || !rx_buf) {
+		/* if it's not PP cmd */
+		if (op->cmd.opcode == SPINOR_OP_PP ||
+		    op->cmd.opcode == SPINOR_OP_PP_1_1_4 ||
+		    op->cmd.opcode == SPINOR_OP_PP_1_4_4 ||
+		    op->cmd.opcode == SPINOR_OP_PP_4B ||
+		    op->cmd.opcode == SPINOR_OP_PP_1_1_4_4B ||
+		    op->cmd.opcode == SPINOR_OP_PP_1_4_4_4B) {
+			ret = spi_xfer(slave, op->data.nbytes * 8, tx_buf,
+				       rx_buf, SPI_XFER_END | SPI_XFER_USER_DATA);
+		} else { /* if it's not PP cmd */
+			ret = spi_xfer(slave, op->data.nbytes * 8, tx_buf,
+				       rx_buf, SPI_XFER_END);
+		}
 	}
+	if (ret)
+		return ret;
 
 	spi_release_bus(slave);
 
diff --git a/drivers/spi/spi-uclass.c b/drivers/spi/spi-uclass.c
index d867b2780..d545a4b72 100644
--- a/drivers/spi/spi-uclass.c
+++ b/drivers/spi/spi-uclass.c
@@ -30,7 +30,7 @@ static int spi_set_speed_mode(struct udevice *bus, int speed, int mode)
 
 	ops = spi_get_ops(bus);
 	if (ops->set_speed)
-		ret = ops->set_speed(bus, speed);
+		ret = ops->set_speed(bus, (unsigned int)speed);
 	else
 		ret = -EINVAL;
 	if (ret) {
@@ -39,7 +39,7 @@ static int spi_set_speed_mode(struct udevice *bus, int speed, int mode)
 	}
 
 	if (ops->set_mode)
-		ret = ops->set_mode(bus, mode);
+		ret = ops->set_mode(bus, (unsigned int)mode);
 	else
 		ret = -EINVAL;
 	if (ret) {
diff --git a/drivers/usb/gadget/config.c b/drivers/usb/gadget/config.c
index e96782644..0122b6316 100644
--- a/drivers/usb/gadget/config.c
+++ b/drivers/usb/gadget/config.c
@@ -28,7 +28,7 @@
  * negative error code if they can't all be copied.  Useful when
  * assembling descriptors for an associated set of interfaces used
  * as part of configuring a composite device; or in other cases where
- * sets of descriptors need to be marshaled.
+ * sets of descriptors need to be cv181xhaled.
  */
 int
 usb_descriptor_fillbuf(void *buf, unsigned buflen,
diff --git a/drivers/video/cvitek/Kconfig b/drivers/video/cvitek/Kconfig
new file mode 100644
index 000000000..4d55c2678
--- /dev/null
+++ b/drivers/video/cvitek/Kconfig
@@ -0,0 +1,69 @@
+#
+# Video drivers selection for cvitek soc.
+#
+
+menuconfig VIDEO_CVITEK
+	bool "Enable Cvitek Video Support"
+	depends on DM_VIDEO || BOOTLOGO
+	default y if DM_VIDEO || BOOTLOGO
+	help
+	  Cvitek SoCs provide video output capabilities for Low-voltage
+	  Differential Signalling (LVDS), and Display Serial Interface (DSI).
+
+	  This driver supports the on-chip video output device, and targets the
+	  Cvitek CV1835.
+
+config VIDEO_CVITEK_MAX_XRES
+        int "Maximum horizontal resolution (for memory allocation purposes)"
+	depends on VIDEO_CVITEK
+	default 1920
+	help
+	  The maximum horizontal resolution to support for the framebuffer.
+	  This configuration is used for reserving/allocating memory for the
+	  framebuffer during device-model binding/probing.
+
+config VIDEO_CVITEK_MAX_YRES
+        int "Maximum vertical resolution (for memory allocation purposes)"
+	depends on VIDEO_CVITEK
+	default 1080
+	help
+	  The maximum vertical resolution to support for the framebuffer.
+	  This configuration is used for reserving/allocating memory for the
+	  framebuffer during device-model binding/probing.
+
+if VIDEO_CVITEK
+
+choice
+	prompt "Display port selection"
+	default DISPLAY_CVITEK_MIPI
+	depends on VIDEO_CVITEK
+	help
+	  Select one kind of display port.
+
+config DISPLAY_CVITEK_LVDS
+	bool "LVDS Port"
+	help
+	  This enables Low-voltage Differential Signaling(LVDS) display support.
+	  LVDS is a high-speed, long-distance digital interface for serial
+	  communication (sending one bit at time) over two copper wires
+	  (differential) that are placed at 180 degrees from each other.
+
+config DISPLAY_CVITEK_I80
+	bool "I80 Port"
+	help
+	  This enables Intel 8080(I80) display support.
+	  Intel 8080 (I80) is one kind of the most common LCD MPU parallel
+	  interfaces, LCD controller signals are divided into two types:
+	  data signals and control signals.
+
+config DISPLAY_CVITEK_MIPI
+	bool "DSI Port"
+	help
+	  This enables Display Serial Interface(DSI) display support.
+	  The MIPI Display Serial Interface (MIPI DSI) defines a
+	  high-speed serial interface between a host processor and
+	  a display module.
+
+endchoice
+
+endif
diff --git a/drivers/video/cvitek/Makefile b/drivers/video/cvitek/Makefile
new file mode 100644
index 000000000..f43b4e435
--- /dev/null
+++ b/drivers/video/cvitek/Makefile
@@ -0,0 +1,11 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_VIDEO_CVITEK
+obj-y += cvi_disp.o cvi_mipi.o scaler.o reg.o vip_sys.o dsi_phy.o cvi_i80.o
+obj-$(CONFIG_DISPLAY_CVITEK_LVDS) += cvi_lvds.o
+endif
diff --git a/drivers/video/cvitek/cvi_disp.c b/drivers/video/cvitek/cvi_disp.c
new file mode 100644
index 000000000..aa7d9b395
--- /dev/null
+++ b/drivers/video/cvitek/cvi_disp.c
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <display.h>
+#include <dm.h>
+#include <regmap.h>
+#include <video.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <dt-structs.h>
+#include <asm/gpio.h>
+
+#include "vip_common.h"
+#include "scaler.h"
+#include "dsi_phy.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct cvi_vo_priv {
+	phys_addr_t regs_sc;
+	phys_addr_t regs_vip;
+	phys_addr_t regs_dphy;
+	struct disp_ctrl_gpios ctrl_gpios;
+};
+
+static int cvi_vo_bind(struct udevice *dev)
+{
+	struct video_uc_platdata *plat = dev_get_uclass_platdata(dev);
+
+	plat->size = 4 * (CONFIG_VIDEO_CVITEK_MAX_XRES *
+			  CONFIG_VIDEO_CVITEK_MAX_YRES);
+
+	return 0;
+}
+
+static int cvi_vo_ofdata_to_platdata(struct udevice *dev)
+{
+	struct cvi_vo_priv *priv = dev_get_priv(dev);
+
+	priv->regs_sc = devfdt_get_addr_name(dev, "sc");
+	if (priv->regs_sc == FDT_ADDR_T_NONE) {
+		debug("%s: Get VO sc address failed (ret=%llu)\n", __func__, (u64)priv->regs_sc);
+		return -ENXIO;
+	}
+	priv->regs_vip = devfdt_get_addr_name(dev, "vip_sys");
+	if (priv->regs_vip == FDT_ADDR_T_NONE) {
+		debug("%s: Get dsi address failed (ret=%llu)\n", __func__, (u64)priv->regs_vip);
+		return -ENXIO;
+	}
+	priv->regs_dphy = devfdt_get_addr_name(dev, "dphy");
+	if (priv->regs_dphy == FDT_ADDR_T_NONE) {
+		debug("%s: Get MIPI dsi address failed (ret=%llu)\n", __func__, (u64)priv->regs_dphy);
+		return -ENXIO;
+	}
+	debug("%s: base(sc)=%#llx base(vip)=%#llx base(dphy)=%#llx\n", __func__
+	     , priv->regs_sc, priv->regs_vip, priv->regs_dphy);
+	return 0;
+}
+
+static int cvi_vo_probe(struct udevice *dev)
+{
+	//struct video_uc_platdata *plat = dev_get_uclass_platdata(dev);
+	//const void *blob = gd->fdt_blob;
+	struct cvi_vo_priv *priv = dev_get_priv(dev);
+	int ret = 0;
+
+	debug("%s: start\n", __func__);
+
+	/* Before relocation we don't need to do anything */
+	if (!(gd->flags & GD_FLG_RELOC))
+		return 0;
+
+	sclr_set_base_addr((void *)priv->regs_sc);
+	vip_set_base_addr((void *)priv->regs_vip);
+	dphy_set_base_addr((void *)priv->regs_dphy);
+
+#ifdef BOOTLOGO_ISP_RESET
+	vip_isp_clk_reset();
+#endif
+	sclr_ctrl_init();
+	sclr_ctrl_set_disp_src(false);
+
+	ret = gpio_request_by_name(dev, "reset-gpio", 0, &priv->ctrl_gpios.disp_reset_gpio,
+				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	if (ret) {
+		debug("%s: Warning: cannot get enable GPIO: ret=%d\n", __func__, ret);
+		if (ret != -ENOENT)
+			return ret;
+	}
+	ret = gpio_request_by_name(dev, "pwm-gpio", 0, &priv->ctrl_gpios.disp_pwm_gpio,
+				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	if (ret) {
+		debug("%s: Warning: cannot get enable GPIO: ret=%d\n", __func__, ret);
+		if (ret != -ENOENT)
+			return ret;
+	}
+	ret = gpio_request_by_name(dev, "power-ct-gpio", 0, &priv->ctrl_gpios.disp_power_ct_gpio,
+				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	if (ret) {
+		debug("%s: Warning: cannot get enable GPIO: ret=%d\n", __func__, ret);
+		if (ret != -ENOENT)
+			return ret;
+	}
+	set_disp_ctrl_gpios(&priv->ctrl_gpios);
+
+	video_set_flush_dcache(dev, 1);
+
+	return ret;
+}
+
+static const struct udevice_id cvi_vo_ids[] = {
+	{ .compatible = "cvitek,vo" },
+	{ }
+};
+
+static const struct video_ops cvi_vo_ops = {
+};
+
+U_BOOT_DRIVER(cvi_vo) = {
+	.name	= "cvi_vo",
+	.id	= UCLASS_VIDEO,
+	.of_match = cvi_vo_ids,
+	.ops	= &cvi_vo_ops,
+	.bind	= cvi_vo_bind,
+	.probe	= cvi_vo_probe,
+	.ofdata_to_platdata	= cvi_vo_ofdata_to_platdata,
+	.priv_auto_alloc_size = sizeof(struct cvi_vo_priv),
+};
diff --git a/drivers/video/cvitek/cvi_i80.c b/drivers/video/cvitek/cvi_i80.c
new file mode 100644
index 000000000..532d8cb6e
--- /dev/null
+++ b/drivers/video/cvitek/cvi_i80.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <asm/gpio.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include "reg.h"
+#include "vip_common.h"
+#include "scaler.h"
+#include "cvi_i80.h"
+#include "dsi_phy.h"
+
+unsigned char i80_ctrl[I80_CTRL_MAX] = { 0x31, 0x75, 0xff };
+
+unsigned int _MAKECOLOR(unsigned char r, unsigned char g, unsigned char b, enum _VO_I80_FORMAT fmt)
+{
+	unsigned char r1, g1, b1;
+	unsigned char r_len, g_len, b_len;
+
+	switch (fmt) {
+	case VO_I80_FORMAT_RGB444:
+		r_len = 4;
+		g_len = 4;
+		b_len = 4;
+		break;
+
+	default:
+	case VO_I80_FORMAT_RGB565:
+		r_len = 5;
+		g_len = 6;
+		b_len = 5;
+		break;
+
+	case VO_I80_FORMAT_RGB666:
+		r_len = 6;
+		g_len = 6;
+		b_len = 6;
+		break;
+	}
+
+	r1 = r >> (8 - r_len);
+	g1 = g >> (8 - g_len);
+	b1 = b >> (8 - b_len);
+	return (b1 | (g1 << b_len) | (r1 << (b_len + g_len)));
+}
+
+#if 1
+/* 90 rotation */
+void i80_package_frame(unsigned char *in, unsigned char *out, unsigned int stride, unsigned char byte_cnt,
+		       unsigned short w, unsigned short h)
+{
+	unsigned int out_offset = 0;
+	unsigned int pixel;
+	int x, y;
+	unsigned char (*b_in)[960];//BMP BGR888, 320x240x2
+	unsigned char (*b_out)[1472];
+
+	b_in = (void *)in;
+	b_out = (void *)out;
+
+	for (y = 0; y < h; ++y) {
+		out_offset = 0;
+		for (x = 0; x < w; ++x) {
+			//_get_frame_rgb(&in, stride, x, y, &r, &g, &b);
+			//pixel = _MAKECOLOR(r, g, b, VO_I80_FORMAT_RGB565);
+			pixel = _MAKECOLOR(b_in[w - 1 - x][y * byte_cnt + 2], b_in[w - 1 - x][y * byte_cnt + 1],
+					   b_in[w - 1 - x][y * byte_cnt], VO_I80_FORMAT_RGB565);
+			b_out[y][out_offset++] = pixel >> 8;
+			b_out[y][out_offset++] = i80_ctrl[I80_CTRL_DATA];
+			b_out[y][out_offset++] = I80_OP_GO;
+			b_out[y][out_offset++] = pixel & 0xFF;
+			b_out[y][out_offset++] = i80_ctrl[I80_CTRL_DATA];
+			b_out[y][out_offset++] = I80_OP_GO;
+		}
+		b_out[y][w * byte_cnt * 2 + 0] = 0xff;
+		b_out[y][w * byte_cnt * 2 + 1] = i80_ctrl[I80_CTRL_EOF];
+		b_out[y][w * byte_cnt * 2 + 2] = I80_OP_GO;
+	}
+	b_out[h - 1][w * byte_cnt * 2 + 0] = 0x00;
+	b_out[h - 1][w * byte_cnt * 2 + 1] = i80_ctrl[I80_CTRL_EOF];
+	b_out[h - 1][w * byte_cnt * 2 + 2] = I80_OP_DONE;
+}
+#else
+static void _i80_package_eol(unsigned char buffer[3])
+{
+	buffer[0] = 0xff;
+	buffer[1] = i80_ctrl[I80_CTRL_EOF];
+	buffer[2] = I80_OP_GO;
+}
+
+static void _i80_package_eof(unsigned char buffer[3])
+{
+	buffer[0] = 0x00;
+	buffer[1] = i80_ctrl[I80_CTRL_EOF];
+	buffer[2] = I80_OP_DONE;
+}
+
+static void _i80_package_rgb(unsigned char r, unsigned char g, unsigned char b,
+			     unsigned char *buffer, unsigned char byte_cnt)
+{
+	unsigned int pixel;
+
+	pixel = _MAKECOLOR(r, g, b, VO_I80_FORMAT_RGB565);
+
+	for (unsigned char i = 0, offset = 0; i < byte_cnt; ++i) {
+		*(buffer + offset++) = pixel >> ((byte_cnt - i - 1) << 3);
+		*(buffer + offset++) = i80_ctrl[I80_CTRL_DATA];
+		*(buffer + offset++) = I80_OP_GO;
+	}
+}
+
+static void _get_frame_rgb(unsigned char **buf, unsigned int stride, unsigned short x, unsigned short y,
+			   unsigned char *r, unsigned char *g, unsigned char *b)
+{
+	unsigned int offset = 3 * x + stride * y;
+	//bgr
+	*b = *(buf[0] + offset);
+	*g = *(buf[0] + offset + 1);
+	*r = *(buf[0] + offset + 2);
+}
+
+void i80_package_frame(unsigned char *in, unsigned char *out, unsigned int stride, unsigned char byte_cnt,
+		       unsigned short w, unsigned short h)
+{
+	unsigned int out_offset = 0;
+	unsigned short line_data = (1 + w * byte_cnt) * 3;
+	unsigned short padding = ALIGN(line_data, 32) - line_data;
+	unsigned char r, g, b;
+
+	for (int y = (h - 1); y >= 0; --y) {
+		for (int x = 0; x < w; ++x) {
+			_get_frame_rgb(&in, stride, x, y, &r, &g, &b);
+			_i80_package_rgb(r, g, b, out + out_offset, byte_cnt);
+			out_offset += byte_cnt * 3;
+		}
+		_i80_package_eol(out + out_offset);
+		out_offset += 3;
+		memset(out + out_offset, 0, padding);
+		out_offset += padding;
+	}
+	// replace last eol with eof
+	_i80_package_eof(out + out_offset - 3 - padding);
+}
+#endif
+
+static void _fill_disp_timing(struct sclr_disp_timing *timing, const struct sync_info_s *sync_info)
+{
+	timing->vtotal = sync_info->vid_vsa_lines + sync_info->vid_vbp_lines
+			 + sync_info->vid_active_lines + sync_info->vid_vfp_lines;
+	timing->htotal = sync_info->vid_hsa_pixels + sync_info->vid_hbp_pixels
+			 + sync_info->vid_hline_pixels + sync_info->vid_hfp_pixels;
+	timing->vsync_start = 1;
+	timing->vsync_end = timing->vsync_start + sync_info->vid_vsa_lines;
+	timing->vfde_start = timing->vsync_end + sync_info->vid_vbp_lines;
+	timing->vfde_end = timing->vfde_start + sync_info->vid_active_lines - 1;
+	timing->hsync_start = 1;
+	timing->hsync_end = timing->hsync_start + sync_info->vid_hsa_pixels;
+	timing->hfde_start = timing->hsync_end + sync_info->vid_hbp_pixels;
+	timing->hfde_end = timing->hfde_start + sync_info->vid_hline_pixels - 1;
+	timing->vsync_pol = sync_info->vid_vsa_pos_polarity;
+	timing->hsync_pol = sync_info->vid_hsa_pos_polarity;
+
+	timing->vmde_start = timing->vfde_start;
+	timing->vmde_end = timing->vfde_end;
+	timing->hmde_start = timing->hfde_start;
+	timing->hmde_end = timing->hfde_end;
+}
+
+int i80_set_combo_dev_cfg(const struct _VO_I80_CFG_S *i80_cfg)
+{
+	int ret;
+	unsigned int clkkHz;
+
+	union sclr_bt_enc enc;
+	union sclr_bt_sync_code sync;
+	struct sclr_disp_timing timing;
+
+	_fill_disp_timing(&timing, &i80_cfg->sync_info);
+	sclr_disp_set_intf(SCLR_VO_INTF_I80);
+	enc.raw = 0;
+	enc.b.fmt_sel = 2;
+	enc.b.clk_inv = 1;
+	sync.raw = 0;
+	sync.b.sav_vld = 0x80;
+	sync.b.sav_blk = 0xab;
+	sync.b.eav_vld = 0x9d;
+	sync.b.eav_blk = 0xb6;
+	sclr_bt_set(enc, sync);
+
+	i80_ctrl[I80_CTRL_CMD] = BIT(i80_cfg->lane_s.RD) | ((BIT(i80_cfg->lane_s.RD) | BIT(i80_cfg->lane_s.WR)) << 4);
+	i80_ctrl[I80_CTRL_DATA] = (BIT(i80_cfg->lane_s.RD) | BIT(i80_cfg->lane_s.RS)) |
+				  ((BIT(i80_cfg->lane_s.RD) | BIT(i80_cfg->lane_s.WR) | BIT(i80_cfg->lane_s.RS)) << 4);
+	i80_ctrl[I80_CTRL_EOF] = 0xff;
+
+	clkkHz = 1000000 / (i80_cfg->cycle_time / 2);
+	if (clkkHz < 8000) {
+		debug("i80 disp set clk less than 8000 kHz.\n");
+		return -EINVAL;
+	}
+	dphy_dsi_set_pll(clkkHz, 4, 24);
+	sclr_disp_set_timing(&timing);
+	sclr_disp_tgen_enable(false);
+
+	//#if defined(CONFIG_BOARD_ZAM180)
+	_reg_write_mask(0x03021004, 0x1000010, 0x1000010); //backlight & reset
+	_reg_write_mask(0x03021000, 0x1000010, 0x1000010);
+	//#endif
+
+	return ret;
+}
+
+void i80_set_sw_mode(unsigned long mode_flags)
+{
+	if (mode_flags)
+		sclr_i80_sw_mode(SCLR_I80_MODE_SW);
+	else
+		sclr_i80_sw_mode(SCLR_I80_MODE_IDLE);
+}
+
+int i80_set_cmd(unsigned int cmd)
+{
+	int ret = 0;
+
+	sclr_i80_packet(cmd);
+
+	return ret;
+}
+
+int i80_set_run(void)
+{
+	int ret = 0;
+
+	sclr_i80_run();
+
+	return ret;
+}
+
+void i80_sclr_intr_clr(void)
+{
+	sclr_intr_clr(sclr_intr_status());
+}
+
diff --git a/drivers/video/cvitek/cvi_lvds.c b/drivers/video/cvitek/cvi_lvds.c
new file mode 100644
index 000000000..4dbf6e3e4
--- /dev/null
+++ b/drivers/video/cvitek/cvi_lvds.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <display.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <panel.h>
+#include <regmap.h>
+#include <syscon.h>
+#include <asm/gpio.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <dm/uclass-internal.h>
+#include <linux/kernel.h>
+
+#include "vip_common.h"
+#include "scaler.h"
+#include "dsi_phy.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define MHz 1000000
+
+/*
+ * Private information for cvi lvds
+ *
+ * @regs: lvds controller address
+ * @panel: panel assined by device tree
+ * @ref_clk: reference clock for lvds dsi pll
+ * @sysclk: config clock for lvds dsi register
+ * @pix_clk: pixel clock for vop->dsi data transmission
+ * @phy_clk: lvds dphy output clock
+ * @txbyte_clk: clock for dsi->dphy high speed data transmission
+ * @txesc_clk: clock for tx esc mode
+ */
+struct cvi_lvds_priv {
+	struct udevice *panel;
+	u32 ref_clk;
+	u32 sys_clk;
+	u32 pix_clk;
+	u32 phy_clk;
+	u32 txbyte_clk;
+	u32 txesc_clk;
+};
+
+static int cvi_lvds_read_timing(struct udevice *dev, struct display_timing *timing)
+{
+	int ret;
+
+	ret = fdtdec_decode_display_timing(gd->fdt_blob, dev_of_offset(dev), 0, timing);
+	if (ret) {
+		debug("%s: Failed to decode display timing (ret=%d)\n",
+		      __func__, ret);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * This function is called by cvi_display_init() using cvi_lvds_enable() and
+ * cvi_lvds_phy_enable() to initialize lvds controller and dphy. If success,
+ * enable backlight.
+ */
+static int cvi_lvds_enable(struct udevice *dev, int panel_bpp, const struct display_timing *timing)
+{
+	int ret = 0;
+	struct cvi_lvds_priv *priv = dev_get_priv(dev);
+
+	/* Fill the lvds controller parameter */
+	priv->ref_clk = 24 * MHz;
+	priv->sys_clk = priv->ref_clk;
+	priv->pix_clk = timing->pixelclock.typ;
+	priv->phy_clk = priv->pix_clk * 6;
+	priv->txbyte_clk = priv->phy_clk / 8;
+	priv->txesc_clk = 20 * MHz;
+
+#if 0
+	/* Config  and enable lvds dsi according to timing */
+	ret = rk_lvds_enable(dev, timing);
+	if (ret) {
+		debug("%s: rk_lvds_enable() failed (err=%d)\n",
+		      __func__, ret);
+		return ret;
+	}
+
+	/* Config and enable lvds phy */
+	ret = rk_lvds_phy_enable(dev);
+	if (ret) {
+		debug("%s: rk_lvds_phy_enable() failed (err=%d)\n",
+		      __func__, ret);
+		return ret;
+	}
+
+	/* Enable backlight */
+	ret = panel_enable_backlight(priv->panel);
+	if (ret) {
+		debug("%s: panel_enable_backlight() failed (err=%d)\n",
+		      __func__, ret);
+		return ret;
+	}
+#endif
+
+	return ret;
+}
+
+static int cvi_lvds_ofdata_to_platdata(struct udevice *dev)
+{
+	struct cvi_lvds_priv *priv = dev_get_priv(dev);
+
+	priv = priv;
+
+#if 0
+	priv->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (priv->grf <= 0) {
+		debug("%s: Get syscon grf failed (ret=%llu)\n",
+		      __func__, (u64)priv->grf);
+		return  -ENXIO;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Probe function: check panel existence and readingit's timing. Then config
+ * lvds dsi controller and enable it according to the timing parameter.
+ */
+static int cvi_lvds_probe(struct udevice *dev)
+{
+	int ret = 0;
+	struct cvi_lvds_priv *priv = dev_get_priv(dev);
+
+	priv = priv;
+
+#if 0
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL, dev, "cvitek,panel",
+					   &priv->panel);
+	if (ret) {
+		debug("%s: Can not find panel (err=%d)\n", __func__, ret);
+		return ret;
+	}
+#endif
+
+	return ret;
+}
+
+static const struct dm_display_ops cvi_lvds_ops = {
+	.read_timing = cvi_lvds_read_timing,
+	.enable = cvi_lvds_enable,
+};
+
+static const struct udevice_id cvi_lvds_ids[] = {
+	{ .compatible = "cvitek,lvds" },
+	{ }
+};
+
+U_BOOT_DRIVER(cvi_lvds) = {
+	.name	= "cvi_lvds",
+	.id	= UCLASS_DISPLAY,
+	.of_match = cvi_lvds_ids,
+	.ofdata_to_platdata = cvi_lvds_ofdata_to_platdata,
+	.probe	= cvi_lvds_probe,
+	.ops	= &cvi_lvds_ops,
+	.priv_auto_alloc_size   = sizeof(struct cvi_lvds_priv),
+};
+
diff --git a/drivers/video/cvitek/cvi_mipi.c b/drivers/video/cvitek/cvi_mipi.c
new file mode 100644
index 000000000..f97e3af5e
--- /dev/null
+++ b/drivers/video/cvitek/cvi_mipi.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <asm/gpio.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <linux/stringify.h>
+
+#include "reg.h"
+#include "vip_common.h"
+#include "scaler.h"
+#include "dsi_phy.h"
+#include <cvi_mipi.h>
+
+/* cmd_mode: cmd_mode
+ * bit[0]: dcs cmd mode. 0(hw)/1(sw)
+ */
+static int cmd_mode = 1;
+
+static void _fill_disp_timing(struct sclr_disp_timing *timing, struct sync_info_s *sync_info)
+{
+	timing->vtotal = sync_info->vid_vsa_lines + sync_info->vid_vbp_lines
+			+ sync_info->vid_active_lines + sync_info->vid_vfp_lines - 1;
+	timing->htotal = sync_info->vid_hsa_pixels + sync_info->vid_hbp_pixels
+			+ sync_info->vid_hline_pixels + sync_info->vid_hfp_pixels - 1;
+	timing->vsync_start = 1;
+	timing->vsync_end = timing->vsync_start + sync_info->vid_vsa_lines - 1;
+	timing->vfde_start = timing->vsync_start + sync_info->vid_vsa_lines + sync_info->vid_vbp_lines;
+	timing->vfde_end = timing->vfde_start + sync_info->vid_active_lines - 1;
+	timing->hsync_start = 1;
+	timing->hsync_end = timing->hsync_start + sync_info->vid_hsa_pixels - 1;
+	timing->hfde_start = timing->hsync_start + sync_info->vid_hsa_pixels + sync_info->vid_hbp_pixels;
+	timing->hfde_end = timing->hfde_start + sync_info->vid_hline_pixels - 1;
+	timing->vsync_pol = sync_info->vid_vsa_pos_polarity;
+	timing->hsync_pol = sync_info->vid_hsa_pos_polarity;
+
+	timing->vmde_start = timing->vfde_start;
+	timing->vmde_end = timing->vfde_end;
+	timing->hmde_start = timing->hfde_start;
+	timing->hmde_end = timing->hfde_end;
+}
+
+static void _cal_htt_extra(struct combo_dev_cfg_s *dev_cfg, u8 lane_num, u8 bits)
+{
+	unsigned short htt_old, htt_new, htt_new_extra = 0;
+	unsigned short vtt;
+	float fps;
+	float bit_rate_MHz;
+	float clk_hs_MHz;
+	float clk_hs_ns;
+	float line_rate_KHz, line_time_us;
+	float over_head;
+	float t_period_max, t_period_real;
+	struct sync_info_s *sync_info = &dev_cfg->sync_info;
+
+	htt_old = sync_info->vid_hsa_pixels + sync_info->vid_hbp_pixels
+			+ sync_info->vid_hline_pixels + sync_info->vid_hfp_pixels;
+	vtt = sync_info->vid_vsa_lines + sync_info->vid_vbp_lines
+			+ sync_info->vid_active_lines + sync_info->vid_vfp_lines;
+	fps = dev_cfg->pixel_clk * 1000.0 / (htt_old * vtt);
+	bit_rate_MHz = dev_cfg->pixel_clk / 1000.0 * bits / lane_num;
+	clk_hs_MHz = bit_rate_MHz / 2;
+	clk_hs_ns = 1000 / clk_hs_MHz;
+	line_rate_KHz = vtt * fps / 1000;
+	line_time_us = 1000 / line_rate_KHz;
+	over_head = (3 * 50 * 2 * 3) + clk_hs_ns * 360;
+	t_period_max = line_time_us * 1000 - over_head;
+	t_period_real = clk_hs_ns * sync_info->vid_hline_pixels * bits / 4 / 2;
+	htt_new = (unsigned short)(htt_old * t_period_real / t_period_max);
+	if (htt_new > htt_old) {
+		if (htt_new & 0x0003)
+			htt_new += (4 - (htt_new & 0x0003));
+		htt_new_extra = htt_new - htt_old;
+		sync_info->vid_hfp_pixels += htt_new_extra;
+		dev_cfg->pixel_clk = htt_new * vtt * fps / 1000;
+	}
+}
+
+int mipi_tx_set_combo_dev_cfg(const struct combo_dev_cfg_s *dev_cfg)
+{
+	int ret, i;
+	bool data_en[LANE_MAX_NUM] = {false, false, false, false, false};
+	u8 lane_num = 0;
+	struct sclr_disp_timing timing;
+	enum sclr_dsi_fmt dsi_fmt;
+	u8 bits;
+	bool preamble_on = false;
+	struct combo_dev_cfg_s dev_cfg_t = *dev_cfg;
+	struct disp_ctrl_gpios ctrl_gpios;
+
+	sclr_disp_set_intf(SCLR_VO_INTF_MIPI);
+
+	for (i = 0; i < LANE_MAX_NUM; i++) {
+		if ((dev_cfg_t.lane_id[i] < 0) || (dev_cfg_t.lane_id[i] >= MIPI_TX_LANE_MAX)) {
+			data_en[i] = false;
+			continue;
+		}
+		dphy_dsi_set_lane(i, dev_cfg_t.lane_id[i], dev_cfg_t.lane_pn_swap[i]);
+		if (dev_cfg_t.lane_id[i] != MIPI_TX_LANE_CLK) {
+			++lane_num;
+			data_en[dev_cfg_t.lane_id[i] - 1] = true;
+		}
+	}
+	if (lane_num == 0) {
+		debug("%s: no active mipi-dsi lane\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (dev_cfg_t.output_format) {
+	case OUT_FORMAT_RGB_16_BIT:
+		bits = 16;
+		dsi_fmt = SCLR_DSI_FMT_RGB565;
+	break;
+
+	case OUT_FORMAT_RGB_18_BIT:
+		bits = 18;
+		dsi_fmt = SCLR_DSI_FMT_RGB666;
+	break;
+
+	case OUT_FORMAT_RGB_24_BIT:
+		bits = 24;
+		dsi_fmt = SCLR_DSI_FMT_RGB888;
+	break;
+
+	case OUT_FORMAT_RGB_30_BIT:
+		bits = 30;
+		dsi_fmt = SCLR_DSI_FMT_RGB101010;
+	break;
+
+	default:
+	return -EINVAL;
+	}
+	_cal_htt_extra(&dev_cfg_t, lane_num, bits);
+	_fill_disp_timing(&timing, &dev_cfg_t.sync_info);
+	preamble_on = (dev_cfg_t.pixel_clk * bits / lane_num) > 1500000;
+	dphy_dsi_lane_en(true, data_en, preamble_on);
+	dphy_dsi_set_pll(dev_cfg_t.pixel_clk, lane_num, bits);
+	sclr_dsi_config(lane_num, dsi_fmt, dev_cfg_t.sync_info.vid_hline_pixels);
+	sclr_disp_set_timing(&timing);
+	sclr_disp_tgen_enable(true);
+
+	get_disp_ctrl_gpios(&ctrl_gpios);
+
+	ret = dm_gpio_set_value(&ctrl_gpios.disp_power_ct_gpio,
+				ctrl_gpios.disp_power_ct_gpio.flags & GPIOD_ACTIVE_LOW ? 0 : 1);
+	if (ret < 0) {
+		error("dm_gpio_set_value(disp_power_ct_gpio, deassert) failed: %d", ret);
+		return ret;
+	}
+	ret = dm_gpio_set_value(&ctrl_gpios.disp_pwm_gpio,
+				ctrl_gpios.disp_pwm_gpio.flags & GPIOD_ACTIVE_LOW ? 0 : 1);
+	if (ret < 0) {
+		error("dm_gpio_set_value(disp_pwm_gpio, deassert) failed: %d", ret);
+		return ret;
+	}
+	ret = dm_gpio_set_value(&ctrl_gpios.disp_reset_gpio,
+				ctrl_gpios.disp_reset_gpio.flags & GPIOD_ACTIVE_LOW ? 0 : 1);
+	if (ret < 0) {
+		error("dm_gpio_set_value(disp_reset_gpio, deassert) failed: %d", ret);
+		return ret;
+	}
+	mdelay(10);
+	ret = dm_gpio_set_value(&ctrl_gpios.disp_reset_gpio,
+				ctrl_gpios.disp_reset_gpio.flags & GPIOD_ACTIVE_LOW ? 1 : 0);
+	if (ret < 0) {
+		error("dm_gpio_set_value(disp_reset_gpio, deassert) failed: %d", ret);
+		return ret;
+	}
+	mdelay(10);
+	ret = dm_gpio_set_value(&ctrl_gpios.disp_reset_gpio,
+				ctrl_gpios.disp_reset_gpio.flags & GPIOD_ACTIVE_LOW ? 0 : 1);
+	if (ret < 0) {
+		error("dm_gpio_set_value(disp_reset_gpio, deassert) failed: %d", ret);
+		return ret;
+	}
+	mdelay(100);
+
+	return ret;
+}
+
+int mipi_tx_set_cmd(struct cmd_info_s *cmd_info)
+{
+	if (cmd_info->cmd_size > CMD_MAX_NUM) {
+		debug("cmd_size(%d) can't exceed %d!\n", cmd_info->cmd_size, CMD_MAX_NUM);
+		return -EINVAL;
+	} else if ((cmd_info->cmd_size != 0) && !cmd_info->cmd) {
+		debug("cmd is NULL, but cmd_size(%d) isn't zero!\n", cmd_info->cmd_size);
+		return -EINVAL;
+	}
+
+#if 0
+	if (cmd_info->cmd_size > 2)
+		pr_info("%s: %#x %#x %#x %#x\n", __func__, cmd_info->cmd[0], cmd_info->cmd[1]
+			, cmd_info->cmd[2], cmd_info->cmd[3]);
+	else
+		pr_info("%s: %#x %#x\n", __func__, cmd_info->cmd[0], cmd_info->cmd[1]);
+#endif
+
+	return sclr_dsi_dcs_write_buffer(cmd_info->data_type, cmd_info->cmd, cmd_info->cmd_size, cmd_mode & 0x01);
+}
+
+int mipi_tx_get_cmd(struct get_cmd_info_s *get_cmd_info)
+{
+	if (get_cmd_info->get_data_size > RX_MAX_NUM) {
+		debug("get_data_size(%d) can't exceed %d!\n", get_cmd_info->get_data_size, RX_MAX_NUM);
+		return -EINVAL;
+	} else if ((get_cmd_info->get_data_size != 0) && (!get_cmd_info->get_data)) {
+		debug("cmd is NULL, but cmd_size(%d) isn't zero!\n", get_cmd_info->get_data_size);
+		return -EINVAL;
+	}
+
+	return sclr_dsi_dcs_read_buffer(get_cmd_info->data_type, get_cmd_info->data_param
+		, get_cmd_info->get_data, get_cmd_info->get_data_size, cmd_mode & 0x01);
+}
+
+void mipi_tx_set_mode(unsigned long mode_flags)
+{
+	if (mode_flags)
+		sclr_dsi_set_mode(SCLR_DSI_MODE_HS);
+	else
+		sclr_dsi_set_mode(SCLR_DSI_MODE_IDLE);
+}
diff --git a/drivers/video/cvitek/dsi_phy.c b/drivers/video/cvitek/dsi_phy.c
new file mode 100644
index 000000000..5b676486d
--- /dev/null
+++ b/drivers/video/cvitek/dsi_phy.c
@@ -0,0 +1,244 @@
+#include <common.h>
+#include <stdbool.h>
+#include <errno.h>
+
+#include "vip_common.h"
+#include "scaler_reg.h"
+#include "reg.h"
+#include "dsi_phy.h"
+
+/****************************************************************************
+ * Global parameters
+ ****************************************************************************/
+static uintptr_t reg_base;
+static u8 data_0_lane;
+static bool data_0_pn_swap;
+
+/****************************************************************************
+ * Interfaces
+ ****************************************************************************/
+void dphy_set_base_addr(void *base)
+{
+	reg_base = (uintptr_t)base;
+}
+
+/**
+ * dphy_dsi_lane_en - set dsi-lanes enable control.
+ *                    setup before dphy_dsi_init().
+ *
+ * @param clk_en: clk lane enable
+ * @param data_en: data lane[0-3] enable
+ * @param preamble_en: preeamble enable
+ */
+void dphy_dsi_lane_en(bool clk_en, bool *data_en, bool preamble_en)
+{
+	u8 val = 0, i = 0;
+
+	val |= clk_en;
+	for (i = 0; i < 4; ++i)
+		val |= (data_en[i] << (i + 1));
+	if (preamble_en)
+		val |= 0x20;
+	_reg_write_mask(reg_base + REG_DSI_PHY_EN, 0x3f, val);
+}
+
+/**
+ * dphy_dsi_set_lane - dsi-lanes control.
+ *                     setup before dphy_dsi_lane_en().
+ *
+ * @param lane_num: lane[0-4].
+ * @param lane: the role of this lane.
+ * @param pn_swap: if this lane positive/negative swap.
+ * @return: 0 for success.
+ */
+int dphy_dsi_set_lane(u8 lane_num, enum lane_id lane, bool pn_swap)
+{
+	if ((lane_num > 4) || (lane > DSI_LANE_MAX))
+		return -1;
+
+	_reg_write_mask(reg_base + REG_DSI_PHY_LANE_SEL, 0x7 << (4 * lane_num), lane << (4 * lane_num));
+	_reg_write_mask(reg_base + REG_DSI_PHY_LANE_PN_SWAP, BIT(lane_num), pn_swap << lane_num);
+
+	if (lane == DSI_LANE_CLK)
+		_reg_write_mask(reg_base + REG_DSI_PHY_LANE_SEL, 0x1f << 24, (1 << 24) << lane_num);
+	if (lane == DSI_LANE_0) {
+		data_0_lane = lane_num;
+		data_0_pn_swap = pn_swap;
+	}
+	return 0;
+}
+
+void dphy_lvds_enable(bool en)
+{
+	_reg_write(reg_base + REG_DSI_PHY_LVDS_EN, en);
+}
+
+/**
+ * dphy_dsi_init - dphy init.
+ *                 Invoked after dphy_dsi_set_lane() and dphy_dsi_lane_en().
+ *
+ */
+void dphy_init(enum sclr_vo_intf intf)
+{
+	_reg_write(reg_base + REG_DSI_PHY_PD, (intf == SCLR_VO_INTF_MIPI || intf == SCLR_VO_INTF_LVDS
+		) ? 0x0 : 0x1f1f);
+	_reg_write(reg_base + REG_DSI_PHY_ESC_INIT, 0x100);
+	_reg_write(reg_base + REG_DSI_PHY_ESC_WAKE, 0x100);
+
+	if ((intf == SCLR_VO_INTF_BT656) || (intf == SCLR_VO_INTF_BT1120) || (intf == SCLR_VO_INTF_I80))
+		_reg_write(reg_base + REG_DSI_PHY_EXT_GPIO, 0x000fffff);
+	else
+		_reg_write(reg_base + REG_DSI_PHY_EXT_GPIO, 0x0);
+
+	_reg_write(reg_base + REG_DSI_PHY_LVDS_EN, (intf == SCLR_VO_INTF_LVDS));
+}
+
+int ilog2(int x)
+{
+	/*
+	 * Find the leftmost 1. Use a method that is similar to
+	 * binary search.
+	 */
+	int result = 0;
+
+	result = (!!(x >> 16)) << 4; // if > 16?
+	// based on previous result, if > (result + 8)
+	result = result + ((!!(x >> (result + 8))) << 3);
+	result = result + ((!!(x >> (result + 4))) << 2);
+	result = result + ((!!(x >> (result + 2))) << 1);
+	result = result + (!!(x >> (result + 1)));
+	return result;
+}
+
+void _cal_pll_reg(u32 clkkHz, u32 VCOR_10000, u32 *reg_txpll, u32 *reg_set)
+{
+	u8 gain = 1 << ilog2(max((u32)1, (u32)(25000000UL / VCOR_10000)));
+	u32 VCOC_1000 = VCOR_10000 * gain / 10;
+	u8 reg_disp_div_sel = VCOC_1000 / clkkHz;
+	u8 dig_dig = ilog2(gain);
+	u8 reg_divout_sel = min((u8)3, dig_dig);
+	u8 reg_div_sel = dig_dig - reg_divout_sel;
+	u8 loop_gain = (((VCOC_1000 / 266000) + 7) >> 3) << 3;
+	*reg_set = ((u64)(1200000 * loop_gain) << 26) / VCOC_1000;
+
+	*reg_txpll = (reg_div_sel << 10) | (reg_divout_sel << 8) | reg_disp_div_sel;
+
+#if 0
+	pr_info("clkkHz(%d) VCORx10000(%d) gain(%d)\n", clkkHz, VCOR_10000, gain);
+	pr_info("VCOCx1000(%d) dig_dig(%d) loop_gain(%d)\n", VCOC_1000, dig_dig, loop_gain);
+	pr_info("regs: disp_div_sel(%d), divout_sel(%d), set(%#x)\n", reg_disp_div_sel, reg_divout_sel, *reg_set);
+#endif
+}
+
+void dphy_lvds_set_pll(u32 clkkHz, u8 link)
+{
+	u32 VCOR_10000 = clkkHz * 70 / link;
+	u32 reg_txpll, reg_set;
+
+	_cal_pll_reg(clkkHz, VCOR_10000, &reg_txpll, &reg_set);
+
+	_reg_write_mask(reg_base + REG_DSI_PHY_TXPLL, 0x7ff, reg_txpll);
+	_reg_write(reg_base + REG_DSI_PHY_REG_SET, reg_set);
+}
+
+void dphy_dsi_set_pll(u32 clkkHz, u8 lane, u8 bits)
+{
+	u32 VCOR_10000 = clkkHz * bits * 10 / lane;
+	u32 reg_txpll, reg_set;
+
+	_cal_pll_reg(clkkHz, VCOR_10000, &reg_txpll, &reg_set);
+
+	_reg_write_mask(reg_base + REG_DSI_PHY_TXPLL, 0x7ff, reg_txpll);
+	_reg_write(reg_base + REG_DSI_PHY_REG_SET, reg_set);
+
+	// update
+	_reg_write_mask(reg_base + REG_DSI_PHY_REG_8C, BIT(0), 0);
+	_reg_write_mask(reg_base + REG_DSI_PHY_REG_8C, BIT(0), 1);
+}
+
+#define dcs_delay 1
+
+enum LP_DATA {
+	LP_DATA_00 = 0x00010001,
+	LP_DATA_01 = 0x00010101,
+	LP_DATA_10 = 0x01010001,
+	LP_DATA_11 = 0x01010101,
+	LP_DATA_MAX
+};
+
+static inline void _data_0_manual_data(enum LP_DATA data)
+{
+	if (data_0_pn_swap) {
+		switch (data) {
+		case LP_DATA_01:
+			_reg_write(reg_base + REG_DSI_PHY_DATA_OV, LP_DATA_10 << data_0_lane);
+			break;
+		case LP_DATA_10:
+			_reg_write(reg_base + REG_DSI_PHY_DATA_OV, LP_DATA_01 << data_0_lane);
+			break;
+		default:
+			_reg_write(reg_base + REG_DSI_PHY_DATA_OV, data << data_0_lane);
+			break;
+		}
+	} else {
+		_reg_write(reg_base + REG_DSI_PHY_DATA_OV, data << data_0_lane);
+	}
+	udelay(dcs_delay);
+}
+
+// LP-11, LP-10, LP-00, LP-01, LP-00
+static void _esc_entry(void)
+{
+	_data_0_manual_data(LP_DATA_11);
+	_data_0_manual_data(LP_DATA_10);
+	_data_0_manual_data(LP_DATA_00);
+	_data_0_manual_data(LP_DATA_01);
+	_data_0_manual_data(LP_DATA_00);
+}
+
+// LP-00, LP-10, LP-11
+static void _esc_exit(void)
+{
+	_data_0_manual_data(LP_DATA_00);
+	_data_0_manual_data(LP_DATA_10);
+	_data_0_manual_data(LP_DATA_11);
+}
+
+static void _esc_data(u8 data)
+{
+	u8 i = 0;
+
+	for (i = 0; i < 8; ++i) {
+		_data_0_manual_data(((data & (1 << i)) ? LP_DATA_10 : LP_DATA_01));
+		_data_0_manual_data(LP_DATA_00);
+	}
+}
+
+void dpyh_mipi_tx_manual_packet(const u8 *data, u8 count)
+{
+	u8 i = 0;
+
+	_esc_entry();
+	_esc_data(0x87); // LPDT
+	for (i = 0; i < count; ++i)
+		_esc_data(data[i]);
+	_esc_exit();
+	_reg_write(reg_base + REG_DSI_PHY_DATA_OV, 0x0);
+}
+
+void dphy_set_hs_settle(u8 prepare, u8 zero, u8 trail)
+{
+	_reg_write_mask(reg_base + REG_DSI_PHY_HS_CFG1, 0xffffff00, (trail << 24) | (zero << 16) | (prepare << 8));
+}
+
+void dphy_get_hs_settle(u8 *prepare, u8 *zero, u8 *trail)
+{
+	u32 value = _reg_read(reg_base + REG_DSI_PHY_HS_CFG1);
+
+	if (prepare)
+		*prepare = (value >> 8) & 0xff;
+	if (zero)
+		*zero = (value >> 16) & 0xff;
+	if (trail)
+		*trail = (value >> 24) & 0xff;
+}
diff --git a/drivers/video/cvitek/dsi_phy.h b/drivers/video/cvitek/dsi_phy.h
new file mode 100644
index 000000000..81593379f
--- /dev/null
+++ b/drivers/video/cvitek/dsi_phy.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#ifndef _CVI_DSI_PHY_H_
+#define _CVI_DSI_PHY_H_
+
+#include "scaler.h"
+
+enum lane_id {
+	DSI_LANE_CLK = 0,
+	DSI_LANE_0,
+	DSI_LANE_1,
+	DSI_LANE_2,
+	DSI_LANE_3,
+	DSI_LANE_MAX,
+};
+
+void dphy_set_base_addr(void *base);
+void dphy_dsi_lane_en(bool clk_en, bool *data_en, bool preamble_en);
+int dphy_dsi_set_lane(u8 lane_num, enum lane_id lane, bool pn_swap);
+void dphy_init(enum sclr_vo_intf intf);
+void dphy_dsi_set_pll(u32 clkkHz, u8 lane, u8 bits);
+void dphy_lvds_enable(bool en);
+void dphy_lvds_set_pll(u32 clkkHz, u8 link);
+
+void dpyh_mipi_tx_manual_packet(const u8 *data, u8 count);
+
+void dphy_set_hs_settle(u8 prepare, u8 zero, u8 trail);
+void dphy_get_hs_settle(u8 *prepare, u8 *zero, u8 *trail);
+
+#endif	// _CVI_DSI_PHY_H
diff --git a/drivers/video/cvitek/reg.c b/drivers/video/cvitek/reg.c
new file mode 100644
index 000000000..aab07e7bb
--- /dev/null
+++ b/drivers/video/cvitek/reg.c
@@ -0,0 +1,14 @@
+#include <common.h>
+#include <asm/io.h>
+
+#include "scaler_reg.h"
+#include "reg.h"
+
+void _reg_write_mask(uintptr_t addr, u32 mask, u32 data)
+{
+	u32 value;
+
+	value = readl((void __iomem *)addr) & ~mask;
+	value |= (data & mask);
+	writel(value, (void __iomem *)addr);
+}
diff --git a/drivers/video/cvitek/reg.h b/drivers/video/cvitek/reg.h
new file mode 100644
index 000000000..509724c39
--- /dev/null
+++ b/drivers/video/cvitek/reg.h
@@ -0,0 +1,11 @@
+#ifndef _CVI_REG_H_
+#define _CVI_REG_H_
+
+#include <asm/io.h>
+
+#define _reg_read(addr) readl((void __iomem *)addr)
+#define _reg_write(addr, data) writel(data, (void __iomem *)addr)
+
+void _reg_write_mask(uintptr_t addr, u32 mask, u32 data);
+
+#endif //_CVI_REG_H_
diff --git a/drivers/video/cvitek/reg_vip_sys.h b/drivers/video/cvitek/reg_vip_sys.h
new file mode 100644
index 000000000..1da008b85
--- /dev/null
+++ b/drivers/video/cvitek/reg_vip_sys.h
@@ -0,0 +1,397 @@
+// $Module: vip_sys $
+// $RegisterBank Version: V 1.0.00 $
+// $Author:  $
+// $Date: Fri, 14 Feb 2020 03:56:40 PM $
+//
+
+//GEN REG ADDR/OFFSET/MASK
+#define  VIP_SYS_VIP_RESETS  0x0
+#define  VIP_SYS_VIP_ENABLE  0x4
+#define  VIP_SYS_VIP_INT  0x8
+#define  VIP_SYS_VIP_INT_EN  0xc
+#define  VIP_SYS_VIP_AXI_SW  0x10
+#define  VIP_SYS_VIP_CLK_LP  0x14
+#define  VIP_SYS_VIP_CLK_CTRL0  0x18
+#define  VIP_SYS_VIP_CLK_CTRL1  0x1c
+#define  VIP_SYS_VIP_LP_CTRL_AXI_RT  0x20
+#define  VIP_SYS_VIP_LP_CTRL_AXI_OFF  0x24
+#define  VIP_SYS_VIP_LP_CTRL_X2P  0x28
+#define  VIP_SYS_VIP_LP_CTRL_STATUS  0x2c
+#define  VIP_SYS_VIP_CLK_RATIO0  0x30
+#define  VIP_SYS_VIP_CLK_RATIO1  0x34
+#define  VIP_SYS_VIP_CLK_RATIO2  0x38
+#define  VIP_SYS_VIP_CLK_CTRL2  0x3c
+#define  VIP_SYS_VIP_DUMMY0  0x40
+#define  VIP_SYS_VIP_DUMMY1  0x44
+#define  VIP_SYS_VIP_DUMMY2  0x48
+#define  VIP_SYS_VIP_DUMMY3  0x4c
+#define  VIP_SYS_VIP_DBG0  0x80
+#define  VIP_SYS_VIP_DBG1  0x84
+#define  VIP_SYS_VIP_DBG2  0x88
+#define  VIP_SYS_VIP_DBG3  0x8c
+#define  VIP_SYS_REG_RST_AXI   0x0
+#define  VIP_SYS_REG_RST_AXI_OFFSET 0
+#define  VIP_SYS_REG_RST_AXI_MASK   0x1
+#define  VIP_SYS_REG_RST_ISP_TOP   0x0
+#define  VIP_SYS_REG_RST_ISP_TOP_OFFSET 1
+#define  VIP_SYS_REG_RST_ISP_TOP_MASK   0x2
+#define  VIP_SYS_REG_RST_IMG_D   0x0
+#define  VIP_SYS_REG_RST_IMG_D_OFFSET 2
+#define  VIP_SYS_REG_RST_IMG_D_MASK   0x4
+#define  VIP_SYS_REG_RST_IMG_V   0x0
+#define  VIP_SYS_REG_RST_IMG_V_OFFSET 3
+#define  VIP_SYS_REG_RST_IMG_V_MASK   0x8
+#define  VIP_SYS_REG_RST_SC_TOP   0x0
+#define  VIP_SYS_REG_RST_SC_TOP_OFFSET 4
+#define  VIP_SYS_REG_RST_SC_TOP_MASK   0x10
+#define  VIP_SYS_REG_RST_SC_D   0x0
+#define  VIP_SYS_REG_RST_SC_D_OFFSET 5
+#define  VIP_SYS_REG_RST_SC_D_MASK   0x20
+#define  VIP_SYS_REG_RST_SC_V1   0x0
+#define  VIP_SYS_REG_RST_SC_V1_OFFSET 6
+#define  VIP_SYS_REG_RST_SC_V1_MASK   0x40
+#define  VIP_SYS_REG_RST_SC_V2   0x0
+#define  VIP_SYS_REG_RST_SC_V2_OFFSET 7
+#define  VIP_SYS_REG_RST_SC_V2_MASK   0x80
+#define  VIP_SYS_REG_RST_SC_V3   0x0
+#define  VIP_SYS_REG_RST_SC_V3_OFFSET 8
+#define  VIP_SYS_REG_RST_SC_V3_MASK   0x100
+#define  VIP_SYS_REG_RST_DISP   0x0
+#define  VIP_SYS_REG_RST_DISP_OFFSET 9
+#define  VIP_SYS_REG_RST_DISP_MASK   0x200
+#define  VIP_SYS_REG_RST_BT   0x0
+#define  VIP_SYS_REG_RST_BT_OFFSET 10
+#define  VIP_SYS_REG_RST_BT_MASK   0x400
+#define  VIP_SYS_REG_RST_DSI_MAC   0x0
+#define  VIP_SYS_REG_RST_DSI_MAC_OFFSET 11
+#define  VIP_SYS_REG_RST_DSI_MAC_MASK   0x800
+#define  VIP_SYS_REG_RST_CSI_MAC0   0x0
+#define  VIP_SYS_REG_RST_CSI_MAC0_OFFSET 12
+#define  VIP_SYS_REG_RST_CSI_MAC0_MASK   0x1000
+#define  VIP_SYS_REG_RST_CSI_MAC1   0x0
+#define  VIP_SYS_REG_RST_CSI_MAC1_OFFSET 13
+#define  VIP_SYS_REG_RST_CSI_MAC1_MASK   0x2000
+#define  VIP_SYS_REG_RST_DWA   0x0
+#define  VIP_SYS_REG_RST_DWA_OFFSET 14
+#define  VIP_SYS_REG_RST_DWA_MASK   0x4000
+#define  VIP_SYS_REG_RST_CLK_BT_DIV   0x0
+#define  VIP_SYS_REG_RST_CLK_BT_DIV_OFFSET 15
+#define  VIP_SYS_REG_RST_CLK_BT_DIV_MASK   0x8000
+#define  VIP_SYS_REG_RST_ISP_CSI0   0x0
+#define  VIP_SYS_REG_RST_ISP_CSI0_OFFSET 16
+#define  VIP_SYS_REG_RST_ISP_CSI0_MASK   0x10000
+#define  VIP_SYS_REG_RST_ISP_CSI1   0x0
+#define  VIP_SYS_REG_RST_ISP_CSI1_OFFSET 17
+#define  VIP_SYS_REG_RST_ISP_CSI1_MASK   0x20000
+#define  VIP_SYS_ECO_REG_CLK_ISP_TOP_EN   0x0
+#define  VIP_SYS_ECO_REG_CLK_ISP_TOP_EN_OFFSET 18
+#define  VIP_SYS_ECO_REG_CLK_ISP_TOP_EN_MASK   0x40000
+#define  VIP_SYS_ECO_REG_CLK_AXI_ISP_EN   0x0
+#define  VIP_SYS_ECO_REG_CLK_AXI_ISP_EN_OFFSET 19
+#define  VIP_SYS_ECO_REG_CLK_AXI_ISP_EN_MASK   0x80000
+#define  VIP_SYS_ECO_REG_CLK_CSI_MAC0_EN   0x0
+#define  VIP_SYS_ECO_REG_CLK_CSI_MAC0_EN_OFFSET 20
+#define  VIP_SYS_ECO_REG_CLK_CSI_MAC0_EN_MASK   0x100000
+#define  VIP_SYS_ECO_REG_CLK_CSI_MAC1_EN   0x0
+#define  VIP_SYS_ECO_REG_CLK_CSI_MAC1_EN_OFFSET 21
+#define  VIP_SYS_ECO_REG_CLK_CSI_MAC1_EN_MASK   0x200000
+#define  VIP_SYS_REG_RESERVE0   0x0
+#define  VIP_SYS_REG_RESERVE0_OFFSET 22
+#define  VIP_SYS_REG_RESERVE0_MASK   0xffc00000
+#define  VIP_SYS_ECO_REG_RST_CSI_MAC0   0x4
+#define  VIP_SYS_ECO_REG_RST_CSI_MAC0_OFFSET 0
+#define  VIP_SYS_ECO_REG_RST_CSI_MAC0_MASK   0x1
+#define  VIP_SYS_ECO_REG_RST_CSI_MAC1   0x4
+#define  VIP_SYS_ECO_REG_RST_CSI_MAC1_OFFSET 1
+#define  VIP_SYS_ECO_REG_RST_CSI_MAC1_MASK   0x2
+#define  VIP_SYS_REG_EN_REV0   0x4
+#define  VIP_SYS_REG_EN_REV0_OFFSET 2
+#define  VIP_SYS_REG_EN_REV0_MASK   0xfffc
+#define  VIP_SYS_REG_EN_REV1   0x4
+#define  VIP_SYS_REG_EN_REV1_OFFSET 16
+#define  VIP_SYS_REG_EN_REV1_MASK   0xffff0000
+#define  VIP_SYS_INT_SC_TOP   0x8
+#define  VIP_SYS_INT_SC_TOP_OFFSET 0
+#define  VIP_SYS_INT_SC_TOP_MASK   0x1
+#define  VIP_SYS_INT_ISP_TOP   0x8
+#define  VIP_SYS_INT_ISP_TOP_OFFSET 16
+#define  VIP_SYS_INT_ISP_TOP_MASK   0x10000
+#define  VIP_SYS_INT_DWA_WRAP   0x8
+#define  VIP_SYS_INT_DWA_WRAP_OFFSET 24
+#define  VIP_SYS_INT_DWA_WRAP_MASK   0x1000000
+#define  VIP_SYS_INT_CSI_MAC0   0x8
+#define  VIP_SYS_INT_CSI_MAC0_OFFSET 28
+#define  VIP_SYS_INT_CSI_MAC0_MASK   0x10000000
+#define  VIP_SYS_INT_CSI_MAC1   0x8
+#define  VIP_SYS_INT_CSI_MAC1_OFFSET 29
+#define  VIP_SYS_INT_CSI_MAC1_MASK   0x20000000
+#define  VIP_SYS_INT_EN_SC_TOP   0xc
+#define  VIP_SYS_INT_EN_SC_TOP_OFFSET 0
+#define  VIP_SYS_INT_EN_SC_TOP_MASK   0xffff
+#define  VIP_SYS_INT_EN_ISP_TOP   0xc
+#define  VIP_SYS_INT_EN_ISP_TOP_OFFSET 16
+#define  VIP_SYS_INT_EN_ISP_TOP_MASK   0x10000
+#define  VIP_SYS_INT_EN_DWA_WRAP   0xc
+#define  VIP_SYS_INT_EN_DWA_WRAP_OFFSET 24
+#define  VIP_SYS_INT_EN_DWA_WRAP_MASK   0x1000000
+#define  VIP_SYS_INT_EN_CSI_MAC0   0xc
+#define  VIP_SYS_INT_EN_CSI_MAC0_OFFSET 28
+#define  VIP_SYS_INT_EN_CSI_MAC0_MASK   0x10000000
+#define  VIP_SYS_INT_EN_CSI_MAC1   0xc
+#define  VIP_SYS_INT_EN_CSI_MAC1_OFFSET 29
+#define  VIP_SYS_INT_EN_CSI_MAC1_MASK   0x20000000
+#define  VIP_SYS_REG_PORT_SEL_SC_OFF   0x10
+#define  VIP_SYS_REG_PORT_SEL_SC_OFF_OFFSET 0
+#define  VIP_SYS_REG_PORT_SEL_SC_OFF_MASK   0x1
+#define  VIP_SYS_REG_PORT_SEL_ISP_OFF0   0x10
+#define  VIP_SYS_REG_PORT_SEL_ISP_OFF0_OFFSET 1
+#define  VIP_SYS_REG_PORT_SEL_ISP_OFF0_MASK   0x2
+#define  VIP_SYS_REG_PORT_SEL_ISP_OFF1   0x10
+#define  VIP_SYS_REG_PORT_SEL_ISP_OFF1_OFFSET 2
+#define  VIP_SYS_REG_PORT_SEL_ISP_OFF1_MASK   0x4
+#define  VIP_SYS_APB_CLK_EN_SC_TOP   0x14
+#define  VIP_SYS_APB_CLK_EN_SC_TOP_OFFSET 0
+#define  VIP_SYS_APB_CLK_EN_SC_TOP_MASK   0x1
+#define  VIP_SYS_APB_CLK_EN_ISP_TOP   0x14
+#define  VIP_SYS_APB_CLK_EN_ISP_TOP_OFFSET 1
+#define  VIP_SYS_APB_CLK_EN_ISP_TOP_MASK   0x2
+#define  VIP_SYS_APB_CLK_EN_DWA_WRAP   0x14
+#define  VIP_SYS_APB_CLK_EN_DWA_WRAP_OFFSET 2
+#define  VIP_SYS_APB_CLK_EN_DWA_WRAP_MASK   0x4
+#define  VIP_SYS_APB_CLK_EN_ROT_TOP   0x14
+#define  VIP_SYS_APB_CLK_EN_ROT_TOP_OFFSET 3
+#define  VIP_SYS_APB_CLK_EN_ROT_TOP_MASK   0x8
+#define  VIP_SYS_APB_CLK_EN_VIP_SYS   0x14
+#define  VIP_SYS_APB_CLK_EN_VIP_SYS_OFFSET 4
+#define  VIP_SYS_APB_CLK_EN_VIP_SYS_MASK   0x10
+#define  VIP_SYS_APB_CLK_EN_CSI_MAC0   0x14
+#define  VIP_SYS_APB_CLK_EN_CSI_MAC0_OFFSET 8
+#define  VIP_SYS_APB_CLK_EN_CSI_MAC0_MASK   0x100
+#define  VIP_SYS_APB_CLK_EN_CSI_MAC1   0x14
+#define  VIP_SYS_APB_CLK_EN_CSI_MAC1_OFFSET 9
+#define  VIP_SYS_APB_CLK_EN_CSI_MAC1_MASK   0x200
+#define  VIP_SYS_SC_X2P_BUSY_EN   0x14
+#define  VIP_SYS_SC_X2P_BUSY_EN_OFFSET 12
+#define  VIP_SYS_SC_X2P_BUSY_EN_MASK   0x1000
+#define  VIP_SYS_ISP_X2P_BUSY_EN   0x14
+#define  VIP_SYS_ISP_X2P_BUSY_EN_OFFSET 13
+#define  VIP_SYS_ISP_X2P_BUSY_EN_MASK   0x2000
+#define  VIP_SYS_DWA_X2P_BUSY_EN   0x14
+#define  VIP_SYS_DWA_X2P_BUSY_EN_OFFSET 14
+#define  VIP_SYS_DWA_X2P_BUSY_EN_MASK   0x4000
+#define  VIP_SYS_APB_AUTO_GATING_EN_SC_TOP   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_SC_TOP_OFFSET 16
+#define  VIP_SYS_APB_AUTO_GATING_EN_SC_TOP_MASK   0x10000
+#define  VIP_SYS_APB_AUTO_GATING_EN_ISP_TOP   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_ISP_TOP_OFFSET 17
+#define  VIP_SYS_APB_AUTO_GATING_EN_ISP_TOP_MASK   0x20000
+#define  VIP_SYS_APB_AUTO_GATING_EN_DWA_WRAP   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_DWA_WRAP_OFFSET 18
+#define  VIP_SYS_APB_AUTO_GATING_EN_DWA_WRAP_MASK   0x40000
+#define  VIP_SYS_APB_AUTO_GATING_EN_ROT_TOP   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_ROT_TOP_OFFSET 19
+#define  VIP_SYS_APB_AUTO_GATING_EN_ROT_TOP_MASK   0x80000
+#define  VIP_SYS_APB_AUTO_GATING_EN_VIP_SYS   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_VIP_SYS_OFFSET 20
+#define  VIP_SYS_APB_AUTO_GATING_EN_VIP_SYS_MASK   0x100000
+#define  VIP_SYS_APB_AUTO_GATING_EN_CSI_MAC0   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_CSI_MAC0_OFFSET 24
+#define  VIP_SYS_APB_AUTO_GATING_EN_CSI_MAC0_MASK   0x1000000
+#define  VIP_SYS_APB_AUTO_GATING_EN_CSI_MAC1   0x14
+#define  VIP_SYS_APB_AUTO_GATING_EN_CSI_MAC1_OFFSET 25
+#define  VIP_SYS_APB_AUTO_GATING_EN_CSI_MAC1_MASK   0x2000000
+#define  VIP_SYS_CLK_BT_SRC_SEL   0x18
+#define  VIP_SYS_CLK_BT_SRC_SEL_OFFSET 0
+#define  VIP_SYS_CLK_BT_SRC_SEL_MASK   0x3
+#define  VIP_SYS_CLK_LVDS0_SRC_SEL   0x18
+#define  VIP_SYS_CLK_LVDS0_SRC_SEL_OFFSET 2
+#define  VIP_SYS_CLK_LVDS0_SRC_SEL_MASK   0x4
+#define  VIP_SYS_CLK_LVDS1_SRC_SEL   0x18
+#define  VIP_SYS_CLK_LVDS1_SRC_SEL_OFFSET 3
+#define  VIP_SYS_CLK_LVDS1_SRC_SEL_MASK   0x8
+#define  VIP_SYS_CLK_DISP_SEL_BT_DIV1   0x18
+#define  VIP_SYS_CLK_DISP_SEL_BT_DIV1_OFFSET 4
+#define  VIP_SYS_CLK_DISP_SEL_BT_DIV1_MASK   0x10
+#define  VIP_SYS_CLK_DSI_MAC_SEL_DIV   0x18
+#define  VIP_SYS_CLK_DSI_MAC_SEL_DIV_OFFSET 6
+#define  VIP_SYS_CLK_DSI_MAC_SEL_DIV_MASK   0xc0
+#define  VIP_SYS_CLK_DSI_MAC_SRC_SEL   0x18
+#define  VIP_SYS_CLK_DSI_MAC_SRC_SEL_OFFSET 8
+#define  VIP_SYS_CLK_DSI_MAC_SRC_SEL_MASK   0x100
+#define  VIP_SYS_CLK_CSI0_RX_SRC_SEL   0x18
+#define  VIP_SYS_CLK_CSI0_RX_SRC_SEL_OFFSET 10
+#define  VIP_SYS_CLK_CSI0_RX_SRC_SEL_MASK   0x400
+#define  VIP_SYS_CLK_CSI1_RX_SRC_SEL   0x18
+#define  VIP_SYS_CLK_CSI1_RX_SRC_SEL_OFFSET 11
+#define  VIP_SYS_CLK_CSI1_RX_SRC_SEL_MASK   0x800
+#define  VIP_SYS_PAD_VI_CLK_SRC_SEL   0x18
+#define  VIP_SYS_PAD_VI_CLK_SRC_SEL_OFFSET 12
+#define  VIP_SYS_PAD_VI_CLK_SRC_SEL_MASK   0x1000
+#define  VIP_SYS_PAD_VI1_CLK_SRC_SEL   0x18
+#define  VIP_SYS_PAD_VI1_CLK_SRC_SEL_OFFSET 13
+#define  VIP_SYS_PAD_VI1_CLK_SRC_SEL_MASK   0x2000
+#define  VIP_SYS_CLK_VIP_SRC_SEL   0x1c
+#define  VIP_SYS_CLK_VIP_SRC_SEL_OFFSET 0
+#define  VIP_SYS_CLK_VIP_SRC_SEL_MASK   0x1
+#define  VIP_SYS_CLK_CSI_MAC0_SRC_SEL   0x1c
+#define  VIP_SYS_CLK_CSI_MAC0_SRC_SEL_OFFSET 4
+#define  VIP_SYS_CLK_CSI_MAC0_SRC_SEL_MASK   0x30
+#define  VIP_SYS_CLK_CSI_MAC1_SRC_SEL   0x1c
+#define  VIP_SYS_CLK_CSI_MAC1_SRC_SEL_OFFSET 8
+#define  VIP_SYS_CLK_CSI_MAC1_SRC_SEL_MASK   0x300
+#define  VIP_SYS_ISP_CLK_CSI0_SRC_SEL   0x1c
+#define  VIP_SYS_ISP_CLK_CSI0_SRC_SEL_OFFSET 16
+#define  VIP_SYS_ISP_CLK_CSI0_SRC_SEL_MASK   0x10000
+#define  VIP_SYS_ISP_CLK_CSI1_SRC_SEL   0x1c
+#define  VIP_SYS_ISP_CLK_CSI1_SRC_SEL_OFFSET 20
+#define  VIP_SYS_ISP_CLK_CSI1_SRC_SEL_MASK   0x100000
+#define  VIP_SYS_REG_LP_DISABLE_VIP_AXI_RT   0x20
+#define  VIP_SYS_REG_LP_DISABLE_VIP_AXI_RT_OFFSET 0
+#define  VIP_SYS_REG_LP_DISABLE_VIP_AXI_RT_MASK   0x1
+#define  VIP_SYS_REG_LP_LOCK_VIP_AXI_RT   0x20
+#define  VIP_SYS_REG_LP_LOCK_VIP_AXI_RT_OFFSET 1
+#define  VIP_SYS_REG_LP_LOCK_VIP_AXI_RT_MASK   0x2
+#define  VIP_SYS_REG_LP_CTRL_VIP_AXI_RT   0x20
+#define  VIP_SYS_REG_LP_CTRL_VIP_AXI_RT_OFFSET 8
+#define  VIP_SYS_REG_LP_CTRL_VIP_AXI_RT_MASK   0x3f00
+#define  VIP_SYS_REG_LP_DISABLE_VIP_AXI_OFF   0x24
+#define  VIP_SYS_REG_LP_DISABLE_VIP_AXI_OFF_OFFSET 0
+#define  VIP_SYS_REG_LP_DISABLE_VIP_AXI_OFF_MASK   0x1
+#define  VIP_SYS_REG_LP_LOCK_VIP_AXI_OFF   0x24
+#define  VIP_SYS_REG_LP_LOCK_VIP_AXI_OFF_OFFSET 1
+#define  VIP_SYS_REG_LP_LOCK_VIP_AXI_OFF_MASK   0x2
+#define  VIP_SYS_REG_LP_CTRL_VIP_AXI_OFF   0x24
+#define  VIP_SYS_REG_LP_CTRL_VIP_AXI_OFF_OFFSET 8
+#define  VIP_SYS_REG_LP_CTRL_VIP_AXI_OFF_MASK   0x3f00
+#define  VIP_SYS_REG_LP_DISABLE_VIP_X2P   0x28
+#define  VIP_SYS_REG_LP_DISABLE_VIP_X2P_OFFSET 0
+#define  VIP_SYS_REG_LP_DISABLE_VIP_X2P_MASK   0x1
+#define  VIP_SYS_REG_LP_LOCK_VIP_X2P   0x28
+#define  VIP_SYS_REG_LP_LOCK_VIP_X2P_OFFSET 1
+#define  VIP_SYS_REG_LP_LOCK_VIP_X2P_MASK   0x2
+#define  VIP_SYS_REG_LP_CTRL_VIP_X2P   0x28
+#define  VIP_SYS_REG_LP_CTRL_VIP_X2P_OFFSET 8
+#define  VIP_SYS_REG_LP_CTRL_VIP_X2P_MASK   0x3f00
+#define  VIP_SYS_CACTIVE_AXI_RT_FAB   0x2c
+#define  VIP_SYS_CACTIVE_AXI_RT_FAB_OFFSET 0
+#define  VIP_SYS_CACTIVE_AXI_RT_FAB_MASK   0x1
+#define  VIP_SYS_CSYSREQ_AXI_RT_FAB   0x2c
+#define  VIP_SYS_CSYSREQ_AXI_RT_FAB_OFFSET 1
+#define  VIP_SYS_CSYSREQ_AXI_RT_FAB_MASK   0x2
+#define  VIP_SYS_CSYSACK_AXI_RT_FAB   0x2c
+#define  VIP_SYS_CSYSACK_AXI_RT_FAB_OFFSET 2
+#define  VIP_SYS_CSYSACK_AXI_RT_FAB_MASK   0x4
+#define  VIP_SYS_LPC_RT_FAB_LP_LOCK_O   0x2c
+#define  VIP_SYS_LPC_RT_FAB_LP_LOCK_O_OFFSET 4
+#define  VIP_SYS_LPC_RT_FAB_LP_LOCK_O_MASK   0x10
+#define  VIP_SYS_LPC_RT_FAB_LP_BUSY_O   0x2c
+#define  VIP_SYS_LPC_RT_FAB_LP_BUSY_O_OFFSET 5
+#define  VIP_SYS_LPC_RT_FAB_LP_BUSY_O_MASK   0x20
+#define  VIP_SYS_CACTIVE_AXI_OFF_FAB   0x2c
+#define  VIP_SYS_CACTIVE_AXI_OFF_FAB_OFFSET 8
+#define  VIP_SYS_CACTIVE_AXI_OFF_FAB_MASK   0x100
+#define  VIP_SYS_CSYSREQ_AXI_OFF_FAB   0x2c
+#define  VIP_SYS_CSYSREQ_AXI_OFF_FAB_OFFSET 9
+#define  VIP_SYS_CSYSREQ_AXI_OFF_FAB_MASK   0x200
+#define  VIP_SYS_CSYSACK_AXI_OFF_FAB   0x2c
+#define  VIP_SYS_CSYSACK_AXI_OFF_FAB_OFFSET 10
+#define  VIP_SYS_CSYSACK_AXI_OFF_FAB_MASK   0x400
+#define  VIP_SYS_LPC_OFF_FAB_LP_LOCK_O   0x2c
+#define  VIP_SYS_LPC_OFF_FAB_LP_LOCK_O_OFFSET 12
+#define  VIP_SYS_LPC_OFF_FAB_LP_LOCK_O_MASK   0x1000
+#define  VIP_SYS_LPC_OFF_FAB_LP_BUSY_O   0x2c
+#define  VIP_SYS_LPC_OFF_FAB_LP_BUSY_O_OFFSET 13
+#define  VIP_SYS_LPC_OFF_FAB_LP_BUSY_O_MASK   0x2000
+#define  VIP_SYS_CACTIVE_X2P   0x2c
+#define  VIP_SYS_CACTIVE_X2P_OFFSET 16
+#define  VIP_SYS_CACTIVE_X2P_MASK   0x10000
+#define  VIP_SYS_CSYSREQ_X2P   0x2c
+#define  VIP_SYS_CSYSREQ_X2P_OFFSET 17
+#define  VIP_SYS_CSYSREQ_X2P_MASK   0x20000
+#define  VIP_SYS_CSYSACK_X2P   0x2c
+#define  VIP_SYS_CSYSACK_X2P_OFFSET 18
+#define  VIP_SYS_CSYSACK_X2P_MASK   0x40000
+#define  VIP_SYS_LPC_X2P_FAB_LP_LOCK_O   0x2c
+#define  VIP_SYS_LPC_X2P_FAB_LP_LOCK_O_OFFSET 20
+#define  VIP_SYS_LPC_X2P_FAB_LP_LOCK_O_MASK   0x100000
+#define  VIP_SYS_LPC_X2P_FAB_LP_BUSY_O   0x2c
+#define  VIP_SYS_LPC_X2P_FAB_LP_BUSY_O_OFFSET 21
+#define  VIP_SYS_LPC_X2P_FAB_LP_BUSY_O_MASK   0x200000
+#define  VIP_SYS_REG_CK_COEF_ISP_TOP   0x30
+#define  VIP_SYS_REG_CK_COEF_ISP_TOP_OFFSET 0
+#define  VIP_SYS_REG_CK_COEF_ISP_TOP_MASK   0x1f
+#define  VIP_SYS_REG_CK_COEF_DWA   0x30
+#define  VIP_SYS_REG_CK_COEF_DWA_OFFSET 5
+#define  VIP_SYS_REG_CK_COEF_DWA_MASK   0x3e0
+#define  VIP_SYS_REG_CK_COEF_IMG_D   0x30
+#define  VIP_SYS_REG_CK_COEF_IMG_D_OFFSET 10
+#define  VIP_SYS_REG_CK_COEF_IMG_D_MASK   0x7c00
+#define  VIP_SYS_REG_CK_COEF_IMG_V   0x30
+#define  VIP_SYS_REG_CK_COEF_IMG_V_OFFSET 15
+#define  VIP_SYS_REG_CK_COEF_IMG_V_MASK   0xf8000
+#define  VIP_SYS_REG_CK_COEF_SC_D   0x30
+#define  VIP_SYS_REG_CK_COEF_SC_D_OFFSET 20
+#define  VIP_SYS_REG_CK_COEF_SC_D_MASK   0x1f00000
+#define  VIP_SYS_REG_CK_COEF_SC_V1   0x30
+#define  VIP_SYS_REG_CK_COEF_SC_V1_OFFSET 25
+#define  VIP_SYS_REG_CK_COEF_SC_V1_MASK   0x3e000000
+#define  VIP_SYS_REG_CK_COEF_SC_V2   0x34
+#define  VIP_SYS_REG_CK_COEF_SC_V2_OFFSET 0
+#define  VIP_SYS_REG_CK_COEF_SC_V2_MASK   0x1f
+#define  VIP_SYS_REG_CK_COEF_SC_V3   0x34
+#define  VIP_SYS_REG_CK_COEF_SC_V3_OFFSET 5
+#define  VIP_SYS_REG_CK_COEF_SC_V3_MASK   0x3e0
+#define  VIP_SYS_REG_CK_COEF_CSI_MAC0   0x34
+#define  VIP_SYS_REG_CK_COEF_CSI_MAC0_OFFSET 10
+#define  VIP_SYS_REG_CK_COEF_CSI_MAC0_MASK   0x7c00
+#define  VIP_SYS_REG_CK_COEF_CSI_MAC1   0x34
+#define  VIP_SYS_REG_CK_COEF_CSI_MAC1_OFFSET 15
+#define  VIP_SYS_REG_CK_COEF_CSI_MAC1_MASK   0xf8000
+#define  VIP_SYS_REG_CK_COEF_REV0   0x34
+#define  VIP_SYS_REG_CK_COEF_REV0_OFFSET 20
+#define  VIP_SYS_REG_CK_COEF_REV0_MASK   0x1f00000
+#define  VIP_SYS_REG_CK_COEF_BT   0x34
+#define  VIP_SYS_REG_CK_COEF_BT_OFFSET 25
+#define  VIP_SYS_REG_CK_COEF_BT_MASK   0x3e000000
+#define  VIP_SYS_REG_CK_COEF_LVDS0   0x38
+#define  VIP_SYS_REG_CK_COEF_LVDS0_OFFSET 0
+#define  VIP_SYS_REG_CK_COEF_LVDS0_MASK   0x1f
+#define  VIP_SYS_REG_CK_COEF_LVDS1   0x38
+#define  VIP_SYS_REG_CK_COEF_LVDS1_OFFSET 5
+#define  VIP_SYS_REG_CK_COEF_LVDS1_MASK   0x3e0
+#define  VIP_SYS_REG_CK_COEF_CSI0_RX   0x38
+#define  VIP_SYS_REG_CK_COEF_CSI0_RX_OFFSET 10
+#define  VIP_SYS_REG_CK_COEF_CSI0_RX_MASK   0x7c00
+#define  VIP_SYS_REG_CK_COEF_CSI1_RX   0x38
+#define  VIP_SYS_REG_CK_COEF_CSI1_RX_OFFSET 15
+#define  VIP_SYS_REG_CK_COEF_CSI1_RX_MASK   0xf8000
+#define  VIP_SYS_REG_CK_COEF_PAD_VI   0x38
+#define  VIP_SYS_REG_CK_COEF_PAD_VI_OFFSET 20
+#define  VIP_SYS_REG_CK_COEF_PAD_VI_MASK   0x1f00000
+#define  VIP_SYS_CLK_SC_D_SRC_SEL   0x3c
+#define  VIP_SYS_CLK_SC_D_SRC_SEL_OFFSET 0
+#define  VIP_SYS_CLK_SC_D_SRC_SEL_MASK   0x1
+#define  VIP_SYS_REG_DUMMY0   0x40
+#define  VIP_SYS_REG_DUMMY0_OFFSET 0
+#define  VIP_SYS_REG_DUMMY0_MASK   0xffffffff
+#define  VIP_SYS_REG_DUMMY1   0x44
+#define  VIP_SYS_REG_DUMMY1_OFFSET 0
+#define  VIP_SYS_REG_DUMMY1_MASK   0xffffffff
+#define  VIP_SYS_REG_DUMMY2   0x48
+#define  VIP_SYS_REG_DUMMY2_OFFSET 0
+#define  VIP_SYS_REG_DUMMY2_MASK   0xffffffff
+#define  VIP_SYS_REG_DUMMY3   0x4c
+#define  VIP_SYS_REG_DUMMY3_OFFSET 0
+#define  VIP_SYS_REG_DUMMY3_MASK   0xffffffff
+#define  VIP_SYS_REG_DBG_BUS0   0x80
+#define  VIP_SYS_REG_DBG_BUS0_OFFSET 0
+#define  VIP_SYS_REG_DBG_BUS0_MASK   0xffffffff
+#define  VIP_SYS_REG_DBG_BUS1   0x84
+#define  VIP_SYS_REG_DBG_BUS1_OFFSET 0
+#define  VIP_SYS_REG_DBG_BUS1_MASK   0xffffffff
+#define  VIP_SYS_REG_DBG_BUS2   0x88
+#define  VIP_SYS_REG_DBG_BUS2_OFFSET 0
+#define  VIP_SYS_REG_DBG_BUS2_MASK   0xffffffff
+#define  VIP_SYS_REG_DBG_BUS3   0x8c
+#define  VIP_SYS_REG_DBG_BUS3_OFFSET 0
+#define  VIP_SYS_REG_DBG_BUS3_MASK   0xffffffff
diff --git a/drivers/video/cvitek/scaler.c b/drivers/video/cvitek/scaler.c
new file mode 100644
index 000000000..a5f344783
--- /dev/null
+++ b/drivers/video/cvitek/scaler.c
@@ -0,0 +1,1425 @@
+#include <common.h>
+
+#include "vip_common.h"
+#include "scaler.h"
+#include "scaler_reg.h"
+#include "reg.h"
+#include "dsi_phy.h"
+
+/****************************************************************************
+ * Global parameters
+ ****************************************************************************/
+static struct sclr_top_cfg g_top_cfg;
+static struct sclr_disp_cfg g_disp_cfg;
+static struct sclr_disp_timing disp_timing;
+static uintptr_t reg_base;
+/****************************************************************************
+ * Initial info
+ ****************************************************************************/
+#define DEFINE_CSC_COEF0(a, b, c) \
+		.coef[0][0] = a, .coef[0][1] = b, .coef[0][2] = c,
+#define DEFINE_CSC_COEF1(a, b, c) \
+		.coef[1][0] = a, .coef[1][1] = b, .coef[1][2] = c,
+#define DEFINE_CSC_COEF2(a, b, c) \
+		.coef[2][0] = a, .coef[2][1] = b, .coef[2][2] = c,
+static struct sclr_csc_matrix csc_mtrx[SCL_CSC_MAX] = {
+	// none
+	{
+		DEFINE_CSC_COEF0(BIT(10),	0,		0)
+		DEFINE_CSC_COEF1(0,		BIT(10),	0)
+		DEFINE_CSC_COEF2(0,		0,		BIT(10))
+		.sub[0] = 0,   .sub[1] = 0,   .sub[2] = 0,
+		.add[0] = 0,   .add[1] = 0,   .add[2] = 0
+	},
+	// yuv2rgb
+	// 601 Limited
+	//  R = Y + 1.402* Pr                           //
+	//  G = Y - 0.344 * Pb  - 0.792* Pr             //
+	//  B = Y + 1.772 * Pb                          //
+	{
+		DEFINE_CSC_COEF0(BIT(10),	0,		1436)
+		DEFINE_CSC_COEF1(BIT(10),	BIT(13) | 352,	BIT(13) | 731)
+		DEFINE_CSC_COEF2(BIT(10),	1815,		0)
+		.sub[0] = 0,   .sub[1] = 128, .sub[2] = 128,
+		.add[0] = 0,   .add[1] = 0,   .add[2] = 0
+	},
+	// 601 Full
+	//  R = 1.164 *(Y - 16) + 1.596 *(Cr - 128)                     //
+	//  G = 1.164 *(Y - 16) - 0.392 *(Cb - 128) - 0.812 *(Cr - 128) //
+	//  B = 1.164 *(Y - 16) + 2.016 *(Cb - 128)                     //
+	{
+		DEFINE_CSC_COEF0(1192,	0,		1634)
+		DEFINE_CSC_COEF1(1192,	BIT(13) | 401,	BIT(13) | 833)
+		DEFINE_CSC_COEF2(1192,	2065,		0)
+		.sub[0] = 16,  .sub[1] = 128, .sub[2] = 128,
+		.add[0] = 0,   .add[1] = 0,   .add[2] = 0
+	},
+	// 709 Limited
+	// R = Y + 1.540(Cr – 128)
+	// G = Y - 0.183(Cb – 128) – 0.459(Cr – 128)
+	// B = Y + 1.816(Cb – 128)
+	{
+		DEFINE_CSC_COEF0(BIT(10),	0,		1577)
+		DEFINE_CSC_COEF1(BIT(10),	BIT(13) | 187,	BIT(13) | 470)
+		DEFINE_CSC_COEF2(BIT(10),	1860,		0)
+		.sub[0] = 0,   .sub[1] = 128, .sub[2] = 128,
+		.add[0] = 0,   .add[1] = 0,   .add[2] = 0
+	},
+	// 709 Full
+	//  R = 1.164 *(Y - 16) + 1.792 *(Cr - 128)                     //
+	//  G = 1.164 *(Y - 16) - 0.213 *(Cb - 128) - 0.534 *(Cr - 128) //
+	//  B = 1.164 *(Y - 16) + 2.114 *(Cb - 128)                     //
+	{
+		DEFINE_CSC_COEF0(1192,	0,		1836)
+		DEFINE_CSC_COEF1(1192,	BIT(13) | 218,	BIT(13) | 547)
+		DEFINE_CSC_COEF2(1192,	2166,		0)
+		.sub[0] = 16,  .sub[1] = 128, .sub[2] = 128,
+		.add[0] = 0,   .add[1] = 0,   .add[2] = 0
+	},
+	// rgb2yuv
+	// 601 Limited
+	//  Y = 0.299 * R + 0.587 * G + 0.114 * B       //
+	// Pb =-0.169 * R - 0.331 * G + 0.500 * B       //
+	// Pr = 0.500 * R - 0.419 * G - 0.081 * B       //
+	{
+		DEFINE_CSC_COEF0(306,		601,		117)
+		DEFINE_CSC_COEF1(BIT(13) | 173,	BIT(13) | 339,	512)
+		DEFINE_CSC_COEF2(512,		BIT(13) | 429,	BIT(13) | 83)
+		.sub[0] = 0,   .sub[1] = 0,   .sub[2] = 0,
+		.add[0] = 0,   .add[1] = 128, .add[2] = 128
+	},
+	// 601 Full
+	//  Y = 16  + 0.257 * R + 0.504 * g + 0.098 * b //
+	// Cb = 128 - 0.148 * R - 0.291 * g + 0.439 * b //
+	// Cr = 128 + 0.439 * R - 0.368 * g - 0.071 * b //
+	{
+		DEFINE_CSC_COEF0(263,		516,		100)
+		DEFINE_CSC_COEF1(BIT(13) | 152,	BIT(13) | 298,	450)
+		DEFINE_CSC_COEF2(450,		BIT(13) | 377,	BIT(13) | 73)
+		.sub[0] = 0,   .sub[1] = 0,   .sub[2] = 0,
+		.add[0] = 16,  .add[1] = 128, .add[2] = 128
+	},
+	// 709 Limited
+	//   Y =       0.2126   0.7152   0.0722
+	//  Cb = 128 - 0.1146  -0.3854   0.5000
+	//  Cr = 128 + 0.5000  -0.4542  -0.0468
+	{
+		DEFINE_CSC_COEF0(218,		732,		74)
+		DEFINE_CSC_COEF1(BIT(13) | 117,	BIT(13) | 395,	512)
+		DEFINE_CSC_COEF2(512,		BIT(13) | 465,	BIT(13) | 48)
+		.sub[0] = 0,   .sub[1] = 0,   .sub[2] = 0,
+		.add[0] = 0,   .add[1] = 128, .add[2] = 128
+	},
+	// 709 Full
+	//  Y = 16  + 0.183 * R + 0.614 * g + 0.062 * b //
+	// Cb = 128 - 0.101 * R - 0.339 * g + 0.439 * b //
+	// Cr = 128 + 0.439 * R - 0.399 * g - 0.040 * b //
+	{
+		DEFINE_CSC_COEF0(187,		629,		63)
+		DEFINE_CSC_COEF1(BIT(13) | 103,	BIT(13) | 347,	450)
+		DEFINE_CSC_COEF2(450,		BIT(13) | 408,	BIT(13) | 41)
+		.sub[0] = 0,   .sub[1] = 0,   .sub[2] = 0,
+		.add[0] = 16,  .add[1] = 128, .add[2] = 128
+	},
+};
+
+/****************************************************************************
+ * Interfaces
+ ****************************************************************************/
+void sclr_set_base_addr(void *base)
+{
+	reg_base = (uintptr_t)base;
+}
+
+/**
+ * sclr_top_set_cfg - set scl-top's configurations.
+ *
+ * @param cfg: scl-top's settings.
+ */
+void sclr_top_set_cfg(struct sclr_top_cfg *cfg)
+{
+	u32 sc_top = 0;
+	union vip_sys_clk clk;
+
+	_reg_write(reg_base + REG_SCL_TOP_CFG0, cfg->ip_trig_src << 3);
+
+	clk = vip_get_clk_lp();
+	clk.b.sc_top = 1;
+	vip_set_clk_lp(clk);
+
+	if (cfg->sclr_enable[0])
+		sc_top |= BIT(0);
+	if (cfg->sclr_enable[1])
+		sc_top |= BIT(1);
+	if (cfg->sclr_enable[2])
+		sc_top |= BIT(2);
+	if (cfg->sclr_enable[3])
+		sc_top |= BIT(3);
+	if (cfg->disp_enable)
+		sc_top |= BIT(4);
+	if (cfg->disp_from_sc)
+		sc_top |= BIT(8);
+	if (cfg->sclr_d_src)
+		sc_top |= BIT(9);
+
+	_reg_write(reg_base + REG_SCL_TOP_CFG1, sc_top);
+	sclr_img_set_trig(SCL_IMG_D, cfg->img_in_d_trig_src);
+	sclr_img_set_trig(SCL_IMG_V, cfg->img_in_v_trig_src);
+
+	sclr_top_reg_done();
+	sclr_top_reg_force_up();
+	g_top_cfg = *cfg;
+}
+
+/**
+ * sclr_top_get_cfg - get scl_top's cfg
+ *
+ * @return: scl_top's cfg
+ */
+struct sclr_top_cfg *sclr_top_get_cfg(void)
+{
+	return &g_top_cfg;
+}
+
+/**
+ * sclr_top_reg_done - to mark all sc-reg valid for update.
+ *
+ */
+void sclr_top_reg_done(void)
+{
+	_reg_write_mask(reg_base + REG_SCL_TOP_CFG0, 0, 1);
+}
+
+/**
+ * sclr_top_reg_force_up - trigger reg update by sw.
+ *
+ */
+void sclr_top_reg_force_up(void)
+{
+	_reg_write_mask(reg_base + REG_SCL_TOP_SHD, 0x00ff, 0xff);
+}
+
+u8 sclr_top_pg_late_get_bus(void)
+{
+	return (_reg_read(reg_base + REG_SCL_TOP_PG) >> 8) & 0xff;
+}
+
+void sclr_top_pg_late_clr(void)
+{
+	_reg_write_mask(reg_base + REG_SCL_TOP_PG, 0x0f0000, 0x80000);
+}
+
+union sclr_intr sclr_get_intr_mask(void)
+{
+	union sclr_intr intr_mask;
+
+	intr_mask.raw = _reg_read(reg_base + REG_SCL_TOP_INTR_MASK);
+	return intr_mask;
+}
+
+/**
+ * sclr_set_intr_mask - sclr's interrupt mask. Only enable ones will be
+ *			integrated to vip_subsys.  check 'union sclr_intr'
+ *			for each bit mask.
+ *
+ * @param intr_mask: On/Off ctrl of the interrupt.
+ */
+void sclr_set_intr_mask(union sclr_intr intr_mask)
+{
+	_reg_write(reg_base + REG_SCL_TOP_INTR_MASK, intr_mask.raw);
+}
+
+/**
+ * sclr_intr_clr - clear sclr's interrupt
+ *                 check 'union sclr_intr' for each bit mask
+ *
+ * @param intr_mask: On/Off ctrl of the interrupt.
+ */
+void sclr_intr_clr(union sclr_intr intr_mask)
+{
+	_reg_write(reg_base + REG_SCL_TOP_INTR_STATUS, intr_mask.raw);
+}
+
+/**
+ * sclr_intr_status - sclr's interrupt status
+ *                    check 'union sclr_intr' for each bit mask
+ *
+ * @return: The interrupt's status
+ */
+union sclr_intr sclr_intr_status(void)
+{
+	union sclr_intr status;
+
+	status.raw = (_reg_read(reg_base + REG_SCL_TOP_INTR_STATUS) & 0xffff);
+	return status;
+}
+
+/**
+ * sclr_img_set_trig - set img's src of job_start.
+ *
+ * @param inst: (0~1), the instance of img-in which want to be configured.
+ * @param trig_src: img's src of job_start.
+ */
+void sclr_img_set_trig(u8 inst, enum sclr_img_trig_src trig_src)
+{
+	u32 mask = BIT(12) | BIT(8);
+	u32 val = 0;
+
+	switch (trig_src) {
+	case SCL_IMG_TRIG_SRC_SW:
+		break;
+	case SCL_IMG_TRIG_SRC_DISP:
+		val |= BIT(8);
+		break;
+	case SCL_IMG_TRIG_SRC_ISP:
+		val |= BIT(12);
+		break;
+	default:
+		break;
+	}
+
+	if (inst == SCL_IMG_V) {
+		mask <<= 1;
+		val <<= 1;
+		g_top_cfg.img_in_v_trig_src = trig_src;
+	} else {
+		g_top_cfg.img_in_d_trig_src = trig_src;
+	}
+	//uartlog("mask(%#x) val(%#x)\n", mask, val);
+	_reg_write_mask(reg_base + REG_SCL_TOP_IMG_CTRL, mask, val);
+}
+
+/****************************************************************************
+ * SCALER GOP
+ ****************************************************************************/
+/**
+ * sclr_gop_set_cfg - configure gop
+ *
+ * @param inst: (0~4), the instance of gop which want to be configured.
+ *		0~3 is on scl, 4 is on disp.
+ * @param cfg: gop's settings
+ */
+void sclr_gop_set_cfg(u8 inst, struct sclr_gop_cfg *cfg)
+{
+	_reg_write(reg_base + REG_SCL_DISP_GOP_CFG, cfg->raw & 0xffff);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_FONTCOLOR,
+		   (cfg->font_fg_color << 16) | cfg->font_bg_color);
+	if (cfg->b.colorkey_en)
+		_reg_write(reg_base + REG_SCL_DISP_GOP_COLORKEY,
+			   cfg->colorkey);
+
+	g_disp_cfg.gop_cfg = *cfg;
+}
+
+/**
+ * sclr_gop_get_cfg - get gop's configurations.
+ *
+ * @param inst: (0~4), the instance of gop which want to be configured.
+ *		0~3 is on scl, 4 is on disp.
+ */
+struct sclr_gop_cfg *sclr_gop_get_cfg(u8 inst)
+{
+	return &g_disp_cfg.gop_cfg;
+
+	return NULL;
+}
+
+/**
+ * sclr_gop_setup LUT - setup gop's Look-up table
+ *
+ * @param inst: (0~4), the instance of gop which want to be configured.
+ *		0~3 is on scl, 4 is on disp.
+ * @param data: values of LUT-table. There should be 256 instances.
+ */
+void sclr_gop_setup_LUT(u8 inst, u16 *data)
+{
+	u16 i = 0;
+
+	for (i = 0; i < 256; ++i) {
+		_reg_write(reg_base + REG_SCL_DISP_GOP_LUT0,
+			   (i << 16) | *(data + i));
+		_reg_write(reg_base + REG_SCL_DISP_GOP_LUT1, (u32)~BIT(16));
+		_reg_write(reg_base + REG_SCL_DISP_GOP_LUT1, BIT(16));
+	}
+}
+
+/**
+ * sclr_gop_update_LUT - update gop's Look-up table by index.
+ *
+ * @param inst: (0~4), the instance of gop which want to be configured.
+ *		0~3 is on scl, 4 is on disp.
+ * @param index: start address of LUT-table. There should be 256 instances.
+ * @param data: value of LUT-table.
+ */
+int sclr_gop_update_LUT(u8 inst, u8 index, u16 data)
+{
+	if (index > 255)
+		return -1;
+
+	_reg_write(reg_base + REG_SCL_DISP_GOP_LUT0,
+		   (index << 16) | data);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_LUT1, (u32)~BIT(16));
+	_reg_write(reg_base + REG_SCL_DISP_GOP_LUT1, BIT(16));
+	return 0;
+}
+
+/**
+ * sclr_gop_ow_set_cfg - set gop's osd-window configurations.
+ *
+ * @param inst: (0~4), the instance of gop which want to be configured.
+ *		0~3 is on scl, 4 is on disp.
+ * @param ow_inst: (0~7), the instance of ow which want to be configured.
+ * @param cfg: ow's settings.
+ */
+void sclr_gop_ow_set_cfg(u8 inst, u8 ow_inst, struct sclr_gop_ow_cfg *cfg)
+{
+	static u8 reg_map_fmt[SCL_GOP_FMT_MAX] = {0, 0x4, 0x5, 0x8, 0xc};
+
+	_reg_write(reg_base + REG_SCL_DISP_GOP_FMT(ow_inst),
+		   reg_map_fmt[cfg->fmt]);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_H_RANGE(ow_inst),
+		   (cfg->end.x << 16) | cfg->start.x);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_V_RANGE(ow_inst),
+		   (cfg->end.y << 16) | cfg->start.y);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_ADDR_L(ow_inst),
+		   cfg->addr);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_ADDR_H(ow_inst),
+		   cfg->addr >> 32);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_PITCH(ow_inst),
+		   cfg->pitch);
+	_reg_write(reg_base + REG_SCL_DISP_GOP_SIZE(ow_inst),
+		   (cfg->mem_size.h << 16) | cfg->mem_size.w);
+
+	g_disp_cfg.gop_cfg.ow_cfg[ow_inst] = *cfg;
+}
+
+/****************************************************************************
+ * SCALER DISP
+ ****************************************************************************/
+/**
+ * sclr_disp_reg_shadow_sel - control the read reg-bank.
+ *
+ * @param read_shadow: true(shadow); false(working)
+ */
+void sclr_disp_reg_shadow_sel(bool read_shadow)
+{
+	_reg_write_mask(reg_base + REG_SCL_DISP_CFG, BIT(18),
+			(read_shadow ? 0x0 : BIT(18)));
+}
+
+/**
+ * sclr_disp_reg_shadow_mask - reg won't be update by sw/hw until unmask.
+ *
+ * @param mask: true(mask); false(unmask)
+ * @return: mask status before thsi modification.
+ */
+bool sclr_disp_reg_shadow_mask(bool mask)
+{
+	bool is_masked = (_reg_read(reg_base + REG_SCL_DISP_CFG) & BIT(17));
+
+	if (is_masked != mask)
+		_reg_write_mask(reg_base + REG_SCL_DISP_CFG, BIT(17),
+				(mask ? 0x0 : BIT(17)));
+
+	return is_masked;
+}
+
+/**
+ * sclr_disp_reg_force_up - trigger reg update by sw.
+ *
+ */
+void sclr_disp_reg_force_up(void)
+{
+	_reg_write_mask(reg_base + REG_SCL_DISP_CFG, BIT(16), BIT(16));
+}
+
+/**
+ * sclr_disp_tgen - enable timing-generator on disp.
+ *
+ * @param enable: AKA.
+ * @return: tgen's enable status before change.
+ */
+bool sclr_disp_tgen_enable(bool enable)
+{
+	bool is_enable = (_reg_read(reg_base + REG_SCL_DISP_CFG) & 0x80);
+
+	if (is_enable != enable) {
+		_reg_write_mask(reg_base + REG_SCL_DISP_CFG, 0x0080,
+				enable ? 0x80 : 0x00);
+		g_disp_cfg.tgen_en = enable;
+	}
+
+	return is_enable;
+}
+
+/**
+ * sclr_disp_set_cfg - set disp's configurations.
+ *
+ * @param cfg: disp's settings.
+ */
+void sclr_disp_set_cfg(struct sclr_disp_cfg *cfg)
+{
+	u32 tmp = 0;
+	bool is_enable = false;
+
+	tmp |= cfg->disp_from_sc;
+	tmp |= (cfg->fmt << 12);
+	if (cfg->sync_ext)
+		tmp |= BIT(4);
+	if (cfg->tgen_en)
+		tmp |= BIT(7);
+	if (cfg->dw1_en)
+		tmp |= BIT(8);
+	if (cfg->dw2_en)
+		tmp |= BIT(9);
+
+	is_enable = sclr_disp_reg_shadow_mask(false);
+	if (!cfg->disp_from_sc) {
+		sclr_disp_set_mem(&cfg->mem);
+		_reg_write_mask(reg_base + REG_SCL_DISP_PITCH_Y, 0xf0000000,
+				cfg->burst << 28);
+
+		sclr_disp_set_in_csc(cfg->in_csc);
+	}
+
+	sclr_disp_set_out_csc(cfg->out_csc);
+
+	_reg_write_mask(reg_base + REG_SCL_DISP_CFG, 0x0000ff9f, tmp);
+	_reg_write_mask(reg_base + REG_SCL_DISP_CACHE, BIT(0), cfg->cache_mode);
+
+	switch (cfg->out_bit) {
+	case 6:
+		tmp = 3 << 16;
+		break;
+	case 8:
+		tmp = 2 << 16;
+		break;
+	default:
+		tmp = 0;
+		break;
+	}
+	tmp |= cfg->drop_mode << 18;
+	_reg_write_mask(reg_base + REG_SCL_DISP_PAT_COLOR4, 0x000f0000, tmp);
+
+	if (is_enable)
+		sclr_disp_reg_shadow_mask(true);
+
+	g_disp_cfg = *cfg;
+}
+
+/**
+ * sclr_disp_get_cfg - get scl_disp's cfg
+ *
+ * @return: scl_disp's cfg
+ */
+struct sclr_disp_cfg *sclr_disp_get_cfg(void)
+{
+	return &g_disp_cfg;
+}
+
+/**
+ * sclr_disp_set_timing - modify disp's timing-generator.
+ *
+ * @param timing: new timing of disp.
+ */
+void sclr_disp_set_timing(struct sclr_disp_timing *timing)
+{
+	u32 tmp = 0;
+	bool is_enable = sclr_disp_tgen_enable(false);
+
+	if (timing->vsync_pol)
+		tmp |= 0x20;
+	if (timing->hsync_pol)
+		tmp |= 0x40;
+
+	_reg_write_mask(reg_base + REG_SCL_DISP_CFG, 0x0060, tmp);
+	_reg_write(reg_base + REG_SCL_DISP_TOTAL,
+		   (timing->htotal << 16) | timing->vtotal);
+	_reg_write(reg_base + REG_SCL_DISP_VSYNC,
+		   (timing->vsync_end << 16) | timing->vsync_start);
+	_reg_write(reg_base + REG_SCL_DISP_VFDE,
+		   (timing->vfde_end << 16) | timing->vfde_start);
+	_reg_write(reg_base + REG_SCL_DISP_VMDE,
+		   (timing->vmde_end << 16) | timing->vmde_start);
+	_reg_write(reg_base + REG_SCL_DISP_HSYNC,
+		   (timing->hsync_end << 16) | timing->hsync_start);
+	_reg_write(reg_base + REG_SCL_DISP_HFDE,
+		   (timing->hfde_end << 16) | timing->hfde_start);
+	_reg_write(reg_base + REG_SCL_DISP_HMDE,
+		   (timing->hmde_end << 16) | timing->hmde_start);
+
+	if (is_enable)
+		sclr_disp_tgen_enable(true);
+	disp_timing = *timing;
+}
+
+struct sclr_disp_timing *sclr_disp_get_timing(void)
+{
+	return &disp_timing;
+}
+
+/**
+ * sclr_disp_set_rect - setup rect(me) of disp
+ *
+ * @param rect: the pos/size of me, which should fit with disp's input.
+ */
+int sclr_disp_set_rect(struct sclr_rect rect)
+{
+	bool is_enable = sclr_disp_reg_shadow_mask(false);
+
+	if ((rect.y > disp_timing.vfde_end) ||
+	    (rect.x > disp_timing.hfde_end) ||
+	    ((disp_timing.vfde_start + rect.y + rect.h - 1) >
+	      disp_timing.vfde_end) ||
+	    ((disp_timing.hfde_start + rect.x + rect.w - 1) >
+	      disp_timing.hfde_end)) {
+		debug("[cvi-vip][sc] %s: me's pos(%d, %d) size(%d, %d) ",
+		      __func__, rect.x, rect.y, rect.w, rect.h);
+		debug(" out of range(%d, %d).\n",
+		      disp_timing.hfde_end, disp_timing.vfde_end);
+		return -EINVAL;
+	}
+
+	disp_timing.vmde_start = rect.y + disp_timing.vfde_start;
+	disp_timing.hmde_start = rect.x + disp_timing.hfde_start;
+	disp_timing.vmde_end = disp_timing.vmde_start + rect.h - 1;
+	disp_timing.hmde_end = disp_timing.hmde_start + rect.w - 1;
+
+	_reg_write(reg_base + REG_SCL_DISP_HMDE,
+		   (disp_timing.hmde_end << 16) | disp_timing.hmde_start);
+	_reg_write(reg_base + REG_SCL_DISP_VMDE,
+		   (disp_timing.vmde_end << 16) | disp_timing.vmde_start);
+
+	if (is_enable)
+		sclr_disp_reg_shadow_mask(true);
+
+	return 0;
+}
+
+/**
+ * sclr_disp_set_mem - setup disp's mem settings. Only work if disp from mem.
+ *
+ * @param mem: mem settings for disp
+ */
+void sclr_disp_set_mem(struct sclr_mem *mem)
+{
+	bool is_enable = sclr_disp_reg_shadow_mask(false);
+
+	_reg_write(reg_base + REG_SCL_DISP_OFFSET,
+		   (mem->start_y << 16) | mem->start_x);
+	_reg_write(reg_base + REG_SCL_DISP_SIZE,
+		   ((mem->height - 1) << 16) | (mem->width - 1));
+	_reg_write_mask(reg_base + REG_SCL_DISP_PITCH_Y, 0x00ffffff,
+			mem->pitch_y);
+	_reg_write(reg_base + REG_SCL_DISP_PITCH_C, mem->pitch_c);
+
+	sclr_disp_set_addr(mem->addr0, mem->addr1, mem->addr2);
+	if (is_enable)
+		sclr_disp_reg_shadow_mask(true);
+
+	g_disp_cfg.mem = *mem;
+}
+
+/**
+ * sclr_disp_set_addr - setup disp's mem address. Only work if disp from mem.
+ *
+ * @param addr0: address of planar0
+ * @param addr1: address of planar1
+ * @param addr2: address of planar2
+ */
+void sclr_disp_set_addr(u64 addr0, u64 addr1, u64 addr2)
+{
+	_reg_write(reg_base + REG_SCL_DISP_ADDR0_L, addr0);
+	_reg_write(reg_base + REG_SCL_DISP_ADDR0_H, addr0 >> 32);
+	_reg_write(reg_base + REG_SCL_DISP_ADDR1_L, addr1);
+	_reg_write(reg_base + REG_SCL_DISP_ADDR1_H, addr1 >> 32);
+	_reg_write(reg_base + REG_SCL_DISP_ADDR2_L, addr2);
+	_reg_write(reg_base + REG_SCL_DISP_ADDR2_H, addr2 >> 32);
+
+	g_disp_cfg.mem.addr0 = addr0;
+	g_disp_cfg.mem.addr1 = addr1;
+	g_disp_cfg.mem.addr2 = addr2;
+}
+
+/**
+ * sclr_disp_set_csc - configure disp's input CSC's coefficient/offset
+ *
+ * @param cfg: The settings for CSC
+ */
+void sclr_disp_set_csc(struct sclr_csc_matrix *cfg)
+{
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC0, BIT(31) |
+		   (cfg->coef[0][1] << 16) | (cfg->coef[0][0]));
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC1,
+		   (cfg->coef[1][0] << 16) | (cfg->coef[0][2]));
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC2,
+		   (cfg->coef[1][2] << 16) | (cfg->coef[1][1]));
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC3,
+		   (cfg->coef[2][1] << 16) | (cfg->coef[2][0]));
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC4, (cfg->coef[2][2]));
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC_SUB,
+		   (cfg->sub[2] << 16) | (cfg->sub[1] << 8) |
+		   cfg->sub[0]);
+	_reg_write(reg_base + REG_SCL_DISP_IN_CSC_ADD,
+		   (cfg->add[2] << 16) | (cfg->add[1] << 8) |
+		   cfg->add[0]);
+}
+
+/**
+ * sclr_disp_set_in_csc - setup disp's csc on input. Only work if disp from mem.
+ *
+ * @param csc: csc settings
+ */
+void sclr_disp_set_in_csc(enum sclr_csc csc)
+{
+	if (csc == SCL_CSC_NONE)
+		_reg_write(reg_base + REG_SCL_DISP_IN_CSC0, 0);
+	else if (csc < SCL_CSC_MAX)
+		sclr_disp_set_csc(&csc_mtrx[csc]);
+
+	g_disp_cfg.in_csc = csc;
+}
+
+/**
+ * sclr_disp_set_out_csc - setup disp's csc on output.
+ *
+ * @param csc: csc settings
+ */
+void sclr_disp_set_out_csc(enum sclr_csc csc)
+{
+	if (csc == SCL_CSC_NONE) {
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC0, 0);
+	} else if (csc < SCL_CSC_MAX) {
+		struct sclr_csc_matrix *cfg = &csc_mtrx[csc];
+
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC0, BIT(31) |
+			   (cfg->coef[0][1] << 16) | (cfg->coef[0][0]));
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC1,
+			   (cfg->coef[1][0] << 16) | (cfg->coef[0][2]));
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC2,
+			   (cfg->coef[1][2] << 16) | (cfg->coef[1][1]));
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC3,
+			   (cfg->coef[2][1] << 16) | (cfg->coef[2][0]));
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC4, (cfg->coef[2][2]));
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC_SUB,
+			   (cfg->sub[2] << 16) | (cfg->sub[1] << 8) |
+			   cfg->sub[0]);
+		_reg_write(reg_base + REG_SCL_DISP_OUT_CSC_ADD,
+			   (cfg->add[2] << 16) | (cfg->add[1] << 8) |
+			   cfg->add[0]);
+	}
+
+	g_disp_cfg.out_csc = csc;
+}
+
+/**
+ * sclr_disp_set_pattern - setup disp's pattern generator.
+ *
+ * @param type: type of pattern
+ * @param color: color of pattern. Only for Gradient/FULL type.
+ */
+void sclr_disp_set_pattern(enum sclr_disp_pat_type type,
+			   enum sclr_disp_pat_color color, const u16 *rgb)
+{
+	switch (type) {
+	case SCL_PAT_TYPE_OFF:
+		_reg_write_mask(reg_base + REG_SCL_DISP_PAT_CFG, 0x16, 0);
+		break;
+
+	case SCL_PAT_TYPE_SNOW:
+		_reg_write_mask(reg_base + REG_SCL_DISP_PAT_CFG, 0x16, 0x10);
+		break;
+
+	case SCL_PAT_TYPE_AUTO:
+		_reg_write(reg_base + REG_SCL_DISP_PAT_COLOR0, 0x03ff03ff);
+		_reg_write_mask(reg_base + REG_SCL_DISP_PAT_COLOR1, 0x000003ff, 0x3ff);
+		_reg_write_mask(reg_base + REG_SCL_DISP_PAT_CFG, 0xff0016,
+				0x780006);
+		break;
+
+	case SCL_PAT_TYPE_V_GRAD:
+	case SCL_PAT_TYPE_H_GRAD:
+	case SCL_PAT_TYPE_FULL: {
+		if (color == SCL_PAT_COLOR_USR) {
+			_reg_write(reg_base + REG_SCL_DISP_PAT_COLOR0, rgb[1] << 16 | rgb[0]);
+			_reg_write_mask(reg_base + REG_SCL_DISP_PAT_COLOR1, 0x000003ff, rgb[2]);
+			_reg_write_mask(reg_base + REG_SCL_DISP_PAT_CFG, 0x1f000016,
+					(type << 27) | (SCL_PAT_COLOR_WHITE << 24) | 0x0002);
+		} else {
+			_reg_write(reg_base + REG_SCL_DISP_PAT_COLOR0, 0x03ff03ff);
+			_reg_write_mask(reg_base + REG_SCL_DISP_PAT_COLOR1, 0x000003ff, 0x3ff);
+			_reg_write_mask(reg_base + REG_SCL_DISP_PAT_CFG, 0x1f000016,
+					(type << 27) | (color << 24) | 0x0002);
+		}
+		break;
+	}
+	default:
+		debug("%s - unacceptiable pattern-type(%d)\n", __func__, type);
+		break;
+	}
+}
+
+/**
+ * sclr_disp_set_frame_bgcolro - setup disp frame(area outside mde)'s
+ *				 background color.
+ *
+ * @param r: 10bit red value
+ * @param g: 10bit green value
+ * @param b: 10bit blue value
+ */
+void sclr_disp_set_frame_bgcolor(u16 r, u16 g, u16 b)
+{
+	_reg_write_mask(reg_base + REG_SCL_DISP_PAT_COLOR1, 0x0fff0000,
+			r << 16);
+	_reg_write(reg_base + REG_SCL_DISP_PAT_COLOR2, b << 16 | g);
+}
+
+/**
+ * sclr_disp_set_window_bgcolro - setup disp window's background color.
+ *
+ * @param r: 10bit red value
+ * @param g: 10bit green value
+ * @param b: 10bit blue value
+ */
+void sclr_disp_set_window_bgcolor(u16 r, u16 g, u16 b)
+{
+	_reg_write(reg_base + REG_SCL_DISP_PAT_COLOR3, g << 16 | r);
+	_reg_write_mask(reg_base + REG_SCL_DISP_PAT_COLOR4, 0x0fff, b);
+}
+
+/**
+ * sclr_disp_enable_window_bgcolor - Use window bg-color to hide everything
+ *				     including test-pattern.
+ *
+ * @param enable: enable window bgcolor or not.
+ */
+void sclr_disp_enable_window_bgcolor(bool enable)
+{
+	_reg_write_mask(reg_base + REG_SCL_DISP_PAT_CFG, 0x20, enable ? 0x20 : 0);
+}
+
+union sclr_disp_dbg_status sclr_disp_get_dbg_status(bool clr)
+{
+	union sclr_disp_dbg_status status;
+
+	status.raw = _reg_read(reg_base + REG_SCL_DISP_DBG);
+
+	if (clr) {
+		status.b.err_fwr_clr = 1;
+		status.b.err_erd_clr = 1;
+		status.b.bw_fail_clr = 1;
+		_reg_write(reg_base + REG_SCL_DISP_DBG, status.raw);
+	}
+
+	return status;
+}
+
+void sclr_disp_gamma_ctrl(bool enable, bool pre_osd)
+{
+	u32 value = 0;
+
+	if (enable)
+		value |= 0x04;
+	if (pre_osd)
+		value |= 0x08;
+	_reg_write_mask(reg_base + REG_SCL_DISP_GAMMA_CTRL, 0x0C, value);
+}
+
+void sclr_disp_gamma_lut_update(const u8 *b, const u8 *g, const u8 *r)
+{
+	u8 i;
+	u32 value;
+
+	_reg_write_mask(reg_base + REG_SCL_DISP_GAMMA_CTRL, 0x03, 0x03);
+
+	for (i = 0; i < 65; ++i) {
+		value = *(b + i) | (*(g + i) << 8) | (*(r + i) << 16)
+			| (i << 24) | 0x80000000;
+		_reg_write(reg_base + REG_SCL_DISP_GAMMA_WR_LUT, value);
+	}
+
+	_reg_write_mask(reg_base + REG_SCL_DISP_GAMMA_CTRL, 0x03, 0x00);
+}
+
+void sclr_lvdstx_set(union sclr_lvdstx cfg)
+{
+	_reg_write(reg_base + REG_SCL_TOP_LVDSTX, cfg.raw);
+}
+
+void sclr_lvdstx_get(union sclr_lvdstx *cfg)
+{
+	cfg->raw = _reg_read(reg_base + REG_SCL_TOP_LVDSTX);
+}
+
+void sclr_bt_set(union sclr_bt_enc enc, union sclr_bt_sync_code sync)
+{
+	_reg_write(reg_base + REG_SCL_TOP_BT_ENC, enc.raw);
+	_reg_write(reg_base + REG_SCL_TOP_BT_SYNC_CODE, sync.raw);
+}
+
+void sclr_bt_get(union sclr_bt_enc *enc, union sclr_bt_sync_code *sync)
+{
+	enc->raw = _reg_read(reg_base + REG_SCL_TOP_BT_ENC);
+	sync->raw = _reg_read(reg_base + REG_SCL_TOP_BT_SYNC_CODE);
+}
+
+void sclr_disp_mux_sel(enum sclr_vo_sel sel)
+{
+	_reg_write_mask(reg_base + REG_SCL_TOP_VO_MUX, 0x07, sel);
+}
+
+void sclr_disp_set_intf(enum sclr_vo_intf intf)
+{
+	bool data_en[5] = {true, true, true, true};
+
+	if (intf == SCLR_VO_INTF_DISABLE)
+		_reg_write_mask(0x03002840, 0xa, 0);
+	else
+		_reg_write_mask(0x03002840, 0xa, 0xa);
+
+	dphy_init(intf);
+
+	if (intf == SCLR_VO_INTF_DISABLE) {
+		sclr_disp_mux_sel(SCLR_VO_SEL_DISABLE);
+	} else if ((intf == SCLR_VO_INTF_BT601) || (intf == SCLR_VO_INTF_BT656) || (intf == SCLR_VO_INTF_BT1120)) {
+		if (intf == SCLR_VO_INTF_BT601)
+			sclr_disp_mux_sel(SCLR_VO_SEL_BT601);
+		else if (intf == SCLR_VO_INTF_BT656)
+			sclr_disp_mux_sel(SCLR_VO_SEL_BT656);
+		else if (intf == SCLR_VO_INTF_BT1120)
+			sclr_disp_mux_sel(SCLR_VO_SEL_BT1120);
+		dphy_dsi_lane_en(true, data_en, false);
+	} else if (intf == SCLR_VO_INTF_I80) {
+		sclr_disp_mux_sel(SCLR_VO_SEL_I80);
+		dphy_dsi_lane_en(true, data_en, false);
+		_reg_write_mask(reg_base + REG_SCL_DISP_MCU_IF_CTRL, BIT(0), 1);
+	} else if (intf == SCLR_VO_INTF_SW) {
+		sclr_disp_mux_sel(SCLR_VO_SEL_SW);
+	} else if (intf == SCLR_VO_INTF_MIPI) {
+		sclr_disp_mux_sel(SCLR_VO_SEL_DISABLE);
+	} else if (intf == SCLR_VO_INTF_LVDS) {
+		sclr_disp_mux_sel(SCLR_VO_SEL_DISABLE);
+	}
+}
+
+/**
+ * sclr_dsi_get_mode - get current dsi mode
+ *
+ * @return: current dsi mode
+ */
+enum sclr_dsi_mode sclr_dsi_get_mode(void)
+{
+	return (_reg_read(reg_base + REG_SCL_DSI_MAC_EN) & 0x0f);
+}
+
+/**
+ * sclr_dsi_clr_mode - let dsi back to idle mode
+ *
+ */
+void sclr_dsi_clr_mode(void)
+{
+	u32 mode = _reg_read(reg_base + REG_SCL_DSI_MAC_EN);
+
+	if (mode != SCLR_DSI_MODE_IDLE)
+		_reg_write(reg_base + REG_SCL_DSI_MAC_EN, mode);
+}
+
+/**
+ * sclr_dsi_set_mode - set dsi mode
+ *
+ * @param mode: new dsi mode except for idle
+ * @return: 0 if success
+ */
+int sclr_dsi_set_mode(enum sclr_dsi_mode mode)
+{
+	if (mode >= SCLR_DSI_MODE_MAX)
+		return -1;
+
+	if (mode == SCLR_DSI_MODE_IDLE) {
+		sclr_dsi_clr_mode();
+		return 0;
+	}
+
+	if (_reg_read(reg_base + REG_SCL_DSI_MAC_EN))
+		return -1;
+
+	_reg_write(reg_base + REG_SCL_DSI_MAC_EN, mode);
+	return 0;
+}
+
+/**
+ * sclr_dsi_chk_mode_done - check if dsi's work done.
+ *
+ * @param mode: the mode to check.
+ * @return: 0 if success
+ */
+int sclr_dsi_chk_mode_done(enum sclr_dsi_mode mode)
+{
+	u32 val = 0;
+
+	if ((mode == SCLR_DSI_MODE_ESC) || (mode == SCLR_DSI_MODE_SPKT)) {
+		val = _reg_read(reg_base + REG_SCL_DSI_MAC_EN) & 0xf0;
+		return (val ^ (mode << 4)) ? -1 : 0;
+	}
+
+	if ((mode == SCLR_DSI_MODE_IDLE) || (mode == SCLR_DSI_MODE_HS)) {
+		val = _reg_read(reg_base + REG_SCL_DSI_MAC_EN) & 0x0f;
+		return (val == (mode)) ? 0 : -1;
+	}
+
+	return -1;
+}
+
+int _dsi_chk_and_clean_mode(enum sclr_dsi_mode mode)
+{
+	int i, ret;
+
+	for (i = 0; i < 5; ++i) {
+		udelay(20);
+		ret = sclr_dsi_chk_mode_done(mode);
+		if (ret == 0) {
+			sclr_dsi_clr_mode();
+			break;
+		}
+	}
+	return ret;
+}
+
+#define POLY 0x8408
+/*
+ *                                      16   12   5
+ * this is the CCITT CRC 16 polynomial X  + X  + X  + 1.
+ * This works out to be 0x1021, but the way the algorithm works
+ * lets us use 0x8408 (the reverse of the bit pattern).  The high
+ * bit is always assumed to be set, thus we only use 16 bits to
+ * represent the 17 bit value.
+ */
+static u16 crc16(unsigned char *data_p, unsigned short length)
+{
+	u8 i, data;
+	u16 crc = 0xffff;
+
+	if (length == 0)
+		return (~crc);
+
+	do {
+		for (i = 0, data = 0xff & *data_p++; i < 8; i++, data >>= 1) {
+			if ((crc & 0x0001) ^ (data & 0x0001))
+				crc = (crc >> 1) ^ POLY;
+			else
+				crc >>= 1;
+		}
+	} while (--length);
+
+	return crc;
+}
+
+static unsigned char ecc(unsigned char *data)
+{
+	char D0, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12;
+	char D13, D14, D15, D16, D17, D18, D19, D20, D21, D22, D23;
+	char P0, P1, P2, P3, P4, P5, P6, P7;
+
+	D0  = data[0] & 0x01;
+	D1  = (data[0] >> 1) & 0x01;
+	D2  = (data[0] >> 2) & 0x01;
+	D3  = (data[0] >> 3) & 0x01;
+	D4  = (data[0] >> 4) & 0x01;
+	D5  = (data[0] >> 5) & 0x01;
+	D6  = (data[0] >> 6) & 0x01;
+	D7  = (data[0] >> 7) & 0x01;
+
+	D8  = data[1] & 0x01;
+	D9  = (data[1] >> 1) & 0x01;
+	D10 = (data[1] >> 2) & 0x01;
+	D11 = (data[1] >> 3) & 0x01;
+	D12 = (data[1] >> 4) & 0x01;
+	D13 = (data[1] >> 5) & 0x01;
+	D14 = (data[1] >> 6) & 0x01;
+	D15 = (data[1] >> 7) & 0x01;
+
+	D16 = data[2] & 0x01;
+	D17 = (data[2] >> 1) & 0x01;
+	D18 = (data[2] >> 2) & 0x01;
+	D19 = (data[2] >> 3) & 0x01;
+	D20 = (data[2] >> 4) & 0x01;
+	D21 = (data[2] >> 5) & 0x01;
+	D22 = (data[2] >> 6) & 0x01;
+	D23 = (data[2] >> 7) & 0x01;
+
+	P7 = 0;
+	P6 = 0;
+	P5 = (D10 ^ D11 ^ D12 ^ D13 ^ D14 ^ D15 ^ D16 ^ D17 ^ D18 ^ D19 ^ D21 ^ D22 ^ D23) & 0x01;
+	P4 = (D4 ^ D5 ^ D6 ^ D7 ^ D8 ^ D9 ^ D16 ^ D17 ^ D18 ^ D19 ^ D20 ^ D22 ^ D23) & 0x01;
+	P3 = (D1 ^ D2 ^ D3 ^ D7 ^ D8 ^ D9 ^ D13 ^ D14 ^ D15 ^ D19 ^ D20 ^ D21 ^ D23) & 0x01;
+	P2 = (D0 ^ D2 ^ D3 ^ D5 ^ D6 ^ D9 ^ D11 ^ D12 ^ D15 ^ D18 ^ D20 ^ D21 ^ D22) & 0x01;
+	P1 = (D0 ^ D1 ^ D3 ^ D4 ^ D6 ^ D8 ^ D10 ^ D12 ^ D14 ^ D17 ^ D20 ^ D21 ^ D22 ^ D23) & 0x01;
+	P0 = (D0 ^ D1 ^ D2 ^ D4 ^ D5 ^ D7 ^ D10 ^ D11 ^ D13 ^ D16 ^ D20 ^ D21 ^ D22 ^ D23) & 0x01;
+
+	return (P7 << 7) | (P6 << 6) | (P5 << 5) | (P4 << 4) |
+		(P3 << 3) | (P2 << 2) | (P1 << 1) | P0;
+}
+
+/**
+ * sclr_dsi_long_packet_raw - send dsi long packet by escapet-lpdt.
+ *
+ * @param data: long packet data including header and crc.
+ * @param count: number of long packet data, 16 at most.
+ * @return: 0 if success
+ */
+int sclr_dsi_long_packet_raw(const u8 *data, u8 count)
+{
+	u64 addr = reg_base + REG_SCL_DSI_ESC_TX0;
+	u32 val = 0;
+	u8 i = 0;
+
+	if ((count > SCL_MAX_DSI_LP) || (count == 0)) {
+		debug("%s: count(%d) invalid\n", __func__, count);
+		return -1;
+	}
+
+	val = 0x01 | ((count - 1) << 8);
+	_reg_write(reg_base + REG_SCL_DSI_ESC, val);
+	for (i = 0; i < count; i += 4) {
+		if (count - i < 4) {
+			val = 0;
+			memcpy(&val, &data[i], count - i);
+			_reg_write(addr + i, val);
+			break;
+		}
+		memcpy(&val, &data[i], 4);
+		_reg_write(addr + i, val);
+	}
+
+	sclr_dsi_set_mode(SCLR_DSI_MODE_ESC);
+	return _dsi_chk_and_clean_mode(SCLR_DSI_MODE_ESC);
+}
+
+/**
+ * sclr_dsi_long_packet - send dsi long packet by escapet-lpdt.
+ *
+ * @param di: data ID
+ * @param data: long packet data
+ * @param count: number of long packet data, 100 at most.
+ * @param sw_mode: use sw-overwrite to create dcs cmd
+ * @return: 0 if success
+ */
+int sclr_dsi_long_packet(u8 di, const u8 *data, u8 count, bool sw_mode)
+{
+	u8 packet[100] = {di, count, 0, 0};
+	u16 crc;
+
+	packet[3] = ecc(packet);
+	memcpy(&packet[4], data, count);
+	count += 4;
+	crc = crc16(packet, count);
+	packet[count++] = crc & 0xff;
+	packet[count++] = crc >> 8;
+
+	if (!sw_mode && count < SCL_MAX_DSI_LP)
+		return sclr_dsi_long_packet_raw(packet, count);
+
+	dpyh_mipi_tx_manual_packet(packet, count);
+	return 0;
+}
+
+/**
+ * sclr_dsi_short_packet - send dsi short packet by escapet-lpdt.
+ *   *NOTE*: ecc is hw-generated.
+ *
+ * @param di: data ID
+ * @param data: short packet data
+ * @param count: number of short packet data, 1 or 2.
+ * @param sw_mode: use sw-overwrite to create dcs cmd
+ * @return: 0 if success
+ */
+int sclr_dsi_short_packet(u8 di, const u8 *data, u8 count, bool sw_mode)
+{
+	u32 val = 0;
+
+	if ((count > SCL_MAX_DSI_SP) || (count == 0))
+		return -1;
+
+	val = di;
+	if (count == 2) {
+		//val = 0x15;
+		val |= (data[0] << 8) | (data[1] << 16);
+	} else {
+		//val = 0x05;
+		val |= data[0] << 8;
+	}
+
+	if (!sw_mode) {
+		_reg_write_mask(reg_base + REG_SCL_DSI_HS_0, 0x00ffffff, val);
+		sclr_dsi_set_mode(SCLR_DSI_MODE_SPKT);
+		return _dsi_chk_and_clean_mode(SCLR_DSI_MODE_SPKT);
+	}
+
+	val |= (ecc((u8 *)&val) << 24);
+	dpyh_mipi_tx_manual_packet((u8 *)&val, 4);
+	return 0;
+}
+
+/**
+ * sclr_dsi_dcs_write_buffer - send dsi packet by escapet-lpdt.
+ *
+ * @param di: data ID
+ * @param data: packet data
+ * @param count: number of packet data
+ * @param sw_mode: use sw-overwrite to create dcs cmd
+ * @return: Zero on success or a negative error code on failure.
+ */
+int sclr_dsi_dcs_write_buffer(u8 di, const void *data, size_t len, bool sw_mode)
+{
+	if (len == 0) {
+		debug("[cvi_mipi_tx] %s: 0 param unacceptable.\n", __func__);
+		return -1;
+	}
+
+	if ((di == 0x06) || (di == 0x05) || (di == 0x04) || (di == 0x03)) {
+		if (len != 1) {
+			debug("[cvi_mipi_tx] %s: cmd(0x%02x) should has 1 param.\n", __func__, di);
+			return -1;
+		}
+		return sclr_dsi_short_packet(di, data, len, sw_mode);
+	}
+	if ((di == 0x15) || (di == 0x37) || (di == 0x13) || (di == 0x14)) {
+		if (len != 2) {
+			debug("[cvi_mipi_tx] %s: cmd(0x%02x) should has 2 param.\n", __func__, di);
+			return -1;
+		}
+		return sclr_dsi_short_packet(di, data, len, sw_mode);
+	}
+	if ((di == 0x29) || (di == 0x39))
+		return sclr_dsi_long_packet(di, data, len, sw_mode);
+
+	return sclr_dsi_long_packet(di, data, len, sw_mode);
+}
+
+#define ACK_WR       0x02
+#define GEN_READ_LP  0x1A
+#define GEN_READ_SP1 0x11
+#define GEN_READ_SP2 0x12
+#define DCS_READ_LP  0x1C
+#define DCS_READ_SP1 0x21
+#define DCS_READ_SP2 0x22
+
+int sclr_dsi_dcs_read_buffer(u8 di, const u16 data_param, u8 *data, size_t len, bool sw_mode)
+{
+	int ret = 0;
+	u32 rx_data;
+	int i = 0;
+
+	if (len > 4)
+		len = 4;
+
+	if (sclr_dsi_get_mode() == SCLR_DSI_MODE_HS) {
+		debug("[cvi_mipi_tx] %s: not work in HS.\n", __func__);
+		return -1;
+	}
+
+	_reg_write(reg_base + REG_SCL_DSI_ESC, 0x04);
+
+	// send read cmd
+	sclr_dsi_short_packet(di, (u8 *)&data_param, 2, sw_mode);
+
+	// goto BTA
+	sclr_dsi_set_mode(SCLR_DSI_MODE_ESC);
+	udelay(20);
+	ret = sclr_dsi_chk_mode_done(SCLR_DSI_MODE_ESC);
+	if (ret == 0) {
+		sclr_dsi_clr_mode();
+	} else {
+		debug("[cvi_mipi_tx] %s: BTA error.\n", __func__);
+		return ret;
+	}
+
+	// check result
+	rx_data = _reg_read(reg_base + REG_SCL_DSI_ESC_RX0);
+	switch (rx_data & 0xff) {
+	case GEN_READ_SP1:
+	case DCS_READ_SP1:
+		data[0] = (rx_data >> 8) & 0xff;
+		break;
+	case GEN_READ_SP2:
+	case DCS_READ_SP2:
+		data[0] = (rx_data >> 8) & 0xff;
+		data[1] = (rx_data >> 16) & 0xff;
+		break;
+	case GEN_READ_LP:
+	case DCS_READ_LP:
+		rx_data = _reg_read(reg_base + REG_SCL_DSI_ESC_RX1);
+		for (i = 0; i < len; ++i)
+			data[i] = (rx_data >> (i * 8)) & 0xff;
+		break;
+	case ACK_WR:
+		debug("[cvi_mipi_tx] %s: dcs read, ack with error(%#x %#x).\n"
+			, __func__, (rx_data >> 8) & 0xff, (rx_data >> 16) & 0xff);
+		ret = -1;
+		break;
+	default:
+		debug("[cvi_mipi_tx] %s: unknown DT, %#x.", __func__, rx_data);
+		ret = -1;
+		break;
+	}
+
+	//debug("%s: %#x %#x\n", __func__, rx_data0, rx_data1);
+	return ret;
+}
+
+int sclr_dsi_config(u8 lane_num, enum sclr_dsi_fmt fmt, u16 width)
+{
+	u32 val = 0;
+	u8 bit_depth[] = {24, 18, 16, 30};
+
+	if ((lane_num != 1) && (lane_num != 2) && (lane_num != 4))
+		return -EINVAL;
+	if (fmt > SCLR_DSI_FMT_MAX)
+		return -EINVAL;
+
+	lane_num >>= 1;
+	val = (fmt << 30) | (lane_num << 24);
+	_reg_write_mask(reg_base + REG_SCL_DSI_HS_0, 0xc3000000, val);
+	val = (width / 6) << 16 | ((width * bit_depth[fmt] + 7) >> 3);
+	_reg_write(reg_base + REG_SCL_DSI_HS_1, val);
+
+	return 0;
+}
+
+void sclr_i80_sw_mode(bool enable)
+{
+	_reg_write_mask(reg_base + REG_SCL_DISP_MCU_IF_CTRL, BIT(11) | BIT(1), enable ? 0x802 : 0x000);
+
+	if (enable) {
+		sclr_disp_tgen_enable(true);
+		mdelay(40);
+		sclr_disp_tgen_enable(false);
+	}
+}
+
+void sclr_i80_packet(u32 cmd)
+{
+	u8 cnt = 0;
+
+	_reg_write(reg_base + REG_SCL_DISP_MCU_SW_CTRL, cmd);
+	_reg_write_mask(reg_base + REG_SCL_DISP_MCU_SW_CTRL, BIT(31), BIT(31));
+
+	do {
+		udelay(1);
+		if (_reg_read(reg_base + REG_SCL_DISP_MCU_SW_CTRL) & BIT(24))
+			break;
+	} while (++cnt < 10);
+
+	if (cnt == 10)
+		debug("[cvi_vip] %s: cmd(%#x) not ready.\n", __func__, cmd);
+}
+
+void sclr_i80_run(void)
+{
+	u8 cnt = 0;
+
+	_reg_write_mask(reg_base + REG_SCL_DISP_MCU_IF_CTRL, BIT(11), BIT(11));
+
+	do {
+		udelay(5 * 1000);
+		if (_reg_read(reg_base + REG_SCL_DISP_MCU_STATUS) == 0x08)
+			break;
+	} while (++cnt < 10);
+
+	if (cnt == 10) {
+		debug("[cvi_vip] %s: not finish. sw clear it.\n", __func__);
+		_reg_write_mask(reg_base + REG_SCL_DISP_MCU_IF_CTRL, BIT(10), BIT(10));
+	}
+}
+
+/****************************************************************************
+ * SCALER CTRL
+ ****************************************************************************/
+/**
+ * sclr_ctrl_init - setup all sc instances.
+ *
+ */
+void sclr_ctrl_init(void)
+{
+	union sclr_intr intr_mask;
+	bool disp_from_sc = false;
+
+	// init variables
+	memset(&g_top_cfg, 0, sizeof(g_top_cfg));
+	memset(&g_disp_cfg, 0, sizeof(g_disp_cfg));
+	memset(&disp_timing, 0, sizeof(disp_timing));
+
+	g_top_cfg.ip_trig_src = true;
+	g_top_cfg.sclr_enable[0] = false;
+	g_top_cfg.sclr_enable[1] = false;
+	g_top_cfg.sclr_enable[2] = false;
+	g_top_cfg.sclr_enable[3] = false;
+	g_top_cfg.disp_enable = false;
+	g_top_cfg.disp_from_sc = disp_from_sc;
+	g_top_cfg.img_in_d_trig_src = SCL_IMG_TRIG_SRC_SW;
+	g_top_cfg.img_in_v_trig_src = SCL_IMG_TRIG_SRC_SW;
+	g_disp_cfg.disp_from_sc = disp_from_sc;
+	g_disp_cfg.cache_mode = true;
+	g_disp_cfg.sync_ext = false;
+	g_disp_cfg.tgen_en = false;
+	g_disp_cfg.fmt = SCL_FMT_RGB_PLANAR;
+	g_disp_cfg.in_csc = SCL_CSC_NONE;
+	g_disp_cfg.out_csc = SCL_CSC_NONE;
+	g_disp_cfg.burst = 7;
+	g_disp_cfg.out_bit = 8;
+	g_disp_cfg.drop_mode = SCL_DISP_DROP_MODE_DITHER;
+
+	// init hw
+	sclr_top_set_cfg(&g_top_cfg);
+
+	sclr_disp_reg_shadow_sel(false);
+	sclr_disp_tgen_enable(false);
+	sclr_disp_set_cfg(&g_disp_cfg);
+
+	intr_mask.b.img_in_d_frame_end = true;
+	intr_mask.b.img_in_v_frame_end = true;
+	intr_mask.b.scl0_frame_end = true;
+	intr_mask.b.scl1_frame_end = true;
+	intr_mask.b.scl2_frame_end = true;
+	intr_mask.b.scl3_frame_end = true;
+	intr_mask.b.prog_too_late = true;
+	intr_mask.b.cmdq = true;
+	intr_mask.b.disp_frame_end = true;
+	sclr_set_intr_mask(intr_mask);
+
+	sclr_top_reg_done();
+	sclr_top_reg_force_up();
+	sclr_top_pg_late_clr();
+}
+
+/**
+ * sclr_ctrl_set_disp_src - setup input-src of disp.
+ *
+ * @param disp_from_sc: true(from sc_0); false(from mem)
+ * @return: 0 if success
+ */
+int sclr_ctrl_set_disp_src(bool disp_from_sc)
+{
+	g_top_cfg.disp_from_sc = disp_from_sc;
+	g_disp_cfg.disp_from_sc = disp_from_sc;
+
+	sclr_top_set_cfg(&g_top_cfg);
+	sclr_disp_set_cfg(&g_disp_cfg);
+
+	return 0;
+}
+
+int set_disp_ctrl_gpios(struct disp_ctrl_gpios *ctrl_gpios)
+{
+	g_disp_cfg.ctrl_gpios = *ctrl_gpios;
+
+	return 0;
+}
+
+int get_disp_ctrl_gpios(struct disp_ctrl_gpios *ctrl_gpios)
+{
+	*ctrl_gpios = g_disp_cfg.ctrl_gpios;
+
+	return 0;
+}
+
diff --git a/drivers/video/cvitek/scaler.h b/drivers/video/cvitek/scaler.h
new file mode 100644
index 000000000..8b1191a5f
--- /dev/null
+++ b/drivers/video/cvitek/scaler.h
@@ -0,0 +1,488 @@
+#ifndef _CVI_SCL_H_
+#define _CVI_SCL_H_
+
+#include <asm/gpio.h>
+
+#define SCL_INTR_SCL_NUM 139
+#define SCL_MAX_INST 4
+#define SCL_MIN_WIDTH  32
+#define SCL_MIN_HEIGHT 32
+#define SCL_MAX_WIDTH  2688
+#define SCL_MAX_HEIGHT 2688
+#define SCL_MAX_DSI_LP 16
+#define SCL_MAX_DSI_SP 2
+
+struct sclr_size {
+	u16 w;
+	u16 h;
+};
+
+struct sclr_point {
+	u16 x;
+	u16 y;
+};
+
+struct sclr_rect {
+	u16 x;
+	u16 y;
+	u16 w;
+	u16 h;
+};
+
+struct sclr_status {
+	u8 crop_idle : 1;
+	u8 hscale_idle : 1;
+	u8 vscale_idle : 1;
+	u8 gop_idle : 1;
+	u8 wdma_idle : 1;
+	u8 rsv : 2;
+};
+
+enum sclr_img_in {
+	SCL_IMG_V,  // for video-encoder
+	SCL_IMG_D,  // for display
+	SCL_IMG_MAX,
+};
+
+struct sclr_csc_matrix {
+	u16 coef[3][3];
+	u8 sub[3];
+	u8 add[3];
+};
+
+union sclr_intr {
+	struct {
+		u32 disp_frame_start : 1;
+		u32 disp_frame_end : 1;
+		u32 img_in_d_frame_start : 1;
+		u32 img_in_d_frame_end : 1;
+		u32 img_in_v_frame_start : 1;
+		u32 img_in_v_frame_end : 1;
+		u32 scl0_frame_end : 1;
+		u32 scl1_frame_end : 1;
+		u32 scl2_frame_end : 1;
+		u32 scl3_frame_end : 1;
+		u32 prog_too_late : 1;
+		u32 scl0_line_target_hit : 1;
+		u32 scl1_line_target_hit : 1;
+		u32 scl2_line_target_hit : 1;
+		u32 scl3_line_target_hit : 1;
+		u32 scl0_cycle_line_target_hit : 1;
+		u32 scl1_cycle_line_target_hit : 1;
+		u32 scl2_cycle_line_target_hit : 1;
+		u32 scl3_cycle_line_target_hit : 1;
+		u32 map_cv_frame_end : 1;
+		u32 cmdq : 1;
+		u32 cmdq_start : 1;
+		u32 cmdq_end : 1;
+		u32 cmdq_lint_hit : 1;
+		u32 cmdq_cycle_line_hit : 1;
+	} b;
+	u32 raw;
+};
+
+enum sclr_format {
+	SCL_FMT_YUV420,
+	SCL_FMT_YUV422,
+	SCL_FMT_RGB_PLANAR,
+	SCL_FMT_BGR_PACKED, // B lsb
+	SCL_FMT_RGB_PACKED, // R lsb
+	SCL_FMT_Y_ONLY,
+	SCL_FMT_MAX
+};
+
+enum sclr_csc {
+	SCL_CSC_NONE,
+	SCL_CSC_601_LIMIT_YUV2RGB,
+	SCL_CSC_601_FULL_YUV2RGB,
+	SCL_CSC_709_LIMIT_YUV2RGB,
+	SCL_CSC_709_FULL_YUV2RGB,
+	SCL_CSC_601_LIMIT_RGB2YUV,
+	SCL_CSC_601_FULL_RGB2YUV,
+	SCL_CSC_709_LIMIT_RGB2YUV,
+	SCL_CSC_709_FULL_RGB2YUV,
+	SCL_CSC_MAX,
+};
+
+enum sclr_gop_format {
+	SCL_GOP_FMT_ARGB8888,
+	SCL_GOP_FMT_ARGB4444,
+	SCL_GOP_FMT_ARGB1555,
+	SCL_GOP_FMT_256LUT,
+	SCL_GOP_FMT_FONT,
+	SCL_GOP_FMT_MAX
+};
+
+enum sclr_disp_drop_mode {
+	SCL_DISP_DROP_MODE_DITHER = 1,
+	SCL_DISP_DROP_MODE_ROUNDING = 2,
+	SCL_DISP_DROP_MODE_DROP = 3,
+	SCL_DISP_DROP_MODE_MAX,
+};
+
+enum sclr_img_trig_src {
+	SCL_IMG_TRIG_SRC_SW = 0,
+	SCL_IMG_TRIG_SRC_DISP,
+	SCL_IMG_TRIG_SRC_ISP,
+	SCL_IMG_TRIG_SRC_MAX,
+};
+
+struct sclr_top_cfg {
+	bool ip_trig_src;    // 0(IMG_V), 1(IMG_D)
+	bool sclr_enable[4];
+	bool disp_enable;
+	bool disp_from_sc;   // 0(DRAM), 1(SCL_D)
+	bool sclr_d_src;     // 0(IMG_D), 1(IMG_V)
+	enum sclr_img_trig_src img_in_d_trig_src;
+	enum sclr_img_trig_src img_in_v_trig_src;
+};
+
+struct sclr_mem {
+	u64 addr0;
+	u64 addr1;
+	u64 addr2;
+	u16 pitch_y;
+	u16 pitch_c;
+	u16 start_x;
+	u16 start_y;
+	u16 width;
+	u16 height;
+};
+
+struct sclr_gop_ow_cfg {
+	enum sclr_gop_format fmt;
+	struct sclr_point start;
+	struct sclr_point end;
+	u64 addr;
+	u16 pitch;
+	struct sclr_size mem_size;
+	struct sclr_size img_size;
+};
+
+struct sclr_gop_cfg {
+	union {
+		struct {
+			u16 ow0_en : 1;
+			u16 ow1_en : 1;
+			u16 ow2_en : 1;
+			u16 ow3_en : 1;
+			u16 ow4_en : 1;
+			u16 ow5_en : 1;
+			u16 ow6_en : 1;
+			u16 ow7_en : 1;
+			u16 hscl_en: 1;
+			u16 vscl_en: 1;
+			u16 colorkey_en : 1;
+			u16 resv   : 1;
+			u16 burst  : 4;
+		} b;
+		u16 raw;
+	};
+	u32 colorkey;       // RGB888
+	u16 font_fg_color;  // ARGB4444
+	u16 font_bg_color;  // ARGB4444
+	struct sclr_gop_ow_cfg ow_cfg[8];
+};
+
+enum sclr_disp_pat_color {
+	SCL_PAT_COLOR_WHITE,
+	SCL_PAT_COLOR_RED,
+	SCL_PAT_COLOR_GREEN,
+	SCL_PAT_COLOR_BLUE,
+	SCL_PAT_COLOR_CYAN,
+	SCL_PAT_COLOR_MAGENTA,
+	SCL_PAT_COLOR_YELLOW,
+	SCL_PAT_COLOR_BAR,
+	SCL_PAT_COLOR_USR,
+	SCL_PAT_COLOR_MAX
+};
+
+enum sclr_disp_pat_type {
+	SCL_PAT_TYPE_FULL,
+	SCL_PAT_TYPE_H_GRAD,
+	SCL_PAT_TYPE_V_GRAD,
+	SCL_PAT_TYPE_AUTO,
+	SCL_PAT_TYPE_SNOW,
+	SCL_PAT_TYPE_OFF,
+	SCL_PAT_TYPE_MAX
+};
+
+struct disp_ctrl_gpios {
+	struct gpio_desc disp_reset_gpio;
+	struct gpio_desc disp_pwm_gpio;
+	struct gpio_desc disp_power_ct_gpio;
+
+};
+
+struct sclr_disp_cfg {
+	bool disp_from_sc;  // 0(DRAM), 1(scaler_d)
+	bool cache_mode;
+	bool sync_ext;
+	bool tgen_en;
+	bool dw1_en;
+	bool dw2_en;
+	enum sclr_format fmt;
+	enum sclr_csc in_csc;
+	enum sclr_csc out_csc;
+	u8 burst;       // 0~15
+	u8 out_bit;     // 6/8/10-bit
+	enum sclr_disp_drop_mode drop_mode;
+	struct sclr_mem mem;
+	struct sclr_gop_cfg gop_cfg;
+	struct disp_ctrl_gpios ctrl_gpios;
+};
+
+/**
+ * @ vsync_pol: vsync polarity
+ * @ hsync_pol: hsync polarity
+ * @ vtotal: total line of each frame, should sub 1,
+ *           start line is included, end line isn't included
+ * @ htotal: total pixel of each line, should sub 1,
+ *           start pixel is included, end pixel isn't included
+ * @ vsync_start: start line of vsync
+ * @ vsync_end: end line of vsync, should sub 1
+ * @ vfde_start: start line of actually video data
+ * @ vfde_end: end line of actually video data, should sub 1
+ * @ vmde_start: equal to vfde_start
+ * @ vmde_end: equal to vfde_end
+ * @ hsync_start: start pixel of hsync
+ * @ hsync_end: end pixel of hsync, should sub 1
+ * @ hfde_start: start pixel of actually video data in each line
+ * @ hfde_end: end pixel of actually video data in each line, should sub 1
+ * @ hmde_start: equal to hfde_start
+ * @ hmde_end: equal to hfde_end
+ */
+struct sclr_disp_timing {
+	bool vsync_pol;
+	bool hsync_pol;
+	u16 vtotal;
+	u16 htotal;
+	u16 vsync_start;
+	u16 vsync_end;
+	u16 vfde_start;
+	u16 vfde_end;
+	u16 vmde_start;
+	u16 vmde_end;
+	u16 hsync_start;
+	u16 hsync_end;
+	u16 hfde_start;
+	u16 hfde_end;
+	u16 hmde_start;
+	u16 hmde_end;
+};
+
+union sclr_disp_dbg_status {
+	struct {
+		u32 bw_fail     : 1;
+		u32 bw_fail_clr : 1;
+		u32 resv0       : 2;
+		u32 err_fwr_y   : 1;
+		u32 err_fwr_u   : 1;
+		u32 err_fwr_v   : 1;
+		u32 err_fwr_clr : 1;
+		u32 err_erd_y   : 1;
+		u32 err_erd_u   : 1;
+		u32 err_erd_v   : 1;
+		u32 err_erd_clr : 1;
+		u32 lb_full_y   : 1;
+		u32 lb_full_u   : 1;
+		u32 lb_full_v   : 1;
+		u32 resv1       : 1;
+		u32 lb_empty_y  : 1;
+		u32 lb_empty_u  : 1;
+		u32 lb_empty_v  : 1;
+		u32 resv2       : 13;
+	} b;
+	u32 raw;
+};
+
+/**
+ * @ out_bit: 0(6-bit), 1(8-bit), others(10-bit)
+ * @ vesa_mode: 0(JEIDA), 1(VESA)
+ * @ dual_ch: dual link
+ * @ vs_out_en: vs output enable
+ * @ hs_out_en: hs output enable
+ * @ hs_blk_en: vertical blanking hs output enable
+ * @ ml_swap: lvdstx hs data msb/lsb swap
+ * @ ctrl_rev: serializer 0(msb first), 1(lsb first)
+ * @ oe_swap: lvdstx even/odd link swap
+ * @ en: lvdstx enable
+ */
+union sclr_lvdstx {
+	struct {
+		u32 out_bit	: 2;
+		u32 vesa_mode	: 1;
+		u32 dual_ch	: 1;
+		u32 vs_out_en	: 1;
+		u32 hs_out_en	: 1;
+		u32 hs_blk_en	: 1;
+		u32 resv_1	: 1;
+		u32 ml_swap	: 1;
+		u32 ctrl_rev	: 1;
+		u32 oe_swap	: 1;
+		u32 en		: 1;
+		u32 resv	: 20;
+	} b;
+	u32 raw;
+};
+
+/**
+ * @fmt_sel: [0] clk select
+ *		0: bt clock 2x of disp clock
+ *		1: bt clock 2x of disp clock
+ *	     [1] sync signal index
+ *		0: with sync pattern
+ *		1: without sync pattern
+ * @hde_gate: gate output hde with vde
+ * @data_seq: fmt_sel[0] = 0
+ *		00: Cb0Y0Cr0Y1
+ *		01: Cr0Y0Cb0Y1
+ *		10: Y0Cb0Y1Cr0
+ *		11: Y0Cr0Y1Cb0
+ *	      fmt_sel[0] = 1
+ *		0: Cb0Cr0
+ *		1: Cr0Cb0
+ * @clk_inv: clock rising edge at middle of data
+ * @vs_inv: vs low active
+ * @hs_inv: hs low active
+ */
+union sclr_bt_enc {
+	struct {
+		u32 fmt_sel	: 2;
+		u32 resv_1	: 1;
+		u32 hde_gate	: 1;
+		u32 data_seq	: 2;
+		u32 resv_2	: 2;
+		u32 clk_inv	: 1;
+		u32 hs_inv	: 1;
+		u32 vs_inv	: 1;
+	} b;
+	u32 raw;
+};
+
+/**
+ * @ sav_vld: sync pattern for start of valid data
+ * @ sav_blk: sync pattern for start of blanking data
+ * @ eav_vld: sync pattern for end of valid data
+ * @ eav_blk: sync pattern for end of blanking data
+ */
+union sclr_bt_sync_code {
+	struct {
+		u8 sav_vld;
+		u8 sav_blk;
+		u8 eav_vld;
+		u8 eav_blk;
+	} b;
+	u32 raw;
+};
+
+enum sclr_vo_sel {
+	SCLR_VO_SEL_DISABLE,
+	SCLR_VO_SEL_SW = 2,
+	SCLR_VO_SEL_I80,
+	SCLR_VO_SEL_BT601,
+	SCLR_VO_SEL_BT656,
+	SCLR_VO_SEL_BT1120,
+	SCLR_VO_SEL_BT1120R,
+	SCLR_VO_SEL_MAX,
+};
+
+enum sclr_vo_intf {
+	SCLR_VO_INTF_DISABLE,
+	SCLR_VO_INTF_SW,
+	SCLR_VO_INTF_I80,
+	SCLR_VO_INTF_BT601,
+	SCLR_VO_INTF_BT656,
+	SCLR_VO_INTF_BT1120,
+	SCLR_VO_INTF_MIPI,
+	SCLR_VO_INTF_LVDS,
+	SCLR_VO_INTF_MAX,
+};
+
+enum sclr_dsi_mode {
+	SCLR_DSI_MODE_IDLE = 0,
+	SCLR_DSI_MODE_SPKT = 1,
+	SCLR_DSI_MODE_ESC = 2,
+	SCLR_DSI_MODE_HS = 4,
+	SCLR_DSI_MODE_UNKNOWN,
+	SCLR_DSI_MODE_MAX = SCLR_DSI_MODE_UNKNOWN,
+};
+
+enum sclr_dsi_fmt {
+	SCLR_DSI_FMT_RGB888 = 0,
+	SCLR_DSI_FMT_RGB666,
+	SCLR_DSI_FMT_RGB565,
+	SCLR_DSI_FMT_RGB101010,
+	SCLR_DSI_FMT_MAX,
+};
+
+enum sclr_i80_mode {
+	SCLR_I80_MODE_IDLE = 0,
+	SCLR_I80_MODE_SW = 1,
+};
+
+void sclr_set_base_addr(void *base);
+void sclr_top_set_cfg(struct sclr_top_cfg *cfg);
+struct sclr_top_cfg *sclr_top_get_cfg(void);
+void sclr_top_reg_done(void);
+void sclr_top_reg_force_up(void);
+u8 sclr_top_pg_late_get_bus(void);
+void sclr_top_pg_late_clr(void);
+
+void sclr_img_set_trig(u8 inst, enum sclr_img_trig_src trig_src);
+
+void sclr_disp_set_cfg(struct sclr_disp_cfg *cfg);
+struct sclr_disp_cfg *sclr_disp_get_cfg(void);
+void sclr_disp_set_timing(struct sclr_disp_timing *timing);
+struct sclr_disp_timing *sclr_disp_get_timing(void);
+int sclr_disp_set_rect(struct sclr_rect rect);
+void sclr_disp_set_mem(struct sclr_mem *mem);
+void sclr_disp_set_addr(u64 addr0, u64 addr1, u64 addr2);
+void sclr_disp_set_csc(struct sclr_csc_matrix *cfg);
+void sclr_disp_set_in_csc(enum sclr_csc csc);
+void sclr_disp_set_out_csc(enum sclr_csc csc);
+void sclr_disp_set_pattern(enum sclr_disp_pat_type type,
+			   enum sclr_disp_pat_color color, const u16 *rgb);
+void sclr_disp_set_frame_bgcolor(u16 r, u16 g, u16 b);
+void sclr_disp_set_window_bgcolor(u16 r, u16 g, u16 b);
+void sclr_disp_enable_window_bgcolor(bool enable);
+void sclr_disp_reg_force_up(void);
+bool sclr_disp_tgen_enable(bool enable);
+union sclr_disp_dbg_status sclr_disp_get_dbg_status(bool clr);
+void sclr_disp_gamma_ctrl(bool enable, bool pre_osd);
+void sclr_disp_gamma_lut_update(const u8 *b, const u8 *g, const u8 *r);
+void sclr_lvdstx_set(union sclr_lvdstx cfg);
+void sclr_lvdstx_get(union sclr_lvdstx *cfg);
+void sclr_bt_set(union sclr_bt_enc enc, union sclr_bt_sync_code sync);
+void sclr_bt_get(union sclr_bt_enc *enc, union sclr_bt_sync_code *sync);
+void sclr_disp_set_intf(enum sclr_vo_intf intf);
+
+enum sclr_dsi_mode sclr_dsi_get_mode(void);
+int sclr_dsi_set_mode(enum sclr_dsi_mode mode);
+void sclr_dsi_clr_mode(void);
+int sclr_dsi_chk_mode_done(enum sclr_dsi_mode mode);
+int sclr_dsi_long_packet(u8 di, const u8 *data, u8 count, bool sw_mode);
+int sclr_dsi_long_packet_raw(const u8 *data, u8 count);
+int sclr_dsi_short_packet(u8 di, const u8 *data, u8 count, bool sw_mode);
+int sclr_dsi_dcs_write_buffer(u8 di, const void *data, size_t len, bool sw_mode);
+int sclr_dsi_dcs_read_buffer(u8 di, const u16 data_param, u8 *data, size_t len, bool sw_mode);
+int sclr_dsi_config(u8 lane_num, enum sclr_dsi_fmt fmt, u16 width);
+void sclr_i80_sw_mode(bool enable);
+void sclr_i80_packet(u32 cmd);
+void sclr_i80_run(void);
+
+void sclr_gop_set_cfg(u8 inst, struct sclr_gop_cfg *cfg);
+struct sclr_gop_cfg *sclr_gop_get_cfg(u8 inst);
+void sclr_gop_ow_set_cfg(u8 inst, u8 ow_inst, struct sclr_gop_ow_cfg *cfg);
+void sclr_gop_setup_LUT(u8 inst, u16 *data);
+int sclr_gop_update_LUT(u8 inst, u8 index, u16 data);
+
+void sclr_ctrl_init(void);
+int sclr_ctrl_set_disp_src(bool disp_from_sc);
+void sclr_intr_clr(union sclr_intr intr_mask);
+union sclr_intr sclr_intr_status(void);
+
+int set_disp_ctrl_gpios(struct disp_ctrl_gpios *ctrl_gpios);
+int get_disp_ctrl_gpios(struct disp_ctrl_gpios *ctrl_gpios);
+
+#endif  //_CVI_SCL_H_
diff --git a/drivers/video/cvitek/scaler_reg.h b/drivers/video/cvitek/scaler_reg.h
new file mode 100644
index 000000000..e4ca0ae22
--- /dev/null
+++ b/drivers/video/cvitek/scaler_reg.h
@@ -0,0 +1,146 @@
+#ifndef _CVI_SCL_REG_H_
+#define _CVI_SCL_REG_H_
+
+#if defined(ENV_CVITEST) || defined(ENV_EMU)
+#define REG_SCL_TOP_BASE 0x0A080000
+#define REG_DSI_WRAP_BASE 0x0300C000
+#else
+#define REG_SCL_TOP_BASE 0
+#define REG_DSI_WRAP_BASE 0
+#endif
+
+#define REG_GOP_OFFSET 0x800
+
+#define REG_SCL_DISP_BASE (REG_SCL_TOP_BASE + 0x8000)
+#define REG_SCL_BT_BASE (REG_SCL_TOP_BASE + 0x9000)
+#define REG_SCL_DSI_BASE (REG_SCL_TOP_BASE + 0xA000)
+
+// ============== TOP ============== //
+#define REG_SCL_TOP_CFG0 (REG_SCL_TOP_BASE + 0x00)
+#define REG_SCL_TOP_CFG1 (REG_SCL_TOP_BASE + 0x04)
+#define REG_SCL_TOP_AXI (REG_SCL_TOP_BASE + 0x08)
+#define REG_SCL_TOP_BT_CFG (REG_SCL_TOP_BASE + 0x0C)
+#define REG_SCL_TOP_SHD (REG_SCL_TOP_BASE + 0x10)
+#define REG_SCL_TOP_INTR_MASK (REG_SCL_TOP_BASE + 0x30)
+#define REG_SCL_TOP_INTR_STATUS (REG_SCL_TOP_BASE + 0x34)
+#define REG_SCL_TOP_INTR_ENABLE (REG_SCL_TOP_BASE + 0x38)
+#define REG_SCL_TOP_IMG_CTRL (REG_SCL_TOP_BASE + 0x40)
+#define REG_SCL_TOP_CMDQ_START (REG_SCL_TOP_BASE + 0x44)
+#define REG_SCL_TOP_CMDQ_STOP (REG_SCL_TOP_BASE + 0x48)
+#define REG_SCL_TOP_PG (REG_SCL_TOP_BASE + 0x4C)
+#define REG_SCL_TOP_LVDSTX (REG_SCL_TOP_BASE + 0x50)
+#define REG_SCL_TOP_BT_ENC (REG_SCL_TOP_BASE + 0x60)
+#define REG_SCL_TOP_BT_SYNC_CODE (REG_SCL_TOP_BASE + 0x64)
+#define REG_SCL_TOP_BT_BLK_DATA (REG_SCL_TOP_BASE + 0x68)
+#define REG_SCL_TOP_VO_MUX (REG_SCL_TOP_BASE + 0x70)
+
+// ============== DISP ============== //
+#define REG_SCL_DISP_CFG (REG_SCL_DISP_BASE + 0x00)
+#define REG_SCL_DISP_TOTAL (REG_SCL_DISP_BASE + 0x04)
+#define REG_SCL_DISP_VSYNC (REG_SCL_DISP_BASE + 0x08)
+#define REG_SCL_DISP_VFDE (REG_SCL_DISP_BASE + 0x0C)
+#define REG_SCL_DISP_VMDE (REG_SCL_DISP_BASE + 0x10)
+#define REG_SCL_DISP_HSYNC (REG_SCL_DISP_BASE + 0x14)
+#define REG_SCL_DISP_HFDE (REG_SCL_DISP_BASE + 0x18)
+#define REG_SCL_DISP_HMDE (REG_SCL_DISP_BASE + 0x1C)
+#define REG_SCL_DISP_ADDR0_L (REG_SCL_DISP_BASE + 0x34)
+#define REG_SCL_DISP_ADDR0_H (REG_SCL_DISP_BASE + 0x38)
+#define REG_SCL_DISP_ADDR1_L (REG_SCL_DISP_BASE + 0x3C)
+#define REG_SCL_DISP_ADDR1_H (REG_SCL_DISP_BASE + 0x40)
+#define REG_SCL_DISP_ADDR2_L (REG_SCL_DISP_BASE + 0x44)
+#define REG_SCL_DISP_ADDR2_H (REG_SCL_DISP_BASE + 0x48)
+#define REG_SCL_DISP_PITCH_Y (REG_SCL_DISP_BASE + 0x4C)
+#define REG_SCL_DISP_PITCH_C (REG_SCL_DISP_BASE + 0x50)
+#define REG_SCL_DISP_OFFSET (REG_SCL_DISP_BASE + 0x50)
+#define REG_SCL_DISP_SIZE (REG_SCL_DISP_BASE + 0x58)
+#define REG_SCL_DISP_OUT_CSC0 (REG_SCL_DISP_BASE + 0x5C)
+#define REG_SCL_DISP_OUT_CSC1 (REG_SCL_DISP_BASE + 0x60)
+#define REG_SCL_DISP_OUT_CSC2 (REG_SCL_DISP_BASE + 0x64)
+#define REG_SCL_DISP_OUT_CSC3 (REG_SCL_DISP_BASE + 0x68)
+#define REG_SCL_DISP_OUT_CSC4 (REG_SCL_DISP_BASE + 0x6C)
+#define REG_SCL_DISP_OUT_CSC_SUB (REG_SCL_DISP_BASE + 0x70)
+#define REG_SCL_DISP_OUT_CSC_ADD (REG_SCL_DISP_BASE + 0x74)
+#define REG_SCL_DISP_IN_CSC0 (REG_SCL_DISP_BASE + 0x78)
+#define REG_SCL_DISP_IN_CSC1 (REG_SCL_DISP_BASE + 0x7C)
+#define REG_SCL_DISP_IN_CSC2 (REG_SCL_DISP_BASE + 0x80)
+#define REG_SCL_DISP_IN_CSC3 (REG_SCL_DISP_BASE + 0x84)
+#define REG_SCL_DISP_IN_CSC4 (REG_SCL_DISP_BASE + 0x88)
+#define REG_SCL_DISP_IN_CSC_SUB (REG_SCL_DISP_BASE + 0x8C)
+#define REG_SCL_DISP_IN_CSC_ADD (REG_SCL_DISP_BASE + 0x90)
+#define REG_SCL_DISP_PAT_CFG (REG_SCL_DISP_BASE + 0x94)
+#define REG_SCL_DISP_PAT_COLOR0 (REG_SCL_DISP_BASE + 0x98)
+#define REG_SCL_DISP_PAT_COLOR1 (REG_SCL_DISP_BASE + 0x9C)
+#define REG_SCL_DISP_PAT_COLOR2 (REG_SCL_DISP_BASE + 0xA0)
+#define REG_SCL_DISP_PAT_COLOR3 (REG_SCL_DISP_BASE + 0xA4)
+#define REG_SCL_DISP_PAT_COLOR4 (REG_SCL_DISP_BASE + 0xA8)
+#define REG_SCL_DISP_DBG (REG_SCL_DISP_BASE + 0xAC)
+#define REG_SCL_DISP_AXI_ST (REG_SCL_DISP_BASE + 0xB0)
+#define REG_SCL_DISP_CACHE (REG_SCL_DISP_BASE + 0xC0)
+#define REG_SCL_DISP_DUMMY (REG_SCL_DISP_BASE + 0xF8)
+
+// GAMMA
+#define REG_SCL_DISP_GAMMA_CTRL (REG_SCL_DISP_BASE + 0x180)
+#define REG_SCL_DISP_GAMMA_WR_LUT (REG_SCL_DISP_BASE + 0x184)
+#define REG_SCL_DISP_GAMMA_RD_LUT (REG_SCL_DISP_BASE + 0x188)
+
+// i80
+#define REG_SCL_DISP_MCU_IF_CTRL (REG_SCL_DISP_BASE + 0x200)
+#define REG_SCL_DISP_MCU_SW_CTRL (REG_SCL_DISP_BASE + 0x204)
+#define REG_SCL_DISP_MCU_STATUS (REG_SCL_DISP_BASE + 0x208)
+
+// GOP
+#define REG_SCL_DISP_GOP_FMT(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x00)
+#define REG_SCL_DISP_GOP_H_RANGE(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x04)
+#define REG_SCL_DISP_GOP_V_RANGE(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x08)
+#define REG_SCL_DISP_GOP_ADDR_L(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x0c)
+#define REG_SCL_DISP_GOP_ADDR_H(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x10)
+#define REG_SCL_DISP_GOP_PITCH(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x14)
+#define REG_SCL_DISP_GOP_SIZE(y) (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x20 * (y) + 0x18)
+#define REG_SCL_DISP_GOP_CFG (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x100)
+#define REG_SCL_DISP_GOP_LUT0 (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x104)
+#define REG_SCL_DISP_GOP_LUT1 (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x108)
+#define REG_SCL_DISP_GOP_COLORKEY (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x10c)
+#define REG_SCL_DISP_GOP_FONTCOLOR (REG_SCL_DISP_BASE + REG_GOP_OFFSET + 0x110)
+
+// ============== DSI ============== //
+#define REG_SCL_DSI_MAC_EN  (REG_SCL_DSI_BASE + 0x00)
+#define REG_SCL_DSI_HS_0    (REG_SCL_DSI_BASE + 0x04)
+#define REG_SCL_DSI_HS_1    (REG_SCL_DSI_BASE + 0x08)
+#define REG_SCL_DSI_ESC     (REG_SCL_DSI_BASE + 0x0C)
+#define REG_SCL_DSI_ESC_TX0 (REG_SCL_DSI_BASE + 0x10)
+#define REG_SCL_DSI_ESC_TX1 (REG_SCL_DSI_BASE + 0x14)
+#define REG_SCL_DSI_ESC_TX2 (REG_SCL_DSI_BASE + 0x18)
+#define REG_SCL_DSI_ESC_TX3 (REG_SCL_DSI_BASE + 0x1C)
+#define REG_SCL_DSI_ESC_RX0 (REG_SCL_DSI_BASE + 0x20)
+#define REG_SCL_DSI_ESC_RX1 (REG_SCL_DSI_BASE + 0x24)
+
+// ============== DSI PHY ============== //
+#define REG_DSI_PHY_EN             (REG_DSI_WRAP_BASE + 0x00)
+#define REG_DSI_PHY_CLK_CFG1       (REG_DSI_WRAP_BASE + 0x04)
+#define REG_DSI_PHY_CLK_CFG2       (REG_DSI_WRAP_BASE + 0x08)
+#define REG_DSI_PHY_ESC_INIT       (REG_DSI_WRAP_BASE + 0x0C)
+#define REG_DSI_PHY_ESC_WAKE       (REG_DSI_WRAP_BASE + 0x10)
+#define REG_DSI_PHY_HS_CFG1        (REG_DSI_WRAP_BASE + 0x14)
+#define REG_DSI_PHY_HS_CFG2        (REG_DSI_WRAP_BASE + 0x18)
+#define REG_DSI_PHY_CAL_CFG        (REG_DSI_WRAP_BASE + 0x1C)
+#define REG_DSI_PHY_CAL_NUM        (REG_DSI_WRAP_BASE + 0x20)
+#define REG_DSI_PHY_CLK_STATE      (REG_DSI_WRAP_BASE + 0x24)
+#define REG_DSI_PHY_DATA0_STATE    (REG_DSI_WRAP_BASE + 0x28)
+#define REG_DSI_PHY_DATA12_STATE   (REG_DSI_WRAP_BASE + 0x2C)
+#define REG_DSI_PHY_DATA3_STATE    (REG_DSI_WRAP_BASE + 0x30)
+#define REG_DSI_PHY_HS_OV          (REG_DSI_WRAP_BASE + 0x38)
+#define REG_DSI_PHY_HS_SW1         (REG_DSI_WRAP_BASE + 0x3C)
+#define REG_DSI_PHY_HS_SW2         (REG_DSI_WRAP_BASE + 0x40)
+#define REG_DSI_PHY_DATA_OV        (REG_DSI_WRAP_BASE + 0x44)
+#define REG_DSI_PHY_LPTX_OV        (REG_DSI_WRAP_BASE + 0x4C)
+#define REG_DSI_PHY_LPRX_OV        (REG_DSI_WRAP_BASE + 0x4C)
+#define REG_DSI_PHY_PD             (REG_DSI_WRAP_BASE + 0x64)
+#define REG_DSI_PHY_TXPLL          (REG_DSI_WRAP_BASE + 0x6C)
+#define REG_DSI_PHY_REG_8C         (REG_DSI_WRAP_BASE + 0x8C)
+#define REG_DSI_PHY_REG_SET        (REG_DSI_WRAP_BASE + 0x90)
+#define REG_DSI_PHY_LANE_SEL       (REG_DSI_WRAP_BASE + 0x9C)
+#define REG_DSI_PHY_LANE_PN_SWAP   (REG_DSI_WRAP_BASE + 0xA0)
+#define REG_DSI_PHY_LVDS_EN        (REG_DSI_WRAP_BASE + 0xB4)
+#define REG_DSI_PHY_EXT_GPIO       (REG_DSI_WRAP_BASE + 0xC0)
+
+#endif  // _CVI_SCL_REG_H_
diff --git a/drivers/video/cvitek/vip_common.h b/drivers/video/cvitek/vip_common.h
new file mode 100644
index 000000000..8a2662cc4
--- /dev/null
+++ b/drivers/video/cvitek/vip_common.h
@@ -0,0 +1,150 @@
+#ifndef _COMMON_VIP_H_
+#define _COMMON_VIP_H_
+
+#include <linux/kernel.h>
+#include "reg_vip_sys.h"
+
+#define BASE_OFFSET 0x000000000
+#define GOP_FRAME_OFFSET 0x200000
+
+#define CLIP(x, _min, _max) max(min(x, _max), _min)
+#define VIP_ALIGN(x) (((x) + 0x1F) & ~0x1F)   // for 32byte alignment
+
+#define R_IDX 0
+#define G_IDX 1
+#define B_IDX 2
+
+struct vip_rect {
+	u16 x;
+	u16 y;
+	u16 w;
+	u16 h;
+};
+
+union vip_sys_reg0 {
+	struct {
+		u32 rst_axi : 1;
+		u32 rst_isp_top : 1;
+		u32 rst_img_d : 1;
+		u32 rst_img_v : 1;
+		u32 rst_sc_top : 1;
+		u32 rst_sc_d : 1;
+		u32 rst_sc_v1 : 1;
+		u32 rst_sc_v2 : 1;
+		u32 rst_sc_v3 : 1;
+		u32 rst_disp : 1;
+		u32 rst_bt : 1;
+		u32 rst_dsi_mac : 1;
+		u32 resv_12 : 2;
+		u32 rst_dwa : 1;
+		u32 rst_clk_div : 1;
+		u32 rsv_16 : 2;
+		u32 clk_isp_top_en : 1;
+		u32 clk_axi_isp_en : 1;
+		u32 clk_csi_mac0_en : 1;
+		u32 clk_csi_mac1_en : 1;
+		u32 rsv_22 : 10;
+	} b;
+	u32 raw;
+};
+
+union vip_sys_reg4 {
+	struct {
+		u32 rst_csi_mac0 : 1;
+		u32 rst_csi_mac1 : 1;
+		u32 rsv_2 : 30;
+	} b;
+	u32 raw;
+};
+
+union vip_sys_reset {
+	struct {
+		u32 axi : 1;
+		u32 isp_top : 1;
+		u32 img_d : 1;
+		u32 img_v : 1;
+		u32 sc_top : 1;
+		u32 sc_d : 1;
+		u32 sc_v1 : 1;
+		u32 sc_v2 : 1;
+		u32 sc_v3 : 1;
+		u32 disp : 1;
+		u32 bt : 1;
+		u32 dsi_mac : 1;
+		u32 csi_mac0 : 1;
+		u32 csi_mac1 : 1;
+		u32 dwa : 1;
+		u32 clk_div : 1;
+		u32 rsv : 16;
+	} b;
+	u32 raw;
+};
+
+union vip_sys_isp_clk {
+	struct {
+		u32 rsv : 18;
+		u32 clk_isp_top_en : 1;
+		u32 clk_axi_isp_en : 1;
+		u32 clk_csi_mac0_en : 1;
+		u32 clk_csi_mac1_en : 1;
+	} b;
+	u32 raw;
+};
+
+union vip_sys_clk {
+	struct {
+		u32 sc_top : 1;
+		u32 isp_top : 1;
+		u32 dwa : 1;
+		u32 rot_top : 1;
+		u32 vip_sys : 1;
+		u32 rsv1 : 3;
+		u32 csi_mac0 : 1;
+		u32 csi_mac1 : 1;
+		u32 rsv2 : 6;
+		u32 auto_sc_top : 1;
+		u32 auto_isp_top : 1;
+		u32 auto_dwa : 1;
+		u32 auto_rot_top : 1;
+		u32 auto_vip_sys : 1;
+		u32 rsv3 : 3;
+		u32 auto_csi_mac0 : 1;
+		u32 auto_csi_mac1 : 1;
+	} b;
+	u32 raw;
+};
+
+union vip_sys_intr {
+	struct {
+		u32 sc : 1;
+		u32 rsv1 : 15;
+		u32 isp : 1;
+		u32 rsv2 : 7;
+		u32 dwa : 1;
+		u32 rsv3 : 3;
+		u32 rot : 1;
+		u32 csi_mac0 : 1;
+		u32 csi_mac1 : 1;
+	} b;
+	u32 raw;
+};
+
+/********************************************************************
+ *   APIs to replace bmtest's standard APIs
+ ********************************************************************/
+void vip_set_base_addr(void *base);
+union vip_sys_clk vip_get_clk_lp(void);
+void vip_set_clk_lp(union vip_sys_clk clk);
+union vip_sys_isp_clk vip_get_isp_clk(void);
+void vip_set_isp_clk(union vip_sys_isp_clk clk);
+union vip_sys_reset vip_get_reset(void);
+void vip_set_reset(union vip_sys_reset reset);
+void vip_toggle_reset(union vip_sys_reset mask);
+union vip_sys_intr vip_get_intr_status(void);
+union vip_sys_intr vip_get_intr_mask(void);
+void vip_set_intr_mask(union vip_sys_intr intr);
+void vip_isp_clk_reset(void);
+void vip_sys_reg_read(uintptr_t addr);
+void vip_sys_reg_write_mask(uintptr_t addr, u32 mask, u32 data);
+
+#endif
diff --git a/drivers/video/cvitek/vip_sys.c b/drivers/video/cvitek/vip_sys.c
new file mode 100644
index 000000000..b85373b75
--- /dev/null
+++ b/drivers/video/cvitek/vip_sys.c
@@ -0,0 +1,180 @@
+#include <common.h>
+
+#include "vip_common.h"
+#include "reg.h"
+
+static uintptr_t reg_base;
+
+void vip_set_base_addr(void *base)
+{
+	reg_base = (uintptr_t)base;
+}
+
+union vip_sys_isp_clk vip_get_isp_clk(void)
+{
+	union vip_sys_reg0 reg0;
+	union vip_sys_isp_clk clk;
+
+	reg0.raw = _reg_read(reg_base + VIP_SYS_VIP_RESETS);
+	clk.raw = 0;
+	clk.b.clk_isp_top_en = reg0.b.clk_isp_top_en;
+	clk.b.clk_axi_isp_en = reg0.b.clk_axi_isp_en;
+	clk.b.clk_csi_mac0_en = reg0.b.clk_csi_mac0_en;
+	clk.b.clk_csi_mac1_en = reg0.b.clk_csi_mac1_en;
+
+	return clk;
+}
+
+void vip_set_isp_clk(union vip_sys_isp_clk clk)
+{
+	union vip_sys_reg0 reg0;
+
+	reg0.raw = _reg_read(reg_base + VIP_SYS_VIP_RESETS);
+	reg0.b.clk_isp_top_en = clk.b.clk_isp_top_en;
+	reg0.b.clk_axi_isp_en = clk.b.clk_axi_isp_en;
+	reg0.b.clk_csi_mac0_en = clk.b.clk_csi_mac0_en;
+	reg0.b.clk_csi_mac1_en = clk.b.clk_csi_mac1_en;
+	_reg_write(reg_base + VIP_SYS_VIP_RESETS, reg0.raw);
+}
+
+union vip_sys_clk vip_get_clk_lp(void)
+{
+	union vip_sys_clk clk;
+
+	clk.raw = _reg_read(reg_base + VIP_SYS_VIP_CLK_LP);
+	return clk;
+}
+
+void vip_set_clk_lp(union vip_sys_clk clk)
+{
+	_reg_write(reg_base + VIP_SYS_VIP_CLK_LP, clk.raw);
+}
+
+union vip_sys_reset vip_get_reset(void)
+{
+	union vip_sys_reg0 reg0;
+	union vip_sys_reg4 reg4;
+	union vip_sys_reset reset;
+
+	reg0.raw = _reg_read(reg_base + VIP_SYS_VIP_RESETS);
+	reg4.raw = _reg_read(reg_base + VIP_SYS_VIP_ENABLE);
+	reset.raw = reg0.raw & 0x0000cfff;
+	reset.raw |= (reg4.raw & 0x03) << 12;
+	return reset;
+}
+
+void vip_set_reset(union vip_sys_reset reset)
+{
+	union vip_sys_reg0 reg0;
+	union vip_sys_reg4 reg4;
+
+	reg0.raw = _reg_read(reg_base + VIP_SYS_VIP_RESETS);
+	reg0.raw &= 0xffff0000;
+	reg0.raw |= (reset.raw & 0x0000cfff);
+	_reg_write(reg_base + VIP_SYS_VIP_RESETS, reg0.raw);
+
+	reg4.raw = (reset.raw & 0x00003000) >> 12;
+	_reg_write(reg_base + VIP_SYS_VIP_ENABLE, reg4.raw);
+}
+
+/**
+ * vip_toggle_reset - enable/disable reset specified in mask. Lock protected.
+ *
+ * @param mask: resets want to be toggled.
+ */
+void vip_toggle_reset(union vip_sys_reset mask)
+{
+	union vip_sys_reset value;
+
+	value = vip_get_reset();
+	value.raw |= mask.raw;
+	vip_set_reset(value);
+
+	udelay(20);
+	value.raw &= ~mask.raw;
+	vip_set_reset(value);
+}
+
+union vip_sys_intr vip_get_intr_status(void)
+{
+	union vip_sys_intr intr;
+
+	intr.raw = _reg_read(reg_base + VIP_SYS_VIP_INT);
+	return intr;
+}
+
+union vip_sys_intr vip_get_intr_mask(void)
+{
+	union vip_sys_intr intr;
+
+	intr.raw = _reg_read(reg_base + VIP_SYS_VIP_INT_EN);
+	return intr;
+}
+
+void vip_set_intr_mask(union vip_sys_intr intr)
+{
+	_reg_write(reg_base + VIP_SYS_VIP_INT_EN, intr.raw);
+}
+
+void vip_isp_clk_reset(void)
+{
+	union vip_sys_reset reset;
+	union vip_sys_isp_clk clk;
+
+	memset(&reset, 0, sizeof(reset));
+	reset.b.axi = 1;
+	reset.b.isp_top = 1;
+	reset.b.csi_mac0 = 1;
+	reset.b.csi_mac1 = 1;
+	vip_set_reset(reset);
+
+	// enable all clk
+	clk.raw = 0xffffffff;
+	vip_set_isp_clk(clk);
+	// disable all clk
+	clk.raw = 0x0;
+	vip_set_isp_clk(clk);
+
+	// release reset clk-axi
+	clk.b.clk_axi_isp_en = 1;
+	vip_set_isp_clk(clk);
+	reset.b.axi = 0;
+	vip_set_reset(reset);
+	clk.raw = 0x0;
+	vip_set_isp_clk(clk);
+
+	// release reset clk-isp
+	clk.b.clk_isp_top_en = 1;
+	vip_set_isp_clk(clk);
+	reset.b.isp_top = 0;
+	vip_set_reset(reset);
+	clk.raw = 0x0;
+	vip_set_isp_clk(clk);
+
+	// release reset clk-mac
+	clk.b.clk_csi_mac0_en = 1;
+	clk.b.clk_csi_mac1_en = 1;
+	vip_set_isp_clk(clk);
+	reset.b.csi_mac0 = 0;
+	reset.b.csi_mac1 = 0;
+	vip_set_reset(reset);
+	clk.raw = 0x0;
+	vip_set_isp_clk(clk);
+
+	// enable all clk
+	clk.raw = 0xffffffff;
+	vip_set_isp_clk(clk);
+
+	//iowrite32((ioread32(ioremap(0x03002030, 0x4)) & 0xfc1fffff),  ioremap(0x03002030, 0x4));
+	_reg_write_mask(0x03002030, 0xfc1fffff, 0);
+}
+
+void vip_sys_reg_read(uintptr_t addr)
+{
+	_reg_read(reg_base + addr);
+}
+
+void vip_sys_reg_write_mask(uintptr_t addr, u32 mask, u32 data)
+{
+	_reg_write_mask(reg_base + addr, mask, data);
+}
diff --git a/drivers/watchdog/designware_wdt.c b/drivers/watchdog/designware_wdt.c
index cfec29bd1..ee84d60aa 100644
--- a/drivers/watchdog/designware_wdt.c
+++ b/drivers/watchdog/designware_wdt.c
@@ -10,6 +10,11 @@
 #include <wdt.h>
 #include <asm/io.h>
 #include <linux/bitops.h>
+#if IS_ENABLED(CONFIG_TARGET_CVITEK_CV181X)
+#include "../../board/cvitek/cv181x/cv181x_reg.h"
+#elif IS_ENABLED(CONFIG_TARGET_CVITEK_CV180X)
+#include "../../board/cvitek/cv180x/cv180x_reg.h"
+#endif
 
 #define DW_WDT_CR	0x00
 #define DW_WDT_TORR	0x04
diff --git a/dts/Makefile b/dts/Makefile
index cb3111382..b4f917d77 100644
--- a/dts/Makefile
+++ b/dts/Makefile
@@ -13,7 +13,8 @@ endif
 ifneq ($(EXT_DTB),)
 DTB := $(EXT_DTB)
 else
-DTB := arch/$(ARCH)/dts/$(DEVICE_TREE).dtb
+#DTB := arch/$(ARCH)/dts/$(DEVICE_TREE).dtb
+DTB := arch/$(ARCH)/dts/$(CHIP)_$(CVIBOARD).dtb
 endif
 
 $(obj)/dt-$(SPL_NAME).dtb: dts/dt.dtb $(objtree)/tools/fdtgrep FORCE
diff --git a/env/Kconfig b/env/Kconfig
index c0dff1fd8..262509e09 100644
--- a/env/Kconfig
+++ b/env/Kconfig
@@ -301,6 +301,7 @@ config ENV_IS_IN_SPI_FLASH
 	default y if NORTHBRIDGE_INTEL_IVYBRIDGE
 	default y if INTEL_QUARK
 	default y if INTEL_QUEENSBAY
+	default y if CVITEK_SPI_FLASH
 	help
 	  Define this if you have a SPI Flash memory device which you
 	  want to use for the environment.
@@ -560,18 +561,6 @@ config ENV_OFFSET_REDUND
 	  Offset from the start of the device (or partition) of the redundant
 	  environment location.
 
-config ENV_SIZE
-	hex "Environment Size"
-	default 0x40000 if ENV_IS_IN_SPI_FLASH && ARCH_ZYNQMP
-	default 0x20000 if ARCH_SUNXI || ARCH_ZYNQ || ARCH_OMAP2PLUS || ARCH_AT91
-	default 0x8000 if ARCH_ROCKCHIP && ENV_IS_IN_MMC
-	default 0x2000 if ARCH_ROCKCHIP && ENV_IS_IN_SPI_FLASH
-	default 0x8000 if ARCH_ZYNQMP || ARCH_VERSAL
-	default 0x4000 if ARC
-	default 0x1f000
-	help
-	  Size of the environment storage area
-
 config ENV_SECT_SIZE
 	hex "Environment Sector-Size"
 	depends on ENV_IS_IN_FLASH || ENV_IS_IN_SPI_FLASH
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
index 7021138b9..2cc5a42cd 100644
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -148,7 +148,7 @@ static void get_name(dir_entry *dirent, char *s_name)
 
 static int flush_dirty_fat_buffer(fsdata *mydata);
 
-#if !CONFIG_IS_ENABLED(FAT_WRITE)
+#if !defined(CONFIG_FAT_WRITE)
 /* Stub for read only operation */
 int flush_dirty_fat_buffer(fsdata *mydata)
 {
diff --git a/fs/fs.c b/fs/fs.c
index 023f89caf..102a594f5 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -746,7 +746,7 @@ int do_load(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[],
 		pos = 0;
 
 	time = get_timer(0);
-	ret = _fs_read(filename, addr, pos, bytes, 1, &len_read);
+	ret = _fs_read(filename, addr, pos, bytes, 0, &len_read);
 	time = get_timer(time);
 	if (ret < 0) {
 		log_err("Failed to load '%s'\n", filename);
diff --git a/include/configs/cv180x-asic.h b/include/configs/cv180x-asic.h
new file mode 100644
index 000000000..db3ef7fae
--- /dev/null
+++ b/include/configs/cv180x-asic.h
@@ -0,0 +1,322 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV180X_ASIC_H__
+#define __CV180X_ASIC_H__
+
+#include <../../../board/cvitek/cv180x/cv180x_reg.h>
+
+/* defined in cvipart.h */
+#undef CONFIG_ENV_OFFSET
+#undef CONFIG_ENV_OFFSET_REDUND
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#undef CONFIG_ENV_IS_IN_MMC
+#undef CONFIG_ENV_IS_IN_NAND
+#undef CONFIG_ENV_SECT_SIZE
+
+/* cvi_board_memmap.h is generated from build/boards/{CHIP_ARCH}/{BOARD}/memmap.py */
+#include "cvi_board_memmap.h"
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+// defined in this .h
+#undef CONFIG_BOOTCOMMAND
+
+#if defined(__aarch64__)
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+/* Physical Memory Map */
+#define CONFIG_SYS_RESVIONSZ		CVIMMAP_ION_SIZE
+#define CONFIG_SYS_BOOTMAPSZ		CVIMMAP_KERNEL_MEMORY_SIZE
+
+#define PHYS_SDRAM_1			CVIMMAP_KERNEL_MEMORY_ADDR
+#define PHYS_SDRAM_1_SIZE		CVIMMAP_KERNEL_MEMORY_SIZE
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
+
+/* Link Definitions */
+#define CONFIG_SYS_INIT_SP_ADDR		CVIMMAP_CONFIG_SYS_INIT_SP_ADDR
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+#define CONFIG_SYS_BOOTM_LEN		(64 << 20)
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (8 << 20))
+
+#if defined(__aarch64__)
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+#endif
+
+#if defined(__riscv)
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#endif
+
+// Frequency of ARM arch timer and RISC-V rdtime
+#define SYS_COUNTER_FREQ_IN_SECOND 25000000
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* Download related definitions */
+#define UBOOT_PID_SRAM_ADDR  0x0e000030
+#define UPDATE_ADDR	CVIMMAP_ION_ADDR
+#define HEADER_ADDR	UPDATE_ADDR
+#define USB_UPDATE_MAGIC MAGIC_NUM_USB_DL
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	//#define CONFIG_CMD_UBI
+	//#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#ifndef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#endif
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_MMC_UHS_SUPPORT
+#define CONFIG_MMC_HS200_SUPPORT
+#define CONFIG_MMC_SUPPORTS_TUNING
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+
+#if 1 /* CONFIG_USE_DEFAULT_ENV */
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	CVIMMAP_UIMAG_ADDR
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs rootwait ro root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi release loglevel=0 riscv.fwsz=0x80000\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi loglevel=9 riscv.fwsz=0x80000\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=115200\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"update_addr=" __stringify(UPDATE_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		"sdboot=" SD_BOOTM_COMMAND "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND (LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG)
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define SD_BOOTM_COMMAND \
+				SET_BOOTARGS \
+				"echo Boot from SD with ramboot.itb;" \
+				"mmc dev 1 && fatload mmc 1 ${uImage_addr} ramboot.itb; " \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "cvi_update || run norboot || run nandboot ||run emmcboot"
+
+	#if defined(CONFIG_NAND_SUPPORT)
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_EMMC_SUPPORT)
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV181X_ASIC_H__ */
diff --git a/include/configs/cv180x-fpga.h b/include/configs/cv180x-fpga.h
new file mode 100644
index 000000000..83d4a01d4
--- /dev/null
+++ b/include/configs/cv180x-fpga.h
@@ -0,0 +1,328 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV180X_FPGA_H__
+#define __CV180X_FPGA_H__
+
+#include <../../../board/cvitek/cv180x/cv180x_reg.h>
+
+/* defined in cvipart.h */
+#undef CONFIG_ENV_OFFSET
+#undef CONFIG_ENV_OFFSET_REDUND
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#undef CONFIG_ENV_IS_IN_MMC
+#undef CONFIG_ENV_IS_IN_NAND
+#undef CONFIG_ENV_SECT_SIZE
+
+/* cvi_board_memmap.h is generated from build/boards/{CHIP_ARCH}/{BOARD}/memmap.py */
+#include "cvi_board_memmap.h"
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+// defined in this .h
+#undef CONFIG_BOOTCOMMAND
+
+#if defined(__aarch64__)
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+/* Physical Memory Map */
+#define CONFIG_SYS_RESVIONSZ		CVIMMAP_ION_SIZE
+#define CONFIG_SYS_BOOTMAPSZ		CVIMMAP_KERNEL_MEMORY_SIZE
+
+#define PHYS_SDRAM_1			CVIMMAP_KERNEL_MEMORY_ADDR
+#define PHYS_SDRAM_1_SIZE		CVIMMAP_KERNEL_MEMORY_SIZE
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
+
+/* Link Definitions */
+#define CONFIG_SYS_INIT_SP_ADDR		CVIMMAP_CONFIG_SYS_INIT_SP_ADDR
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+#define CONFIG_SYS_BOOTM_LEN		(64 << 20)
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+#if defined(__aarch64__)
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+#endif
+
+#if defined(__riscv)
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#endif
+
+// Frequency of ARM arch timer and RISC-V rdtime
+#define SYS_COUNTER_FREQ_IN_SECOND 25000000
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* Download related definitions */
+#define UBOOT_PID_SRAM_ADDR  0x0e000030
+#define UPDATE_ADDR	CVIMMAP_ION_ADDR
+#define HEADER_ADDR	UPDATE_ADDR
+#define USB_UPDATE_MAGIC MAGIC_NUM_USB_DL
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	//#define CONFIG_CMD_UBI
+	//#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#ifndef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#endif
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_MMC_UHS_SUPPORT
+#define CONFIG_MMC_HS200_SUPPORT
+#define CONFIG_MMC_SUPPORTS_TUNING
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	0x90000000  /* In FPGA, put ramboot.itb after 256MB */
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs rootwait ro root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi release loglevel=0\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi loglevel=9\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=115200\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"update_addr=" __stringify(UPDATE_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		"sdboot=" SD_BOOTM_COMMAND "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND (LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG)
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define SD_BOOTM_COMMAND \
+				SET_BOOTARGS \
+				"echo Boot from SD with ramboot.itb;" \
+				"mmc dev 0 && fatload mmc 0 ${uImage_addr} ramboot.itb; " \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "run ramboot"
+
+	#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;" \
+				"echo run Ramboot...;" \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#if defined(CONFIG_NAND_SUPPORT)
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_EMMC_SUPPORT)
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV180X_FPGA_H__ */
diff --git a/include/configs/cv180x-palladium.h b/include/configs/cv180x-palladium.h
new file mode 100644
index 000000000..e84b9e6f0
--- /dev/null
+++ b/include/configs/cv180x-palladium.h
@@ -0,0 +1,328 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV180X_PALLADIUM_H__
+#define __CV180X_PALLADIUM_H__
+
+#include <../../../board/cvitek/cv180x/cv180x_reg.h>
+
+/* defined in cvipart.h */
+#undef CONFIG_ENV_OFFSET
+#undef CONFIG_ENV_OFFSET_REDUND
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#undef CONFIG_ENV_IS_IN_MMC
+#undef CONFIG_ENV_IS_IN_NAND
+#undef CONFIG_ENV_SECT_SIZE
+
+/* cvi_board_memmap.h is generated from build/boards/{CHIP_ARCH}/{BOARD}/memmap.py */
+#include "cvi_board_memmap.h"
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+// defined in this .h
+#undef CONFIG_BOOTCOMMAND
+
+#if defined(__aarch64__)
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+/* Physical Memory Map */
+#define CONFIG_SYS_RESVIONSZ		CVIMMAP_ION_SIZE
+#define CONFIG_SYS_BOOTMAPSZ		CVIMMAP_KERNEL_MEMORY_SIZE
+
+#define PHYS_SDRAM_1			CVIMMAP_KERNEL_MEMORY_ADDR
+#define PHYS_SDRAM_1_SIZE		CVIMMAP_KERNEL_MEMORY_SIZE
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
+
+/* Link Definitions */
+#define CONFIG_SYS_INIT_SP_ADDR		CVIMMAP_CONFIG_SYS_INIT_SP_ADDR
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+#define CONFIG_SYS_BOOTM_LEN		(64 << 20)
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (8 << 20))
+
+#if defined(__aarch64__)
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+#endif
+
+#if defined(__riscv)
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#endif
+
+// Frequency of ARM arch timer and RISC-V rdtime
+#define SYS_COUNTER_FREQ_IN_SECOND 25000000
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		307200
+
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* Download related definitions */
+#define UBOOT_PID_SRAM_ADDR  0x0e000030
+#define HEADER_ADDR CVIMMAP_CVI_UPDATE_HEADER_ADDR
+#define USB_UPDATE_MAGIC MAGIC_NUM_USB_DL
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	//#define CONFIG_CMD_UBI
+	//#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#ifndef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#endif
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_MMC_UHS_SUPPORT
+#define CONFIG_MMC_HS200_SUPPORT
+#define CONFIG_MMC_SUPPORTS_TUNING
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	0x90000000  /* In FPGA, put ramboot.itb after 256MB */
+	#define UPDATE_ADDR	0x83800000
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs rootwait ro root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi release loglevel=0\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi loglevel=9\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=19200\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"update_addr=" __stringify(UPDATE_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		"sdboot=" SD_BOOTM_COMMAND "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND (LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG)
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define SD_BOOTM_COMMAND \
+				SET_BOOTARGS \
+				"echo Boot from SD with ramboot.itb;" \
+				"mmc dev 0 && fatload mmc 0 ${uImage_addr} ramboot.itb; " \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "run ramboot"
+
+	#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;" \
+				"echo run Ramboot...;" \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#if defined(CONFIG_NAND_SUPPORT)
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_EMMC_SUPPORT)
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV180X_PALLADIUM_H__ */
diff --git a/include/configs/cv181x-asic.h b/include/configs/cv181x-asic.h
new file mode 100644
index 000000000..6f2a43873
--- /dev/null
+++ b/include/configs/cv181x-asic.h
@@ -0,0 +1,324 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV181X_ASIC_H__
+#define __CV181X_ASIC_H__
+
+#include <../../../board/cvitek/cv181x/cv181x_reg.h>
+
+/* defined in cvipart.h */
+#undef CONFIG_ENV_OFFSET
+#undef CONFIG_ENV_OFFSET_REDUND
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#undef CONFIG_ENV_IS_IN_MMC
+#undef CONFIG_ENV_IS_IN_NAND
+#undef CONFIG_ENV_SECT_SIZE
+
+/* cvi_board_memmap.h is generated from build/boards/{CHIP_ARCH}/{BOARD}/memmap.py */
+#include "cvi_board_memmap.h"
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+// defined in this .h
+#undef CONFIG_BOOTCOMMAND
+
+#if defined(__aarch64__)
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+/* Physical Memory Map */
+#define CONFIG_SYS_RESVIONSZ		CVIMMAP_ION_SIZE
+#define CONFIG_SYS_BOOTMAPSZ		CVIMMAP_KERNEL_MEMORY_SIZE
+
+#define PHYS_SDRAM_1			CVIMMAP_KERNEL_MEMORY_ADDR
+#define PHYS_SDRAM_1_SIZE		CVIMMAP_KERNEL_MEMORY_SIZE
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
+
+/* Link Definitions */
+#define CONFIG_SYS_INIT_SP_ADDR		CVIMMAP_CONFIG_SYS_INIT_SP_ADDR
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+#define CONFIG_SYS_BOOTM_LEN		(64 << 20)
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+#if defined(__aarch64__)
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+#endif
+
+#if defined(__riscv)
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#endif
+
+// Frequency of ARM arch timer and RISC-V rdtime
+#define SYS_COUNTER_FREQ_IN_SECOND 25000000
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+
+/* Download related definitions */
+#define UPGRADE_SRAM_ADDR    0x0e000030
+#define UBOOT_PID_SRAM_ADDR  0x0e000030
+#define UPDATE_ADDR	CVIMMAP_ION_ADDR
+#define HEADER_ADDR	UPDATE_ADDR
+#define USB_UPDATE_MAGIC MAGIC_NUM_USB_DL
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	//#define CONFIG_CMD_UBI
+	//#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#ifndef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#endif
+
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_MMC_UHS_SUPPORT
+#define CONFIG_MMC_HS200_SUPPORT
+#define CONFIG_MMC_SUPPORTS_TUNING
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	CVIMMAP_UIMAG_ADDR
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs rootwait ro root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi release loglevel=0 riscv.fwsz=0x80000\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi loglevel=9 riscv.fwsz=0x80000\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=115200\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"update_addr=" __stringify(UPDATE_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		"sdboot=" SD_BOOTM_COMMAND "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND (LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG)
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define SD_BOOTM_COMMAND \
+				SET_BOOTARGS \
+				"echo Boot from SD with ramboot.itb;" \
+				"mmc dev 1 && fatload mmc 1 ${uImage_addr} ramboot.itb; " \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "cvi_update || run norboot || run nandboot ||run emmcboot"
+
+	#if defined(CONFIG_NAND_SUPPORT)
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_EMMC_SUPPORT)
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV181X_ASIC_H__ */
diff --git a/include/configs/cv181x-fpga.h b/include/configs/cv181x-fpga.h
new file mode 100644
index 000000000..5e146d87e
--- /dev/null
+++ b/include/configs/cv181x-fpga.h
@@ -0,0 +1,334 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV181X_FPGA_H__
+#define __CV181X_FPGA_H__
+
+/* defined in cvipart.h */
+#undef CONFIG_ENV_OFFSET
+#undef CONFIG_ENV_OFFSET_REDUND
+#undef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#undef CONFIG_ENV_SECT_SIZE
+
+/* defined in this .h */
+#undef CONFIG_BOOTCOMMAND
+
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+
+#include "cvi_panels/cvi_panel_diffs.h"
+
+#if defined(__aarch64__)
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+#endif
+
+#define CONFIG_REMAKE_ELF
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1			0x80000000
+#define PHYS_SDRAM_1_SIZE		CONFIG_SYS_BOOTMAPSZ
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
+
+/* Link Definitions */
+#define CONFIG_SYS_TEXT_BASE		0x80200000
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+#define CONFIG_SYS_BOOTM_LEN		(64 << 20)
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (8 << 20))
+
+#if defined(__aarch64__)
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+#endif
+
+#if defined(__riscv)
+#define CONFIG_SYS_CACHELINE_SIZE	64
+#endif
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+
+/* Download related definitions */
+#define UPGRADE_SRAM_ADDR    0x0e000030
+#define UBOOT_PID_SRAM_ADDR  0x0e000030
+#define IMG_ADDR 0x80090000
+#define HEADER_ADDR 0x80080000
+#define USB_UPDATE_MAGIC 0x4D474E31
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	#define CONFIG_CMD_UBI
+	#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#ifndef CONFIG_NAND_FLASH_CVSNFC_V3
+	#define CONFIG_NAND_FLASH_CVSNFC_V3
+#endif
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#ifndef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#endif
+
+#define CONFIG_ENV_OVERWRITE
+
+#ifndef CONFIG_NAND_SUPPORT
+/* #define CONFIG_MMC_HS200_SUPPORT */
+/* #define CONFIG_MMC_SUPPORTS_TUNING */
+#endif
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_UDP_FUNCTION_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH_MMC_DEV 0
+#define CONFIG_FASTBOOT_BUF_ADDR 0x98000000
+#define CONFIG_FASTBOOT_BUF_SIZE 0x8000000
+
+#define CONFIG_IPADDR            "192.168.0.3"
+#define CONFIG_NETMASK            "255.255.255.0"
+#define CONFIG_GATEWAYIP        "192.168.0.11"
+#define CONFIG_SERVERIP            "192.168.56.101"
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	(0x81200000)
+	#define MEM_SISZ	__stringify(CONFIG_SYS_BOOTMAPSZ)
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi release loglevel=0\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon=sbi loglevel=9\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=115200\0" \
+		"mem=" MEM_SISZ "\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs mem=${mem} ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+
+	#if defined(CONFIG_NAND_SUPPORT) || defined(CONFIG_SPI_FLASH) || defined(CONFIG_EMMC_SUPPORT)
+		#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "cvi_update || run norboot || run nandboot ||run emmcboot"
+	#else
+		#define CONFIG_BOOTCOMMAND	"run ramboot"
+	#endif
+
+	#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;" \
+				"echo run Ramboot...;" \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#if defined(CONFIG_NAND_SUPPORT)
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SD_BOOT)
+		#define CONFIG_SDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"fatload mmc 1:1 ${uImage_addr} boot.sd;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_EMMC_SUPPORT)
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV1822_ASIC_H */
diff --git a/include/configs/cv181x-palladium.h b/include/configs/cv181x-palladium.h
new file mode 100644
index 000000000..cd7a6e3e9
--- /dev/null
+++ b/include/configs/cv181x-palladium.h
@@ -0,0 +1,325 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV181X_PALLADIUM_H__
+#define __CV181X_PALLADIUM_H__
+
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x88000000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (8 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		307200
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x80000000
+#define PHYS_SDRAM_1_SIZE	0x10000000
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Download related definitions */
+#define UPGRADE_SRAM_ADDR    0x0e000030
+#define HEADER_ADDR 0x80080000
+#define USB_UPDATE_MAGIC 0x4D474E31
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_CMD_SF		 /* sf read/sf write/sf erase */
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	#define CONFIG_CMD_UBI
+	#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#ifndef CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#endif
+
+#define CONFIG_FAT_WRITE
+#define CONFIG_ENV_OVERWRITE
+
+#ifndef CONFIG_NAND_SUPPORT
+/* #define CONFIG_MMC_HS200_SUPPORT */
+/* #define CONFIG_MMC_SUPPORTS_TUNING */
+#endif
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_UDP_FUNCTION_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH_MMC_DEV 0
+#define CONFIG_FASTBOOT_BUF_ADDR 0x98000000
+#define CONFIG_FASTBOOT_BUF_SIZE 0x8000000
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	(0x81200000)
+	#define MEM_SISZ	__stringify(CONFIG_SYS_BOOTMAPSZ)
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon release loglevel=0\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon loglevel=10\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=19200\0" \
+		"mem=" MEM_SISZ "\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs mem=${mem} ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define CONFIG_BOOTCOMMAND	"run ramboot"
+
+	#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;" \
+				"echo run Ramboot...;" \
+				"if test $? -eq 0; then " \
+				UBOOT_VBOOT_BOOTM_COMMAND \
+				"fi;"
+
+	#ifdef CONFIG_NAND_SUPPORT
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SD_BOOT)
+		#define CONFIG_SDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"fatload mmc 1:1 ${uImage_addr} boot.sd;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#else
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV1822_ASIC_H */
diff --git a/include/configs/cv1822-asic.h b/include/configs/cv1822-asic.h
new file mode 100644
index 000000000..95b2d04ab
--- /dev/null
+++ b/include/configs/cv1822-asic.h
@@ -0,0 +1,320 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV1822_ASIC_H
+#define __CV1822_ASIC_H
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+#define CONFIG_ARMV8_SWITCH_TO_EL1
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x83080000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x80000000
+#define PHYS_SDRAM_1_SIZE	CONFIG_SYS_BOOTMAPSZ
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Enable watchdog */
+#define CONFIG_HW_WATCHDOG
+#define CONFIG_DESIGNWARE_WATCHDOG
+#define CONFIG_WATCHDOG_TIMEOUT_MSECS 42000 // options: 1s, 2s, 5s, 10s, 21, 42s, 85s
+
+/* Download related definitions */
+#define SD_UPDATE_SRAM_ADDR  0x0e000004
+#define USB_UPDATE_SRAM_ADDR 0x0e000004
+#define UPGRADE_SRAM_ADDR    0x0e000030
+#define HEADER_ADDR 0x80080000
+#define USB_UPDATE_MAGIC 0x4D474E31
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_CMD_SF		 /* sf read/sf write/sf erase */
+	#define CONFIG_SPI_FLASH_CVSFC
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+	#define CONFIG_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_CMD_SAVEENV
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+	#define CONFIG_MTD
+	#define CONFIG_MTD_RAW_NAND
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	//#define CONFIG_CMD_UBI
+	//#define CONFIG_CMD_UBIFS
+	//#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	//#define CONFIG_MTD_UBI_BEB_LIMIT 20
+	#define NANDBOOT_V2
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#define CONFIG_FAT_WRITE
+#define CONFIG_ENV_OVERWRITE
+
+/* Support eMMC/SD tuning function for SDR104/HS200 Mode */
+#define CONFIG_MMC_SUPPORTS_TUNING
+/* Support SD UHS Feature SDR104 Mode */
+/* #define CONFIG_MMC_UHS_SUPPORT */
+#ifdef CONFIG_EMMC_SUPPORT
+/* Support eMMC Feature HS200 Mode */
+#define CONFIG_MMC_HS200_SUPPORT
+#endif
+
+/* #define CONFIG_USB_DWC2 */
+/* #define CONFIG_USB_DWC2_REG_ADDR	0x04340000 */
+/* Enable below CONFIG for fastboot */
+
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH
+
+/* To use usb fastboot, you need to enable below Kconfig
+ * CONFIG_USB, CONFIG_USB_GADGET and CONFIG_USB_GADGET_DWC2_OTG
+ */
+
+#ifdef CONFIG_USB_GADGET
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_USB_GADGET_DOWNLOAD
+#define CONFIG_G_DNL_MANUFACTURER "Cvitek"
+#define CONFIG_G_DNL_VENDOR_NUM   0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM 0x4ee0
+#endif
+
+#define CONFIG_UDP_FUNCTION_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH_MMC_DEV 0
+#define CONFIG_FASTBOOT_BUF_ADDR 0x98000000
+#define CONFIG_FASTBOOT_BUF_SIZE 0x8000000
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+	#define UIMAG_ADDR	(0x81200000)
+	#define MEM_SISZ	__stringify(CONFIG_SYS_BOOTMAPSZ)
+
+	#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x81800000"
+		#define LOGO_READ_ADDR "0x84080000"
+		#define VO_ALIGNMENT "16"
+		#define LOGOSIZE "0x80000"
+	#endif
+/******************************************************************************/
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon release loglevel=8\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon loglevel=8\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=115200\0" \
+		"mem=" MEM_SISZ "\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND "bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+	#define SET_BOOTARGS "setenv bootargs mem=${mem} ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "cvi_update || run norboot || run nandboot ||run emmcboot"
+
+	#ifdef CONFIG_NAND_SUPPORT
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#else
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+#endif /* __CV1822_ASIC_H */
diff --git a/include/configs/cv1822-fpga.h b/include/configs/cv1822-fpga.h
new file mode 100644
index 000000000..f25acceea
--- /dev/null
+++ b/include/configs/cv1822-fpga.h
@@ -0,0 +1,224 @@
+
+#ifndef __CV1822_FGPA_H
+#define __CV1822_FPGA_H
+
+/*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define MTDPARTS_DEFAULT     \
+							"mtdparts=cvsnfc:"    \
+							"8m(fip),"         \
+							"8m(config),"      \
+							"48m(itbImage0),"   \
+							"48m(itbImage1)"
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x83080000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x80080000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x80000000
+#define PHYS_SDRAM_1_SIZE	0x10000000
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+				"netdev=eth0\0"		\
+				"consoledev=ttyS0\0"	\
+				"baudrate=115200\0"	\
+				"othbootargs=earlycon debug user_debug=31 loglevel=10 no_console_suspend"
+
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+/* #define CONFIG_SPI_SUPPORT */
+
+#ifdef CONFIG_SPI_SUPPORT
+	#define CONFIG_CMD_SF		/* sf read/sf write/sf erase */
+	#define CONFIG_SPI_FLASH_CVSFC
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+#endif
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_CVSFC_BUFFER_BASE_ADDRESS	SFC_MEM_BASE
+	#define CONFIG_CVSFC_REG_BASE_ADDRESS	SFC_REG_BASE
+	#define CONFIG_CVSFC_PERIPHERY_REGBASE	CRG_REG_BASE
+	#define CONFIG_CVSFC_CHIP_NUM		2
+#endif /* CONFIG_SPI_FLASH_HISFC350 */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+/* #define CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_SUPPORT
+	#define NANDBOOT_V2
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE		1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define MTDIDS_DEFAULT "nand0=cvsnfc"
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP	CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif
+
+/* Config Boot From RAM or NFS */
+#define CONFIG_BOOTCOMMAND	"run ramboot"
+/* #define CONFIG_BOOTCOMMAND	CONFIG_RAMBOOTCOMMAND */
+
+#define CONFIG_NFSBOOTCOMMAND	"setenv bootargs root=/dev/nfs init=/init rw "			\
+					"nfsroot=$serverip:$rootpath,v3,tcp "				\
+					"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+					"console=$consoledev,$baudrate $othbootargs;"			\
+				"setenv kernel_name Image;"			\
+				"setenv kernel_addr 0x80080000;"		\
+				"setenv fdt_name cv1822_fpga.dtb;"	\
+				"setenv fdt_addr 0x80200000;"			\
+				"tftp ${kernel_addr} ${kernel_name}; "		\
+				"tftp ${fdt_addr} ${fdt_name}; "		\
+				"fdt addr ${fdt_addr}; fdt resize; "		\
+				"booti ${kernel_addr} - ${fdt_addr}"
+
+#define CONFIG_NANDBOOTCOMMAND	"setenv bootargs console=${consoledev},${baudrate} ${othbootargs}, " \
+				MTDPARTS_DEFAULT ";"\
+				"setenv uimage_addr 0x120000000;"				\
+				"bootm ${uimage_addr}#config@1"
+
+/* 0x4D474E32 For SD Download magic number*/
+#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;" \
+				"setenv uimage_addr 0x81000000;" \
+				"echo run Ramboot...;" \
+				"bootm ${uimage_addr}#config@1;"
+
+#define CONFIG_MMCBOOTCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"fatload mmc 1:1 ${uimage_addr} sdboot.itb;"		\
+				"if test $? -eq 0; then "\
+				"bootm ${uimage_addr}#config@1;"	\
+				"fi;"
+
+#define CONFIG_BMDLCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110000000;"				\
+				"mw.l 0x04000388 0x626d646c;"				\
+				"cmp.l 0x04000384 0x04000388 1;"				\
+				"if test $? -eq 0; then "\
+				"mw.l 0x04000384 0x0;"				\
+				"bm_update ${uimage_addr}#config@1;"	\
+				"if test $? -eq 0; then "\
+				"bm_reboot;"    \
+				"fi;"  \
+				"fi;"
+
+#define CONFIG_EMMCBOOTCOMMAND  "setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"setenv boot_part_offset 0x2000;"		\
+				"setenv boot_part_blocks 0x77FF;"		\
+				"mmc dev 0 ;"		\
+				"mmc read ${uimage_addr} ${boot_part_offset} ${boot_part_blocks} ;"		\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+#define CONFIG_HOSTNAME			unknown
+#define CONFIG_ROOTPATH			"/home/share/nfsroot"
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_FAT_WRITE
+
+/* Enable below CONFIG for fastboot */
+/*
+ * #define CONFIG_CMD_FASTBOOT
+ * #define CONFIG_FASTBOOT
+ * #define CONFIG_FASTBOOT_FLASH
+ * #define CONFIG_UDP_FUNCTION_FASTBOOT
+ * #define CONFIG_FASTBOOT_FLASH_MMC_DEV 0
+ * #define CONFIG_FASTBOOT_BUF_ADDR 0x10F100000
+ * #define CONFIG_FASTBOOT_BUF_SIZE 0x8000000
+ */
+
+#endif /* __CV1822_FPGA_H */
diff --git a/include/configs/cv1822-palladium.h b/include/configs/cv1822-palladium.h
new file mode 100644
index 000000000..cc137a9b2
--- /dev/null
+++ b/include/configs/cv1822-palladium.h
@@ -0,0 +1,168 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV1822_PALLADIUM_H
+#define __CV1822_PALLADIUM_H
+
+/*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define MTDPARTS_DEFAULT     \
+							"mtdparts=cvsnfc:"    \
+							"8m(fip),"         \
+							"8m(config),"      \
+							"48m(itbImage0),"   \
+							"48m(itbImage1)"
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x88000000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x90000000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		307200
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x80000000
+#define PHYS_SDRAM_1_SIZE	0x10000000
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+				"netdev=eth0\0"		\
+				"consoledev=ttyS0\0"	\
+				"baudrate=19200\0"	\
+				"othbootargs=earlycon debug user_debug=31 loglevel=10 no_console_suspend"
+
+/* Config Boot From RAM or NFS */
+#define CONFIG_BOOTCOMMAND	"run ramboot"
+/* #define CONFIG_BOOTCOMMAND	CONFIG_RAMBOOTCOMMAND */
+
+#define CONFIG_NFSBOOTCOMMAND	"setenv bootargs root=/dev/nfs init=/init rw "			\
+					"nfsroot=$serverip:$rootpath,v3,tcp "				\
+					"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+					"console=$consoledev,$baudrate $othbootargs;"			\
+				"setenv kernel_name Image;"			\
+				"setenv kernel_addr 0x80080000;"		\
+				"setenv fdt_name cv1822_palladium.dtb;"	\
+				"setenv fdt_addr 0x80200000;"			\
+				"tftp ${kernel_addr} ${kernel_name}; "		\
+				"tftp ${fdt_addr} ${fdt_name}; "		\
+				"fdt addr ${fdt_addr}; fdt resize; "		\
+				"booti ${kernel_addr} - ${fdt_addr}"
+
+#define CONFIG_NANDBOOTCOMMAND	"setenv bootargs console=${consoledev},${baudrate} ${othbootargs}, " \
+				MTDPARTS_DEFAULT ";"\
+				"setenv uimage_addr 0x120000000;"				\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x90000000;" \
+				"echo run Ramboot...;" \
+				"bootm ${uimage_addr}#config@1;"
+
+#define CONFIG_MMCBOOTCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"fatload mmc 1:1 ${uimage_addr} sdboot.itb;"		\
+				"if test $? -eq 0; then "\
+				"bootm ${uimage_addr}#config@1;"	\
+				"fi;"
+
+#define CONFIG_BMDLCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110000000;"				\
+				"mw.l 0x04000388 0x626d646c;"				\
+				"cmp.l 0x04000384 0x04000388 1;"				\
+				"if test $? -eq 0; then "\
+				"mw.l 0x04000384 0x0;"				\
+				"bm_update ${uimage_addr}#config@1;"	\
+				"if test $? -eq 0; then "\
+				"bm_reboot;"    \
+				"fi;"  \
+				"fi;"
+
+#define CONFIG_EMMCBOOTCOMMAND  "setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"mmcbcb mmc 0 recovery;"	\
+				"if test $recovery = boot-recovery;then "		\
+				"setenv boot_part_offset 0x42000;"		\
+				"setenv boot_part_blocks 0x40000;"		\
+				"else "				\
+				"setenv boot_part_offset 0x2000;"		\
+				"setenv boot_part_blocks 0x77FF;"		\
+				"fi;"		\
+				"mmc dev 0 ;"		\
+				"mmc read ${uimage_addr} ${boot_part_offset} ${boot_part_blocks} ;"		\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+#define CONFIG_HOSTNAME			unknown
+#define CONFIG_ROOTPATH			"/home/share/nfsroot"
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_FAT_WRITE
+
+#endif /* __CV1822_PALLADIUM_H */
diff --git a/include/configs/cv1835-asic.h b/include/configs/cv1835-asic.h
new file mode 100644
index 000000000..ac2d56973
--- /dev/null
+++ b/include/configs/cv1835-asic.h
@@ -0,0 +1,313 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV1835_ASIC_H
+#define __CV1835_ASIC_H
+/* partition definitions header which is created by mkcvipart.py */
+/* please do not modify header manually */
+#include "cvipart.h"
+#include "cvi_panels/cvi_panel_diffs.h"
+
+/*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x108000000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x100080000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x100000000
+#define PHYS_SDRAM_1_SIZE	0x10000000
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Enable watchdog */
+#define CONFIG_HW_WATCHDOG
+#define CONFIG_DESIGNWARE_WATCHDOG
+#define CONFIG_WATCHDOG_TIMEOUT_MSECS 42000 // options: 1s, 2s, 5s, 10s, 21, 42s, 85s
+
+/* Download related definitions */
+#define SD_UPDATE_SRAM_ADDR 0xe00fc00
+#define USB_UPDATE_SRAM_ADDR 0xe00fc08
+#define UPGRADE_SRAM_ADDR 0x03005D00
+#define HEADER_ADDR 0x10F200000
+#define USB_UPDATE_MAGIC 0x4D474E33
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_CMD_SF		 /* sf read/sf write/sf erase */
+	#define CONFIG_SPI_FLASH_CVSFC
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define CONFIG_FLASH_CFI_MTD
+	#define CONFIG_SYS_MAX_FLASH_BANKS 1
+	#define CONFIG_SPI_FLASH_MTD
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE	 1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	/* For CMD_UBI && CMD_UBIFS */
+	#define CONFIG_RBTREE
+	#define CONFIG_LZO
+	#define CONFIG_CMD_UBI
+	#define CONFIG_CMD_UBIFS
+	#define CONFIG_MTD_UBI_WL_THRESHOLD 4096
+	#define CONFIG_MTD_UBI_BEB_LIMIT 20
+    // Only support Toshiba SPINAND for now
+    //#define DEBUG_WRITE_TWICE
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#define CONFIG_FAT_WRITE
+#define CONFIG_ENV_OVERWRITE
+
+/* Support eMMC/SD tuning function for SDR104/HS200 Mode */
+#define CONFIG_MMC_SUPPORTS_TUNING
+/* Support SD UHS Feature SDR104 Mode */
+#define CONFIG_MMC_UHS_SUPPORT
+#ifdef CONFIG_EMMC_SUPPORT
+/* Support eMMC Feature HS200 Mode */
+#define CONFIG_MMC_HS200_SUPPORT
+#endif
+
+/* Enable below CONFIG for fastboot */
+
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH
+#define CONFIG_UDP_FUNCTION_FASTBOOT
+#define CONFIG_FASTBOOT_FLASH_MMC_DEV 0
+#define CONFIG_FASTBOOT_BUF_ADDR 0x10F100000
+#define CONFIG_FASTBOOT_BUF_SIZE 0x8000000
+
+#ifdef CONFIG_USE_DEFAULT_ENV
+/* The following Settings are chip dependent */
+/******************************************************************************/
+#define UIMAG_ADDR	(0x101080000)
+#ifdef CONFIG_BOOTLOGO
+		#define LOGO_RESERVED_ADDR "0x11FE00000"
+		#define LOGO_READ_ADDR "0x132000000"
+		#define VO_ALIGNMENT "32"
+		#define LOGOSIZE "0x80000"
+#endif
+/******************************************************************************/
+
+/* define common env */
+/*******************************************************************************/
+	/* Config FDT_NO */
+	#ifndef USE_HOSTCC
+		#define FDT_NO __stringify(CVICHIP) "_" __stringify(CVIBOARD)
+	#else
+		#define FDT_NO ""
+	#endif
+
+	/* config root */
+	#ifdef CONFIG_NAND_SUPPORT
+		#ifdef CONFIG_SKIP_RAMDISK
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs"
+
+		#else
+			#define ROOTARGS "ubi.mtd=ROOTFS ubi.block=0,0"
+		#endif /* CONFIG_SKIP_RAMDISK */
+	#else
+		#define ROOTARGS "rootfstype=squashfs root=" ROOTFS_DEV
+	#endif
+
+	/* BOOTARGS */
+	#define PARTS  PART_LAYOUT
+
+	/* config uart */
+	#define CONSOLEDEV "ttyS0\0"
+
+	/* config loglevel */
+	#ifdef RELEASE
+		#define OTHERBOOTARGS   "othbootargs=earlycon release loglevel=8\0"
+	#else
+		#define OTHERBOOTARGS   "othbootargs=earlycon loglevel=8\0"
+	#endif
+
+	/* config mtdids */
+	#ifdef CONFIG_NAND_SUPPORT
+		#define MTDIDS_DEFAULT "nand0=cvsnfc"
+	#elif CONFIG_SPI_FLASH
+		#define MTDIDS_DEFAULT "nor1=flash-0"
+	#else
+		#define MTDIDS_DEFAULT ""
+	#endif
+
+	#define CONFIG_EXTRA_ENV_SETTINGS	\
+		"netdev=eth0\0"		\
+		"consoledev=" CONSOLEDEV  \
+		"baudrate=115200\0" \
+		"uImage_addr=" __stringify(UIMAG_ADDR) "\0" \
+		"mtdparts=" PARTS "\0" \
+		"mtdids=" MTDIDS_DEFAULT "\0" \
+		"root=" ROOTARGS "\0" \
+		OTHERBOOTARGS \
+		PARTS_OFFSET
+
+/********************************************************************************/
+	/* UBOOT_VBOOT commands */
+	#ifdef UBOOT_VBOOT
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"mw.l 0x3009000 0x94e;" \
+					"aes_itb dec_fdt_key 0 ${uImage_addr} ${uImage_addr}; " \
+					"if test $? -ne 0; then " \
+					"  echo ITB decryption failed; " \
+					"else; " \
+					"  bootm ${uImage_addr}#config-" FDT_NO ";" \
+					"fi;"
+	#else
+		#define UBOOT_VBOOT_BOOTM_COMMAND \
+					"mw.l 0x3009000 0x94e;" \
+					"bootm ${uImage_addr}#config-" FDT_NO ";"
+	#endif
+
+	/* BOOTLOGO */
+	#ifdef CONFIG_BOOTLOGO
+		#define SHOWLOGOCMD "run showlogo;"
+
+		#ifdef CONFIG_NAND_SUPPORT
+			#define LOAD_LOGO "nand read " LOGO_READ_ADDR " MISC;"
+		#elif defined(CONFIG_SPI_FLASH)
+			#define LOAD_LOGO ""
+		#else
+			#define LOAD_LOGO "mmc dev 0;mmc read " LOGO_READ_ADDR " ${MISC_PART_OFFSET} ${MISC_PART_SIZE};"
+		#endif
+		#define SHOWLOGOCOMMAND LOAD_LOGO CVI_JPEG START_VO START_VL SET_VO_BG
+	#else
+		#define SHOWLOGOCMD
+	#endif
+
+#define SET_BOOTARGS "setenv bootargs ${root} ${mtdparts} " \
+					"console=$consoledev,$baudrate $othbootargs;"
+
+	#define CONFIG_BOOTCOMMAND	SHOWLOGOCMD "cvi_update || run norboot || run nandboot ||run emmcboot"
+
+	#ifdef CONFIG_NAND_SUPPORT
+	/* For spi nand boot, need to reset DMA and its setting before exiting uboot */
+	/* 0x4330058 : DMA reset */
+	/* 0x3000154 : restore DMA remap to 0 */
+
+		#define CONFIG_NANDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"nand read ${uImage_addr} BOOT;" \
+				"mw.l 4330058 1 1; md.l 4330058 1; mw.l 3000154 0 1;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SPI_FLASH)
+		#define CONFIG_NORBOOTCOMMAND \
+				SET_BOOTARGS \
+				"sf probe;sf read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE};" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#elif defined(CONFIG_SD_BOOT)
+		#define CONFIG_SDBOOTCOMMAND \
+				SET_BOOTARGS \
+				"fatload mmc 1:1 ${uImage_addr} boot.sd;" \
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#else
+		#define CONFIG_EMMCBOOTCOMMAND \
+				SET_BOOTARGS \
+				"mmc dev 0 ;"		\
+				"mmc read ${uImage_addr} ${BOOT_PART_OFFSET} ${BOOT_PART_SIZE} ;"		\
+				UBOOT_VBOOT_BOOTM_COMMAND
+	#endif
+
+#else
+	/* define your environment */
+	#define CONFIG_BOOTCOMMAND ""
+
+#endif /* CONFIG_USE_DEFAULT_ENV */
+
+
+#endif /* __CV1835_ASIC_H */
diff --git a/include/configs/cv1835-fpga.h b/include/configs/cv1835-fpga.h
new file mode 100644
index 000000000..d5ecf1e25
--- /dev/null
+++ b/include/configs/cv1835-fpga.h
@@ -0,0 +1,222 @@
+
+#ifndef __CV1835_FGPA_H
+#define __CV1835_FPGA_H
+
+/*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define MTDPARTS_DEFAULT     \
+							"mtdparts=cvsnfc:"    \
+							"8m(fip),"         \
+							"8m(config),"      \
+							"48m(itbImage0),"   \
+							"48m(itbImage1)"
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x108000000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x100080000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		25000000
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x100000000
+#define PHYS_SDRAM_1_SIZE	0x10000000
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+				"netdev=eth0\0"		\
+				"consoledev=ttyS0\0"	\
+				"baudrate=115200\0"	\
+				"othbootargs=earlycon debug user_debug=31 loglevel=10 no_console_suspend"
+
+/*----------------------------------------------------------------------
+ * SPI Flash Configuration
+ * ---------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_SPI_FLASH
+	#define CONFIG_CMD_SF		 /* sf read/sf write/sf erase */
+	#define CONFIG_SPI_FLASH_CVSFC
+#define CONFIG_SPI_FLASH_BAR
+#endif /* CONFIG_SPI_FLASH */
+
+/*-----------------------------------------------------------------------
+ * SPI NAND Flash Configuration
+ *----------------------------------------------------------------------
+ */
+
+#ifdef CONFIG_NAND_SUPPORT
+	/*#define CONFIG_ENV_IS_IN_NAND*/ /* env in nand flash */
+	#define CONFIG_CMD_NAND
+	#define CONFIG_SYS_MAX_NAND_DEVICE		1
+
+	#define CONFIG_NAND_FLASH_CVSNFC
+	#define CONFIG_SYS_MAX_NAND_CHIPS 1
+	/*#define CONFIG_SYS_NAND_SELF_INIT*/
+
+	#define CONFIG_CMD_MTDPARTS
+	#define CONFIG_MTD_PARTITIONS
+	#define MTDIDS_DEFAULT "nand0=cvsnfc"
+
+#endif /* CONFIG_NAND_SUPPORT */
+
+#ifdef CONFIG_NAND_FLASH_CVSNFC
+	#define SPI_NAND_TX_DATA_BASE 0x4060060
+	#define SPI_NAND_RX_DATA_BASE 0x4060064
+
+	#define SPI_NAND_REG_BASE 0x4060000
+	#define CONFIG_SYS_NAND_MAX_CHIPS		1
+	#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_MAX_CHIP	CONFIG_SYS_MAX_NAND_DEVICE
+	#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+	#define CONFIG_CVSNFC_BUFFER_BASE_ADDRESS	SPI_NAND_MEM_BASE
+	#define CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+	#define CONFIG_SYS_NAND_BASE_LIST		{CONFIG_SYS_NAND_BASE}
+
+#endif
+
+/* Config Boot From RAM or NFS */
+#define CONFIG_BOOTCOMMAND	"run ramboot || run bmdl || run sdboot || run emmcboot || run nfsboot"
+/* #define CONFIG_BOOTCOMMAND	CONFIG_RAMBOOTCOMMAND */
+
+#define CONFIG_NFSBOOTCOMMAND	"setenv bootargs root=/dev/nfs init=/init rw "			\
+					"nfsroot=$serverip:$rootpath,v3,tcp "				\
+					"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+					"console=$consoledev,$baudrate $othbootargs;"			\
+				"setenv kernel_name Image;"			\
+				"setenv kernel_addr 0x100080000;"		\
+				"setenv fdt_name cv1835_fpga.dtb;"	\
+				"setenv fdt_addr 0x102000000;"			\
+				"tftp ${kernel_addr} ${kernel_name}; "		\
+				"tftp ${fdt_addr} ${fdt_name}; "		\
+				"fdt addr ${fdt_addr}; fdt resize; "		\
+				"booti ${kernel_addr} - ${fdt_addr}"
+
+#define CONFIG_NANDBOOTCOMMAND	"setenv bootargs console=${consoledev},${baudrate} ${othbootargs}, " \
+				MTDPARTS_DEFAULT ";"\
+				"setenv uimage_addr 0x120000000;"				\
+				"bootm ${uimage_addr}#config@1"
+
+/* 0x4D474E32 For SD Download magic number*/
+#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;" \
+				"setenv uimage_addr 0x120000000;" \
+				"mw.l  0xe00fc04 0x4D474E32;" \
+				"cmp.l 0xe00fc00 0xe00fc04 1;" \
+				"if test $? -eq 0; then " \
+				"echo SD downloading...;" \
+				"fatload mmc 1:0 0x10F200000 sd_script.img;" \
+				"source 0x10F200000;" \
+				"else " \
+				"echo run Ramboot...;" \
+				"bootm ${uimage_addr}#config@1;" \
+				"fi;"
+
+#define CONFIG_MMCBOOTCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"fatload mmc 1:1 ${uimage_addr} sdboot.itb;"		\
+				"if test $? -eq 0; then "\
+				"bootm ${uimage_addr}#config@1;"	\
+				"fi;"
+
+#define CONFIG_BMDLCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110000000;"				\
+				"mw.l 0x04000388 0x626d646c;"				\
+				"cmp.l 0x04000384 0x04000388 1;"				\
+				"if test $? -eq 0; then "\
+				"mw.l 0x04000384 0x0;"				\
+				"bm_update ${uimage_addr}#config@1;"	\
+				"if test $? -eq 0; then "\
+				"bm_reboot;"    \
+				"fi;"  \
+				"fi;"
+
+#define CONFIG_EMMCBOOTCOMMAND  "setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"setenv boot_part_offset 0x2000;"		\
+				"setenv boot_part_blocks 0x77FF;"		\
+				"mmc dev 0 ;"		\
+				"mmc read ${uimage_addr} ${boot_part_offset} ${boot_part_blocks} ;"		\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+#define CONFIG_HOSTNAME			unknown
+#define CONFIG_ROOTPATH			"/home/share/nfsroot"
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_FAT_WRITE
+
+/* Enable below CONFIG for fastboot */
+/*
+ * #define CONFIG_CMD_FASTBOOT
+ * #define CONFIG_FASTBOOT
+ * #define CONFIG_FASTBOOT_FLASH
+ * #define CONFIG_UDP_FUNCTION_FASTBOOT
+ * #define CONFIG_FASTBOOT_FLASH_MMC_DEV 0
+ * #define CONFIG_FASTBOOT_BUF_ADDR 0x10F100000
+ * #define CONFIG_FASTBOOT_BUF_SIZE 0x8000000
+ */
+
+#endif /* __CV1835_FPGA_H */
diff --git a/include/configs/cv1835-palladium.h b/include/configs/cv1835-palladium.h
new file mode 100644
index 000000000..afcf15a0f
--- /dev/null
+++ b/include/configs/cv1835-palladium.h
@@ -0,0 +1,159 @@
+/*
+ * Configuration for Versatile Express. Parts were derived from other ARM
+ *   configurations.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CV1835_PALLADIUM_H
+#define __CV1835_PALLADIUM_H
+
+/*#define CONFIG_ARMV8_SWITCH_TO_EL1*/
+
+#define CONFIG_REMAKE_ELF
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* Link Definitions */
+/* ATF loads u-boot here for BASE_FVP model */
+#define CONFIG_SYS_TEXT_BASE		0x108000000
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_SDRAM_BASE + 0x03f00000)
+
+#define CONFIG_SYS_BOOTM_LEN (64 << 20)      /* Increase max gunzip size */
+
+/* default address for bootm command without arguments */
+#define CONFIG_SYS_LOAD_ADDR		0x100080000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x01F01000)
+#define GICC_BASE			(0x01F02000)
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (9 << 20))
+
+/* For network descriptor, should be enabled when mmu is okay */
+#define CONFIG_SYS_NONCACHED_MEMORY	BIT(20)	/* 1 MiB */
+
+/* 16550 Serial Configuration */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550_COM1		0x04140000
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_CLK		307200
+/* include/generated/autoconf.h would define CONFIG_BAUDRATE from drivers/serial/Kconfig (default 115200) */
+
+/*#define CONFIG_MENU_SHOW*/
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+
+/* Physical Memory Map */
+#define PHYS_SDRAM_1		0x100000000
+#define PHYS_SDRAM_1_SIZE	0x10000000
+#define CONFIG_SYS_SDRAM_BASE	PHYS_SDRAM_1
+
+#define BM_UPDATE_FW_START_ADDR             (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+#define BM_UPDATE_FW_SIZE		            (0x70000000)
+#define BM_UPDATE_FW_FILLBUF_SIZE           (1024 * 512)
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* Enable memtest */
+#define CONFIG_SYS_MEMTEST_START	PHYS_SDRAM_1
+#define CONFIG_SYS_MEMTEST_END		(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+				"netdev=eth0\0"		\
+				"consoledev=ttyS0\0"	\
+				"baudrate=19200\0"	\
+				"othbootargs=earlycon debug user_debug=31 loglevel=10"
+
+/* Config Boot From RAM or NFS */
+/* #define CONFIG_BOOTCOMMAND	"run bmdl || run sdboot || run emmcboot || run nfsboot" */
+#define CONFIG_BOOTCOMMAND	CONFIG_RAMBOOTCOMMAND
+
+#define CONFIG_NFSBOOTCOMMAND	"setenv bootargs root=/dev/nfs init=/init rw "			\
+					"nfsroot=$serverip:$rootpath,v3,tcp "				\
+					"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+					"console=$consoledev,$baudrate $othbootargs;"			\
+				"setenv kernel_name Image;"			\
+				"setenv kernel_addr 0x100080000;"		\
+				"setenv fdt_name cv1835_palladium.dtb;"	\
+				"setenv fdt_addr 0x102000000;"			\
+				"tftp ${kernel_addr} ${kernel_name}; "		\
+				"tftp ${fdt_addr} ${fdt_name}; "		\
+				"fdt addr ${fdt_addr}; fdt resize; "		\
+				"booti ${kernel_addr} - ${fdt_addr}"
+
+#define CONFIG_NANDBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x10F100000; nand read $uimage_addr 2800000 2000000;"	\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_RAMBOOTCOMMAND	"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x120000000;"				\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_MMCBOOTCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"fatload mmc 1:1 ${uimage_addr} sdboot.itb;"		\
+				"if test $? -eq 0; then "\
+				"bootm ${uimage_addr}#config@1;"	\
+				"fi;"
+
+#define CONFIG_BMDLCOMMAND	\
+				"setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110000000;"				\
+				"mw.l 0x04000388 0x626d646c;"				\
+				"cmp.l 0x04000384 0x04000388 1;"				\
+				"if test $? -eq 0; then "\
+				"mw.l 0x04000384 0x0;"				\
+				"bm_update ${uimage_addr}#config@1;"	\
+				"if test $? -eq 0; then "\
+				"bm_reboot;"    \
+				"fi;"  \
+				"fi;"
+
+#define CONFIG_EMMCBOOTCOMMAND  "setenv bootargs console=$consoledev,$baudrate $othbootargs;"	\
+				"setenv uimage_addr 0x110080000;"				\
+				"mmcbcb mmc 0 recovery;"	\
+				"if test $recovery = boot-recovery;then "		\
+				"setenv boot_part_offset 0x42000;"		\
+				"setenv boot_part_blocks 0x40000;"		\
+				"else "				\
+				"setenv boot_part_offset 0x2000;"		\
+				"setenv boot_part_blocks 0x77FF;"		\
+				"fi;"		\
+				"mmc dev 0 ;"		\
+				"mmc read ${uimage_addr} ${boot_part_offset} ${boot_part_blocks} ;"		\
+				"bootm ${uimage_addr}#config@1"
+
+#define CONFIG_IPADDR			192.168.0.3
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		192.168.0.11
+#define CONFIG_SERVERIP			192.168.56.101
+#define CONFIG_HOSTNAME			unknown
+#define CONFIG_ROOTPATH			"/home/share/nfsroot"
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_ENV_ADDR			PHYS_SDRAM_1
+#define CONFIG_ENV_SECT_SIZE		0x00040000
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_IS_NOWHERE
+#define CONFIG_FAT_WRITE
+
+#endif /* __CV1835_PALLADIUM_H */
diff --git a/include/crc.h b/include/crc.h
new file mode 100644
index 000000000..111cb4adb
--- /dev/null
+++ b/include/crc.h
@@ -0,0 +1,43 @@
+/*
+ *==========================================================================
+ *
+ *      crc.h
+ *
+ *      Interface for the CRC algorithms.
+ *
+ *==========================================================================
+ * SPDX-License-Identifier:	eCos-2.0
+ *==========================================================================
+ *#####DESCRIPTIONBEGIN####
+ *
+ * Author(s):    Andrew Lunn
+ * Contributors: Andrew Lunn
+ * Date:         2002-08-06
+ * Purpose:
+ * Description:
+ *
+ * This code is part of eCos (tm).
+ *
+ *####DESCRIPTIONEND####
+ *
+ *==========================================================================
+ */
+
+#ifndef _SERVICES_CRC_CRC_H_
+#define _SERVICES_CRC_CRC_H_
+
+#include <linux/types.h>
+
+#ifndef __externC
+# ifdef __cplusplus
+#  define __externC extern "C"
+# else
+#  define __externC extern
+# endif
+#endif
+
+/* 16 bit CRC with polynomial x^16+x^12+x^5+1 (CRC-CCITT) */
+
+uint16_t crc16_ccitt(uint16_t crc_start, unsigned char *s, int len);
+
+#endif /* _SERVICES_CRC_CRC_H_ */
diff --git a/include/cvi_efuse.h b/include/cvi_efuse.h
new file mode 100644
index 000000000..b912862bc
--- /dev/null
+++ b/include/cvi_efuse.h
@@ -0,0 +1,58 @@
+#ifndef _CVI_EFUSE_H
+#define _CVI_EFUSE_H 1
+
+#ifndef CVI_U8
+#define CVI_U8 uint8_t
+#endif
+#ifndef CVI_U32
+#define CVI_U32 uint32_t
+#endif
+#ifndef CVI_S8
+#define CVI_S8 int8_t
+#endif
+#ifndef CVI_S32
+#define CVI_S32 int32_t
+#endif
+
+#ifndef CVI_SUCCESS
+#define CVI_SUCCESS 0
+#endif
+#ifndef CVI_FAILURE
+#define CVI_FAILURE (-1)
+#endif
+
+#define CVI_ERR_EFUSE_INVALID_AREA -0x0001
+#define CVI_ERR_EFUSE_INVALID_PARA -0x0002
+
+enum CVI_EFUSE_AREA_E {
+	CVI_EFUSE_AREA_USER,
+	CVI_EFUSE_AREA_DEVICE_ID,
+	CVI_EFUSE_AREA_HASH0_PUBLIC,
+	CVI_EFUSE_AREA_LOADER_EK,
+	CVI_EFUSE_AREA_DEVICE_EK,
+	CVI_EFUSE_AREA_LAST
+};
+
+enum CVI_EFUSE_LOCK_E {
+	CVI_EFUSE_LOCK_HASH0_PUBLIC = CVI_EFUSE_AREA_LAST + 1,
+	CVI_EFUSE_LOCK_LOADER_EK,
+	CVI_EFUSE_LOCK_DEVICE_EK,
+	CVI_EFUSE_LOCK_LAST
+};
+
+enum CVI_EFUSE_OTHERS_E {
+	CVI_EFUSE_SECUREBOOT = CVI_EFUSE_LOCK_LAST + 1,
+	CVI_EFUSE_OTHERS
+};
+
+CVI_S32 CVI_EFUSE_GetSize(enum CVI_EFUSE_AREA_E area, CVI_U32 *size);
+CVI_S32 CVI_EFUSE_Read(enum CVI_EFUSE_AREA_E area, CVI_U8 *buf, CVI_U32 buf_size);
+CVI_S32 CVI_EFUSE_Write(enum CVI_EFUSE_AREA_E area, const CVI_U8 *buf, CVI_U32 buf_size);
+CVI_S32 CVI_EFUSE_EnableSecureBoot(void);
+CVI_S32 CVI_EFUSE_IsSecureBootEnabled(void);
+CVI_S32 CVI_EFUSE_Lock(enum CVI_EFUSE_LOCK_E lock);
+CVI_S32 CVI_EFUSE_IsLocked(enum CVI_EFUSE_LOCK_E lock);
+CVI_S32 CVI_EFUSE_LockWrite(enum CVI_EFUSE_LOCK_E lock);
+CVI_S32 CVI_EFUSE_IsWriteLocked(enum CVI_EFUSE_LOCK_E lock);
+
+#endif /* _CVI_EFUSE_H */
diff --git a/include/cvi_update.h b/include/cvi_update.h
new file mode 100644
index 000000000..4432dc042
--- /dev/null
+++ b/include/cvi_update.h
@@ -0,0 +1,15 @@
+#ifndef __CVI_UPDATE_H__
+#define __CVI_UPDATE_H__
+
+#define EXTRA_FLAG_SIZE 32
+
+#undef pr_debug
+#ifdef DEBUG
+#define pr_debug(fmt, ...) printf(fmt, ##__VA_ARGS__)
+#else
+#define pr_debug(fmt, ...)
+#endif
+
+int _prgImage(char *file, uint32_t chunk_header_size, char *file_name);
+
+#endif /* __CVI_UPDATE_H__ */
diff --git a/include/cvitek/cv183x_reg.h b/include/cvitek/cv183x_reg.h
new file mode 100644
index 000000000..2be6ff707
--- /dev/null
+++ b/include/cvitek/cv183x_reg.h
@@ -0,0 +1,116 @@
+#ifndef __CV183X_REG_H
+#define __CV183X_REG_H
+
+#define TOP_BASE        0x03000000
+#define PINMUX_BASE     (TOP_BASE + 0x1000)
+#define WATCHDOG_BASE	(TOP_BASE + 0x00010000)
+
+/*
+ * Pinmux definitions
+ */
+#define PINMUX_UART0    0
+#define PINMUX_UART1    1
+#define PINMUX_UART2    2
+#define PINMUX_UART3    3
+#define PINMUX_UART3_2  4
+#define PINMUX_I2C0     5
+#define PINMUX_I2C1     6
+#define PINMUX_I2C2     7
+#define PINMUX_I2C3     8
+#define PINMUX_I2C4     9
+#define PINMUX_I2C4_2   10
+#define PINMUX_SPI0     11
+#define PINMUX_SPI1     12
+#define PINMUX_SPI2     13
+#define PINMUX_SPI2_2   14
+#define PINMUX_SPI3     15
+#define PINMUX_SPI3_2   16
+#define PINMUX_I2S0     17
+#define PINMUX_I2S1     18
+#define PINMUX_I2S2     19
+#define PINMUX_I2S3     20
+#define PINMUX_USBID    21
+#define PINMUX_SDIO0    22
+#define PINMUX_SDIO1    23
+#define PINMUX_ND       24
+#define PINMUX_EMMC     25
+#define PINMUX_SPI_NOR  26
+#define PINMUX_SPI_NAND 27
+#define PINMUX_CAM0     28
+#define PINMUX_CAM1     29
+#define PINMUX_PCM0     30
+#define PINMUX_PCM1     31
+#define PINMUX_CSI0     32
+#define PINMUX_CSI1     33
+#define PINMUX_CSI2     34
+#define PINMUX_DSI      35
+#define PINMUX_VI0      36
+#define PINMUX_VO       37
+#define PINMUX_RMII1    38
+#define PINMUX_EPHY_LED 39
+#define PINMUX_I80      40
+#define PINMUX_LVDS     41
+
+/* rst */
+#define REG_TOP_SOFT_RST        0x3000
+#define BIT_TOP_SOFT_RST_USB    BIT(11)
+#define BIT_TOP_SOFT_RST_SDIO   BIT(14)
+#define BIT_TOP_SOFT_RST_NAND   BIT(12)
+
+#define REG_TOP_USB_CTRSTS	(TOP_BASE + 0x38)
+
+#define REG_TOP_CONF_INFO		(TOP_BASE + 0x4)
+#define BIT_TOP_CONF_INFO_VBUS		BIT(9)
+#define REG_TOP_USB_PHY_CTRL		(TOP_BASE + 0x48)
+#define BIT_TOP_USB_PHY_CTRL_EXTVBUS	BIT(0)
+#define REG_TOP_DDR_ADDR_MODE		(TOP_BASE + 0x64)
+
+/* irq */
+#define IRQ_LEVEL   0
+#define IRQ_EDGE    3
+
+/* usb */
+#define USB_BASE            0x040C0000
+#define USB_HOST_BASE       0x040D0000
+#define USB_DEV_BASE        0x040E0000
+
+/* ethernet phy */
+#define ETH_PHY_BASE        0x03009000
+#define ETH_PHY_INIT_MASK   0xFFFFFFF9
+#define ETH_PHY_SHUTDOWN    BIT(1)
+#define ETH_PHY_POWERUP     0xFFFFFFFD
+#define ETH_PHY_RESET       0xFFFFFFFB
+#define ETH_PHY_RESET_N     BIT(2)
+#define ETH_PHY_LED_LOW_ACTIVE  BIT(3)
+
+/* watchdog */
+#define CONFIG_DW_WDT_BASE WATCHDOG_BASE
+#define CONFIG_DW_WDT_CLOCK_KHZ	25000
+
+#define DW_WDT_CR	0x00
+#define DW_WDT_TORR	0x04
+#define DW_WDT_CRR	0x0C
+
+#define DW_WDT_CR_EN_OFFSET	0x00
+#define DW_WDT_CR_RMOD_OFFSET	0x01
+#define DW_WDT_CR_RMOD_VAL	0x00
+#define DW_WDT_CRR_RESTART_VAL	0x76
+
+/* rtc */
+#define RTC_BASE	(TOP_BASE + 0x00005000)
+#define RTC_DB_REQ_WARM_RST	0x60
+#define RTC_EN_WARM_RST_REQ	0xcc
+
+#define RTCFC_BASE	(TOP_BASE + 0x00004000)
+#define RTC_CTRL0_UNLOCKKEY	0x4
+#define RTC_CTRL0 0x8
+
+/* rst */
+#define CV183X_SOFT_RST_REG0 (TOP_BASE + 0x00003000)
+#define CV183X_SOFT_RST_REG1 (TOP_BASE + 0x00003004)
+
+#define CV183X_TOP				TOP_BASE
+#define CV183X_TOP_WDT_OFFSET	0x8
+#define CV183X_TOP_WDT_VAL		0x4
+
+#endif /* __CV183X_REG_H */
diff --git a/include/cvitek/cvi_disp.h b/include/cvitek/cvi_disp.h
new file mode 100644
index 000000000..6caffa28d
--- /dev/null
+++ b/include/cvitek/cvi_disp.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#ifndef __CVI_DISP_H__
+#define __CVI_DISP_H__
+
+#include <dm.h>
+#include <video.h>
+#include <cvi_mipi.h>
+//#include <cvi_lvds.h>
+
+#define VO_INTF_CVBS (0x01L << 0)
+#define VO_INTF_YPBPR (0x01L << 1)
+#define VO_INTF_VGA (0x01L << 2)
+#define VO_INTF_BT656 (0x01L << 3)
+#define VO_INTF_BT1120 (0x01L << 6)
+#define VO_INTF_LCD (0x01L << 7)
+#define VO_INTF_LCD_18BIT (0x01L << 10)
+#define VO_INTF_LCD_24BIT (0x01L << 11)
+#define VO_INTF_LCD_30BIT (0x01L << 12)
+#define VO_INTF_MIPI (0x01L << 13)
+#define VO_INTF_MIPI_SLAVE (0x01L << 14)
+#define VO_INTF_HDMI (0x01L << 15)
+#define VO_INTF_I80 (0x01L << 16)
+
+#endif // __CVI_DISP_H__
diff --git a/include/cvitek/cvi_efuse.h b/include/cvitek/cvi_efuse.h
new file mode 100644
index 000000000..b912862bc
--- /dev/null
+++ b/include/cvitek/cvi_efuse.h
@@ -0,0 +1,58 @@
+#ifndef _CVI_EFUSE_H
+#define _CVI_EFUSE_H 1
+
+#ifndef CVI_U8
+#define CVI_U8 uint8_t
+#endif
+#ifndef CVI_U32
+#define CVI_U32 uint32_t
+#endif
+#ifndef CVI_S8
+#define CVI_S8 int8_t
+#endif
+#ifndef CVI_S32
+#define CVI_S32 int32_t
+#endif
+
+#ifndef CVI_SUCCESS
+#define CVI_SUCCESS 0
+#endif
+#ifndef CVI_FAILURE
+#define CVI_FAILURE (-1)
+#endif
+
+#define CVI_ERR_EFUSE_INVALID_AREA -0x0001
+#define CVI_ERR_EFUSE_INVALID_PARA -0x0002
+
+enum CVI_EFUSE_AREA_E {
+	CVI_EFUSE_AREA_USER,
+	CVI_EFUSE_AREA_DEVICE_ID,
+	CVI_EFUSE_AREA_HASH0_PUBLIC,
+	CVI_EFUSE_AREA_LOADER_EK,
+	CVI_EFUSE_AREA_DEVICE_EK,
+	CVI_EFUSE_AREA_LAST
+};
+
+enum CVI_EFUSE_LOCK_E {
+	CVI_EFUSE_LOCK_HASH0_PUBLIC = CVI_EFUSE_AREA_LAST + 1,
+	CVI_EFUSE_LOCK_LOADER_EK,
+	CVI_EFUSE_LOCK_DEVICE_EK,
+	CVI_EFUSE_LOCK_LAST
+};
+
+enum CVI_EFUSE_OTHERS_E {
+	CVI_EFUSE_SECUREBOOT = CVI_EFUSE_LOCK_LAST + 1,
+	CVI_EFUSE_OTHERS
+};
+
+CVI_S32 CVI_EFUSE_GetSize(enum CVI_EFUSE_AREA_E area, CVI_U32 *size);
+CVI_S32 CVI_EFUSE_Read(enum CVI_EFUSE_AREA_E area, CVI_U8 *buf, CVI_U32 buf_size);
+CVI_S32 CVI_EFUSE_Write(enum CVI_EFUSE_AREA_E area, const CVI_U8 *buf, CVI_U32 buf_size);
+CVI_S32 CVI_EFUSE_EnableSecureBoot(void);
+CVI_S32 CVI_EFUSE_IsSecureBootEnabled(void);
+CVI_S32 CVI_EFUSE_Lock(enum CVI_EFUSE_LOCK_E lock);
+CVI_S32 CVI_EFUSE_IsLocked(enum CVI_EFUSE_LOCK_E lock);
+CVI_S32 CVI_EFUSE_LockWrite(enum CVI_EFUSE_LOCK_E lock);
+CVI_S32 CVI_EFUSE_IsWriteLocked(enum CVI_EFUSE_LOCK_E lock);
+
+#endif /* _CVI_EFUSE_H */
diff --git a/include/cvitek/cvi_i80.h b/include/cvitek/cvi_i80.h
new file mode 100644
index 000000000..62f2786a4
--- /dev/null
+++ b/include/cvitek/cvi_i80.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#ifndef _CVI_I80_H_
+#define _CVI_I80_H_
+
+#include "cvi_mipi.h"
+
+#define COMMAND 0
+#define DATA	1
+
+enum _PIXEL_FORMAT_E {
+	PIXEL_FORMAT_RGB_888 = 0,
+	PIXEL_FORMAT_BGR_888,
+	PIXEL_FORMAT_RGB_888_PLANAR,
+};
+
+enum _VO_I80_FORMAT {
+	VO_I80_FORMAT_RGB444 = 0,
+	VO_I80_FORMAT_RGB565,
+	VO_I80_FORMAT_RGB666,
+	VO_I80_FORMAT_MAX
+};
+
+enum i80_op_type {
+	I80_OP_GO = 0,
+	I80_OP_TIMER,
+	I80_OP_DONE,
+	I80_OP_MAX,
+};
+
+enum i80_ctrl_type {
+	I80_CTRL_CMD = 0,
+	I80_CTRL_DATA,
+	I80_CTRL_EOL = I80_CTRL_DATA,
+	I80_CTRL_EOF,
+	I80_CTRL_END = I80_CTRL_EOF,
+	I80_CTRL_MAX
+};
+
+/* Define I80's lane (0~3)
+ *
+ * CS: Chip Select
+ * RS(DCX): Data/Command
+ * WR: MCU Write to bus
+ * RD: MCU Read from bus
+ */
+struct _VO_I80_LANE_S {
+	unsigned char CS;
+	unsigned char RS;
+	unsigned char WR;
+	unsigned char RD;
+};
+
+/* Define I80's config
+ *
+ * lane_s: lane mapping
+ * fmt: format of data
+ * cycle_time: cycle time of WR/RD, unit ns, max 250
+ */
+struct _VO_I80_CFG_S {
+	struct _VO_I80_LANE_S lane_s;
+	enum _VO_I80_FORMAT fmt;
+	unsigned short cycle_time;
+	struct sync_info_s sync_info;
+};
+
+/* Define I80's cmd
+ *
+ * delay: ms to delay after instr
+ * data_type: Data(1)/Command(0)
+ * data: data to send
+ */
+struct _VO_I80_INSTR_S {
+	unsigned char delay;
+	unsigned char data_type;
+	unsigned char data;
+};
+
+extern unsigned char i80_ctrl[I80_CTRL_MAX];
+
+void i80_package_frame(unsigned char *in, unsigned char *out, unsigned int stride, unsigned char byte_cnt,
+		       unsigned short w, unsigned short h);
+int i80_set_combo_dev_cfg(const struct _VO_I80_CFG_S *i80_cfg);
+void i80_set_sw_mode(unsigned long mode_flags);
+int i80_set_cmd(unsigned int cmd);
+int i80_set_run(void);
+void i80_sclr_intr_clr(void);
+
+#endif // _CVI_I80_H_
+
diff --git a/include/cvitek/cvi_mipi.h b/include/cvitek/cvi_mipi.h
new file mode 100644
index 000000000..e4331e87a
--- /dev/null
+++ b/include/cvitek/cvi_mipi.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#ifndef _CVI_MIPI_H_
+#define _CVI_MIPI_H_
+
+#define CMD_MAX_NUM    100
+#define RX_MAX_NUM     4
+#define LANE_MAX_NUM   5
+
+enum output_mode_e {
+	OUTPUT_MODE_CSI            = 0x0,              /* csi mode */
+	OUTPUT_MODE_DSI_VIDEO      = 0x1,              /* dsi video mode */
+	OUTPUT_MODE_DSI_CMD        = 0x2,              /* dsi command mode */
+
+	OUTPUT_MODE_BUTT
+};
+
+enum video_mode_e {
+	BURST_MODE                      = 0x0,
+	NON_BURST_MODE_SYNC_PULSES      = 0x1,
+	NON_BURST_MODE_SYNC_EVENTS      = 0x2,
+};
+
+enum output_format_e {
+	OUT_FORMAT_RGB_16_BIT          = 0x0,
+	OUT_FORMAT_RGB_18_BIT          = 0x1,
+	OUT_FORMAT_RGB_24_BIT          = 0x2,
+	OUT_FORMAT_RGB_30_BIT          = 0x3,
+	OUT_FORMAT_YUV420_8_BIT_NORMAL = 0x4,
+	OUT_FORMAT_YUV420_8_BIT_LEGACY = 0x5,
+	OUT_FORMAT_YUV422_8_BIT        = 0x6,
+
+	OUT_FORMAT_BUTT
+};
+
+enum mipi_tx_lane_id {
+	MIPI_TX_LANE_CLK = 0,
+	MIPI_TX_LANE_0,
+	MIPI_TX_LANE_1,
+	MIPI_TX_LANE_2,
+	MIPI_TX_LANE_3,
+	MIPI_TX_LANE_MAX,
+};
+
+struct sync_info_s {
+	unsigned short  vid_hsa_pixels;
+	unsigned short  vid_hbp_pixels;
+	unsigned short  vid_hfp_pixels;
+	unsigned short  vid_hline_pixels;
+	unsigned short  vid_vsa_lines;
+	unsigned short  vid_vbp_lines;
+	unsigned short  vid_vfp_lines;
+	unsigned short  vid_active_lines;
+	unsigned short  edpi_cmd_size;
+	bool            vid_vsa_pos_polarity;
+	bool            vid_hsa_pos_polarity;
+};
+
+/*
+ * devno: device number
+ * lane_id: -1 - disable
+ * output mode: CSI/DSI_VIDEO/DSI_CMD
+ * phy_data_rate: mbps
+ * pixel_clk: KHz
+ */
+struct combo_dev_cfg_s {
+	unsigned int            devno;
+	enum mipi_tx_lane_id    lane_id[LANE_MAX_NUM];
+	enum output_mode_e      output_mode;
+	enum video_mode_e       video_mode;
+	enum output_format_e    output_format;
+	struct sync_info_s      sync_info;
+	unsigned int            phy_data_rate;
+	unsigned int            pixel_clk;
+	bool                    lane_pn_swap[LANE_MAX_NUM];
+};
+
+struct cmd_info_s {
+	unsigned int        devno;                   /* device number */
+	unsigned short      data_type;
+	unsigned short      cmd_size;
+	unsigned char       *cmd;
+};
+
+/*
+ * devno: device number
+ * data_type: DSI data type
+ * data_param: data param,low 8 bit:first param.high 8 bit:second param, set 0 if not use
+ * get_data_size: read data size
+ * get_data: read data memery address, should  malloc by user
+ */
+struct get_cmd_info_s {
+	unsigned int        devno;
+	unsigned short      data_type;
+	unsigned short      data_param;
+	unsigned short      get_data_size;
+	unsigned char       *get_data;
+};
+
+struct hs_settle_s {
+	unsigned char	    prepare;
+	unsigned char	    zero;
+	unsigned char	    trail;
+};
+
+struct dsc_instr {
+	u8	delay;
+	u8	data_type;
+	u8	size;
+	u8	*data;
+};
+
+int mipi_tx_set_combo_dev_cfg(const struct combo_dev_cfg_s *dev_cfg);
+int mipi_tx_set_cmd(struct cmd_info_s *cmd_info);
+int mipi_tx_get_cmd(struct get_cmd_info_s *get_cmd_info);
+void mipi_tx_set_mode(unsigned long mode_flags);
+
+#endif // _CVI_MIPI_H_
diff --git a/include/cvitek/cvi_panels/cvi_panel_diffs.h b/include/cvitek/cvi_panels/cvi_panel_diffs.h
new file mode 100644
index 000000000..2d83cf1be
--- /dev/null
+++ b/include/cvitek/cvi_panels/cvi_panel_diffs.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cvi_panel_diffs.h
+ * Description:
+ */
+
+#ifndef __CVI_PANEL_DIFFS_H__
+#define __CVI_PANEL_DIFFS_H__
+
+#ifdef I80_PANEL_ST7789V
+#define CVI_JPEG ""
+#define START_VO "startvo 0 65536 0;"
+#define LOGO_POS_INFO " 736 0 0 240 320;"
+#else
+#define CVI_JPEG "cvi_jpeg " LOGO_READ_ADDR " " LOGO_RESERVED_ADDR " " LOGOSIZE ";"
+#define START_VO "startvo 0 8192 0;"
+
+#endif
+
+#define START_VL "startvl 0 " LOGO_READ_ADDR " " LOGO_RESERVED_ADDR " " LOGOSIZE " " VO_ALIGNMENT ";"
+#define SET_VO_BG "setvobg 0 0xffffffff;"
+
+#endif
diff --git a/include/cvitek/cvi_panels/cvi_panels.h b/include/cvitek/cvi_panels/cvi_panels.h
new file mode 100644
index 000000000..8670d8c60
--- /dev/null
+++ b/include/cvitek/cvi_panels/cvi_panels.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cvi_panels.h
+ * Description:
+ */
+
+#ifndef __CVI_PANEL_H__
+#define __CVI_PANEL_H__
+
+#include "cvi_i80.h"
+
+struct panel_desc_s {
+	char *panel_name;
+	const struct combo_dev_cfg_s *dev_cfg;
+	const struct hs_settle_s *hs_timing_cfg;
+	const struct dsc_instr *dsi_init_cmds;
+	int dsi_init_cmds_size;
+	const struct _VO_I80_CFG_S *i80_cfg;
+	const struct _VO_I80_INSTR_S *i80_init_cmds;
+	int i80_init_cmds_size;
+};
+
+#ifdef MIPI_PANEL_HX8394
+#include "dsi_hx8394_evb.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "HX8394-720x1280",
+	.dev_cfg = &dev_cfg_hx8394_720x1280,
+	.hs_timing_cfg = &hs_timing_cfg_hx8394_720x1280,
+	.dsi_init_cmds = dsi_init_cmds_hx8394_720x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_hx8394_720x1280)
+};
+#elif defined(MIPI_PANEL_ILI9881C)
+#include "dsi_ili9881c.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "ILI9881C-720x1280",
+	.dev_cfg = &dev_cfg_ili9881c_720x1280,
+	.hs_timing_cfg = &hs_timing_cfg_ili9881c_720x1280,
+	.dsi_init_cmds = dsi_init_cmds_ili9881c_720x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_ili9881c_720x1280)
+};
+#elif defined(MIPI_PANEL_ILI9881D)
+#include "dsi_ili9881d.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "ILI9881D-720x1280",
+	.dev_cfg = &dev_cfg_ili9881d_720x1280,
+	.hs_timing_cfg = &hs_timing_cfg_ili9881d_720x1280,
+	.dsi_init_cmds = dsi_init_cmds_ili9881d_720x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_ili9881d_720x1280)
+};
+#elif defined(MIPI_PANEL_JD9366AB)
+#include "dsi_jd9366ab.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "JD9366AB-800x1280",
+	.dev_cfg = &dev_cfg_jd9366ab_800x1280,
+	.hs_timing_cfg = &hs_timing_cfg_jd9366ab_800x1280,
+	.dsi_init_cmds = dsi_init_cmds_jd9366ab_800x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_jd9366ab_800x1280)
+};
+#elif defined(MIPI_PANEL_NT35521)
+#include "dsi_nt35521.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "NT35521-800x1280",
+	.dev_cfg = &dev_cfg_nt35521_800x1280,
+	.hs_timing_cfg = &hs_timing_cfg_nt35521_800x1280,
+	.dsi_init_cmds = dsi_init_cmds_nt35521_800x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_nt35521_800x1280)
+};
+#elif defined(MIPI_PANEL_OTA7290B)
+#include "dsi_ota7290b.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "OTA7290B-320x1280",
+	.dev_cfg = &dev_cfg_ota7290b_320x1280,
+	.hs_timing_cfg = &hs_timing_cfg_ota7290b_320x1280,
+	.dsi_init_cmds = dsi_init_cmds_ota7290b_320x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_ota7290b_320x1280)
+};
+#elif defined(MIPI_PANEL_OTA7290B_1920)
+#include "dsi_ota7290b_1920.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "OTA7290B-440x1920",
+	.dev_cfg = &dev_cfg_ota7290b_440x1920,
+	.hs_timing_cfg = &hs_timing_cfg_ota7290b_440x1920,
+	.dsi_init_cmds = dsi_init_cmds_ota7290b_440x1920,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_ota7290b_440x1920)
+};
+#elif defined(MIPI_PANEL_ICN9707)
+#include "dsi_icn9707.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "ICN9707-480x1920",
+	.dev_cfg = &dev_cfg_icn9707_480x1920,
+	.hs_timing_cfg = &hs_timing_cfg_icn9707_480x1920,
+	.dsi_init_cmds = dsi_init_cmds_icn9707_480x1920,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_icn9707_480x1920)
+};
+#elif defined(MIPI_PANEL_3AML069LP01G)
+#include "dsi_3aml069lp01g.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "3AML069LP01G-600x1024",
+	.dev_cfg = &dev_cfg_3AML069LP01G_600x1024,
+	.hs_timing_cfg = &hs_timing_cfg_3AML069LP01G_600x1024,
+	.dsi_init_cmds = dsi_init_cmds_3AML069LP01G_600x1024,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_3AML069LP01G_600x1024)
+};
+#elif defined(MIPI_PANEL_ST7701)
+#include "dsi_st7701.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "ST7701-480x800",
+	.dev_cfg = &dev_cfg_st7701_480x800,
+	.hs_timing_cfg = &hs_timing_cfg_st7701_480x800,
+	.dsi_init_cmds = dsi_init_cmds_st7701_480x800,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_st7701_480x800)
+};
+#elif defined(I80_PANEL_ST7789V)
+#include "i80_st7789v.h"
+static struct panel_desc_s panel_desc = {
+	.i80_cfg = &i80_st7789v_cfg,
+	.i80_init_cmds = i80_st7789v_init_cmds,
+	.i80_init_cmds_size = ARRAY_SIZE(i80_st7789v_init_cmds)
+};
+#else
+#include "dsi_hx8394_evb.h"
+static struct panel_desc_s panel_desc = {
+	.panel_name = "HX8394-720x1280",
+	.dev_cfg = &dev_cfg_hx8394_720x1280,
+	.hs_timing_cfg = &hs_timing_cfg_hx8394_720x1280,
+	.dsi_init_cmds = dsi_init_cmds_hx8394_720x1280,
+	.dsi_init_cmds_size = ARRAY_SIZE(dsi_init_cmds_hx8394_720x1280)
+};
+#endif
+
+#endif
diff --git a/include/cvitek/cvi_panels/dsi_3aml069lp01g.h b/include/cvitek/cvi_panels/dsi_3aml069lp01g.h
new file mode 100644
index 000000000..322cf0846
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_3aml069lp01g.h
@@ -0,0 +1,202 @@
+#ifndef _MIPI_TX_PARAM__3AML069LP01G_H_
+#define _MIPI_TX_PARAM__3AML069LP01G_H_
+
+#include <cvi_mipi.h>
+
+#define _3AML069LP01G_RX_VACT        1024
+#define _3AML069LP01G_RX_VSA         3
+#define _3AML069LP01G_RX_VBP         5
+#define _3AML069LP01G_RX_VFP         7
+
+#define _3AML069LP01G_RX_HACT        600
+#define _3AML069LP01G_RX_HSA         20
+#define _3AML069LP01G_RX_HBP         20
+#define _3AML069LP01G_RX_HFP         90
+
+#define PIXEL_CLK(x) ((x##_VACT + x##_VSA + x##_VBP + x##_VFP) \
+	* (x##_HACT + x##_HSA + x##_HBP + x##_HFP) * 60 / 1000)
+
+const struct combo_dev_cfg_s dev_cfg_3AML069LP01G_600x1024 = {
+	.devno = 0,
+#ifdef MIPI_PANEL_2_LANES
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, -1, -1},
+#else
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, MIPI_TX_LANE_2, MIPI_TX_LANE_3},
+#endif
+	.lane_pn_swap = {false, false, false, false, false},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = _3AML069LP01G_RX_HSA,
+		.vid_hbp_pixels = _3AML069LP01G_RX_HBP,
+		.vid_hfp_pixels = _3AML069LP01G_RX_HFP,
+		.vid_hline_pixels = _3AML069LP01G_RX_HACT,
+		.vid_vsa_lines = _3AML069LP01G_RX_VSA,
+		.vid_vbp_lines = _3AML069LP01G_RX_VBP,
+		.vid_vfp_lines = _3AML069LP01G_RX_VFP,
+		.vid_active_lines = _3AML069LP01G_RX_VACT,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = PIXEL_CLK(_3AML069LP01G_RX),
+};
+
+const struct hs_settle_s hs_timing_cfg_3AML069LP01G_600x1024 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_3aml069lp01g_0[] = { 0xee, 0x50 };
+static u8 data_3aml069lp01g_1[] = { 0xea, 0x85, 0x55 };
+static u8 data_3aml069lp01g_2[] = { 0x24, 0x20 };
+static u8 data_3aml069lp01g_3[] = { 0x30, 0x00 };
+static u8 data_3aml069lp01g_4[] = { 0x39, 0x02, 0x07, 0x10 };
+static u8 data_3aml069lp01g_5[] = { 0x79, 0x00 };
+static u8 data_3aml069lp01g_6[] = { 0x7b, 0x00 };
+static u8 data_3aml069lp01g_7[] = { 0x7a, 0x00 };
+static u8 data_3aml069lp01g_8[] = { 0x90, 0x50, 0xc0 };
+static u8 data_3aml069lp01g_9[] = { 0x93, 0x80 };
+static u8 data_3aml069lp01g_10[] = { 0x95, 0x74 };
+static u8 data_3aml069lp01g_11[] = { 0x97, 0x37 };
+static u8 data_3aml069lp01g_12[] = { 0x99, 0x00 };
+static u8 data_3aml069lp01g_13[] = { 0x56, 0x83 };
+static u8 data_3aml069lp01g_14[] = { 0x33, 0x83 };
+static u8 data_3aml069lp01g_15[] = { 0x34, 0x3f };
+static u8 data_3aml069lp01g_16[] = { 0xee, 0x60 };
+static u8 data_3aml069lp01g_17[] = { 0x30, 0x03 };
+static u8 data_3aml069lp01g_18[] = { 0x32, 0xd9 };
+static u8 data_3aml069lp01g_19[] = { 0x3b, 0x00 };
+static u8 data_3aml069lp01g_20[] = { 0x3c, 0x07 };
+static u8 data_3aml069lp01g_21[] = { 0x3d, 0x11 };
+static u8 data_3aml069lp01g_22[] = { 0x3e, 0x94 };
+static u8 data_3aml069lp01g_23[] = { 0x42, 0x55 };
+static u8 data_3aml069lp01g_24[] = { 0x43, 0x55 };
+static u8 data_3aml069lp01g_25[] = { 0x86, 0x20 };
+static u8 data_3aml069lp01g_26[] = { 0x8b, 0x90 };
+static u8 data_3aml069lp01g_27[] = { 0x8d, 0x40 };
+static u8 data_3aml069lp01g_28[] = { 0x91, 0x11 };
+static u8 data_3aml069lp01g_29[] = { 0x92, 0x11 };
+static u8 data_3aml069lp01g_30[] = { 0x93, 0x9f };
+static u8 data_3aml069lp01g_31[] = { 0x9a, 0x07 };
+static u8 data_3aml069lp01g_32[] = { 0x9b, 0x02, 0x00 };
+static u8 data_3aml069lp01g_33[] = { 0x47, 0x05, 0x1e, 0x2f, 0x39, 0x40 };
+static u8 data_3aml069lp01g_34[] = { 0x5a, 0x05, 0x1e, 0x2f, 0x39, 0x40 };
+static u8 data_3aml069lp01g_35[] = { 0x4c, 0x53, 0x4a, 0x5d, 0x40, 0x40 };
+static u8 data_3aml069lp01g_36[] = { 0x5f, 0x53, 0x4a, 0x5d, 0x40, 0x40 };
+static u8 data_3aml069lp01g_37[] = { 0x51, 0x42, 0x29, 0x3e, 0x3d, 0x48 };
+static u8 data_3aml069lp01g_38[] = { 0x64, 0x42, 0x29, 0x3e, 0x3d, 0x48 };
+static u8 data_3aml069lp01g_39[] = { 0x56, 0x4c, 0x57, 0x66, 0x7f };
+static u8 data_3aml069lp01g_40[] = { 0x56, 0x4c, 0x57, 0x66, 0x7f };
+static u8 data_3aml069lp01g_41[] = { 0xee, 0x70 };
+static u8 data_3aml069lp01g_42[] = { 0x00, 0x01, 0x04, 0x00, 0x01 };
+static u8 data_3aml069lp01g_43[] = { 0x04, 0x06, 0x09, 0x44, 0x01 };
+static u8 data_3aml069lp01g_44[] = { 0x0c, 0x05, 0x2d };
+static u8 data_3aml069lp01g_45[] = { 0x10, 0x05, 0x09, 0x00, 0x00, 0x00 };
+static u8 data_3aml069lp01g_46[] = { 0x15, 0x00, 0x19, 0x0c, 0x08, 0x00 };
+static u8 data_3aml069lp01g_47[] = { 0x20, 0x01, 0x05, 0x00, 0x00, 0x00 };
+static u8 data_3aml069lp01g_48[] = { 0x25, 0x00, 0x15, 0x0c, 0x07, 0x00 };
+static u8 data_3aml069lp01g_49[] = { 0x29, 0x05, 0x2d };
+static u8 data_3aml069lp01g_50[] = { 0x45, 0x01 };
+static u8 data_3aml069lp01g_51[] = { 0x46, 0xff, 0x00, 0x00, 0x00, 0x50 };
+static u8 data_3aml069lp01g_52[] = { 0x4b, 0x88 };
+static u8 data_3aml069lp01g_53[] = { 0x60, 0x3c, 0x05, 0x07, 0x19, 0x1d };
+static u8 data_3aml069lp01g_54[] = { 0x65, 0x1b, 0x1f, 0x11, 0x11, 0x3c };
+static u8 data_3aml069lp01g_55[] = { 0x6a, 0x3c, 0x3c, 0x3c, 0x15, 0x15 };
+static u8 data_3aml069lp01g_56[] = { 0x6f, 0x13, 0x13, 0x17, 0x17, 0x01 };
+static u8 data_3aml069lp01g_57[] = { 0x74, 0x03, 0x3c };
+static u8 data_3aml069lp01g_58[] = { 0x80, 0x3c, 0x04, 0x06, 0x18, 0x1c };
+static u8 data_3aml069lp01g_59[] = { 0x85, 0x1a, 0x1e, 0x10, 0x10, 0x3c };
+static u8 data_3aml069lp01g_60[] = { 0x8a, 0x3c, 0x3c, 0x3c, 0x14, 0x14 };
+static u8 data_3aml069lp01g_61[] = { 0x8f, 0x12, 0x12, 0x16, 0x16, 0x00 };
+static u8 data_3aml069lp01g_62[] = { 0x94, 0x02, 0x3c };
+static u8 data_3aml069lp01g_63[] = { 0xea, 0x00, 0x00 };
+static u8 data_3aml069lp01g_64[] = { 0xee, 0x00 };
+static u8 data_3aml069lp01g_65[] = { 0x11 };
+static u8 data_3aml069lp01g_66[] = { 0x29 };
+#ifdef _MIPI_TX_BIST_MODE
+static u8 data_3aml069lp01g_67[] = { 0xee, 0x60 };
+static u8 data_3aml069lp01g_68[] = { 0xea, 0x7a, 0xaa };
+
+static u8 data_3aml069lp01g_69[] = { 0x21, 0x10 };
+static u8 data_3aml069lp01g_70[] = { 0x11 };
+static u8 data_3aml069lp01g_71[] = { 0x29 };
+#endif
+const struct dsc_instr dsi_init_cmds_3AML069LP01G_600x1024[] = {
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_0 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_1 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_3 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_3aml069lp01g_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_7 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_16 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_23 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_24 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_25 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_26 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_27 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_28 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_29 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_31 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_32 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_33 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_34 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_35 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_36 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_37 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_38 },
+	{.delay = 0, .data_type = 0x29, .size = 5, .data = data_3aml069lp01g_39 },
+	{.delay = 0, .data_type = 0x29, .size = 5, .data = data_3aml069lp01g_40 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_41 },
+	{.delay = 0, .data_type = 0x29, .size = 5, .data = data_3aml069lp01g_42 },
+	{.delay = 0, .data_type = 0x29, .size = 5, .data = data_3aml069lp01g_43 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_44 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_45 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_46 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_47 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_48 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_49 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_50 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_51 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_52 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_53 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_54 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_55 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_56 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_57 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_58 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_59 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_60 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_3aml069lp01g_61 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_62 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_63 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_64 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_3aml069lp01g_65 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_3aml069lp01g_66 }
+#ifdef _MIPI_TX_BIST_MODE
+	{ .delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_67 },
+	{ .delay = 200, .data_type = 0x29, .size = 3, .data = data_3aml069lp01g_68 },
+
+	{ .delay = 0, .data_type = 0x15, .size = 2, .data = data_3aml069lp01g_69 },
+	{ .delay = 40, .data_type = 0x05, .size = 1, .data = data_3aml069lp01g_70 },
+	{ .delay = 1, .data_type = 0x05, .size = 1, .data = data_3aml069lp01g_71 },
+#endif
+};
+
+#else
+#error "_MIPI_TX_PARAM__3AML069LP01G_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_H_
diff --git a/include/cvitek/cvi_panels/dsi_hx8394_evb.h b/include/cvitek/cvi_panels/dsi_hx8394_evb.h
new file mode 100644
index 000000000..ef20ae5fd
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_hx8394_evb.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ */
+
+#ifndef _MIPI_TX_PARAM_HX8394_H_
+#define _MIPI_TX_PARAM_HX8394_H_
+
+#include <cvi_mipi.h>
+
+const struct combo_dev_cfg_s dev_cfg_hx8394_720x1280 = {
+	.devno = 0,
+#ifdef MIPI_PANEL_2_LANES
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, -1, -1},
+#else
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, MIPI_TX_LANE_2, MIPI_TX_LANE_3},
+#endif
+#ifdef MIPI_PANEL_LANE_SWAP
+	.lane_pn_swap = {true, true, true, true, true},
+#else
+	.lane_pn_swap = {false, false, false, false, false},
+#endif
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 64,
+		.vid_hbp_pixels = 36,
+		.vid_hfp_pixels = 128,
+		.vid_hline_pixels = 720,
+		.vid_vsa_lines = 16,
+		.vid_vbp_lines = 4,
+		.vid_vfp_lines = 6,
+		.vid_active_lines = 1280,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 74250,
+};
+
+const struct hs_settle_s hs_timing_cfg_hx8394_720x1280 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_hx8394_0[] = { 0xb9, 0xff, 0x83, 0x94 };
+static u8 data_hx8394_1[] = {
+	0xb1, 0x50, 0x15, 0x75, 0x09, 0x32, 0x44, 0x71, 0x31, 0x4d,
+	0x2f, 0x56, 0x73, 0x02, 0x02
+};
+
+static u8 data_hx8394_2[] = {
+#ifdef MIPI_PANEL_2_LANES
+	0xba, 0x61, 0x03, 0x68, 0x6b, 0xb2, 0xc0
+#else
+	0xba, 0x63, 0x03, 0x68, 0x6b, 0xb2, 0xc0
+#endif
+};
+
+static u8 data_hx8394_3[] = { 0xd2, 0x88 };
+static u8 data_hx8394_4[] = { 0xb2, 0x00, 0x80, 0x64, 0x10, 0x07 };
+static u8 data_hx8394_5[] = {
+	0xb4, 0x01, 0x75, 0x01, 0x75, 0x01, 0x75, 0x01, 0x0c, 0x86,
+	0x75, 0x00, 0x3f, 0x01, 0x75, 0x01, 0x75, 0x01, 0x75, 0x01,
+	0x0c, 0x86
+};
+
+static u8 data_hx8394_6[] = {
+	0xd3, 0x00, 0x00, 0x06, 0x06, 0x40, 0x1a, 0x08, 0x00, 0x32,
+	0x10, 0x08, 0x00, 0x08, 0x54, 0x15, 0x10, 0x05, 0x04, 0x02,
+	0x12, 0x10, 0x05, 0x07, 0x23, 0x23, 0x0c, 0x0c, 0x27, 0x10,
+	0x07, 0x07, 0x10, 0x40
+};
+
+static u8 data_hx8394_7[] = {
+	0xd5, 0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03, 0x20,
+	0x21, 0x22, 0x23, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x19, 0x19, 0x18, 0x18, 0x18, 0x18, 0x1b, 0x1b, 0x1a,
+	0x1a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18
+};
+
+static u8 data_hx8394_8[] = {
+	0xd6, 0x03, 0x02, 0x01, 0x00, 0x07, 0x06, 0x05, 0x04, 0x23,
+	0x22, 0x21, 0x20, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x58,
+	0x58, 0x18, 0x18, 0x19, 0x19, 0x18, 0x18, 0x1b, 0x1b, 0x1a,
+	0x1a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x18, 0x18
+};
+
+static u8 data_hx8394_9[] = {
+	0xe0, 0x00, 0x1a, 0x24, 0x2c, 0x2e, 0x32, 0x34, 0x32, 0x66,
+	0x73, 0x82, 0x7f, 0x85, 0x95, 0x97, 0x99, 0xa4, 0xa5, 0xa0,
+	0xab, 0xba, 0x5a, 0x59, 0x5d, 0x61, 0x63, 0x6c, 0x72, 0x7f,
+	0x00, 0x19, 0x24, 0x2c, 0x2e, 0x32, 0x34, 0x32, 0x66, 0x73,
+	0x82, 0x7f, 0x85, 0x95, 0x97, 0x99, 0xa4, 0xa5, 0xa0, 0xab,
+	0xba, 0x5a, 0x59, 0x5d, 0x61, 0x63, 0x6c, 0x72, 0x7f
+};
+
+static u8 data_hx8394_10[] = { 0xcc, 0x03 };
+static u8 data_hx8394_11[] = { 0xc0, 0x1f, 0x73 };
+static u8 data_hx8394_12[] = { 0xb6, 0x42, 0x42 };
+static u8 data_hx8394_13[] = { 0xd4, 0x02 };
+static u8 data_hx8394_14[] = { 0xbd, 0x01 };
+static u8 data_hx8394_15[] = { 0xb1, 0x00 };
+static u8 data_hx8394_16[] = { 0xbd, 0x00 };
+static u8 data_hx8394_17[] = {
+	0xbf, 0x40, 0x81, 0x50, 0x00, 0x1a, 0xfc, 0x01
+};
+
+static u8 data_hx8394_18[] = { 0xc6, 0xef };
+static u8 data_hx8394_19[] = { 0x36, 0x02 };// h-flip
+static u8 data_hx8394_20[] = { 0x11 };
+static u8 data_hx8394_21[] = { 0x29 };
+
+const struct dsc_instr dsi_init_cmds_hx8394_720x1280[] = {
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_hx8394_0 },
+	{.delay = 0, .data_type = 0x29, .size = 15, .data = data_hx8394_1 },
+	{.delay = 0, .data_type = 0x29, .size = 7, .data = data_hx8394_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_3 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_hx8394_4 },
+	{.delay = 0, .data_type = 0x29, .size = 22, .data = data_hx8394_5 },
+	{.delay = 0, .data_type = 0x29, .size = 34, .data = data_hx8394_6 },
+	{.delay = 0, .data_type = 0x29, .size = 45, .data = data_hx8394_7 },
+	{.delay = 0, .data_type = 0x29, .size = 45, .data = data_hx8394_8 },
+	{.delay = 0, .data_type = 0x29, .size = 59, .data = data_hx8394_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_10 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_hx8394_11 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_hx8394_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_16 },
+	{.delay = 0, .data_type = 0x29, .size = 8, .data = data_hx8394_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_hx8394_19 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_hx8394_20 },
+	{.delay = 20, .data_type = 0x05, .size = 1, .data = data_hx8394_21 }
+
+};
+
+#else
+#error "_MIPI_TX_PARAM_HX8394_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_HX8394_H_
diff --git a/include/cvitek/cvi_panels/dsi_icn9707.h b/include/cvitek/cvi_panels/dsi_icn9707.h
new file mode 100644
index 000000000..5185bb369
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_icn9707.h
@@ -0,0 +1,143 @@
+#ifndef _MIPI_TX_PARAM_ICN9707_H_
+#define _MIPI_TX_PARAM_ICN9707_H_
+
+#include <cvi_mipi.h>
+
+const struct combo_dev_cfg_s dev_cfg_icn9707_480x1920 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_3, MIPI_TX_LANE_2, MIPI_TX_LANE_CLK, MIPI_TX_LANE_1, MIPI_TX_LANE_0},
+	#ifdef MIPI_PANEL_LANE_SWAP
+	.lane_pn_swap = {true, true, true, true, true},
+	#else
+	.lane_pn_swap = {false, false, false, false, false},
+	#endif
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 4,
+		.vid_hbp_pixels = 53,
+		.vid_hfp_pixels = 53,
+		.vid_hline_pixels = 480,
+		.vid_vsa_lines = 4,
+		.vid_vbp_lines = 12,
+		.vid_vfp_lines = 32,
+		.vid_active_lines = 1920,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 69660,
+};
+
+const struct hs_settle_s hs_timing_cfg_icn9707_480x1920 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_icn9707_0[] = { 0xf0, 0x5a, 0x59 };
+static u8 data_icn9707_1[] = { 0xf1, 0xa5, 0xa6 };
+static u8 data_icn9707_2[] = {
+	0xb4, 0x1d, 0x1c, 0x0b, 0x10, 0x11, 0x12, 0x13, 0x0c, 0x0d,
+	0x0e, 0x0f, 0x00, 0x1e, 0x1f, 0x04, 0x03, 0x03, 0x03, 0x03,
+	0x03, 0x03, 0x03
+};
+
+static u8 data_icn9707_3[] = {
+	0xb0, 0x60, 0x00, 0x00, 0x08, 0x66, 0x66, 0x33, 0x33, 0x66,
+	0x00, 0x00, 0xaf, 0x00, 0x00, 0x0f
+};
+
+static u8 data_icn9707_4[] = {
+	0xb1, 0x53, 0xa0, 0x00, 0x85, 0x0e, 0x00, 0x00, 0x62, 0x00,
+	0x00
+};
+
+static u8 data_icn9707_5[] = {
+	0xb2, 0x37, 0x09, 0x08, 0x8b, 0x08, 0x00, 0x22, 0x00, 0x44,
+	0xd9
+};
+
+static u8 data_icn9707_6[] = { 0xb6, 0x49, 0x49 };
+static u8 data_icn9707_7[] = {
+	0xb7, 0x01, 0x01, 0x09, 0x0d, 0x11, 0x19, 0x1d, 0x15, 0x00,
+	0x25, 0x21, 0x00, 0x00, 0x00, 0x00, 0x02, 0xf7, 0x38
+};
+
+static u8 data_icn9707_8[] = { 0xb8, 0x34, 0x53, 0x02, 0xcc };
+static u8 data_icn9707_9[] = { 0xba, 0x27, 0x33 };
+static u8 data_icn9707_10[] = {
+	0xbd, 0x43, 0x0e, 0x0e, 0x4b, 0x4b, 0x14, 0x14
+};
+
+static u8 data_icn9707_11[] = {
+	0xc1, 0x00, 0x0c, 0x20, 0x04, 0x00, 0x32, 0x32, 0x04
+};
+
+static u8 data_icn9707_12[] = { 0xc2, 0x31, 0xc0 };
+static u8 data_icn9707_13[] = { 0xc3, 0x22, 0x31 };
+static u8 data_icn9707_14[] = {
+	0xc6, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00
+};
+
+static u8 data_icn9707_15[] = {
+	0xc8, 0x7c, 0x66, 0x56, 0x49, 0x46, 0x37, 0x3a, 0x23, 0x3b,
+	0x38, 0x38, 0x55, 0x43, 0x4c, 0x40, 0x3c, 0x2f, 0x1c, 0x06,
+	0x7c, 0x65, 0x56, 0x4a, 0x46, 0x37, 0x3a, 0x23, 0x3a, 0x38,
+	0x38, 0x55, 0x43, 0x4c, 0x40, 0x3c, 0x2f, 0x1c, 0x06
+};
+
+static u8 data_icn9707_16[] = { 0xd0, 0x07, 0xff, 0xff };
+static u8 data_icn9707_17[] = { 0xd2, 0x63, 0x0b, 0x08, 0x88 };
+static u8 data_icn9707_18[] = {
+	0xd4, 0x00, 0x00, 0x00, 0x32, 0x04, 0x54
+};
+
+static u8 data_icn9707_19[] = { 0xf1, 0x5a, 0x59 };
+static u8 data_icn9707_20[] = { 0xf0, 0xa5, 0xa6 };
+static u8 data_icn9707_21[] = { 0x11 };
+static u8 data_icn9707_22[] = { 0x29 };
+
+#ifdef _MIPI_TX_BIST_MODE
+static u8 data_icn9707_23[] = { 0x01 };
+static u8 data_icn9707_24[] = { 0xF0, 0x5A, 0x59 };
+static u8 data_icn9707_25[] = { 0xF1, 0xA5, 0xA6 };
+static u8 data_icn9707_26[] = { 0xC0, 0x11 };
+static u8 data_icn9707_27[] = { 0x11 };
+static u8 data_icn9707_28[] = { 0x29 };
+#endif
+
+const struct dsc_instr dsi_init_cmds_icn9707_480x1920[] = {
+#ifdef _MIPI_TX_BIST_MODE
+	{ .delay = 120, .data_type = 0x05, .size = 1, .data = data_icn9707_23 },
+	{ .delay = 0, .data_type = 0x29, .size = 3, .data = data_icn9707_24 },
+	{ .delay = 0, .data_type = 0x29, .size = 1, .data = data_icn9707_25 },
+	{ .delay = 0, .data_type = 0x15, .size = 2, .data = data_icn9707_26 },
+	{ .delay = 200, .data_type = 0x05, .size = 1, .data = data_icn9707_27 },
+	{ .delay = 50, .data_type = 0x05, .size = 1, .data = data_icn9707_28 }
+#else
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_0 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_1 },
+	{.delay = 1, .data_type = 0x29, .size = 23, .data = data_icn9707_2 },
+	{.delay = 1, .data_type = 0x29, .size = 16, .data = data_icn9707_3 },
+	{.delay = 1, .data_type = 0x29, .size = 11, .data = data_icn9707_4 },
+	{.delay = 1, .data_type = 0x29, .size = 11, .data = data_icn9707_5 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_6 },
+	{.delay = 1, .data_type = 0x29, .size = 19, .data = data_icn9707_7 },
+	{.delay = 1, .data_type = 0x29, .size = 5, .data = data_icn9707_8 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_9 },
+	{.delay = 1, .data_type = 0x29, .size = 8, .data = data_icn9707_10 },
+	{.delay = 1, .data_type = 0x29, .size = 9, .data = data_icn9707_11 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_12 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_13 },
+	{.delay = 1, .data_type = 0x29, .size = 9, .data = data_icn9707_14 },
+	{.delay = 1, .data_type = 0x29, .size = 39, .data = data_icn9707_15 },
+	{.delay = 1, .data_type = 0x29, .size = 4, .data = data_icn9707_16 },
+	{.delay = 1, .data_type = 0x29, .size = 5, .data = data_icn9707_17 },
+	{.delay = 1, .data_type = 0x29, .size = 7, .data = data_icn9707_18 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_19 },
+	{.delay = 1, .data_type = 0x29, .size = 3, .data = data_icn9707_20 },
+	{.delay = 200, .data_type = 0x05, .size = 1, .data = data_icn9707_21 },
+	{.delay = 50, .data_type = 0x05, .size = 1, .data = data_icn9707_22 }
+#endif
+};
+
+#else
+#error "_MIPI_TX_PARAM_ICN9707_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_ICN9707_H_
diff --git a/include/cvitek/cvi_panels/dsi_ili9881c.h b/include/cvitek/cvi_panels/dsi_ili9881c.h
new file mode 100644
index 000000000..0d4e76234
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_ili9881c.h
@@ -0,0 +1,428 @@
+#ifndef _MIPI_TX_PARAM_ILI9881C_H_
+#define _MIPI_TX_PARAM_ILI9881C_H_
+
+#include <cvi_mipi.h>
+
+const struct combo_dev_cfg_s dev_cfg_ili9881c_720x1280 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, MIPI_TX_LANE_2, MIPI_TX_LANE_3},
+	.lane_pn_swap = {false, false, false, false, false},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 64,
+		.vid_hbp_pixels = 36,
+		.vid_hfp_pixels = 128,
+		.vid_hline_pixels = 720,
+		.vid_vsa_lines = 16,
+		.vid_vbp_lines = 4,
+		.vid_vfp_lines = 6,
+		.vid_active_lines = 1280,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 74250,
+};
+
+const struct hs_settle_s hs_timing_cfg_ili9881c_720x1280 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_ili9881c_0[] = { 0xff, 0x98, 0x81, 0x03 };
+static u8 data_ili9881c_1[] = { 0x01, 0x00 };
+static u8 data_ili9881c_2[] = { 0x02, 0x00 };
+static u8 data_ili9881c_3[] = { 0x03, 0x73 };
+static u8 data_ili9881c_4[] = { 0x04, 0x00 };
+static u8 data_ili9881c_5[] = { 0x05, 0x00 };
+static u8 data_ili9881c_6[] = { 0x06, 0x0a };
+static u8 data_ili9881c_7[] = { 0x07, 0x00 };
+static u8 data_ili9881c_8[] = { 0x08, 0x00 };
+static u8 data_ili9881c_9[] = { 0x09, 0x01 };
+static u8 data_ili9881c_10[] = { 0x0a, 0x00 };
+static u8 data_ili9881c_11[] = { 0x0b, 0x00 };
+static u8 data_ili9881c_12[] = { 0x0c, 0x01 };
+static u8 data_ili9881c_13[] = { 0x0d, 0x00 };
+static u8 data_ili9881c_14[] = { 0x0e, 0x00 };
+static u8 data_ili9881c_15[] = { 0x0f, 0x1d };
+static u8 data_ili9881c_16[] = { 0x10, 0x1d };
+static u8 data_ili9881c_17[] = { 0x11, 0x00 };
+static u8 data_ili9881c_18[] = { 0x12, 0x00 };
+static u8 data_ili9881c_19[] = { 0x13, 0x00 };
+static u8 data_ili9881c_20[] = { 0x14, 0x00 };
+static u8 data_ili9881c_21[] = { 0x15, 0x00 };
+static u8 data_ili9881c_22[] = { 0x16, 0x00 };
+static u8 data_ili9881c_23[] = { 0x17, 0x00 };
+static u8 data_ili9881c_24[] = { 0x18, 0x00 };
+static u8 data_ili9881c_25[] = { 0x19, 0x00 };
+static u8 data_ili9881c_26[] = { 0x1a, 0x00 };
+static u8 data_ili9881c_27[] = { 0x1b, 0x00 };
+static u8 data_ili9881c_28[] = { 0x1c, 0x00 };
+static u8 data_ili9881c_29[] = { 0x1d, 0x00 };
+static u8 data_ili9881c_30[] = { 0x1e, 0x40 };
+static u8 data_ili9881c_31[] = { 0x1f, 0x80 };
+static u8 data_ili9881c_32[] = { 0x20, 0x06 };
+static u8 data_ili9881c_33[] = { 0x21, 0x02 };
+static u8 data_ili9881c_34[] = { 0x22, 0x00 };
+static u8 data_ili9881c_35[] = { 0x23, 0x00 };
+static u8 data_ili9881c_36[] = { 0x24, 0x00 };
+static u8 data_ili9881c_37[] = { 0x25, 0x00 };
+static u8 data_ili9881c_38[] = { 0x26, 0x00 };
+static u8 data_ili9881c_39[] = { 0x27, 0x00 };
+static u8 data_ili9881c_40[] = { 0x28, 0x33 };
+static u8 data_ili9881c_41[] = { 0x29, 0x03 };
+static u8 data_ili9881c_42[] = { 0x2a, 0x00 };
+static u8 data_ili9881c_43[] = { 0x2b, 0x00 };
+static u8 data_ili9881c_44[] = { 0x2c, 0x00 };
+static u8 data_ili9881c_45[] = { 0x2d, 0x00 };
+static u8 data_ili9881c_46[] = { 0x2e, 0x00 };
+static u8 data_ili9881c_47[] = { 0x2f, 0x00 };
+static u8 data_ili9881c_48[] = { 0x30, 0x00 };
+static u8 data_ili9881c_49[] = { 0x31, 0x00 };
+static u8 data_ili9881c_50[] = { 0x32, 0x00 };
+static u8 data_ili9881c_51[] = { 0x33, 0x00 };
+static u8 data_ili9881c_52[] = { 0x34, 0x04 };
+static u8 data_ili9881c_53[] = { 0x35, 0x00 };
+static u8 data_ili9881c_54[] = { 0x36, 0x00 };
+static u8 data_ili9881c_55[] = { 0x37, 0x00 };
+static u8 data_ili9881c_56[] = { 0x38, 0x3c };
+static u8 data_ili9881c_57[] = { 0x39, 0x00 };
+static u8 data_ili9881c_58[] = { 0x3a, 0x40 };
+static u8 data_ili9881c_59[] = { 0x3b, 0x40 };
+static u8 data_ili9881c_60[] = { 0x3c, 0x00 };
+static u8 data_ili9881c_61[] = { 0x3d, 0x00 };
+static u8 data_ili9881c_62[] = { 0x3e, 0x00 };
+static u8 data_ili9881c_63[] = { 0x3f, 0x00 };
+static u8 data_ili9881c_64[] = { 0x40, 0x00 };
+static u8 data_ili9881c_65[] = { 0x41, 0x00 };
+static u8 data_ili9881c_66[] = { 0x42, 0x00 };
+static u8 data_ili9881c_67[] = { 0x43, 0x00 };
+static u8 data_ili9881c_68[] = { 0x44, 0x00 };
+static u8 data_ili9881c_69[] = { 0x50, 0x01 };
+static u8 data_ili9881c_70[] = { 0x51, 0x23 };
+static u8 data_ili9881c_71[] = { 0x52, 0x45 };
+static u8 data_ili9881c_72[] = { 0x53, 0x67 };
+static u8 data_ili9881c_73[] = { 0x54, 0x89 };
+static u8 data_ili9881c_74[] = { 0x55, 0xab };
+static u8 data_ili9881c_75[] = { 0x56, 0x01 };
+static u8 data_ili9881c_76[] = { 0x57, 0x23 };
+static u8 data_ili9881c_77[] = { 0x58, 0x45 };
+static u8 data_ili9881c_78[] = { 0x59, 0x67 };
+static u8 data_ili9881c_79[] = { 0x5a, 0x89 };
+static u8 data_ili9881c_80[] = { 0x5b, 0xab };
+static u8 data_ili9881c_81[] = { 0x5c, 0xcd };
+static u8 data_ili9881c_82[] = { 0x5d, 0xef };
+static u8 data_ili9881c_83[] = { 0x5e, 0x11 };
+static u8 data_ili9881c_84[] = { 0x5f, 0x01 };
+static u8 data_ili9881c_85[] = { 0x60, 0x00 };
+static u8 data_ili9881c_86[] = { 0x61, 0x15 };
+static u8 data_ili9881c_87[] = { 0x62, 0x14 };
+static u8 data_ili9881c_88[] = { 0x63, 0x0e };
+static u8 data_ili9881c_89[] = { 0x64, 0x0f };
+static u8 data_ili9881c_90[] = { 0x65, 0x0c };
+static u8 data_ili9881c_91[] = { 0x66, 0x0d };
+static u8 data_ili9881c_92[] = { 0x67, 0x06 };
+static u8 data_ili9881c_93[] = { 0x68, 0x02 };
+static u8 data_ili9881c_94[] = { 0x69, 0x07 };
+static u8 data_ili9881c_95[] = { 0x6a, 0x02 };
+static u8 data_ili9881c_96[] = { 0x6b, 0x02 };
+static u8 data_ili9881c_97[] = { 0x6c, 0x02 };
+static u8 data_ili9881c_98[] = { 0x6d, 0x02 };
+static u8 data_ili9881c_99[] = { 0x6e, 0x02 };
+static u8 data_ili9881c_100[] = { 0x6f, 0x02 };
+static u8 data_ili9881c_101[] = { 0x70, 0x02 };
+static u8 data_ili9881c_102[] = { 0x71, 0x02 };
+static u8 data_ili9881c_103[] = { 0x72, 0x02 };
+static u8 data_ili9881c_104[] = { 0x73, 0x02 };
+static u8 data_ili9881c_105[] = { 0x74, 0x02 };
+static u8 data_ili9881c_106[] = { 0x75, 0x01 };
+static u8 data_ili9881c_107[] = { 0x76, 0x00 };
+static u8 data_ili9881c_108[] = { 0x77, 0x14 };
+static u8 data_ili9881c_109[] = { 0x78, 0x15 };
+static u8 data_ili9881c_110[] = { 0x79, 0x0e };
+static u8 data_ili9881c_111[] = { 0x7a, 0x0f };
+static u8 data_ili9881c_112[] = { 0x7b, 0x0c };
+static u8 data_ili9881c_113[] = { 0x7c, 0x0d };
+static u8 data_ili9881c_114[] = { 0x7d, 0x06 };
+static u8 data_ili9881c_115[] = { 0x7e, 0x02 };
+static u8 data_ili9881c_116[] = { 0x7f, 0x07 };
+static u8 data_ili9881c_117[] = { 0x80, 0x02 };
+static u8 data_ili9881c_118[] = { 0x81, 0x02 };
+static u8 data_ili9881c_119[] = { 0x82, 0x02 };
+static u8 data_ili9881c_120[] = { 0x83, 0x02 };
+static u8 data_ili9881c_121[] = { 0x84, 0x02 };
+static u8 data_ili9881c_122[] = { 0x85, 0x02 };
+static u8 data_ili9881c_123[] = { 0x86, 0x02 };
+static u8 data_ili9881c_124[] = { 0x87, 0x02 };
+static u8 data_ili9881c_125[] = { 0x88, 0x02 };
+static u8 data_ili9881c_126[] = { 0x89, 0x02 };
+static u8 data_ili9881c_127[] = { 0x8a, 0x02 };
+static u8 data_ili9881c_128[] = { 0xff, 0x98, 0x81, 0x04 };
+static u8 data_ili9881c_129[] = { 0x6c, 0x15 };
+static u8 data_ili9881c_130[] = { 0x6e, 0x2b };
+static u8 data_ili9881c_131[] = { 0x6f, 0x33 };
+static u8 data_ili9881c_132[] = { 0x8d, 0x18 };
+static u8 data_ili9881c_133[] = { 0x87, 0xba };
+static u8 data_ili9881c_134[] = { 0x26, 0x76 };
+static u8 data_ili9881c_135[] = { 0xb2, 0xd1 };
+static u8 data_ili9881c_136[] = { 0xb5, 0x06 };
+static u8 data_ili9881c_137[] = { 0x3a, 0x24 };
+static u8 data_ili9881c_138[] = { 0x35, 0x1f };
+static u8 data_ili9881c_139[] = { 0xff, 0x98, 0x81, 0x01 };
+static u8 data_ili9881c_140[] = { 0x22, 0x09 };
+static u8 data_ili9881c_141[] = { 0x31, 0x00 };
+static u8 data_ili9881c_142[] = { 0x40, 0x33 };
+static u8 data_ili9881c_143[] = { 0x53, 0xa2 };
+static u8 data_ili9881c_144[] = { 0x55, 0x92 };
+static u8 data_ili9881c_145[] = { 0x50, 0x96 };
+static u8 data_ili9881c_146[] = { 0x51, 0x96 };
+static u8 data_ili9881c_147[] = { 0x60, 0x22 };
+static u8 data_ili9881c_148[] = { 0x61, 0x00 };
+static u8 data_ili9881c_149[] = { 0x62, 0x19 };
+static u8 data_ili9881c_150[] = { 0x63, 0x00 };
+static u8 data_ili9881c_151[] = { 0xa0, 0x08 };
+static u8 data_ili9881c_152[] = { 0xa1, 0x11 };
+static u8 data_ili9881c_153[] = { 0xa2, 0x19 };
+static u8 data_ili9881c_154[] = { 0xa3, 0x0d };
+static u8 data_ili9881c_155[] = { 0xa4, 0x0d };
+static u8 data_ili9881c_156[] = { 0xa5, 0x1e };
+static u8 data_ili9881c_157[] = { 0xa6, 0x14 };
+static u8 data_ili9881c_158[] = { 0xa7, 0x17 };
+static u8 data_ili9881c_159[] = { 0xa8, 0x4f };
+static u8 data_ili9881c_160[] = { 0xa9, 0x1a };
+static u8 data_ili9881c_161[] = { 0xaa, 0x27 };
+static u8 data_ili9881c_162[] = { 0xab, 0x49 };
+static u8 data_ili9881c_163[] = { 0xac, 0x1a };
+static u8 data_ili9881c_164[] = { 0xad, 0x18 };
+static u8 data_ili9881c_165[] = { 0xae, 0x4c };
+static u8 data_ili9881c_166[] = { 0xaf, 0x22 };
+static u8 data_ili9881c_167[] = { 0xb0, 0x27 };
+static u8 data_ili9881c_168[] = { 0xb1, 0x4b };
+static u8 data_ili9881c_169[] = { 0xb2, 0x60 };
+static u8 data_ili9881c_170[] = { 0xb3, 0x39 };
+static u8 data_ili9881c_171[] = { 0xc0, 0x08 };
+static u8 data_ili9881c_172[] = { 0xc1, 0x11 };
+static u8 data_ili9881c_173[] = { 0xc2, 0x19 };
+static u8 data_ili9881c_174[] = { 0xc3, 0x0d };
+static u8 data_ili9881c_175[] = { 0xc4, 0x0d };
+static u8 data_ili9881c_176[] = { 0xc5, 0x1e };
+static u8 data_ili9881c_177[] = { 0xc6, 0x14 };
+static u8 data_ili9881c_178[] = { 0xc7, 0x17 };
+static u8 data_ili9881c_179[] = { 0xc8, 0x4f };
+static u8 data_ili9881c_180[] = { 0xc9, 0x1a };
+static u8 data_ili9881c_181[] = { 0xca, 0x27 };
+static u8 data_ili9881c_182[] = { 0xcb, 0x49 };
+static u8 data_ili9881c_183[] = { 0xcc, 0x1a };
+static u8 data_ili9881c_184[] = { 0xcd, 0x18 };
+static u8 data_ili9881c_185[] = { 0xce, 0x4c };
+static u8 data_ili9881c_186[] = { 0xcf, 0x33 };
+static u8 data_ili9881c_187[] = { 0xd0, 0x27 };
+static u8 data_ili9881c_188[] = { 0xd1, 0x4b };
+static u8 data_ili9881c_189[] = { 0xd2, 0x60 };
+static u8 data_ili9881c_190[] = { 0xd3, 0x39 };
+static u8 data_ili9881c_191[] = { 0xff, 0x98, 0x81, 0x00 };
+static u8 data_ili9881c_192[] = { 0x36 };
+static u8 data_ili9881c_193[] = { 0x35 };
+static u8 data_ili9881c_194[] = { 0x11 };
+static u8 data_ili9881c_195[] = { 0x29 };
+
+const struct dsc_instr dsi_init_cmds_ili9881c_720x1280[] = {
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881c_0 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_1 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_3 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_7 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_16 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_23 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_24 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_25 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_26 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_27 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_28 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_29 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_31 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_32 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_33 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_34 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_35 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_36 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_37 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_38 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_39 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_40 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_41 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_42 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_43 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_44 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_45 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_46 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_47 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_48 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_49 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_50 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_51 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_52 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_53 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_54 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_55 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_56 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_57 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_58 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_59 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_60 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_61 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_62 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_63 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_64 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_65 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_66 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_67 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_68 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_69 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_70 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_71 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_72 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_73 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_74 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_75 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_76 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_77 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_78 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_79 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_80 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_81 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_82 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_83 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_84 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_85 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_86 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_87 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_88 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_89 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_90 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_91 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_92 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_93 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_94 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_95 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_96 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_97 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_98 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_99 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_100 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_101 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_102 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_103 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_104 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_105 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_106 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_107 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_108 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_109 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_110 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_111 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_112 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_113 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_114 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_115 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_116 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_117 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_118 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_119 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_120 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_121 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_122 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_123 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_124 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_125 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_126 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_127 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881c_128 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_129 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_130 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_131 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_132 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_133 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_134 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_135 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_136 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_137 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_138 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881c_139 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_140 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_141 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_142 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_143 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_144 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_145 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_146 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_147 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_148 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_149 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_150 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_151 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_152 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_153 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_154 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_155 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_156 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_157 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_158 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_159 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_160 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_161 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_162 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_163 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_164 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_165 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_166 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_167 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_168 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_169 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_170 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_171 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_172 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_173 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_174 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_175 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_176 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_177 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_178 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_179 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_180 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_181 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_182 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_183 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_184 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_185 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_186 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_187 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_188 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_189 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881c_190 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881c_191 },
+	{.delay = 0, .data_type = 0x05, .size = 1, .data = data_ili9881c_192 },
+	{.delay = 0, .data_type = 0x05, .size = 1, .data = data_ili9881c_193 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_ili9881c_194 },
+	{.delay = 20, .data_type = 0x05, .size = 1, .data = data_ili9881c_195 }
+};
+
+#else
+#error "_MIPI_TX_PARAM_ILI9881C_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_ILI9881C_H_
diff --git a/include/cvitek/cvi_panels/dsi_ili9881d.h b/include/cvitek/cvi_panels/dsi_ili9881d.h
new file mode 100644
index 000000000..78b889a5e
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_ili9881d.h
@@ -0,0 +1,419 @@
+#ifndef _MIPI_TX_PARAM_ILI9881D_H_
+#define _MIPI_TX_PARAM_ILI9881D_H_
+
+#include <cvi_mipi.h>
+
+const struct combo_dev_cfg_s dev_cfg_ili9881d_720x1280 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_2, MIPI_TX_LANE_CLK, MIPI_TX_LANE_3},
+	.lane_pn_swap = {false, false, false, false, false},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 60,
+		.vid_hbp_pixels = 60,
+		.vid_hfp_pixels = 140,
+		.vid_hline_pixels = 720,
+		.vid_vsa_lines = 16,
+		.vid_vbp_lines = 24,
+		.vid_vfp_lines = 8,
+		.vid_active_lines = 1280,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 70118,
+};
+
+const struct hs_settle_s hs_timing_cfg_ili9881d_720x1280 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_ili9881d_0[] = { 0xff, 0x98, 0x81, 0x01 };
+static u8 data_ili9881d_1[] = { 0x91, 0x00 };
+static u8 data_ili9881d_2[] = { 0x92, 0x00 };
+static u8 data_ili9881d_3[] = { 0x93, 0x72 };
+static u8 data_ili9881d_4[] = { 0x94, 0x00 };
+static u8 data_ili9881d_5[] = { 0x95, 0x00 };
+static u8 data_ili9881d_6[] = { 0x96, 0x09 };
+static u8 data_ili9881d_7[] = { 0x97, 0x00 };
+static u8 data_ili9881d_8[] = { 0x98, 0x00 };
+static u8 data_ili9881d_9[] = { 0x09, 0x01 };
+static u8 data_ili9881d_10[] = { 0x0a, 0x00 };
+static u8 data_ili9881d_11[] = { 0x0b, 0x00 };
+static u8 data_ili9881d_12[] = { 0x0c, 0x01 };
+static u8 data_ili9881d_13[] = { 0x0d, 0x00 };
+static u8 data_ili9881d_14[] = { 0x0e, 0x00 };
+static u8 data_ili9881d_15[] = { 0x0f, 0x00 };
+static u8 data_ili9881d_16[] = { 0x10, 0x00 };
+static u8 data_ili9881d_17[] = { 0x11, 0x00 };
+static u8 data_ili9881d_18[] = { 0x12, 0x00 };
+static u8 data_ili9881d_19[] = { 0x13, 0x00 };
+static u8 data_ili9881d_20[] = { 0x14, 0x00 };
+static u8 data_ili9881d_21[] = { 0x15, 0x00 };
+static u8 data_ili9881d_22[] = { 0x16, 0x00 };
+static u8 data_ili9881d_23[] = { 0x17, 0x00 };
+static u8 data_ili9881d_24[] = { 0x18, 0x00 };
+static u8 data_ili9881d_25[] = { 0x19, 0x00 };
+static u8 data_ili9881d_26[] = { 0x1a, 0x00 };
+static u8 data_ili9881d_27[] = { 0x1b, 0x00 };
+static u8 data_ili9881d_28[] = { 0x1c, 0x00 };
+static u8 data_ili9881d_29[] = { 0x1d, 0x00 };
+static u8 data_ili9881d_30[] = { 0x1e, 0xc0 };
+static u8 data_ili9881d_31[] = { 0x1f, 0x40 };
+static u8 data_ili9881d_32[] = { 0x20, 0x05 };
+static u8 data_ili9881d_33[] = { 0x21, 0x02 };
+static u8 data_ili9881d_34[] = { 0x22, 0x00 };
+static u8 data_ili9881d_35[] = { 0x23, 0x00 };
+static u8 data_ili9881d_36[] = { 0x24, 0x00 };
+static u8 data_ili9881d_37[] = { 0x25, 0x00 };
+static u8 data_ili9881d_38[] = { 0x26, 0x00 };
+static u8 data_ili9881d_39[] = { 0x27, 0x00 };
+static u8 data_ili9881d_40[] = { 0x28, 0x33 };
+static u8 data_ili9881d_41[] = { 0x29, 0x02 };
+static u8 data_ili9881d_42[] = { 0x2a, 0x00 };
+static u8 data_ili9881d_43[] = { 0x2b, 0x00 };
+static u8 data_ili9881d_44[] = { 0x2c, 0x00 };
+static u8 data_ili9881d_45[] = { 0x2d, 0x00 };
+static u8 data_ili9881d_46[] = { 0x2e, 0x00 };
+static u8 data_ili9881d_47[] = { 0x2f, 0x00 };
+static u8 data_ili9881d_48[] = { 0x30, 0x00 };
+static u8 data_ili9881d_49[] = { 0x31, 0x00 };
+static u8 data_ili9881d_50[] = { 0x32, 0x00 };
+static u8 data_ili9881d_51[] = { 0x33, 0x00 };
+static u8 data_ili9881d_52[] = { 0x34, 0x04 };
+static u8 data_ili9881d_53[] = { 0x35, 0x00 };
+static u8 data_ili9881d_54[] = { 0x36, 0x00 };
+static u8 data_ili9881d_55[] = { 0x37, 0x00 };
+static u8 data_ili9881d_56[] = { 0x38, 0x3c };
+static u8 data_ili9881d_57[] = { 0x39, 0x07 };
+static u8 data_ili9881d_58[] = { 0x3a, 0x00 };
+static u8 data_ili9881d_59[] = { 0x3b, 0x00 };
+static u8 data_ili9881d_60[] = { 0x3c, 0x00 };
+static u8 data_ili9881d_61[] = { 0x40, 0x03 };
+static u8 data_ili9881d_62[] = { 0x41, 0x20 };
+static u8 data_ili9881d_63[] = { 0x42, 0x00 };
+static u8 data_ili9881d_64[] = { 0x43, 0x40 };
+static u8 data_ili9881d_65[] = { 0x44, 0x03 };
+static u8 data_ili9881d_66[] = { 0x45, 0x00 };
+static u8 data_ili9881d_67[] = { 0x46, 0x01 };
+static u8 data_ili9881d_68[] = { 0x47, 0x08 };
+static u8 data_ili9881d_69[] = { 0x48, 0x00 };
+static u8 data_ili9881d_70[] = { 0x49, 0x00 };
+static u8 data_ili9881d_71[] = { 0x4a, 0x00 };
+static u8 data_ili9881d_72[] = { 0x4b, 0x00 };
+static u8 data_ili9881d_73[] = { 0x4c, 0x01 };
+static u8 data_ili9881d_74[] = { 0x4d, 0x45 };
+static u8 data_ili9881d_75[] = { 0x4e, 0x9b };
+static u8 data_ili9881d_76[] = { 0x4f, 0x57 };
+static u8 data_ili9881d_77[] = { 0x50, 0x29 };
+static u8 data_ili9881d_78[] = { 0x51, 0x27 };
+static u8 data_ili9881d_79[] = { 0x52, 0x22 };
+static u8 data_ili9881d_80[] = { 0x53, 0x22 };
+static u8 data_ili9881d_81[] = { 0x54, 0x22 };
+static u8 data_ili9881d_82[] = { 0x55, 0x22 };
+static u8 data_ili9881d_83[] = { 0x56, 0x22 };
+static u8 data_ili9881d_84[] = { 0x57, 0x01 };
+static u8 data_ili9881d_85[] = { 0x58, 0x45 };
+static u8 data_ili9881d_86[] = { 0x59, 0x8a };
+static u8 data_ili9881d_87[] = { 0x5a, 0x46 };
+static u8 data_ili9881d_88[] = { 0x5b, 0x28 };
+static u8 data_ili9881d_89[] = { 0x5c, 0x26 };
+static u8 data_ili9881d_90[] = { 0x5d, 0x22 };
+static u8 data_ili9881d_91[] = { 0x5e, 0x22 };
+static u8 data_ili9881d_92[] = { 0x5f, 0x22 };
+static u8 data_ili9881d_93[] = { 0x60, 0x22 };
+static u8 data_ili9881d_94[] = { 0x61, 0x22 };
+static u8 data_ili9881d_95[] = { 0x62, 0x06 };
+static u8 data_ili9881d_96[] = { 0x63, 0x01 };
+static u8 data_ili9881d_97[] = { 0x64, 0x00 };
+static u8 data_ili9881d_98[] = { 0x65, 0xa4 };
+static u8 data_ili9881d_99[] = { 0x66, 0xa5 };
+static u8 data_ili9881d_100[] = { 0x67, 0x58 };
+static u8 data_ili9881d_101[] = { 0x68, 0x5a };
+static u8 data_ili9881d_102[] = { 0x69, 0x54 };
+static u8 data_ili9881d_103[] = { 0x6a, 0x56 };
+static u8 data_ili9881d_104[] = { 0x6b, 0x06 };
+static u8 data_ili9881d_105[] = { 0x6c, 0x02 };
+static u8 data_ili9881d_106[] = { 0x6d, 0x08 };
+static u8 data_ili9881d_107[] = { 0x6e, 0x02 };
+static u8 data_ili9881d_108[] = { 0x6f, 0x02 };
+static u8 data_ili9881d_109[] = { 0x70, 0x02 };
+static u8 data_ili9881d_110[] = { 0x71, 0x02 };
+static u8 data_ili9881d_111[] = { 0x72, 0x02 };
+static u8 data_ili9881d_112[] = { 0x73, 0x02 };
+static u8 data_ili9881d_113[] = { 0x74, 0x02 };
+static u8 data_ili9881d_114[] = { 0x75, 0x02 };
+static u8 data_ili9881d_115[] = { 0x76, 0x02 };
+static u8 data_ili9881d_116[] = { 0x77, 0x02 };
+static u8 data_ili9881d_117[] = { 0x78, 0x02 };
+static u8 data_ili9881d_118[] = { 0x79, 0x01 };
+static u8 data_ili9881d_119[] = { 0x7a, 0x00 };
+static u8 data_ili9881d_120[] = { 0x7b, 0xa4 };
+static u8 data_ili9881d_121[] = { 0x7c, 0xa5 };
+static u8 data_ili9881d_122[] = { 0x7d, 0x59 };
+static u8 data_ili9881d_123[] = { 0x7e, 0x5b };
+static u8 data_ili9881d_124[] = { 0x7f, 0x55 };
+static u8 data_ili9881d_125[] = { 0x80, 0x57 };
+static u8 data_ili9881d_126[] = { 0x81, 0x07 };
+static u8 data_ili9881d_127[] = { 0x82, 0x02 };
+static u8 data_ili9881d_128[] = { 0x83, 0x09 };
+static u8 data_ili9881d_129[] = { 0x84, 0x02 };
+static u8 data_ili9881d_130[] = { 0x85, 0x02 };
+static u8 data_ili9881d_131[] = { 0x86, 0x02 };
+static u8 data_ili9881d_132[] = { 0x87, 0x02 };
+static u8 data_ili9881d_133[] = { 0x88, 0x02 };
+static u8 data_ili9881d_134[] = { 0x89, 0x02 };
+static u8 data_ili9881d_135[] = { 0x8a, 0x02 };
+static u8 data_ili9881d_136[] = { 0x8b, 0x02 };
+static u8 data_ili9881d_137[] = { 0x8c, 0x02 };
+static u8 data_ili9881d_138[] = { 0x8d, 0x02 };
+static u8 data_ili9881d_139[] = { 0x8e, 0x02 };
+static u8 data_ili9881d_140[] = { 0xa0, 0x35 };
+static u8 data_ili9881d_141[] = { 0xa1, 0x00 };
+static u8 data_ili9881d_142[] = { 0xa2, 0x00 };
+static u8 data_ili9881d_143[] = { 0xa3, 0x00 };
+static u8 data_ili9881d_144[] = { 0xa4, 0x00 };
+static u8 data_ili9881d_145[] = { 0xa5, 0x00 };
+static u8 data_ili9881d_146[] = { 0xa6, 0x00 };
+static u8 data_ili9881d_147[] = { 0xa7, 0x00 };
+static u8 data_ili9881d_148[] = { 0xa8, 0x00 };
+static u8 data_ili9881d_149[] = { 0xa9, 0x00 };
+static u8 data_ili9881d_150[] = { 0xaa, 0x00 };
+static u8 data_ili9881d_151[] = { 0xab, 0x00 };
+static u8 data_ili9881d_152[] = { 0xac, 0x00 };
+static u8 data_ili9881d_153[] = { 0xad, 0x00 };
+static u8 data_ili9881d_154[] = { 0xae, 0xff };
+static u8 data_ili9881d_155[] = { 0xaf, 0x00 };
+static u8 data_ili9881d_156[] = { 0xb0, 0x00 };
+static u8 data_ili9881d_157[] = { 0xff, 0x98, 0x81, 0x02 };
+static u8 data_ili9881d_158[] = {
+	0xa0, 0x00, 0x0e, 0x1a, 0x11, 0x13, 0x25, 0x19, 0x1c, 0x6b,
+	0x1b, 0x28, 0x66, 0x1b, 0x19, 0x4d, 0x22, 0x27, 0x53, 0x63,
+	0x2e
+};
+
+static u8 data_ili9881d_159[] = {
+	0xc0, 0x00, 0x0e, 0x1a, 0x11, 0x13, 0x25, 0x19, 0x1c, 0x6b,
+	0x1b, 0x28, 0x66, 0x1b, 0x19, 0x4d, 0x22, 0x27, 0x53, 0x63,
+	0x2e
+};
+
+//================GIP code finish ================//
+static u8 data_ili9881d_160[] = { 0x18, 0xf4 };
+static u8 data_ili9881d_161[] = { 0xff, 0x98, 0x81, 0x04 };
+static u8 data_ili9881d_162[] = { 0x5d, 0x8b };
+static u8 data_ili9881d_163[] = { 0x5e, 0x8b };
+static u8 data_ili9881d_164[] = { 0x60, 0x68 };
+static u8 data_ili9881d_165[] = { 0x62, 0x52 };
+static u8 data_ili9881d_166[] = { 0x82, 0x38 };
+static u8 data_ili9881d_167[] = { 0x84, 0x38 };
+static u8 data_ili9881d_168[] = { 0x86, 0x1c };
+static u8 data_ili9881d_169[] = { 0x66, 0x04 };
+static u8 data_ili9881d_170[] = { 0xc1, 0x70 };
+static u8 data_ili9881d_171[] = { 0x70, 0x60 };
+static u8 data_ili9881d_172[] = { 0x71, 0x00 };
+static u8 data_ili9881d_173[] = { 0x5b, 0x33 };
+static u8 data_ili9881d_174[] = { 0x6c, 0x10 };
+static u8 data_ili9881d_175[] = { 0x77, 0x03 };
+static u8 data_ili9881d_176[] = { 0x7b, 0x02 };
+static u8 data_ili9881d_177[] = { 0xff, 0x98, 0x81, 0x01 };
+static u8 data_ili9881d_178[] = { 0xf0, 0x00 };
+static u8 data_ili9881d_179[] = { 0xf1, 0xc8 };
+static u8 data_ili9881d_180[] = { 0xff, 0x98, 0x81, 0x05 };
+static u8 data_ili9881d_181[] = { 0x22, 0x3a };
+static u8 data_ili9881d_182[] = { 0xff, 0x98, 0x81, 0x00 };
+static u8 data_ili9881d_183[] = { 0x35, 0x00 };
+static u8 data_ili9881d_184[] = { 0x11, 0x00 };
+static u8 data_ili9881d_185[] = { 0x29, 0x00 };
+
+const struct dsc_instr dsi_init_cmds_ili9881d_720x1280[] = {
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881d_0 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_1 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_3 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_7 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_16 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_23 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_24 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_25 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_26 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_27 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_28 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_29 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_31 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_32 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_33 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_34 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_35 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_36 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_37 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_38 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_39 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_40 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_41 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_42 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_43 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_44 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_45 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_46 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_47 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_48 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_49 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_50 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_51 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_52 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_53 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_54 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_55 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_56 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_57 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_58 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_59 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_60 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_61 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_62 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_63 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_64 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_65 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_66 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_67 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_68 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_69 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_70 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_71 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_72 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_73 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_74 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_75 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_76 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_77 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_78 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_79 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_80 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_81 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_82 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_83 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_84 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_85 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_86 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_87 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_88 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_89 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_90 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_91 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_92 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_93 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_94 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_95 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_96 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_97 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_98 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_99 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_100 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_101 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_102 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_103 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_104 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_105 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_106 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_107 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_108 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_109 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_110 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_111 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_112 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_113 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_114 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_115 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_116 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_117 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_118 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_119 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_120 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_121 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_122 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_123 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_124 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_125 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_126 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_127 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_128 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_129 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_130 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_131 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_132 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_133 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_134 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_135 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_136 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_137 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_138 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_139 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_140 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_141 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_142 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_143 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_144 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_145 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_146 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_147 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_148 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_149 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_150 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_151 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_152 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_153 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_154 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_155 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_156 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881d_157 },
+	{.delay = 0, .data_type = 0x29, .size = 21, .data = data_ili9881d_158 },
+	{.delay = 0, .data_type = 0x29, .size = 21, .data = data_ili9881d_159 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_160 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881d_161 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_162 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_163 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_164 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_165 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_166 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_167 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_168 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_169 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_170 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_171 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_172 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_173 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_174 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_175 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_176 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881d_177 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_178 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_179 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881d_180 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_181 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_ili9881d_182 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ili9881d_183 },
+	{.delay = 120, .data_type = 0x15, .size = 2, .data = data_ili9881d_184 },
+	{.delay = 20, .data_type = 0x15, .size = 2, .data = data_ili9881d_185 }
+};
+
+#else
+#error "_MIPI_TX_PARAM_ILI9881D_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_ILI9881D_H_
diff --git a/include/cvitek/cvi_panels/dsi_jd9366ab.h b/include/cvitek/cvi_panels/dsi_jd9366ab.h
new file mode 100644
index 000000000..58fde33a4
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_jd9366ab.h
@@ -0,0 +1,393 @@
+#ifndef _MIPI_TX_PARAM_JD9366AB_H_
+#define _MIPI_TX_PARAM_JD9366AB_H_
+
+#include <cvi_mipi.h>
+
+const struct combo_dev_cfg_s dev_cfg_jd9366ab_800x1280 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, MIPI_TX_LANE_3, MIPI_TX_LANE_2},
+	.lane_pn_swap = {true, true, true, true, true},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 6,
+		.vid_hbp_pixels = 40,
+		.vid_hfp_pixels = 112,
+		.vid_hline_pixels = 800,
+		.vid_vsa_lines = 4,
+		.vid_vbp_lines = 15,
+		.vid_vfp_lines = 21,
+		.vid_active_lines = 1280,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = false,
+	},
+	.pixel_clk = 70000,
+};
+
+const struct hs_settle_s hs_timing_cfg_jd9366ab_800x1280 = { .prepare = 6, .zero = 16, .trail = 1 };
+
+static u8 data_jd9366ab_0[] = { 0xe0, 0x00 };
+static u8 data_jd9366ab_1[] = { 0xe1, 0x93 };
+static u8 data_jd9366ab_2[] = { 0xe2, 0x65 };
+static u8 data_jd9366ab_3[] = { 0xe3, 0xf8 };
+static u8 data_jd9366ab_4[] = { 0x80, 0x03 };
+static u8 data_jd9366ab_5[] = { 0xe0, 0x04 };
+static u8 data_jd9366ab_6[] = { 0x2d, 0x03 };
+static u8 data_jd9366ab_7[] = { 0xe0, 0x01 };
+static u8 data_jd9366ab_8[] = { 0x00, 0x00 };
+static u8 data_jd9366ab_9[] = { 0x01, 0xb7 };
+static u8 data_jd9366ab_10[] = { 0x17, 0x00 };
+static u8 data_jd9366ab_11[] = { 0x18, 0xcf };
+static u8 data_jd9366ab_12[] = { 0x19, 0x01 };
+static u8 data_jd9366ab_13[] = { 0x1a, 0x00 };
+static u8 data_jd9366ab_14[] = { 0x1b, 0xcf };
+static u8 data_jd9366ab_15[] = { 0x1c, 0x01 };
+static u8 data_jd9366ab_16[] = { 0x1f, 0x3e };
+static u8 data_jd9366ab_17[] = { 0x20, 0x28 };
+static u8 data_jd9366ab_18[] = { 0x21, 0x28 };
+static u8 data_jd9366ab_19[] = { 0x22, 0x0e };
+static u8 data_jd9366ab_20[] = { 0x24, 0xc8 };
+static u8 data_jd9366ab_21[] = { 0x26, 0xf1 };
+static u8 data_jd9366ab_22[] = { 0x37, 0x29 };
+static u8 data_jd9366ab_23[] = { 0x38, 0x05 };
+static u8 data_jd9366ab_24[] = { 0x39, 0x08 };
+static u8 data_jd9366ab_25[] = { 0x3a, 0x12 };
+static u8 data_jd9366ab_26[] = { 0x3c, 0x78 };
+static u8 data_jd9366ab_27[] = { 0x3d, 0xff };
+static u8 data_jd9366ab_28[] = { 0x3e, 0xff };
+static u8 data_jd9366ab_29[] = { 0x3f, 0xff };
+static u8 data_jd9366ab_30[] = { 0x40, 0x06 };
+static u8 data_jd9366ab_31[] = { 0x41, 0xa0 };
+static u8 data_jd9366ab_32[] = { 0x43, 0x15 };
+static u8 data_jd9366ab_33[] = { 0x44, 0x12 };
+static u8 data_jd9366ab_34[] = { 0x45, 0x50 };
+static u8 data_jd9366ab_35[] = { 0x4b, 0x04 };
+static u8 data_jd9366ab_36[] = { 0x55, 0x0f };
+static u8 data_jd9366ab_37[] = { 0x56, 0x01 };
+static u8 data_jd9366ab_38[] = { 0x57, 0x89 };
+static u8 data_jd9366ab_39[] = { 0x58, 0x0a };
+static u8 data_jd9366ab_40[] = { 0x59, 0x2a };
+static u8 data_jd9366ab_41[] = { 0x5a, 0x31 };
+static u8 data_jd9366ab_42[] = { 0x5b, 0x15 };
+static u8 data_jd9366ab_43[] = { 0x5d, 0x7c };
+static u8 data_jd9366ab_44[] = { 0x5e, 0x50 };
+static u8 data_jd9366ab_45[] = { 0x5f, 0x3b };
+static u8 data_jd9366ab_46[] = { 0x60, 0x2b };
+static u8 data_jd9366ab_47[] = { 0x61, 0x25 };
+static u8 data_jd9366ab_48[] = { 0x62, 0x15 };
+static u8 data_jd9366ab_49[] = { 0x63, 0x1a };
+static u8 data_jd9366ab_50[] = { 0x64, 0x04 };
+static u8 data_jd9366ab_51[] = { 0x65, 0x1c };
+static u8 data_jd9366ab_52[] = { 0x66, 0x1a };
+static u8 data_jd9366ab_53[] = { 0x67, 0x19 };
+static u8 data_jd9366ab_54[] = { 0x68, 0x36 };
+static u8 data_jd9366ab_55[] = { 0x69, 0x27 };
+static u8 data_jd9366ab_56[] = { 0x6a, 0x2f };
+static u8 data_jd9366ab_57[] = { 0x6b, 0x23 };
+static u8 data_jd9366ab_58[] = { 0x6c, 0x21 };
+static u8 data_jd9366ab_59[] = { 0x6d, 0x17 };
+static u8 data_jd9366ab_60[] = { 0x6e, 0x05 };
+static u8 data_jd9366ab_61[] = { 0x6f, 0x00 };
+static u8 data_jd9366ab_62[] = { 0x70, 0x7c };
+static u8 data_jd9366ab_63[] = { 0x71, 0x50 };
+static u8 data_jd9366ab_64[] = { 0x72, 0x3b };
+static u8 data_jd9366ab_65[] = { 0x73, 0x2b };
+static u8 data_jd9366ab_66[] = { 0x74, 0x25 };
+static u8 data_jd9366ab_67[] = { 0x75, 0x15 };
+static u8 data_jd9366ab_68[] = { 0x76, 0x1a };
+static u8 data_jd9366ab_69[] = { 0x77, 0x04 };
+static u8 data_jd9366ab_70[] = { 0x78, 0x1c };
+static u8 data_jd9366ab_71[] = { 0x79, 0x1a };
+static u8 data_jd9366ab_72[] = { 0x7a, 0x19 };
+static u8 data_jd9366ab_73[] = { 0x7b, 0x36 };
+static u8 data_jd9366ab_74[] = { 0x7c, 0x27 };
+static u8 data_jd9366ab_75[] = { 0x7d, 0x2f };
+static u8 data_jd9366ab_76[] = { 0x7e, 0x23 };
+static u8 data_jd9366ab_77[] = { 0x7f, 0x21 };
+static u8 data_jd9366ab_78[] = { 0x80, 0x17 };
+static u8 data_jd9366ab_79[] = { 0x81, 0x05 };
+static u8 data_jd9366ab_80[] = { 0x82, 0x00 };
+static u8 data_jd9366ab_81[] = { 0xe0, 0x02 };
+static u8 data_jd9366ab_82[] = { 0x00, 0x00 };
+static u8 data_jd9366ab_83[] = { 0x01, 0x04 };
+static u8 data_jd9366ab_84[] = { 0x02, 0x08 };
+static u8 data_jd9366ab_85[] = { 0x03, 0x05 };
+static u8 data_jd9366ab_86[] = { 0x04, 0x09 };
+static u8 data_jd9366ab_87[] = { 0x05, 0x06 };
+static u8 data_jd9366ab_88[] = { 0x06, 0x0a };
+static u8 data_jd9366ab_89[] = { 0x07, 0x07 };
+static u8 data_jd9366ab_90[] = { 0x08, 0x0b };
+static u8 data_jd9366ab_91[] = { 0x09, 0x1f };
+static u8 data_jd9366ab_92[] = { 0x0a, 0x1f };
+static u8 data_jd9366ab_93[] = { 0x0b, 0x1f };
+static u8 data_jd9366ab_94[] = { 0x0c, 0x1f };
+static u8 data_jd9366ab_95[] = { 0x0d, 0x1f };
+static u8 data_jd9366ab_96[] = { 0x0e, 0x1f };
+static u8 data_jd9366ab_97[] = { 0x0f, 0x17 };
+static u8 data_jd9366ab_98[] = { 0x10, 0x37 };
+static u8 data_jd9366ab_99[] = { 0x11, 0x10 };
+static u8 data_jd9366ab_100[] = { 0x12, 0x1f };
+static u8 data_jd9366ab_101[] = { 0x13, 0x1f };
+static u8 data_jd9366ab_102[] = { 0x14, 0x1f };
+static u8 data_jd9366ab_103[] = { 0x15, 0x1f };
+static u8 data_jd9366ab_104[] = { 0x16, 0x00 };
+static u8 data_jd9366ab_105[] = { 0x17, 0x04 };
+static u8 data_jd9366ab_106[] = { 0x18, 0x08 };
+static u8 data_jd9366ab_107[] = { 0x19, 0x05 };
+static u8 data_jd9366ab_108[] = { 0x1a, 0x09 };
+static u8 data_jd9366ab_109[] = { 0x1b, 0x06 };
+static u8 data_jd9366ab_110[] = { 0x1c, 0x0a };
+static u8 data_jd9366ab_111[] = { 0x1d, 0x07 };
+static u8 data_jd9366ab_112[] = { 0x1e, 0x0b };
+static u8 data_jd9366ab_113[] = { 0x1f, 0x1f };
+static u8 data_jd9366ab_114[] = { 0x20, 0x1f };
+static u8 data_jd9366ab_115[] = { 0x21, 0x1f };
+static u8 data_jd9366ab_116[] = { 0x22, 0x1f };
+static u8 data_jd9366ab_117[] = { 0x23, 0x1f };
+static u8 data_jd9366ab_118[] = { 0x24, 0x1f };
+static u8 data_jd9366ab_119[] = { 0x25, 0x17 };
+static u8 data_jd9366ab_120[] = { 0x26, 0x37 };
+static u8 data_jd9366ab_121[] = { 0x27, 0x10 };
+static u8 data_jd9366ab_122[] = { 0x28, 0x1f };
+static u8 data_jd9366ab_123[] = { 0x29, 0x1f };
+static u8 data_jd9366ab_124[] = { 0x2a, 0x1f };
+static u8 data_jd9366ab_125[] = { 0x2b, 0x1f };
+static u8 data_jd9366ab_126[] = { 0x58, 0x01 };
+static u8 data_jd9366ab_127[] = { 0x59, 0x00 };
+static u8 data_jd9366ab_128[] = { 0x5a, 0x00 };
+static u8 data_jd9366ab_129[] = { 0x5b, 0x00 };
+static u8 data_jd9366ab_130[] = { 0x5c, 0x0c };
+static u8 data_jd9366ab_131[] = { 0x5d, 0x60 };
+static u8 data_jd9366ab_132[] = { 0x5e, 0x00 };
+static u8 data_jd9366ab_133[] = { 0x5f, 0x00 };
+static u8 data_jd9366ab_134[] = { 0x60, 0x30 };
+static u8 data_jd9366ab_135[] = { 0x61, 0x00 };
+static u8 data_jd9366ab_136[] = { 0x62, 0x00 };
+static u8 data_jd9366ab_137[] = { 0x63, 0x03 };
+static u8 data_jd9366ab_138[] = { 0x64, 0x6a };
+static u8 data_jd9366ab_139[] = { 0x65, 0x45 };
+static u8 data_jd9366ab_140[] = { 0x66, 0x14 };
+static u8 data_jd9366ab_141[] = { 0x67, 0x73 };
+static u8 data_jd9366ab_142[] = { 0x68, 0x10 };
+static u8 data_jd9366ab_143[] = { 0x69, 0x06 };
+static u8 data_jd9366ab_144[] = { 0x6a, 0x6a };
+static u8 data_jd9366ab_145[] = { 0x6b, 0x00 };
+static u8 data_jd9366ab_146[] = { 0x6c, 0x00 };
+static u8 data_jd9366ab_147[] = { 0x6d, 0x03 };
+static u8 data_jd9366ab_148[] = { 0x6e, 0x00 };
+static u8 data_jd9366ab_149[] = { 0x6f, 0x08 };
+static u8 data_jd9366ab_150[] = { 0x70, 0x00 };
+static u8 data_jd9366ab_151[] = { 0x71, 0x00 };
+static u8 data_jd9366ab_152[] = { 0x72, 0x06 };
+static u8 data_jd9366ab_153[] = { 0x73, 0x7b };
+static u8 data_jd9366ab_154[] = { 0x74, 0x00 };
+static u8 data_jd9366ab_155[] = { 0x75, 0x80 };
+static u8 data_jd9366ab_156[] = { 0x76, 0x00 };
+static u8 data_jd9366ab_157[] = { 0x77, 0x05 };
+static u8 data_jd9366ab_158[] = { 0x78, 0x1b };
+static u8 data_jd9366ab_159[] = { 0x79, 0x00 };
+static u8 data_jd9366ab_160[] = { 0x7a, 0x00 };
+static u8 data_jd9366ab_161[] = { 0x7b, 0x00 };
+static u8 data_jd9366ab_162[] = { 0x7c, 0x00 };
+static u8 data_jd9366ab_163[] = { 0x7d, 0x03 };
+static u8 data_jd9366ab_164[] = { 0x7e, 0x7b };
+static u8 data_jd9366ab_165[] = { 0xe0, 0x01 };
+static u8 data_jd9366ab_166[] = { 0x0e, 0x01 };
+static u8 data_jd9366ab_167[] = { 0xe0, 0x03 };
+static u8 data_jd9366ab_168[] = { 0x98, 0x2f };
+static u8 data_jd9366ab_169[] = { 0xe0, 0x04 };
+static u8 data_jd9366ab_170[] = { 0x09, 0x10 };
+static u8 data_jd9366ab_171[] = { 0x2b, 0x2b };
+static u8 data_jd9366ab_172[] = { 0x2e, 0x44 };
+static u8 data_jd9366ab_173[] = { 0xe0, 0x00 };
+static u8 data_jd9366ab_174[] = { 0xe6, 0x02 };
+static u8 data_jd9366ab_175[] = { 0xe7, 0x06 };
+static u8 data_jd9366ab_176[] = { 0x11 };
+static u8 data_jd9366ab_177[] = { 0x29 };
+static u8 data_jd9366ab_178[] = { 0x35, 0x00 };
+const struct dsc_instr dsi_init_cmds_jd9366ab_800x1280[] = {
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_0 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_1 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_3 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_7 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_16 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_23 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_24 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_25 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_26 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_27 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_28 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_29 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_31 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_32 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_33 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_34 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_35 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_36 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_37 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_38 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_39 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_40 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_41 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_42 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_43 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_44 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_45 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_46 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_47 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_48 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_49 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_50 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_51 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_52 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_53 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_54 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_55 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_56 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_57 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_58 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_59 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_60 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_61 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_62 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_63 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_64 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_65 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_66 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_67 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_68 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_69 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_70 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_71 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_72 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_73 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_74 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_75 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_76 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_77 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_78 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_79 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_80 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_81 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_82 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_83 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_84 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_85 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_86 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_87 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_88 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_89 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_90 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_91 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_92 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_93 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_94 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_95 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_96 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_97 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_98 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_99 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_100 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_101 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_102 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_103 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_104 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_105 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_106 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_107 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_108 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_109 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_110 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_111 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_112 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_113 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_114 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_115 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_116 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_117 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_118 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_119 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_120 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_121 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_122 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_123 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_124 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_125 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_126 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_127 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_128 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_129 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_130 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_131 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_132 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_133 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_134 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_135 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_136 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_137 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_138 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_139 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_140 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_141 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_142 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_143 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_144 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_145 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_146 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_147 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_148 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_149 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_150 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_151 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_152 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_153 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_154 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_155 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_156 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_157 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_158 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_159 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_160 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_161 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_162 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_163 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_164 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_165 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_166 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_167 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_168 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_169 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_170 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_171 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_172 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_173 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_174 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_175 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_jd9366ab_176 },
+	{.delay = 5, .data_type = 0x05, .size = 1, .data = data_jd9366ab_177 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_jd9366ab_178 }
+};
+
+#else
+#error "_MIPI_TX_PARAM_JD9366AB_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_JD9366AB_H_
diff --git a/include/cvitek/cvi_panels/dsi_nt35521.h b/include/cvitek/cvi_panels/dsi_nt35521.h
new file mode 100644
index 000000000..7b99e77ba
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_nt35521.h
@@ -0,0 +1,206 @@
+#ifndef _MIPI_TX_PARAM_NT35521_H_
+#define _MIPI_TX_PARAM_NT35521_H_
+
+#include <cvi_mipi.h>
+
+const struct combo_dev_cfg_s dev_cfg_nt35521_800x1280 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_CLK, MIPI_TX_LANE_0, MIPI_TX_LANE_2, MIPI_TX_LANE_3, MIPI_TX_LANE_1},
+	.lane_pn_swap = {false, false, false, false, false},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 80,
+		.vid_hbp_pixels = 80,
+		.vid_hfp_pixels = 168,
+		.vid_hline_pixels = 800,
+		.vid_vsa_lines = 6,
+		.vid_vbp_lines = 40,
+		.vid_vfp_lines = 18,
+		.vid_active_lines = 1280,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 90962,
+};
+
+const struct hs_settle_s hs_timing_cfg_nt35521_800x1280 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+//=====================Page 0 relative===================
+static u8 data_nt35521_0[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00 };
+static u8 data_nt35521_1[] = { 0xb1, 0x6c, 0x01 };
+static u8 data_nt35521_2[] = { 0xb5, 0xc8, 0x00 };
+static u8 data_nt35521_3[] = { 0xbc, 0x00 };
+static u8 data_nt35521_4[] = { 0xbd, 0x96, 0xb0, 0x0c, 0x08, 0x01 };
+static u8 data_nt35521_5[] = { 0xc8, 0x80 };
+//=====================Page 1 relative===================
+static u8 data_nt35521_6[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01 };
+static u8 data_nt35521_7[] = { 0xb3, 0x26 };
+static u8 data_nt35521_8[] = { 0xb4, 0x0f };
+static u8 data_nt35521_9[] = { 0xbb, 0x15 };
+static u8 data_nt35521_10[] = { 0xbc, 0xa8 };
+static u8 data_nt35521_11[] = { 0xbd, 0xa8 };
+static u8 data_nt35521_12[] = { 0xbe, 0x28 };
+//=====================Page 2 relative===================
+static u8 data_nt35521_13[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02 };
+static u8 data_nt35521_14[] = { 0xee, 0x01 };
+static u8 data_nt35521_15[] = {
+	0xb0, 0x00, 0x00, 0x00, 0x13, 0x00, 0x33, 0x00, 0x4f, 0x00,
+	0x65, 0x00, 0x79, 0x00, 0x8b, 0x00, 0x9c
+};
+
+static u8 data_nt35521_16[] = {
+	0xb1, 0x00, 0xac, 0x00, 0xe0, 0x01, 0x09, 0x01, 0x4b, 0x01,
+	0x80, 0x01, 0xd1, 0x02, 0x13, 0x02, 0x14
+};
+
+static u8 data_nt35521_17[] = {
+	0xb2, 0x02, 0x50, 0x02, 0x91, 0x02, 0xba, 0x02, 0xf0, 0x03,
+	0x12, 0x03, 0x3d, 0x03, 0x4a, 0x03, 0x57
+};
+
+static u8 data_nt35521_18[] = {
+	0xb3, 0x03, 0x5f, 0x03, 0x74, 0x03, 0x8f, 0x03, 0xb8, 0x03,
+	0xfc, 0x03, 0xff
+};
+
+static u8 data_nt35521_19[] = {
+	0xe9, 0x52, 0x60, 0x63, 0x11, 0x21, 0x52, 0x60, 0x63, 0x11,
+	0x21
+};
+
+static u8 data_nt35521_20[] = {
+	0xea, 0x52, 0x60, 0x63, 0x11, 0x21, 0x52, 0x60, 0x63, 0x11,
+	0x21
+};
+
+static u8 data_nt35521_21[] = {
+	0xeb, 0x52, 0x60, 0x63, 0x11, 0x21, 0x52, 0x60, 0x63, 0x11,
+	0x21
+};
+
+//=====================Page 3 relative===================
+static u8 data_nt35521_22[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03 };
+static u8 data_nt35521_23[] = { 0xb2, 0x00, 0x0b, 0x08, 0x00, 0x00 };
+static u8 data_nt35521_24[] = { 0xb3, 0x00, 0x09, 0x06, 0x00, 0x00 };
+static u8 data_nt35521_25[] = { 0xba, 0x44, 0x00, 0x00, 0x10 };
+static u8 data_nt35521_26[] = { 0xc0, 0x00, 0x34, 0x00 };
+static u8 data_nt35521_27[] = { 0xc1, 0x00, 0x00, 0x34 };
+//=====================Page 4 relative===================
+static u8 data_nt35521_28[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x04 };
+static u8 data_nt35521_29[] = { 0xb1, 0x03, 0x02, 0x00, 0x15, 0x16 };
+//=====================Page 5 relative===================
+static u8 data_nt35521_30[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05 };
+static u8 data_nt35521_31[] = { 0xb0, 0x06 };
+static u8 data_nt35521_32[] = { 0xb2, 0x06, 0x00 };
+static u8 data_nt35521_33[] = { 0xb3, 0x0e, 0x00, 0x00, 0x00, 0x00 };
+static u8 data_nt35521_34[] = { 0xb4, 0x06, 0x00, 0x00, 0x00, 0x00 };
+static u8 data_nt35521_35[] = { 0xb7, 0x06, 0x00, 0x00 };
+static u8 data_nt35521_36[] = { 0xbc, 0x00, 0x00, 0x00, 0x02 };
+static u8 data_nt35521_37[] = { 0xbd, 0x01, 0x03, 0x00, 0x03, 0x03 };
+static u8 data_nt35521_38[] = { 0xc0, 0x07, 0x70 };
+static u8 data_nt35521_39[] = { 0xc4, 0x00, 0x00, 0x3c };
+static u8 data_nt35521_40[] = { 0xc5, 0x00, 0x00, 0x3c };
+static u8 data_nt35521_41[] = { 0xd1, 0x00, 0x05, 0x01, 0x00, 0x00 };
+static u8 data_nt35521_42[] = { 0xe3, 0x84 };
+static u8 data_nt35521_43[] = { 0xe5, 0x1a };
+static u8 data_nt35521_44[] = { 0xe6, 0x1a };
+static u8 data_nt35521_45[] = { 0xe8, 0x1a };
+static u8 data_nt35521_46[] = { 0xe9, 0x1a };
+static u8 data_nt35521_47[] = { 0xea, 0x1a };
+//=====================Page 6 relative===================
+static u8 data_nt35521_48[] = { 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x06 };
+static u8 data_nt35521_49[] = { 0xb0, 0x30, 0x31, 0x2c, 0x2d, 0x14 };
+static u8 data_nt35521_50[] = { 0xb1, 0x16, 0x10, 0x12, 0x00, 0x35 };
+static u8 data_nt35521_51[] = { 0xb2, 0x35, 0x35, 0x35, 0x02, 0x31 };
+static u8 data_nt35521_52[] = { 0xb3, 0x31, 0x31, 0x35, 0x35, 0x35 };
+static u8 data_nt35521_53[] = { 0xb4, 0x35, 0x35, 0x35, 0x31, 0x31 };
+static u8 data_nt35521_54[] = { 0xb5, 0x31, 0x03, 0x35, 0x35, 0x35 };
+static u8 data_nt35521_55[] = { 0xb6, 0x35, 0x01, 0x13, 0x11, 0x17 };
+static u8 data_nt35521_56[] = { 0xb7, 0x15, 0x2d, 0x2c, 0x31, 0x30 };
+static u8 data_nt35521_57[] = { 0xf0, 0x55, 0xaa, 0x52, 0x00, 0x00 };
+static u8 data_nt35521_58[] = { 0x35, 0x00 };
+static u8 data_nt35521_59[] = { 0x11 };
+static u8 data_nt35521_60[] = { 0x29 };
+#ifdef _MIPI_TX_BIST_MODE
+//=====================BIST relative===================
+static u8 data_nt35521_61[] = { 0x10 };
+static u8 data_nt35521_62[] = { 0xF0, 0x55, 0xAA, 0x52, 0x08, 0x00 };
+static u8 data_nt35521_63[] = { 0xEE, 0x87, 0x78, 0xff, 0xff };
+#endif
+
+const struct dsc_instr dsi_init_cmds_nt35521_800x1280[] = {
+#ifdef _MIPI_TX_BIST_MODE
+	//=====================BIST relative===================
+	{ .delay = 0, .data_type = 0x05, .size = 1, .data = data_nt35521_61 },
+	{ .delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_62 },
+	{ .delay = 0, .data_type = 0x29, .size = 5, .data = data_nt35521_63 },
+#else
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_0 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_nt35521_1 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_nt35521_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_3 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_5 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_7 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_12 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_14 },
+	{.delay = 0, .data_type = 0x29, .size = 17, .data = data_nt35521_15 },
+	{.delay = 0, .data_type = 0x29, .size = 17, .data = data_nt35521_16 },
+	{.delay = 0, .data_type = 0x29, .size = 17, .data = data_nt35521_17 },
+	{.delay = 0, .data_type = 0x29, .size = 13, .data = data_nt35521_18 },
+	{.delay = 0, .data_type = 0x29, .size = 11, .data = data_nt35521_19 },
+	{.delay = 0, .data_type = 0x29, .size = 11, .data = data_nt35521_20 },
+	{.delay = 0, .data_type = 0x29, .size = 11, .data = data_nt35521_21 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_22 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_23 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_24 },
+	{.delay = 0, .data_type = 0x29, .size = 5, .data = data_nt35521_25 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_nt35521_26 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_nt35521_27 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_28 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_29 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_31 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_nt35521_32 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_33 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_34 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_nt35521_35 },
+	{.delay = 0, .data_type = 0x29, .size = 5, .data = data_nt35521_36 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_37 },
+	{.delay = 0, .data_type = 0x29, .size = 3, .data = data_nt35521_38 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_nt35521_39 },
+	{.delay = 0, .data_type = 0x29, .size = 4, .data = data_nt35521_40 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_41 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_42 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_43 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_44 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_45 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_46 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_47 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_48 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_49 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_50 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_51 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_52 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_53 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_54 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_55 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_56 },
+	{.delay = 0, .data_type = 0x29, .size = 6, .data = data_nt35521_57 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_nt35521_58 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_nt35521_59 },
+	{.delay = 20, .data_type = 0x05, .size = 1, .data = data_nt35521_60 }
+#endif
+};
+
+#else
+#error "_MIPI_TX_PARAM_NT35521_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_NT35521_H_
diff --git a/include/cvitek/cvi_panels/dsi_ota7290b.h b/include/cvitek/cvi_panels/dsi_ota7290b.h
new file mode 100644
index 000000000..52098b159
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_ota7290b.h
@@ -0,0 +1,547 @@
+#ifndef _MIPI_TX_PARAM_OTA7290B_H_
+#define _MIPI_TX_PARAM_OTA7290B_H_
+
+#include <cvi_mipi.h>
+
+// Not support BTA
+const struct combo_dev_cfg_s dev_cfg_ota7290b_320x1280 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_0, MIPI_TX_LANE_1, MIPI_TX_LANE_CLK, MIPI_TX_LANE_2, MIPI_TX_LANE_3},
+	.lane_pn_swap = {false, false, false, false, false},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 30,
+		.vid_hbp_pixels = 50,
+		.vid_hfp_pixels = 150,
+		.vid_hline_pixels = 320,
+		.vid_vsa_lines = 20,
+		.vid_vbp_lines = 30,
+		.vid_vfp_lines = 150,
+		.vid_active_lines = 1280,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 52910,
+};
+
+const struct hs_settle_s hs_timing_cfg_ota7290b_320x1280 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_ota7290b_0[] = { 0xb0, 0x5a };
+static u8 data_ota7290b_1[] = { 0xb1, 0x00 };
+static u8 data_ota7290b_2[] = { 0x89, 0x01 };
+#ifdef _MIPI_TX_BIST_MODE_
+static u8 data_ota7290b_3[] = { 0x91, 0x16 };
+#else
+static u8 data_ota7290b_3[] = { 0x91, 0x17 };
+#endif
+static u8 data_ota7290b_4[] = { 0xb1, 0x03 };
+static u8 data_ota7290b_5[] = { 0x2c, 0x28 };
+static u8 data_ota7290b_6[] = { 0x00, 0xf1 };
+static u8 data_ota7290b_7[] = { 0x01, 0x18 };
+static u8 data_ota7290b_8[] = { 0x02, 0x00 };
+static u8 data_ota7290b_9[] = { 0x03, 0x00 };
+static u8 data_ota7290b_10[] = { 0x04, 0x00 };
+static u8 data_ota7290b_11[] = { 0x05, 0x00 };
+static u8 data_ota7290b_12[] = { 0x06, 0x00 };
+static u8 data_ota7290b_13[] = { 0x07, 0x00 };
+static u8 data_ota7290b_14[] = { 0x08, 0x00 };
+static u8 data_ota7290b_15[] = { 0x09, 0x00 };
+static u8 data_ota7290b_16[] = { 0x0a, 0x01 };
+static u8 data_ota7290b_17[] = { 0x0b, 0x01 };
+static u8 data_ota7290b_18[] = { 0x0c, 0x00 };
+static u8 data_ota7290b_19[] = { 0x0d, 0x00 };
+static u8 data_ota7290b_20[] = { 0x0e, 0x24 };
+static u8 data_ota7290b_21[] = { 0x0f, 0x1c };
+static u8 data_ota7290b_22[] = { 0x10, 0xc9 };
+static u8 data_ota7290b_23[] = { 0x11, 0x60 };
+static u8 data_ota7290b_24[] = { 0x12, 0x70 };
+static u8 data_ota7290b_25[] = { 0x13, 0x01 };
+static u8 data_ota7290b_26[] = { 0x14, 0xe7 };
+static u8 data_ota7290b_27[] = { 0x15, 0xff };
+static u8 data_ota7290b_28[] = { 0x16, 0x3d };
+static u8 data_ota7290b_29[] = { 0x17, 0x0e };
+static u8 data_ota7290b_30[] = { 0x18, 0x01 };
+static u8 data_ota7290b_31[] = { 0x19, 0x00 };
+static u8 data_ota7290b_32[] = { 0x1a, 0x00 };
+static u8 data_ota7290b_33[] = { 0x1b, 0xfc };
+static u8 data_ota7290b_34[] = { 0x1c, 0x0b };
+static u8 data_ota7290b_35[] = { 0x1d, 0xa0 };
+static u8 data_ota7290b_36[] = { 0x1e, 0x03 };
+static u8 data_ota7290b_37[] = { 0x1f, 0x04 };
+static u8 data_ota7290b_38[] = { 0x20, 0x0c };
+static u8 data_ota7290b_39[] = { 0x21, 0x00 };
+static u8 data_ota7290b_40[] = { 0x22, 0x04 };
+static u8 data_ota7290b_41[] = { 0x23, 0x81 };
+static u8 data_ota7290b_42[] = { 0x24, 0x1f };
+static u8 data_ota7290b_43[] = { 0x25, 0x10 };
+static u8 data_ota7290b_44[] = { 0x26, 0x9b };
+static u8 data_ota7290b_45[] = { 0x2d, 0x01 };
+static u8 data_ota7290b_46[] = { 0x2e, 0x84 };
+static u8 data_ota7290b_47[] = { 0x2f, 0x00 };
+static u8 data_ota7290b_48[] = { 0x30, 0x02 };
+static u8 data_ota7290b_49[] = { 0x31, 0x08 };
+static u8 data_ota7290b_50[] = { 0x32, 0x01 };
+static u8 data_ota7290b_51[] = { 0x33, 0x1c };
+static u8 data_ota7290b_52[] = { 0x34, 0x40 };
+static u8 data_ota7290b_53[] = { 0x35, 0xff };
+static u8 data_ota7290b_54[] = { 0x36, 0xff };
+static u8 data_ota7290b_55[] = { 0x37, 0xff };
+static u8 data_ota7290b_56[] = { 0x38, 0xff };
+static u8 data_ota7290b_57[] = { 0x39, 0xff };
+static u8 data_ota7290b_58[] = { 0x3a, 0x05 };
+static u8 data_ota7290b_59[] = { 0x3b, 0x00 };
+static u8 data_ota7290b_60[] = { 0x3c, 0x00 };
+static u8 data_ota7290b_61[] = { 0x3d, 0x00 };
+static u8 data_ota7290b_62[] = { 0x3e, 0x0f };
+static u8 data_ota7290b_63[] = { 0x3f, 0x8c };
+static u8 data_ota7290b_64[] = { 0x40, 0x2a };
+static u8 data_ota7290b_65[] = { 0x41, 0xfc };
+static u8 data_ota7290b_66[] = { 0x42, 0x01 };
+static u8 data_ota7290b_67[] = { 0x43, 0x40 };
+static u8 data_ota7290b_68[] = { 0x44, 0x05 };
+static u8 data_ota7290b_69[] = { 0x45, 0xe8 };
+static u8 data_ota7290b_70[] = { 0x46, 0x16 };
+static u8 data_ota7290b_71[] = { 0x47, 0x00 };
+static u8 data_ota7290b_72[] = { 0x48, 0x00 };
+static u8 data_ota7290b_73[] = { 0x49, 0x88 };
+static u8 data_ota7290b_74[] = { 0x4a, 0x08 };
+static u8 data_ota7290b_75[] = { 0x4b, 0x05 };
+static u8 data_ota7290b_76[] = { 0x4c, 0x03 };
+static u8 data_ota7290b_77[] = { 0x4d, 0xd0 };
+static u8 data_ota7290b_78[] = { 0x4e, 0x13 };
+static u8 data_ota7290b_79[] = { 0x4f, 0xff };
+static u8 data_ota7290b_80[] = { 0x50, 0x0a };
+static u8 data_ota7290b_81[] = { 0x51, 0x53 };
+static u8 data_ota7290b_82[] = { 0x52, 0x26 };
+static u8 data_ota7290b_83[] = { 0x53, 0x22 };
+static u8 data_ota7290b_84[] = { 0x54, 0x09 };
+static u8 data_ota7290b_85[] = { 0x55, 0x22 };
+static u8 data_ota7290b_86[] = { 0x56, 0x00 };
+static u8 data_ota7290b_87[] = { 0x57, 0x1c };
+static u8 data_ota7290b_88[] = { 0x58, 0x03 };
+static u8 data_ota7290b_89[] = { 0x59, 0x3f };
+static u8 data_ota7290b_90[] = { 0x5a, 0x28 };
+static u8 data_ota7290b_91[] = { 0x5b, 0x01 };
+static u8 data_ota7290b_92[] = { 0x5c, 0xcc };
+static u8 data_ota7290b_93[] = { 0x5d, 0x21 };
+static u8 data_ota7290b_94[] = { 0x5e, 0x84 };
+static u8 data_ota7290b_95[] = { 0x5f, 0x84 };
+static u8 data_ota7290b_96[] = { 0x60, 0x8e };
+static u8 data_ota7290b_97[] = { 0x61, 0x89 };
+static u8 data_ota7290b_98[] = { 0x62, 0xf0 };
+static u8 data_ota7290b_99[] = { 0x63, 0xb9 };
+static u8 data_ota7290b_100[] = { 0x64, 0xc6 };
+static u8 data_ota7290b_101[] = { 0x65, 0x96 };
+static u8 data_ota7290b_102[] = { 0x66, 0x0a };
+static u8 data_ota7290b_103[] = { 0x67, 0x62 };
+static u8 data_ota7290b_104[] = { 0x68, 0x90 };
+static u8 data_ota7290b_105[] = { 0x69, 0x12 };
+static u8 data_ota7290b_106[] = { 0x6a, 0x42 };
+static u8 data_ota7290b_107[] = { 0x6b, 0x48 };
+static u8 data_ota7290b_108[] = { 0x6c, 0xe8 };
+static u8 data_ota7290b_109[] = { 0x6d, 0x98 };
+static u8 data_ota7290b_110[] = { 0x6e, 0x08 };
+static u8 data_ota7290b_111[] = { 0x6f, 0x9f };
+static u8 data_ota7290b_112[] = { 0x70, 0x6b };
+static u8 data_ota7290b_113[] = { 0x71, 0x6c };
+static u8 data_ota7290b_114[] = { 0x72, 0xa9 };
+static u8 data_ota7290b_115[] = { 0x73, 0x20 };
+static u8 data_ota7290b_116[] = { 0x74, 0x06 };
+static u8 data_ota7290b_117[] = { 0x75, 0x29 };
+static u8 data_ota7290b_118[] = { 0x76, 0x00 };
+static u8 data_ota7290b_119[] = { 0x77, 0x00 };
+static u8 data_ota7290b_120[] = { 0x78, 0x0f };
+static u8 data_ota7290b_121[] = { 0x79, 0xe0 };
+static u8 data_ota7290b_122[] = { 0x7a, 0x01 };
+static u8 data_ota7290b_123[] = { 0x7b, 0xff };
+static u8 data_ota7290b_124[] = { 0x7c, 0xff };
+static u8 data_ota7290b_125[] = { 0x7d, 0xff };
+static u8 data_ota7290b_126[] = { 0x7e, 0x4f };
+static u8 data_ota7290b_127[] = { 0x7f, 0xfe };
+static u8 data_ota7290b_128[] = { 0xb1, 0x02 };
+static u8 data_ota7290b_129[] = { 0x00, 0xff };
+static u8 data_ota7290b_130[] = { 0x01, 0x05 };
+static u8 data_ota7290b_131[] = { 0x02, 0xa0 };
+static u8 data_ota7290b_132[] = { 0x03, 0x00 };
+static u8 data_ota7290b_133[] = { 0x04, 0x54 };
+static u8 data_ota7290b_134[] = { 0x05, 0x38 };
+static u8 data_ota7290b_135[] = { 0x06, 0xa0 };
+static u8 data_ota7290b_136[] = { 0x07, 0x0a };
+static u8 data_ota7290b_137[] = { 0x08, 0xc0 };
+static u8 data_ota7290b_138[] = { 0x09, 0x00 };
+static u8 data_ota7290b_139[] = { 0x0a, 0x00 };
+static u8 data_ota7290b_140[] = { 0x0b, 0x14 };
+static u8 data_ota7290b_141[] = { 0x0c, 0xe6 };
+static u8 data_ota7290b_142[] = { 0x0d, 0x0d };
+static u8 data_ota7290b_143[] = { 0x0f, 0x08 };
+static u8 data_ota7290b_144[] = { 0x10, 0x79 };
+static u8 data_ota7290b_145[] = { 0x11, 0x38 };
+static u8 data_ota7290b_146[] = { 0x12, 0x73 };
+static u8 data_ota7290b_147[] = { 0x13, 0xb3 };
+static u8 data_ota7290b_148[] = { 0x14, 0x29 };
+static u8 data_ota7290b_149[] = { 0x15, 0x80 };
+static u8 data_ota7290b_150[] = { 0x16, 0x07 };
+static u8 data_ota7290b_151[] = { 0x17, 0x8a };
+static u8 data_ota7290b_152[] = { 0x18, 0x8d };
+static u8 data_ota7290b_153[] = { 0x19, 0xbf };
+static u8 data_ota7290b_154[] = { 0x1a, 0x69 };
+static u8 data_ota7290b_155[] = { 0x1b, 0x0e };
+static u8 data_ota7290b_156[] = { 0x1c, 0xff };
+static u8 data_ota7290b_157[] = { 0x1d, 0xff };
+static u8 data_ota7290b_158[] = { 0x1e, 0xff };
+static u8 data_ota7290b_159[] = { 0x1f, 0xff };
+static u8 data_ota7290b_160[] = { 0x20, 0xff };
+static u8 data_ota7290b_161[] = { 0x21, 0xff };
+static u8 data_ota7290b_162[] = { 0x22, 0xff };
+static u8 data_ota7290b_163[] = { 0x23, 0xff };
+static u8 data_ota7290b_164[] = { 0x24, 0xff };
+static u8 data_ota7290b_165[] = { 0x25, 0xff };
+static u8 data_ota7290b_166[] = { 0x26, 0xff };
+static u8 data_ota7290b_167[] = { 0x27, 0x1f };
+static u8 data_ota7290b_168[] = { 0x28, 0xff };
+static u8 data_ota7290b_169[] = { 0x29, 0xff };
+static u8 data_ota7290b_170[] = { 0x2a, 0xff };
+static u8 data_ota7290b_171[] = { 0x2b, 0xff };
+static u8 data_ota7290b_172[] = { 0x2c, 0xff };
+static u8 data_ota7290b_173[] = { 0x2d, 0x07 };
+static u8 data_ota7290b_174[] = { 0x33, 0x06 };
+static u8 data_ota7290b_175[] = { 0x35, 0x7e };
+static u8 data_ota7290b_176[] = { 0x36, 0x06 };
+static u8 data_ota7290b_177[] = { 0x38, 0x7e };
+static u8 data_ota7290b_178[] = { 0x3a, 0x80 };
+static u8 data_ota7290b_179[] = { 0x3b, 0x01 };
+static u8 data_ota7290b_180[] = { 0x3c, 0x00 };
+static u8 data_ota7290b_181[] = { 0x3d, 0x2a };
+static u8 data_ota7290b_182[] = { 0x3e, 0x00 };
+static u8 data_ota7290b_183[] = { 0x3f, 0x40 };
+static u8 data_ota7290b_184[] = { 0x40, 0x05 };
+static u8 data_ota7290b_185[] = { 0x41, 0x00 };
+static u8 data_ota7290b_186[] = { 0x42, 0xa8 };
+static u8 data_ota7290b_187[] = { 0x43, 0x00 };
+static u8 data_ota7290b_188[] = { 0x44, 0x00 };
+static u8 data_ota7290b_189[] = { 0x45, 0x05 };
+static u8 data_ota7290b_190[] = { 0x46, 0x00 };
+static u8 data_ota7290b_191[] = { 0x47, 0x00 };
+static u8 data_ota7290b_192[] = { 0x48, 0x9b };
+static u8 data_ota7290b_193[] = { 0x49, 0xd2 };
+static u8 data_ota7290b_194[] = { 0x4a, 0x81 };
+static u8 data_ota7290b_195[] = { 0x4b, 0x02 };
+static u8 data_ota7290b_196[] = { 0x4c, 0x15 };
+static u8 data_ota7290b_197[] = { 0x4d, 0xc0 };
+static u8 data_ota7290b_198[] = { 0x4e, 0x0f };
+static u8 data_ota7290b_199[] = { 0x4f, 0x61 };
+static u8 data_ota7290b_200[] = { 0x50, 0x78 };
+static u8 data_ota7290b_201[] = { 0x51, 0x7a };
+static u8 data_ota7290b_202[] = { 0x52, 0x34 };
+static u8 data_ota7290b_203[] = { 0x53, 0x99 };
+static u8 data_ota7290b_204[] = { 0x54, 0xa2 };
+static u8 data_ota7290b_205[] = { 0x55, 0x02 };
+static u8 data_ota7290b_206[] = { 0x56, 0x14 };
+static u8 data_ota7290b_207[] = { 0x57, 0xb8 };
+static u8 data_ota7290b_208[] = { 0x58, 0xdc };
+static u8 data_ota7290b_209[] = { 0x59, 0x34 };
+static u8 data_ota7290b_210[] = { 0x5a, 0x1e };
+static u8 data_ota7290b_211[] = { 0x5b, 0x8f };
+static u8 data_ota7290b_212[] = { 0x5c, 0xc7 };
+static u8 data_ota7290b_213[] = { 0x5d, 0xe3 };
+static u8 data_ota7290b_214[] = { 0x5e, 0xf1 };
+static u8 data_ota7290b_215[] = { 0x5f, 0x78 };
+static u8 data_ota7290b_216[] = { 0x60, 0x3c };
+static u8 data_ota7290b_217[] = { 0x61, 0x36 };
+static u8 data_ota7290b_218[] = { 0x62, 0x1e };
+static u8 data_ota7290b_219[] = { 0x63, 0x1b };
+static u8 data_ota7290b_220[] = { 0x64, 0x8f };
+static u8 data_ota7290b_221[] = { 0x65, 0xc7 };
+static u8 data_ota7290b_222[] = { 0x66, 0xe3 };
+static u8 data_ota7290b_223[] = { 0x67, 0x31 };
+static u8 data_ota7290b_224[] = { 0x68, 0x0c };
+static u8 data_ota7290b_225[] = { 0x69, 0x89 };
+static u8 data_ota7290b_226[] = { 0x6a, 0x30 };
+static u8 data_ota7290b_227[] = { 0x6b, 0x8c };
+static u8 data_ota7290b_228[] = { 0x6c, 0x8d };
+static u8 data_ota7290b_229[] = { 0x6d, 0x8d };
+static u8 data_ota7290b_230[] = { 0x6e, 0x8d };
+static u8 data_ota7290b_231[] = { 0x6f, 0x8d };
+static u8 data_ota7290b_232[] = { 0x70, 0xc7 };
+static u8 data_ota7290b_233[] = { 0x71, 0xe3 };
+static u8 data_ota7290b_234[] = { 0x72, 0x31 };
+static u8 data_ota7290b_235[] = { 0x73, 0x00 };
+static u8 data_ota7290b_236[] = { 0x74, 0x00 };
+static u8 data_ota7290b_237[] = { 0x75, 0x00 };
+static u8 data_ota7290b_238[] = { 0x76, 0x00 };
+static u8 data_ota7290b_239[] = { 0x77, 0x00 };
+static u8 data_ota7290b_240[] = { 0x78, 0x00 };
+static u8 data_ota7290b_241[] = { 0x79, 0x00 };
+static u8 data_ota7290b_242[] = { 0x7a, 0xc6 };
+static u8 data_ota7290b_243[] = { 0x7b, 0xc6 };
+static u8 data_ota7290b_244[] = { 0x7c, 0xc6 };
+static u8 data_ota7290b_245[] = { 0x7d, 0xc6 };
+static u8 data_ota7290b_246[] = { 0x7e, 0xc6 };
+static u8 data_ota7290b_247[] = { 0x7f, 0xe3 };
+static u8 data_ota7290b_248[] = { 0x0b, 0x00 };
+static u8 data_ota7290b_249[] = { 0xb1, 0x03 };
+static u8 data_ota7290b_250[] = { 0x2c, 0x2c };
+static u8 data_ota7290b_251[] = { 0xb1, 0x00 };
+static u8 data_ota7290b_252[] = { 0x89, 0x03 };
+const struct dsc_instr dsi_init_cmds_ota7290b_320x1280[] = {
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_0 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_3 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_7 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_16 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_23 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_24 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_25 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_26 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_27 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_28 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_29 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_31 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_32 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_33 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_34 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_35 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_36 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_37 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_38 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_39 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_40 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_41 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_42 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_43 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_44 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_45 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_46 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_47 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_48 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_49 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_50 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_51 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_52 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_53 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_54 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_55 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_56 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_57 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_58 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_59 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_60 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_61 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_62 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_63 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_64 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_65 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_66 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_67 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_68 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_69 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_70 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_71 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_72 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_73 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_74 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_75 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_76 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_77 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_78 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_79 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_80 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_81 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_82 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_83 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_84 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_85 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_86 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_87 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_88 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_89 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_90 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_91 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_92 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_93 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_94 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_95 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_96 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_97 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_98 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_99 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_100 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_101 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_102 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_103 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_104 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_105 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_106 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_107 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_108 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_109 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_110 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_111 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_112 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_113 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_114 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_115 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_116 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_117 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_118 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_119 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_120 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_121 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_122 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_123 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_124 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_125 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_126 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_127 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_128 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_129 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_130 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_131 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_132 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_133 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_134 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_135 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_136 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_137 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_138 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_139 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_140 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_141 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_142 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_143 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_144 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_145 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_146 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_147 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_148 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_149 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_150 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_151 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_152 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_153 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_154 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_155 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_156 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_157 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_158 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_159 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_160 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_161 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_162 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_163 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_164 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_165 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_166 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_167 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_168 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_169 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_170 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_171 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_172 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_173 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_174 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_175 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_176 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_177 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_178 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_179 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_180 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_181 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_182 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_183 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_184 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_185 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_186 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_187 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_188 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_189 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_190 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_191 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_192 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_193 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_194 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_195 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_196 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_197 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_198 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_199 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_200 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_201 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_202 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_203 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_204 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_205 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_206 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_207 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_208 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_209 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_210 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_211 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_212 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_213 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_214 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_215 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_216 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_217 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_218 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_219 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_220 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_221 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_222 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_223 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_224 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_225 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_226 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_227 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_228 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_229 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_230 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_231 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_232 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_233 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_234 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_235 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_236 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_237 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_238 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_239 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_240 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_241 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_242 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_243 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_244 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_245 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_246 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_247 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_248 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_249 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_250 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_251 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_252 }
+};
+
+#else
+#error "_MIPI_TX_PARAM_OTA7290B_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_OTA7290B_H_
+
diff --git a/include/cvitek/cvi_panels/dsi_ota7290b_1920.h b/include/cvitek/cvi_panels/dsi_ota7290b_1920.h
new file mode 100644
index 000000000..e547d10a0
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_ota7290b_1920.h
@@ -0,0 +1,553 @@
+#ifndef _MIPI_TX_PARAM_OTA7290B_1920_H_
+#define _MIPI_TX_PARAM_OTA7290B_1920_H_
+
+#include <cvi_mipi.h>
+
+// Not support BTA
+const struct combo_dev_cfg_s dev_cfg_ota7290b_440x1920 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_3, MIPI_TX_LANE_2, MIPI_TX_LANE_CLK, MIPI_TX_LANE_1, MIPI_TX_LANE_0},
+	.lane_pn_swap = {true, true, true, true, true},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = 30,
+		.vid_hbp_pixels = 50,
+		.vid_hfp_pixels = 150,
+		.vid_hline_pixels = 440,
+		.vid_vsa_lines = 20,
+		.vid_vbp_lines = 30,
+		.vid_vfp_lines = 150,
+		.vid_active_lines = 1920,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = true,
+	},
+	.pixel_clk = 85224,
+};
+
+const struct hs_settle_s hs_timing_cfg_ota7290b_440x1920 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_ota7290b_1920_0[] = { 0x11, 0x00 };
+static u8 data_ota7290b_1920_1[] = { 0xb0, 0x5a };
+static u8 data_ota7290b_1920_2[] = { 0xb0, 0x5a };
+static u8 data_ota7290b_1920_3[] = { 0xb1, 0x00 };
+static u8 data_ota7290b_1920_4[] = { 0x89, 0x01 };
+#ifdef _MIPI_TX_BIST_MODE_
+static u8 data_ota7290b_1920_5[] = { 0x91, 0x16 };
+#else
+static u8 data_ota7290b_1920_5[] = { 0x91, 0x17 };
+#endif
+static u8 data_ota7290b_1920_6[] = { 0xb1, 0x03 };
+static u8 data_ota7290b_1920_7[] = { 0x2c, 0x28 };
+static u8 data_ota7290b_1920_8[] = { 0x00, 0xb7 };
+static u8 data_ota7290b_1920_9[] = { 0x01, 0x1b };
+static u8 data_ota7290b_1920_10[] = { 0x02, 0x00 };
+static u8 data_ota7290b_1920_11[] = { 0x03, 0x00 };
+static u8 data_ota7290b_1920_12[] = { 0x04, 0x00 };
+static u8 data_ota7290b_1920_13[] = { 0x05, 0x00 };
+static u8 data_ota7290b_1920_14[] = { 0x06, 0x00 };
+static u8 data_ota7290b_1920_15[] = { 0x07, 0x00 };
+static u8 data_ota7290b_1920_16[] = { 0x08, 0x00 };
+static u8 data_ota7290b_1920_17[] = { 0x09, 0x00 };
+static u8 data_ota7290b_1920_18[] = { 0x0a, 0x01 };
+static u8 data_ota7290b_1920_19[] = { 0x0b, 0x3c };
+static u8 data_ota7290b_1920_20[] = { 0x0c, 0x00 };
+static u8 data_ota7290b_1920_21[] = { 0x0d, 0x00 };
+static u8 data_ota7290b_1920_22[] = { 0x0e, 0x24 };
+static u8 data_ota7290b_1920_23[] = { 0x0f, 0x1c };
+static u8 data_ota7290b_1920_24[] = { 0x10, 0xc9 };
+static u8 data_ota7290b_1920_25[] = { 0x11, 0x60 };
+static u8 data_ota7290b_1920_26[] = { 0x12, 0x70 };
+static u8 data_ota7290b_1920_27[] = { 0x13, 0x01 };
+static u8 data_ota7290b_1920_28[] = { 0x14, 0xe3 };
+static u8 data_ota7290b_1920_29[] = { 0x15, 0xff };
+static u8 data_ota7290b_1920_30[] = { 0x16, 0x3d };
+static u8 data_ota7290b_1920_31[] = { 0x17, 0x0e };
+static u8 data_ota7290b_1920_32[] = { 0x18, 0x01 };
+static u8 data_ota7290b_1920_33[] = { 0x19, 0x00 };
+static u8 data_ota7290b_1920_34[] = { 0x1a, 0x00 };
+static u8 data_ota7290b_1920_35[] = { 0x1b, 0xfc };
+static u8 data_ota7290b_1920_36[] = { 0x1c, 0x0b };
+static u8 data_ota7290b_1920_37[] = { 0x1d, 0xa0 };
+static u8 data_ota7290b_1920_38[] = { 0x1e, 0x03 };
+static u8 data_ota7290b_1920_39[] = { 0x1f, 0x04 };
+static u8 data_ota7290b_1920_40[] = { 0x20, 0x0c };
+static u8 data_ota7290b_1920_41[] = { 0x21, 0x00 };
+static u8 data_ota7290b_1920_42[] = { 0x22, 0x04 };
+static u8 data_ota7290b_1920_43[] = { 0x23, 0x81 };
+static u8 data_ota7290b_1920_44[] = { 0x24, 0x1f };
+static u8 data_ota7290b_1920_45[] = { 0x25, 0x10 };
+static u8 data_ota7290b_1920_46[] = { 0x26, 0x9b };
+static u8 data_ota7290b_1920_47[] = { 0x2d, 0x01 };
+static u8 data_ota7290b_1920_48[] = { 0x2e, 0x84 };
+static u8 data_ota7290b_1920_49[] = { 0x2f, 0x00 };
+static u8 data_ota7290b_1920_50[] = { 0x30, 0x02 };
+static u8 data_ota7290b_1920_51[] = { 0x31, 0x08 };
+static u8 data_ota7290b_1920_52[] = { 0x32, 0x01 };
+static u8 data_ota7290b_1920_53[] = { 0x33, 0x1c };
+static u8 data_ota7290b_1920_54[] = { 0x34, 0x70 };
+static u8 data_ota7290b_1920_55[] = { 0x35, 0xff };
+static u8 data_ota7290b_1920_56[] = { 0x36, 0xff };
+static u8 data_ota7290b_1920_57[] = { 0x37, 0xff };
+static u8 data_ota7290b_1920_58[] = { 0x38, 0xff };
+static u8 data_ota7290b_1920_59[] = { 0x39, 0xff };
+static u8 data_ota7290b_1920_60[] = { 0x3a, 0x05 };
+static u8 data_ota7290b_1920_61[] = { 0x3b, 0x00 };
+static u8 data_ota7290b_1920_62[] = { 0x3c, 0x00 };
+static u8 data_ota7290b_1920_63[] = { 0x3d, 0x00 };
+static u8 data_ota7290b_1920_64[] = { 0x3e, 0x0f };
+static u8 data_ota7290b_1920_65[] = { 0x3f, 0x8c };
+static u8 data_ota7290b_1920_66[] = { 0x40, 0x2a };
+static u8 data_ota7290b_1920_67[] = { 0x41, 0xfc };
+static u8 data_ota7290b_1920_68[] = { 0x42, 0x01 };
+static u8 data_ota7290b_1920_69[] = { 0x43, 0x40 };
+static u8 data_ota7290b_1920_70[] = { 0x44, 0x05 };
+static u8 data_ota7290b_1920_71[] = { 0x45, 0xe8 };
+static u8 data_ota7290b_1920_72[] = { 0x46, 0x16 };
+static u8 data_ota7290b_1920_73[] = { 0x47, 0x00 };
+static u8 data_ota7290b_1920_74[] = { 0x48, 0x00 };
+static u8 data_ota7290b_1920_75[] = { 0x49, 0x88 };
+static u8 data_ota7290b_1920_76[] = { 0x4a, 0x08 };
+static u8 data_ota7290b_1920_77[] = { 0x4b, 0x05 };
+static u8 data_ota7290b_1920_78[] = { 0x4c, 0x03 };
+static u8 data_ota7290b_1920_79[] = { 0x4d, 0xd0 };
+static u8 data_ota7290b_1920_80[] = { 0x4e, 0x13 };
+static u8 data_ota7290b_1920_81[] = { 0x4f, 0xff };
+static u8 data_ota7290b_1920_82[] = { 0x50, 0x0a };
+static u8 data_ota7290b_1920_83[] = { 0x51, 0x53 };
+static u8 data_ota7290b_1920_84[] = { 0x52, 0x26 };
+static u8 data_ota7290b_1920_85[] = { 0x53, 0x22 };
+static u8 data_ota7290b_1920_86[] = { 0x54, 0x09 };
+static u8 data_ota7290b_1920_87[] = { 0x55, 0x22 };
+static u8 data_ota7290b_1920_88[] = { 0x56, 0x00 };
+static u8 data_ota7290b_1920_89[] = { 0x57, 0x1c };
+static u8 data_ota7290b_1920_90[] = { 0x58, 0x03 };
+static u8 data_ota7290b_1920_91[] = { 0x59, 0x3f };
+static u8 data_ota7290b_1920_92[] = { 0x5a, 0x28 };
+static u8 data_ota7290b_1920_93[] = { 0x5b, 0x01 };
+static u8 data_ota7290b_1920_94[] = { 0x5c, 0xcc };
+static u8 data_ota7290b_1920_95[] = { 0x5d, 0x20 };
+static u8 data_ota7290b_1920_96[] = { 0x5e, 0xe8 };
+static u8 data_ota7290b_1920_97[] = { 0x5f, 0x1d };
+static u8 data_ota7290b_1920_98[] = { 0x60, 0xe1 };
+static u8 data_ota7290b_1920_99[] = { 0x61, 0x73 };
+static u8 data_ota7290b_1920_100[] = { 0x62, 0x8d };
+static u8 data_ota7290b_1920_101[] = { 0x63, 0x2d };
+static u8 data_ota7290b_1920_102[] = { 0x64, 0x25 };
+static u8 data_ota7290b_1920_103[] = { 0x65, 0x82 };
+static u8 data_ota7290b_1920_104[] = { 0x66, 0x09 };
+static u8 data_ota7290b_1920_105[] = { 0x67, 0x21 };
+static u8 data_ota7290b_1920_106[] = { 0x68, 0x84 };
+static u8 data_ota7290b_1920_107[] = { 0x69, 0x10 };
+static u8 data_ota7290b_1920_108[] = { 0x6a, 0x42 };
+static u8 data_ota7290b_1920_109[] = { 0x6b, 0x08 };
+static u8 data_ota7290b_1920_110[] = { 0x6c, 0x21 };
+static u8 data_ota7290b_1920_111[] = { 0x6d, 0x84 };
+static u8 data_ota7290b_1920_112[] = { 0x6e, 0x10 };
+static u8 data_ota7290b_1920_113[] = { 0x6f, 0x42 };
+static u8 data_ota7290b_1920_114[] = { 0x70, 0x08 };
+static u8 data_ota7290b_1920_115[] = { 0x71, 0x21 };
+static u8 data_ota7290b_1920_116[] = { 0x72, 0x84 };
+static u8 data_ota7290b_1920_117[] = { 0x73, 0x10 };
+static u8 data_ota7290b_1920_118[] = { 0x74, 0x42 };
+static u8 data_ota7290b_1920_119[] = { 0x75, 0x08 };
+static u8 data_ota7290b_1920_120[] = { 0x76, 0x00 };
+static u8 data_ota7290b_1920_121[] = { 0x77, 0x00 };
+static u8 data_ota7290b_1920_122[] = { 0x78, 0x0f };
+static u8 data_ota7290b_1920_123[] = { 0x79, 0xe0 };
+static u8 data_ota7290b_1920_124[] = { 0x7a, 0x01 };
+static u8 data_ota7290b_1920_125[] = { 0x7b, 0xff };
+static u8 data_ota7290b_1920_126[] = { 0x7c, 0xff };
+static u8 data_ota7290b_1920_127[] = { 0x7d, 0x0c };
+static u8 data_ota7290b_1920_128[] = { 0x7e, 0x41 };
+static u8 data_ota7290b_1920_129[] = { 0x7f, 0xfe };
+static u8 data_ota7290b_1920_130[] = { 0xb1, 0x02 };
+static u8 data_ota7290b_1920_131[] = { 0x00, 0xff };
+static u8 data_ota7290b_1920_132[] = { 0x01, 0x05 };
+static u8 data_ota7290b_1920_133[] = { 0x02, 0xdc };
+static u8 data_ota7290b_1920_134[] = { 0x03, 0x00 };
+static u8 data_ota7290b_1920_135[] = { 0x04, 0x3e };
+static u8 data_ota7290b_1920_136[] = { 0x05, 0x4e };
+static u8 data_ota7290b_1920_137[] = { 0x06, 0x90 };
+static u8 data_ota7290b_1920_138[] = { 0x07, 0x10 };
+static u8 data_ota7290b_1920_139[] = { 0x08, 0xc0 };
+static u8 data_ota7290b_1920_140[] = { 0x09, 0x01 };
+static u8 data_ota7290b_1920_141[] = { 0x0a, 0x00 };
+static u8 data_ota7290b_1920_142[] = { 0x0b, 0x14 };
+static u8 data_ota7290b_1920_143[] = { 0x0c, 0xe6 };
+static u8 data_ota7290b_1920_144[] = { 0x0d, 0x0d };
+static u8 data_ota7290b_1920_145[] = { 0x0f, 0x08 };
+static u8 data_ota7290b_1920_146[] = { 0x10, 0xf9 };
+static u8 data_ota7290b_1920_147[] = { 0x11, 0xf5 };
+static u8 data_ota7290b_1920_148[] = { 0x12, 0xa2 };
+static u8 data_ota7290b_1920_149[] = { 0x13, 0x03 };
+static u8 data_ota7290b_1920_150[] = { 0x14, 0x5e };
+static u8 data_ota7290b_1920_151[] = { 0x15, 0xcf };
+static u8 data_ota7290b_1920_152[] = { 0x16, 0x63 };
+static u8 data_ota7290b_1920_153[] = { 0x17, 0x01 };
+static u8 data_ota7290b_1920_154[] = { 0x18, 0xe9 };
+static u8 data_ota7290b_1920_155[] = { 0x19, 0x5e };
+static u8 data_ota7290b_1920_156[] = { 0x1a, 0x59 };
+static u8 data_ota7290b_1920_157[] = { 0x1b, 0x0e };
+static u8 data_ota7290b_1920_158[] = { 0x1c, 0xff };
+static u8 data_ota7290b_1920_159[] = { 0x1d, 0xff };
+static u8 data_ota7290b_1920_160[] = { 0x1e, 0xff };
+static u8 data_ota7290b_1920_161[] = { 0x1f, 0xff };
+static u8 data_ota7290b_1920_162[] = { 0x20, 0xff };
+static u8 data_ota7290b_1920_163[] = { 0x21, 0xff };
+static u8 data_ota7290b_1920_164[] = { 0x22, 0xff };
+static u8 data_ota7290b_1920_165[] = { 0x23, 0xff };
+static u8 data_ota7290b_1920_166[] = { 0x24, 0xff };
+static u8 data_ota7290b_1920_167[] = { 0x25, 0xff };
+static u8 data_ota7290b_1920_168[] = { 0x26, 0xff };
+static u8 data_ota7290b_1920_169[] = { 0x27, 0x1f };
+static u8 data_ota7290b_1920_170[] = { 0x28, 0xff };
+static u8 data_ota7290b_1920_171[] = { 0x29, 0xff };
+static u8 data_ota7290b_1920_172[] = { 0x2a, 0xff };
+static u8 data_ota7290b_1920_173[] = { 0x2b, 0xff };
+static u8 data_ota7290b_1920_174[] = { 0x2c, 0xff };
+static u8 data_ota7290b_1920_175[] = { 0x2d, 0x07 };
+static u8 data_ota7290b_1920_176[] = { 0x33, 0x00 };
+static u8 data_ota7290b_1920_177[] = { 0x35, 0x7e };
+static u8 data_ota7290b_1920_178[] = { 0x36, 0x00 };
+static u8 data_ota7290b_1920_179[] = { 0x38, 0x7e };
+static u8 data_ota7290b_1920_180[] = { 0x3a, 0x80 };
+static u8 data_ota7290b_1920_181[] = { 0x3b, 0x01 };
+static u8 data_ota7290b_1920_182[] = { 0x3c, 0xc0 };
+static u8 data_ota7290b_1920_183[] = { 0x3d, 0x2d };
+static u8 data_ota7290b_1920_184[] = { 0x3e, 0x00 };
+static u8 data_ota7290b_1920_185[] = { 0x3f, 0xb8 };
+static u8 data_ota7290b_1920_186[] = { 0x40, 0x05 };
+static u8 data_ota7290b_1920_187[] = { 0x41, 0x00 };
+static u8 data_ota7290b_1920_188[] = { 0x42, 0xb7 };
+static u8 data_ota7290b_1920_189[] = { 0x43, 0x00 };
+static u8 data_ota7290b_1920_190[] = { 0x44, 0xe0 };
+static u8 data_ota7290b_1920_191[] = { 0x45, 0x06 };
+static u8 data_ota7290b_1920_192[] = { 0x46, 0x00 };
+static u8 data_ota7290b_1920_193[] = { 0x47, 0x00 };
+static u8 data_ota7290b_1920_194[] = { 0x48, 0x9b };
+static u8 data_ota7290b_1920_195[] = { 0x49, 0xd2 };
+static u8 data_ota7290b_1920_196[] = { 0x4a, 0x71 };
+static u8 data_ota7290b_1920_197[] = { 0x4b, 0xe3 };
+static u8 data_ota7290b_1920_198[] = { 0x4c, 0x16 };
+static u8 data_ota7290b_1920_199[] = { 0x4d, 0xc0 };
+static u8 data_ota7290b_1920_200[] = { 0x4e, 0x0f };
+static u8 data_ota7290b_1920_201[] = { 0x4f, 0x61 };
+static u8 data_ota7290b_1920_202[] = { 0x50, 0x78 };
+static u8 data_ota7290b_1920_203[] = { 0x51, 0x7a };
+static u8 data_ota7290b_1920_204[] = { 0x52, 0x34 };
+static u8 data_ota7290b_1920_205[] = { 0x53, 0x99 };
+static u8 data_ota7290b_1920_206[] = { 0x54, 0xa2 };
+static u8 data_ota7290b_1920_207[] = { 0x55, 0x02 };
+static u8 data_ota7290b_1920_208[] = { 0x56, 0x24 };
+static u8 data_ota7290b_1920_209[] = { 0x57, 0xf8 };
+static u8 data_ota7290b_1920_210[] = { 0x58, 0xfc };
+static u8 data_ota7290b_1920_211[] = { 0x59, 0xf4 };
+static u8 data_ota7290b_1920_212[] = { 0x5a, 0xff };
+static u8 data_ota7290b_1920_213[] = { 0x5b, 0xff };
+static u8 data_ota7290b_1920_214[] = { 0x5c, 0xff };
+static u8 data_ota7290b_1920_215[] = { 0x5d, 0xb2 };
+static u8 data_ota7290b_1920_216[] = { 0x5e, 0xff };
+static u8 data_ota7290b_1920_217[] = { 0x5f, 0xff };
+static u8 data_ota7290b_1920_218[] = { 0x60, 0x8f };
+static u8 data_ota7290b_1920_219[] = { 0x61, 0x62 };
+static u8 data_ota7290b_1920_220[] = { 0x62, 0xb5 };
+static u8 data_ota7290b_1920_221[] = { 0x63, 0xb2 };
+static u8 data_ota7290b_1920_222[] = { 0x64, 0x5a };
+static u8 data_ota7290b_1920_223[] = { 0x65, 0xad };
+static u8 data_ota7290b_1920_224[] = { 0x66, 0x56 };
+static u8 data_ota7290b_1920_225[] = { 0x67, 0x2b };
+static u8 data_ota7290b_1920_226[] = { 0x68, 0x0c };
+static u8 data_ota7290b_1920_227[] = { 0x69, 0x01 };
+static u8 data_ota7290b_1920_228[] = { 0x6a, 0x01 };
+static u8 data_ota7290b_1920_229[] = { 0x6b, 0xfc };
+static u8 data_ota7290b_1920_230[] = { 0x6c, 0xfd };
+static u8 data_ota7290b_1920_231[] = { 0x6d, 0xfd };
+static u8 data_ota7290b_1920_232[] = { 0x6e, 0xfd };
+static u8 data_ota7290b_1920_233[] = { 0x6f, 0xfd };
+static u8 data_ota7290b_1920_234[] = { 0x70, 0xff };
+static u8 data_ota7290b_1920_235[] = { 0x71, 0xff };
+static u8 data_ota7290b_1920_236[] = { 0x72, 0x3f };
+static u8 data_ota7290b_1920_237[] = { 0x73, 0x00 };
+static u8 data_ota7290b_1920_238[] = { 0x74, 0x00 };
+static u8 data_ota7290b_1920_239[] = { 0x75, 0x00 };
+static u8 data_ota7290b_1920_240[] = { 0x76, 0x00 };
+static u8 data_ota7290b_1920_241[] = { 0x77, 0x00 };
+static u8 data_ota7290b_1920_242[] = { 0x78, 0x00 };
+static u8 data_ota7290b_1920_243[] = { 0x79, 0x00 };
+static u8 data_ota7290b_1920_244[] = { 0x7a, 0xdc };
+static u8 data_ota7290b_1920_245[] = { 0x7b, 0xdc };
+static u8 data_ota7290b_1920_246[] = { 0x7c, 0xdc };
+static u8 data_ota7290b_1920_247[] = { 0x7d, 0xdc };
+static u8 data_ota7290b_1920_248[] = { 0x7e, 0xdc };
+static u8 data_ota7290b_1920_249[] = { 0x7f, 0x6e };
+static u8 data_ota7290b_1920_250[] = { 0x0b, 0x04 };
+static u8 data_ota7290b_1920_251[] = { 0xb1, 0x03 };
+static u8 data_ota7290b_1920_252[] = { 0x2c, 0x2c };
+static u8 data_ota7290b_1920_253[] = { 0xb1, 0x00 };
+static u8 data_ota7290b_1920_254[] = { 0x89, 0x03 };
+static u8 data_ota7290b_1920_255[] = { 0x29, 0x00 };
+
+const struct dsc_instr dsi_init_cmds_ota7290b_440x1920[] = {
+	{.delay = 250, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_0 },
+	{.delay = 50, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_1 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_2 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_3 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_4 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_6 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_7 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_8 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_16 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_23 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_24 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_25 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_26 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_27 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_28 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_29 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_30 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_31 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_32 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_33 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_34 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_35 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_36 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_37 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_38 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_39 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_40 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_41 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_42 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_43 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_44 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_45 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_46 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_47 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_48 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_49 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_50 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_51 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_52 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_53 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_54 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_55 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_56 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_57 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_58 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_59 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_60 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_61 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_62 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_63 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_64 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_65 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_66 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_67 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_68 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_69 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_70 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_71 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_72 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_73 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_74 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_75 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_76 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_77 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_78 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_79 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_80 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_81 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_82 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_83 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_84 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_85 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_86 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_87 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_88 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_89 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_90 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_91 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_92 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_93 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_94 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_95 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_96 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_97 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_98 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_99 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_100 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_101 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_102 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_103 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_104 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_105 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_106 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_107 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_108 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_109 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_110 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_111 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_112 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_113 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_114 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_115 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_116 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_117 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_118 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_119 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_120 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_121 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_122 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_123 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_124 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_125 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_126 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_127 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_128 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_129 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_130 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_131 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_132 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_133 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_134 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_135 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_136 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_137 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_138 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_139 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_140 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_141 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_142 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_143 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_144 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_145 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_146 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_147 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_148 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_149 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_150 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_151 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_152 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_153 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_154 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_155 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_156 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_157 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_158 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_159 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_160 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_161 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_162 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_163 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_164 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_165 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_166 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_167 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_168 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_169 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_170 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_171 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_172 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_173 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_174 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_175 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_176 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_177 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_178 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_179 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_180 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_181 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_182 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_183 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_184 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_185 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_186 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_187 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_188 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_189 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_190 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_191 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_192 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_193 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_194 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_195 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_196 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_197 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_198 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_199 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_200 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_201 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_202 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_203 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_204 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_205 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_206 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_207 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_208 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_209 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_210 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_211 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_212 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_213 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_214 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_215 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_216 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_217 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_218 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_219 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_220 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_221 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_222 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_223 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_224 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_225 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_226 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_227 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_228 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_229 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_230 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_231 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_232 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_233 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_234 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_235 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_236 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_237 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_238 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_239 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_240 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_241 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_242 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_243 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_244 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_245 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_246 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_247 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_248 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_249 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_250 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_251 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_252 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_253 },
+	{.delay = 200, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_254 },
+	{.delay = 50, .data_type = 0x15, .size = 2, .data = data_ota7290b_1920_255 }
+};
+
+#else
+#error "_MIPI_TX_PARAM_OTA7290B_1920_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_OTA7290B_1920_H_
diff --git a/include/cvitek/cvi_panels/dsi_st7701.h b/include/cvitek/cvi_panels/dsi_st7701.h
new file mode 100644
index 000000000..b3c175526
--- /dev/null
+++ b/include/cvitek/cvi_panels/dsi_st7701.h
@@ -0,0 +1,170 @@
+#ifndef _MIPI_TX_PARAM_ST_7701_H_
+#define _MIPI_TX_PARAM_ST_7701_H_
+
+#include <cvi_mipi.h>
+
+#define PANEL_NAME "NETEASE-2"
+
+#define ST7701_NETEASE_VACT	800
+#define ST7701_NETEASE_VSA		10
+#define ST7701_NETEASE_VBP		20
+#define ST7701_NETEASE_VFP		20
+
+#define ST7701_NETEASE_HACT		480
+#define ST7701_NETEASE_HSA		10
+#define ST7701_NETEASE_HBP		50
+#define ST7701_NETEASE_HFP		50
+
+#define PIXEL_CLK(x) ((x##_VACT + x##_VSA + x##_VBP + x##_VFP) \
+	* (x##_HACT + x##_HSA + x##_HBP + x##_HFP) * 60 / 1000)
+
+const struct combo_dev_cfg_s dev_cfg_st7701_480x800 = {
+	.devno = 0,
+	.lane_id = {MIPI_TX_LANE_1, MIPI_TX_LANE_0, MIPI_TX_LANE_CLK, -1, -1},
+	.lane_pn_swap = {false, false, false, false, false},
+	.output_mode = OUTPUT_MODE_DSI_VIDEO,
+	.video_mode = BURST_MODE,
+	.output_format = OUT_FORMAT_RGB_24_BIT,
+	.sync_info = {
+		.vid_hsa_pixels = ST7701_NETEASE_HSA,
+		.vid_hbp_pixels = ST7701_NETEASE_HBP,
+		.vid_hfp_pixels = ST7701_NETEASE_HFP,
+		.vid_hline_pixels = ST7701_NETEASE_HACT,
+		.vid_vsa_lines = ST7701_NETEASE_VSA,
+		.vid_vbp_lines = ST7701_NETEASE_VBP,
+		.vid_vfp_lines = ST7701_NETEASE_VFP,
+		.vid_active_lines = ST7701_NETEASE_VACT,
+		.vid_vsa_pos_polarity = true,
+		.vid_hsa_pos_polarity = false,
+	},
+	.pixel_clk = PIXEL_CLK(ST7701_NETEASE),
+};
+
+const struct hs_settle_s hs_timing_cfg_st7701_480x800 = { .prepare = 6, .zero = 32, .trail = 1 };
+
+static u8 data_st7701_0[] = { 0xff, 0x77, 0x01, 0x00, 0x00, 0x13 };
+static u8 data_st7701_1[] = { 0xef, 0x08 };
+static u8 data_st7701_2[] = { 0xff, 0x77, 0x01, 0x00, 0x00, 0x10 };
+static u8 data_st7701_3[] = { 0xc0, 0x63, 0x00 };
+static u8 data_st7701_4[] = { 0xc1, 0x11, 0x0c };
+static u8 data_st7701_5[] = { 0xc2, 0x07, 0x08 };
+static u8 data_st7701_6[] = { 0xcc, 0x10 };
+static u8 data_st7701_7[] = {
+	0xb0, 0x00, 0x0c, 0x13, 0x0d, 0x10, 0x06, 0x01, 0x08, 0x07,
+	0x1e, 0x04, 0x13, 0x10, 0x2d, 0x31, 0x10
+};
+
+static u8 data_st7701_8[] = {
+	0xb1, 0x00, 0x0c, 0x13, 0x0d, 0x10, 0x06, 0x02, 0x08, 0x07,
+	0x1f, 0x05, 0x12, 0x10, 0x27, 0x31, 0x1f
+};
+
+static u8 data_st7701_9[] = { 0xff, 0x77, 0x01, 0x00, 0x00, 0x11 };
+static u8 data_st7701_10[] = { 0xb0, 0x70 };
+static u8 data_st7701_11[] = { 0xb1, 0x93 };
+static u8 data_st7701_12[] = { 0xb2, 0x87 };
+static u8 data_st7701_13[] = { 0xb3, 0x80 };
+static u8 data_st7701_14[] = { 0xb5, 0x49 };
+static u8 data_st7701_15[] = { 0xb7, 0x87 };
+static u8 data_st7701_16[] = { 0xb8, 0x21 };
+static u8 data_st7701_17[] = { 0xb9, 0x10, 0x1f };
+static u8 data_st7701_18[] = { 0xbb, 0x03 };
+static u8 data_st7701_19[] = { 0xc0, 0x89 };
+static u8 data_st7701_20[] = { 0xc1, 0x08 };
+static u8 data_st7701_21[] = { 0xc2, 0x08 };
+static u8 data_st7701_22[] = { 0xc8, 0xbe };
+static u8 data_st7701_23[] = { 0xd0, 0x88 };
+static u8 data_st7701_24[] = {
+	0xe0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0c
+};
+
+static u8 data_st7701_25[] = {
+	0xe1, 0x05, 0x8c, 0x07, 0x8c, 0x06, 0x8c, 0x08, 0x8c, 0x00,
+	0x44, 0x44
+};
+
+static u8 data_st7701_26[] = {
+	0xe2, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00,
+	0x00, 0x02, 0x00
+};
+
+static u8 data_st7701_27[] = { 0xe3, 0x00, 0x00, 0x33, 0x33 };
+static u8 data_st7701_28[] = { 0xe4, 0x44, 0x44 };
+static u8 data_st7701_29[] = {
+	0xe5, 0x0d, 0x3f, 0x0c, 0xa0, 0x0f, 0x41, 0x0c, 0xa0, 0x09,
+	0x3b, 0x0c, 0xa0, 0x0b, 0x3d, 0x0c, 0xa0
+};
+
+static u8 data_st7701_30[] = { 0xe6, 0x00, 0x00, 0x33, 0x33 };
+static u8 data_st7701_31[] = { 0xe7, 0x44, 0x44 };
+static u8 data_st7701_32[] = {
+	0xe8, 0x0e, 0x40, 0x0c, 0xa0, 0x10, 0x42, 0x0c, 0xa0, 0x0a,
+	0x3c, 0x0c, 0xa0, 0x0c, 0x3e, 0x0c, 0xa0
+};
+
+static u8 data_st7701_33[] = {
+	0xeb, 0x00, 0x01, 0xe4, 0xe4, 0x44, 0x00
+};
+
+static u8 data_st7701_34[] = {
+	0xed, 0xf3, 0xc1, 0xba, 0x0f, 0x66, 0x77, 0x44, 0x55, 0x55,
+	0x44, 0x77, 0x66, 0xf0, 0xab, 0x1c, 0x3f
+};
+
+static u8 data_st7701_35[] = {
+	0xef, 0x10, 0x0d, 0x04, 0x08, 0x3f, 0x1f
+};
+
+static u8 data_st7701_36[] = { 0xff, 0x77, 0x01, 0x00, 0x00, 0x13 };
+static u8 data_st7701_37[] = { 0x11 };
+static u8 data_st7701_38[] = { 0x29 };
+static u8 data_st7701_39[] = { 0x36, 0x00 };
+static u8 data_st7701_40[] = { 0x35, 0x00 };
+
+const struct dsc_instr dsi_init_cmds_st7701_480x800[] = {
+	{.delay = 0, .data_type = 0x39, .size = 6, .data = data_st7701_0 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_1 },
+	{.delay = 0, .data_type = 0x39, .size = 6, .data = data_st7701_2 },
+	{.delay = 0, .data_type = 0x39, .size = 3, .data = data_st7701_3 },
+	{.delay = 0, .data_type = 0x39, .size = 3, .data = data_st7701_4 },
+	{.delay = 0, .data_type = 0x39, .size = 3, .data = data_st7701_5 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_6 },
+	{.delay = 0, .data_type = 0x39, .size = 17, .data = data_st7701_7 },
+	{.delay = 0, .data_type = 0x39, .size = 17, .data = data_st7701_8 },
+	{.delay = 0, .data_type = 0x39, .size = 6, .data = data_st7701_9 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_10 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_11 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_12 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_13 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_14 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_15 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_16 },
+	{.delay = 0, .data_type = 0x39, .size = 3, .data = data_st7701_17 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_18 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_19 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_20 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_21 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_22 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_23 },
+	{.delay = 0, .data_type = 0x39, .size = 7, .data = data_st7701_24 },
+	{.delay = 0, .data_type = 0x39, .size = 12, .data = data_st7701_25 },
+	{.delay = 0, .data_type = 0x39, .size = 13, .data = data_st7701_26 },
+	{.delay = 0, .data_type = 0x39, .size = 5, .data = data_st7701_27 },
+	{.delay = 0, .data_type = 0x39, .size = 3, .data = data_st7701_28 },
+	{.delay = 0, .data_type = 0x39, .size = 17, .data = data_st7701_29 },
+	{.delay = 0, .data_type = 0x39, .size = 5, .data = data_st7701_30 },
+	{.delay = 0, .data_type = 0x39, .size = 3, .data = data_st7701_31 },
+	{.delay = 0, .data_type = 0x39, .size = 17, .data = data_st7701_32 },
+	{.delay = 0, .data_type = 0x39, .size = 7, .data = data_st7701_33 },
+	{.delay = 0, .data_type = 0x39, .size = 17, .data = data_st7701_34 },
+	{.delay = 0, .data_type = 0x39, .size = 7, .data = data_st7701_35 },
+	{.delay = 0, .data_type = 0x39, .size = 6, .data = data_st7701_36 },
+	{.delay = 120, .data_type = 0x05, .size = 1, .data = data_st7701_37 },
+	{.delay = 20, .data_type = 0x05, .size = 1, .data = data_st7701_38 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_39 },
+	{.delay = 0, .data_type = 0x15, .size = 2, .data = data_st7701_40 }
+};
+
+#else
+#error "_MIPI_TX_PARAM_ST_7701_H_ multi-delcaration!!"
+#endif // _MIPI_TX_PARAM_ST_7701_H_
diff --git a/include/cvitek/cvi_panels/i80_st7789v.h b/include/cvitek/cvi_panels/i80_st7789v.h
new file mode 100644
index 000000000..2061cd4c6
--- /dev/null
+++ b/include/cvitek/cvi_panels/i80_st7789v.h
@@ -0,0 +1,101 @@
+#ifndef _I80_PARAM_ST7789V_H_
+#define _I80_PARAM_ST7789V_H_
+
+#include <cvi_i80.h>
+
+const struct _VO_I80_CFG_S i80_st7789v_cfg = {
+	.lane_s = {.CS = 0, .RS = 1, .WR = 2, .RD = 3},
+	.fmt = VO_I80_FORMAT_RGB565,
+	.cycle_time = 66,
+	.sync_info = {
+		.vid_hsa_pixels = 0,
+		.vid_hbp_pixels = 0,
+		.vid_hfp_pixels = 0,
+		.vid_hline_pixels = 240,
+		.vid_vsa_lines = 0,
+		.vid_vbp_lines = 0,
+		.vid_vfp_lines = 0,
+		.vid_active_lines = 320,
+		.vid_vsa_pos_polarity = false,
+		.vid_hsa_pos_polarity = false,
+	},
+};
+
+const struct _VO_I80_INSTR_S i80_st7789v_init_cmds[] = {
+	{.delay = 0,   .data_type = COMMAND, .data = 0x11},
+	{.delay = 0,   .data_type = COMMAND, .data = 0x35},
+	{.delay = 0,   .data_type = DATA,    .data = 0x00},
+	{.delay = 0,   .data_type = COMMAND, .data = 0x36},//Display Setting
+	{.delay = 0,   .data_type = DATA,    .data = (1 << 6)/*(1<<5)|(1<<6)*/},
+	{.delay = 0,   .data_type = COMMAND, .data = 0x3A},
+	{.delay = 0,   .data_type = DATA,    .data = 0x05},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xB2},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0C},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0C},
+	{.delay = 0,   .data_type = DATA,    .data = 0x00},
+	{.delay = 0,   .data_type = DATA,    .data = 0x33},
+	{.delay = 0,   .data_type = DATA,    .data = 0x33},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xB7},
+	{.delay = 0,   .data_type = DATA,    .data = 0x75},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xBB},
+	{.delay = 0,   .data_type = DATA,    .data = 0x19},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xC0},
+	{.delay = 0,   .data_type = DATA,    .data = 0x2C},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xC2},
+	{.delay = 0,   .data_type = DATA,    .data = 0x01},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xC3},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0C},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xC4},
+	{.delay = 0,   .data_type = DATA,    .data = 0x20},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xC6},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0F},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xD0},
+	{.delay = 0,   .data_type = DATA,    .data = 0xA4},
+	{.delay = 0,   .data_type = DATA,    .data = 0xA1},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xE0},//Gamma setting
+	{.delay = 0,   .data_type = DATA,    .data = 0xD0},
+	{.delay = 0,   .data_type = DATA,    .data = 0x04},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0C},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0E},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0E},
+	{.delay = 0,   .data_type = DATA,    .data = 0x29},
+	{.delay = 0,   .data_type = DATA,    .data = 0x37},
+	{.delay = 0,   .data_type = DATA,    .data = 0x44},
+	{.delay = 0,   .data_type = DATA,    .data = 0x47},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0B},
+	{.delay = 0,   .data_type = DATA,    .data = 0x17},
+	{.delay = 0,   .data_type = DATA,    .data = 0x16},
+	{.delay = 0,   .data_type = DATA,    .data = 0x1B},
+	{.delay = 0,   .data_type = DATA,    .data = 0x1F},
+	{.delay = 0,   .data_type = COMMAND, .data = 0xE1},
+	{.delay = 0,   .data_type = DATA,    .data = 0xD0},
+	{.delay = 0,   .data_type = DATA,    .data = 0x04},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0C},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0E},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0F},
+	{.delay = 0,   .data_type = DATA,    .data = 0x29},
+	{.delay = 0,   .data_type = DATA,    .data = 0x37},
+	{.delay = 0,   .data_type = DATA,    .data = 0x44},
+	{.delay = 0,   .data_type = DATA,    .data = 0x4A},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0C},
+	{.delay = 0,   .data_type = DATA,    .data = 0x17},
+	{.delay = 0,   .data_type = DATA,    .data = 0x16},
+	{.delay = 0,   .data_type = DATA,    .data = 0x1B},
+	{.delay = 0,   .data_type = DATA,    .data = 0x1F},
+	{.delay = 0,   .data_type = COMMAND, .data = 0x29},
+
+	{.delay = 0,   .data_type = COMMAND, .data = 0x2A},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0 },//Xstart
+	{.delay = 0,   .data_type = DATA,    .data = 0x0 },
+	{.delay = 0,   .data_type = DATA,    .data = 0x0 },//Xend
+	{.delay = 0,   .data_type = DATA,    .data = 0xEF},
+	{.delay = 0,   .data_type = COMMAND, .data = 0x2B},
+	{.delay = 0,   .data_type = DATA,    .data = 0x0 },//Ystart
+	{.delay = 0,   .data_type = DATA,    .data = 0x0 },
+	{.delay = 0,   .data_type = DATA,    .data = 0x01},//Yend
+	{.delay = 0,   .data_type = DATA,    .data = 0x3F},
+	{.delay = 0,   .data_type = COMMAND, .data = 0x2C},
+};
+#else
+#error "_I80_PARAM_ST7789V_H_ multi-delcaration!!"
+#endif // _I80_PARAM_ST7789V_H_
diff --git a/include/cvitek/cvi_reboot.h b/include/cvitek/cvi_reboot.h
new file mode 100644
index 000000000..a53426311
--- /dev/null
+++ b/include/cvitek/cvi_reboot.h
@@ -0,0 +1,7 @@
+#ifndef _CVI_REBOOT_H_
+#define _CVI_REBOOT_H_
+
+#define CVI_SAPD_FLAG 0x53415044
+void software_root_reset(void);
+
+#endif /* _CVI_REBOOT_H_ */
diff --git a/include/cvitek/cvi_utask.h b/include/cvitek/cvi_utask.h
new file mode 100644
index 000000000..e09bcf80a
--- /dev/null
+++ b/include/cvitek/cvi_utask.h
@@ -0,0 +1,4 @@
+#ifndef _BM_USB_H_
+#define _BM_USB_H_
+int cvi_usb_polling(void);
+#endif /* _BM_USB_H_ */
diff --git a/include/cvitek/mmio.h b/include/cvitek/mmio.h
new file mode 100644
index 000000000..0d2182876
--- /dev/null
+++ b/include/cvitek/mmio.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __MMIO_H__
+#define __MMIO_H__
+
+static inline void mmio_write_8(uintptr_t addr, uint8_t value)
+{
+	*(volatile uint8_t*)addr = value;
+}
+
+static inline uint8_t mmio_read_8(uintptr_t addr)
+{
+	return *(volatile uint8_t*)addr;
+}
+
+static inline void mmio_write_16(uintptr_t addr, uint16_t value)
+{
+	*(volatile uint16_t*)addr = value;
+}
+
+static inline uint16_t mmio_read_16(uintptr_t addr)
+{
+	return *(volatile uint16_t*)addr;
+}
+
+static inline void mmio_write_32(uintptr_t addr, uint32_t value)
+{
+	*(volatile uint32_t*)addr = value;
+}
+
+static inline uint32_t mmio_read_32(uintptr_t addr)
+{
+	return *(volatile uint32_t*)addr;
+}
+
+static inline void mmio_write_64(uintptr_t addr, uint64_t value)
+{
+	*(volatile uint64_t*)addr = value;
+}
+
+static inline uint64_t mmio_read_64(uintptr_t addr)
+{
+	return *(volatile uint64_t*)addr;
+}
+
+static inline void mmio_clrbits_32(uintptr_t addr, uint32_t clear)
+{
+	mmio_write_32(addr, mmio_read_32(addr) & ~clear);
+}
+
+static inline void mmio_setbits_32(uintptr_t addr, uint32_t set)
+{
+	mmio_write_32(addr, mmio_read_32(addr) | set);
+}
+
+static inline void mmio_clrsetbits_32(uintptr_t addr,
+				uint32_t clear,
+				uint32_t set)
+{
+	mmio_write_32(addr, (mmio_read_32(addr) & ~clear) | set);
+}
+
+#endif /* __MMIO_H__ */
diff --git a/include/cvsnfc.h b/include/cvsnfc.h
new file mode 100644
index 000000000..bff192773
--- /dev/null
+++ b/include/cvsnfc.h
@@ -0,0 +1,765 @@
+#ifndef __CVSNFC_H__
+#define __CVSNFC_H__
+
+#include <asm/io.h>
+#include <cvsnfc_spi_ids.h>
+
+/******************************************************************************/
+/* These macroes are for debug only, reg option is slower then dma option */
+#undef CVSNFC_SUPPORT_REG_READ
+/* #define CVSNFC_SUPPORT_REG_READ */
+
+#undef CVSNFC_SUPPORT_REG_WRITE
+/* #define CVSNFC_SUPPORT_REG_WRITE */
+
+#define CVI_SYSDMA_REMAP_BASE	0x3000154
+
+/*****************************************************************************/
+// legacy register define
+#define CVSNFC_CFG					0x00
+#define CVSNFC_CFG_BOOT_MODE(_mode)			((_mode) << 17)
+#define CVSNFC_CFG_DEVICE_INTERNAL_ECC_ENABLE	BIT(16)
+#define CVSNFC_CFG_FLASH_SIZE_CS1(_size)		(((_size) & 0xf) << 10)
+#define CVSNFC_CFG_FLASH_SIZE_CS0(_size)		(((_size) & 0xf) << 6)
+#define CVSNFC_CFG_ADDR_MODE(_mode)			((_mode) << 5)
+#define CVSNFC_CFG_ECC_TYPE(type)			(((type) & 0x3) << 3)
+#define CVSNFC_CFG_PAGE_SIZE(size)			((size) << 2)
+#define CVSNFC_CFG_DEVICE_TYPE(_type)		((_type) << 1)
+#define CVSNFC_CFG_OP_MODE(_mode)			((_mode) << 0)
+
+#define BOOT_MODE_MASK				(0x1 << 17)
+
+#define FLASH_SIZE_CS1_SHIFT			10
+#define FLASH_SIZE_CS1_MASK			(0xf << 10)
+
+#define FLASH_SIZE_CS0_SHIFT			6
+#define FLASH_SIZE_CS0_MASK			(0xf << 6)
+
+#define ECC_TYPE_SHIFT				3
+#define ECC_TYPE_MASK				(0x3 << 3)
+
+#define PAGE_SIZE_SHIFT				2
+#define PAGE_SIZE_MASK				(0x1 << 2)
+
+#define DEVICE_TYPE_SHIFT			1
+#define DEVICE_TYPE_MASK			(0x1 << 1)
+#define DEVICE_TYPE_NOR_FLASH			0
+#define DEVICE_TYPE_NAND_FLASH			1
+
+#define OP_MODE_MASK				(0x1 << 0)
+#define OP_MODE_BOOT				0
+#define OP_MODE_NORMAL				1
+
+/*****************************************************************************/
+#define CVSNFC_GLOBAL_CFG			0x04
+#define CVSNFC_GLOBAL_CFG_WP_ENABLE		BIT(5)
+
+/*****************************************************************************/
+#define CVSNFC_TIMING_CFG			0x08
+#define CVSNFC_TIMING_CFG_TCSH(_n)		(((_n) & 0xf) << 8)
+#define CVSNFC_TIMING_CFG_TCSS(_n)		(((_n) & 0xf) << 4)
+#define CVSNFC_TIMING_CFG_TSHSL(_n)		((_n) & 0xf)
+
+#define CS_HOLD_TIME				0x6
+#define CS_SETUP_TIME				0x6
+#define CS_DESELECT_TIME			0xf
+
+/*****************************************************************************/
+#define CVSNFC_INT				0x0c
+#define CVSNFC_INT_OP_DONE			BIT(0)
+
+/*****************************************************************************/
+#define CVSNFC_INT_CLR			0x14
+#define CVSNFC_INT_CLR_DMA_ERR		BIT(5)
+#define CVSNFC_INT_CLR_OP_FAIL		BIT(2)
+#define CVSNFC_INT_CLR_OP_DONE		BIT(0)
+
+#define CVSNFC_INT_CLR_ALL			0x7f
+
+/*****************************************************************************/
+#define CVSNFC_OPCODE			0x18
+
+/*****************************************************************************/
+#define CVSNFC_OP_ADDR			0x1c
+#define CVSNFC_OP_ADDRH_BLOCK_MASK(_page)	(((_page) & 0xffff) << 16)
+#define CVSNFC_OP_ADDRL_BLOCK_MASK(_page)	((_page) & 0xffc0)
+
+#define READ_ID_ADDR				0x00
+#define PROTECTION_ADDR				0xa0
+#define FEATURE_ADDR				0xb0
+#define STATUS_ADDR				0xc0
+#define WRITE_ENABLE_STATUS_ADDR		STATUS_ADDR
+
+/*****************************************************************************/
+#define CVSNFC_OP				0x20
+#define CVSNFC_OP_SEL_CS(_cs)		((_cs) << 11)
+#define CVSNFC_OP_ADDR_NUM(_n)		(((_n) & 0x7) << 8)
+#define CVSNFC_OP_DUMMY_CMD_EN(_en)		((_en) << 7)
+#define CVSNFC_OP_DUMMY_ADDR_EN(_en)		((_en) << 6)
+#define CVSNFC_OP_OPCODE_EN(_en)		((_en) << 5)
+#define CVSNFC_OP_ADDR_EN(_en)		((_en) << 4)
+#define CVSNFC_OP_DATE_WRITE_EN(_en)		((_en) << 3)
+#define CVSNFC_OP_DATE_READ_EN(_en)		((_en) << 2)
+#define CVSNFC_OP_STATUS_READ_EN(_en)	((_en) << 1)
+#define CVSNFC_OP_START			BIT(0)
+
+#define STD_OP_ADDR_NUM				3
+#define READ_ID_ADDR_NUM			1
+
+#define FEATURES_OP_ADDR_NUM			1
+
+/*****************************************************************************/
+#define CVSNFC_DATA_NUM			0x24
+#define CVSNFC_DATA_NUM_CNT(_n)		((_n) & 0x1fff)
+
+#define FEATURES_DATE_NUM			1
+
+#define READ_OOB_BB_LEN				1
+
+/*****************************************************************************/
+#define CVSNFC_OP_CFG			0x28
+#define CVSNFC_OP_CFG_DIR_TRANS_ENABLE	BIT(11)
+#define CVSNFC_OP_CFG_RD_OP_SEL(_type)	(((_type) & 0x3) << 9)
+#define CVSNFC_OP_CFG_MEM_IF_TYPE(_type)	(((_type) & 0x7) << 6)
+#define CVSNFC_OP_CFG_DUMMY_CMD_NUM(_no)	(((_no) & 0x7) << 3)
+#define CVSNFC_OP_CFG_DUMMY_ADDR_NUM(_no)	(((_no) & 0x7) << 0)
+
+#define RD_OP_READ_PAGE				0x0
+#define RD_OP_READ_DATE				0x1
+#define RD_OP_READ_OOB				0x2
+
+/*****************************************************************************/
+#define CVSNFC_ADDRH				0x2c
+#define CVSNFC_ADDRH_SET(_addr)		((_addr) & 0xff)
+
+/*****************************************************************************/
+#define CVSNFC_ADDRL				0x30
+
+/*****************************************************************************/
+#define CVSNFC_OP_CTRL			0x34
+#define CVSNFC_OP_CTRL_RD_OPCODE(_code)	(((_code) & 0xff) << 16)
+#define CVSNFC_OP_CTRL_WR_OPCODE(_code)	(((_code) & 0xff) << 8)
+#define CVSNFC_OP_CTRL_CS_OP(_cs)		((_cs) << 3)
+#define CVSNFC_OP_CTRL_OP_TYPE(_type)	((_type) << 2)
+#define CVSNFC_OP_CTRL_RW_OP(_op)		((_op) << 1)
+#define CVSNFC_OP_CTRL_OP_READY		BIT(0)
+
+#define OP_TYPE_REG				0
+#define OP_TYPE_DMA				1
+
+#define RW_OP_READ				0
+#define RW_OP_WRITE				1
+
+/*****************************************************************************/
+#define CVSNFC_DMA_CTRL			0x3c
+
+#define CVSNFC_DMA_CTRL_ALL_ENABLE		0x7
+
+/*****************************************************************************/
+#define CVSNFC_DMA_SADDR_D			0x40
+
+/*****************************************************************************/
+#define CVSNFC_DMA_SADDR_OOB			0x44
+
+/*****************************************************************************/
+#define CVSNFC_DMA_LEN			0x48
+#define CVSNFC_DMA_LEN_SET(_len)		((_len) & 0xfffffff)
+
+/*****************************************************************************/
+#define CVSNFC_STATUS			0x54
+
+#define GET_OP					0
+#define SET_OP					1
+
+#define PROTECTION_BRWD_MASK			BIT(7)
+#define PROTECTION_BP3_MASK			BIT(6)
+#define PROTECTION_BP2_MASK			BIT(5)
+#define PROTECTION_BP1_MASK			BIT(4)
+#define PROTECTION_BP0_MASK			BIT(3)
+
+#define ALL_BP_MASK				(PROTECTION_BP3_MASK \
+						| PROTECTION_BP2_MASK \
+						| PROTECTION_BP1_MASK \
+						| PROTECTION_BP0_MASK)
+
+#define FEATURE_ECC_ENABLE			BIT(4)
+#define FEATURE_QE_ENABLE			BIT(0)
+
+#define STATUS_ECC_MASK				(0x3 << 4)
+#define STATUS_P_FAIL_MASK			BIT(3)
+#define STATUS_E_FAIL_MASK			BIT(2)
+#define STATUS_WEL_MASK				BIT(1)
+#define STATUS_OIP_MASK				BIT(0)
+
+/*****************************************************************************/
+#define CVSNFC_VERSION			0x68
+
+/*****************************************************************************/
+#define REG_CNT_HIGH_BLOCK_NUM_SHIFT		10
+
+#define REG_CNT_BLOCK_NUM_MASK			0x3ff
+#define REG_CNT_BLOCK_NUM_SHIFT			22
+
+#define REG_CNT_PAGE_NUM_MASK			0x3f
+#define REG_CNT_PAGE_NUM_SHIFT			16
+
+#define REG_CNT_WRAP_MASK			0xf
+#define REG_CNT_WRAP_SHIFT			12
+
+#define REG_CNT_ECC_OFFSET_MASK			0xfff
+#define REG_CNT_ECC_8BIT_OFFSET			1054
+#define REG_CNT_ECC_16BIT_OFFSET		1056
+#define REG_CNT_ECC_24BIT_OFFSET		1082
+
+/* latest register definition */
+#define SPI_NAND_PROGRAM_LOAD_X1 0
+#define SPI_NAND_PROGRAM_LOAD_X4 1
+
+#define SPI_NAND_READ_FROM_CACHE_MODE_X1 0
+#define SPI_NAND_READ_FROM_CACHE_MODE_X2 1
+#define SPI_NAND_READ_FROM_CACHE_MODE_X4 2
+
+#define SPI_NAND_CMD_WREN			0x06
+#define SPI_NAND_CMD_WRDI			0x04
+#define SPI_NAND_CMD_GET_FEATURE		0x0F
+#define SPI_NAND_CMD_SET_FEATURE		0x1F
+#define SPI_NAND_CMD_PAGE_READ_TO_CACHE		0x13
+#define SPI_NAND_CMD_READ_FROM_CACHE		0x03
+#define SPI_NAND_CMD_READ_FROM_CACHE2		0x0B
+#define SPI_NAND_CMD_READ_FROM_CACHEX2		0x3B
+#define SPI_NAND_CMD_READ_FROM_CACHEX4		0x6B
+#define SPI_NAND_CMD_READ_FROM_DUAL_IO		0xBB
+#define SPI_NAND_CMD_READ_FROM_QUAL_IO		0xEB
+#define SPI_NAND_CMD_READ_ID			0x9F
+#define SPI_NAND_CMD_PROGRAM_LOAD		0x02
+#define SPI_NAND_CMD_PROGRAM_LOADX4		0x32
+#define SPI_NAND_CMD_PROGRAM_EXECUTE		0x10
+#define SPI_NAND_CMD_PROGRAM_LOAD_RANDOM_DATA		0x84
+#define SPI_NAND_CMD_PROGRAM_LOAD_RANDOM_DATAX4	0xC4
+#define SPI_NAND_CMD_PROGRAM_LOAD_RANDOM_DATA_QUAD_IO	0x72
+
+#define SPI_NAND_CMD_4K_SUBSECTOR_ERASE		0x20
+#define SPI_NAND_CMD_32K_SUBSECTOR_ERASE	0x52
+#define SPI_NAND_CMD_BLOCK_ERASE		0xD8
+#define SPI_NAND_CMD_RESET			0xFF
+
+#define SPI_NAND_FEATURE_ECC_CONFIG	(0x90)
+#define SPI_NAND_FEATURE_CFG_ECC_EN	(0x01 << 4)
+
+#define SPI_NAND_FEATURE_PROTECTION	(0xA0)
+#define FEATURE_PROTECTION_NONE			0
+#define SPI_NAND_PROTECTION_CMP			(0x01 << 1)
+#define SPI_NAND_PROTECTION_INV			(0x01 << 2)
+#define SPI_NAND_PROTECTION_BP0			(0x01 << 3)
+#define SPI_NAND_PROTECTION_BP1			(0x01 << 4)
+#define SPI_NAND_PROTECTION_BP2			(0x01 << 5)
+#define SPI_NAND_PROTECTION_BRWD		(0x01 << 7)
+
+#define SPI_NAND_FEATURE_FEATURE0	(0xB0)
+#define SPI_NAND_FEATURE0_QE			(0x01 << 0)
+#define SPI_NAND_FEATURE0_ECC_EN		(0x01 << 4)
+#define SPI_NAND_FEATURE0_OTP_EN		(0x01 << 6)
+#define SPI_NAND_FEATURE0_OTP_PRT		(0x01 << 7)
+
+#define SPI_NAND_FEATURE_STATUS0	(0xC0)
+#define SPI_NAND_STATUS0_OIP			(0x01 << 0)
+#define SPI_NAND_STATUS0_WEL			(0x01 << 1)
+#define SPI_NAND_STATUS0_E_FAIL			(0x01 << 2)
+#define SPI_NAND_STATUS0_P_FAIL			(0x01 << 3)
+#define SPI_NAND_STATUS0_ECCS0			(0x01 << 4)
+#define SPI_NAND_STATUS0_ECCS1			(0x01 << 5)
+
+#define SPI_NAND_FEATURE_FEATURE1	(0xD0)
+#define SPI_NAND_FEATURE1_DS_S0			(0x01 << 5)
+#define SPI_NAND_FEATURE1_DS_S1			(0x01 << 6)
+
+#define SPI_NAND_FEATURE_STATUS1	(0xF0)
+#define SPI_NAND_STATUS1_ECCSE0			(0x01 << 4)
+#define SPI_NAND_STATUS1_ECCSE1			(0x01 << 5)
+
+#define SPI_NAND_FLASH_BLOCK_SIZE             256
+#define SPI_NAND_TRAN_CSR_ADDR_BYTES_SHIFT    8
+#define SPI_NAND_MAX_FIFO_DEPTH               8
+
+/*1880V2 spi nand definitions */
+#define REG_SPI_NAND_TRX_CTRL0  0x000
+#define BIT_REG_TRX_START           (0x01 << 0)
+#define BIT_REG_TRX_SW_RST          (0x01 << 1)
+#define BIT_REG_TRX_RST_DONE        (0x01 << 16)
+
+#define REG_SPI_NAND_TRX_CTRL1  0x004
+#define BIT_REG_TRX_TIME_START      (0x01 << 0)
+#define BIT_REG_TRX_TIME_TA         (0x01 << 4)
+#define BIT_REG_TRX_TIME_END        (0x01 << 4)
+#define BIT_REG_TRX_TIME_WAIT       (0x01 << 8)
+#define BIT_REG_TRX_SCK_H           (0x01 << 16)
+#define BIT_REG_TRX_SCK_L           (0x01 << 20)
+#define BIT_REG_NAND_SCK_MASK		(0x00FF0000)
+#define SPI_NAND_SET_SCK_H(x)		((x) << 16)
+#define SPI_NAND_SET_SCK_L(x)		((x) << 20)
+#define BIT_REG_IO_CPOL             (0x01 << 24)
+#define BIT_REG_IO_CPHA             (0x01 << 25)
+
+#define REG_SPI_NAND_TRX_CTRL2  0x008
+#define BIT_REG_TRX_CMD_CONT_SIZE   (0x01 << 0)
+#define BIT_REG_TRX_DUMMY_SIZE      (0x01 << 4)
+#define BIT_REG_TRX_DATA_SIZE       (0x01 << 16)
+#define TRX_CMD_CONT_SIZE_SHIFT    (0)
+#define TRX_DUMMY_SIZE_SHIFT        (4)
+#define TRX_DATA_SIZE_SHIFT         (16)
+
+#define REG_SPI_NAND_TRX_CTRL3  0x00C
+#define BIT_REG_IO_SIZE_MODE        (0x01 << 0)
+#define SPI_NAND_CTRL3_IO_TYPE_X1_MODE      0
+#define SPI_NAND_CTRL3_IO_TYPE_X2_MODE      2
+#define SPI_NAND_CTRL3_IO_TYPE_X4_MODE      3
+//#define SPI_NAND_CTRL3_IO_TYPE_DUAL_MODE    6 // not support
+//#define SPI_NAND_CTRL3_IO_TYPE_QUAD_MODE    7 // not support
+
+#define BIT_REG_TRX_RW              (0x01 << 16) // 1 for write, 0 for read
+#define BIT_REG_TRX_DUMMY_HIZ       (0x01 << 17)
+#define BIT_REG_TRX_DMA_EN          (0x01 << 18)
+#define BIT_REG_RSP_CHK_EN          (0x01 << 19)
+
+#define REG_SPI_NAND_INT_EN         0x010
+#define BIT_REG_TRX_DONE_INT_EN         (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_EN    (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_EN      (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_EN       (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_EN      (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_EN       (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_EN         (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_EN       (0x01 << 9)
+#define BITS_SPI_NAND_INT_EN_ALL         (BIT_REG_TRX_DONE_INT_EN | BIT_REG_TRX_EXCEPTION_INT_EN \
+					| BIT_REG_TX_PUSH_ERR_INT_EN | BIT_REG_TX_POP_ERR_INT_EN \
+					| BIT_REG_RX_PUSH_ERR_INT_EN | BIT_REG_RX_POP_ERR_INT_EN \
+					| BIT_REG_DMA_DONE_INT_EN | BIT_REG_DMA_E_TERM_INT_EN)
+
+#define REG_SPI_NAND_INT_CLR        0x014
+#define BIT_REG_TRX_DONE_INT_CLR        (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_CLR   (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_CLR     (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_CLR      (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_CLR     (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_CLR      (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_CLR        (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_CLR      (0x01 << 9)
+#define BITS_SPI_NAND_INT_CLR_ALL         (BIT_REG_TRX_DONE_INT_CLR | BIT_REG_TRX_EXCEPTION_INT_CLR \
+					| BIT_REG_TX_PUSH_ERR_INT_CLR | BIT_REG_TX_POP_ERR_INT_CLR \
+					| BIT_REG_RX_PUSH_ERR_INT_CLR | BIT_REG_RX_POP_ERR_INT_CLR \
+					| BIT_REG_DMA_DONE_INT_CLR | BIT_REG_DMA_E_TERM_INT_CLR)
+
+#define REG_SPI_NAND_INT_MASK       0x018
+#define BIT_REG_TRX_DONE_INT_MSK        (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_MSK   (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_MSK     (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_MSK      (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_MSK     (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_MSK      (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_MSK        (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_MSK      (0x01 << 9)
+#define BITS_SPI_NAND_INT_MASK_ALL         (BIT_REG_TRX_DONE_INT_MSK | BIT_REG_TRX_EXCEPTION_INT_MSK \
+					| BIT_REG_TX_PUSH_ERR_INT_MSK | BIT_REG_TX_POP_ERR_INT_MSK \
+					| BIT_REG_RX_PUSH_ERR_INT_MSK | BIT_REG_RX_POP_ERR_INT_MSK \
+					| BIT_REG_DMA_DONE_INT_MSK | BIT_REG_DMA_E_TERM_INT_MSK)
+
+#define REG_SPI_NAND_INT            0x01C
+#define BIT_REG_TRX_DONE_INT            (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT       (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT         (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT          (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT         (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT          (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT            (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT          (0x01 << 9)
+#define BITS_REG_TRX_DMA_DONE_INT       (BIT_REG_TRX_DONE_INT | BIT_REG_DMA_DONE_INT)
+
+#define REG_SPI_NAND_INT_RAW            0x020
+#define BIT_REG_TRX_DONE_INT_RAW            (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_RAW       (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_RAW         (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_RAW          (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_RAW         (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_RAW          (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_RAW            (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_RAW          (0x01 << 9)
+
+#define REG_SPI_NAND_BOOT_CTRL          0x024
+#define BIT_REG_BOOT_PRD                    (0x01 << 0)
+#define BIT_REG_RSP_DLY_SEL                 (0x01 << 8)
+#define BIT_REG_RSP_NEG_SEL                 (0x01 << 12)
+#define BIT_REG_RSP_DLY_OW_EN				(0x01 << 30)
+#define BIT_REG_RSP_DLY_MASK				0xFFFFFFFE
+
+#define REG_SPI_NAND_IO_CTRL            0x028
+#define BIT_REG_CSN0_OUT_OW_EN              (0x01 << 0)
+#define BIT_REG_CSN1_OUT_OW_EN              (0x01 << 1)
+#define BIT_REG_SCK_OUT_OW_EN               (0x01 << 3)
+#define BIT_REG_MOSI_OUT_OW_EN              (0x01 << 4)
+#define BIT_REG_MISO_OUT_OW_EN              (0x01 << 5)
+#define BIT_REG_WPN_OUT_OW_EN               (0x01 << 6)
+#define BIT_REG_HOLDN_OUT_OW_EN             (0x01 << 7)
+#define BIT_REG_CSN0_OUT_OW_VAL             (0x01 << 8)
+#define BIT_REG_CSN1_OUT_OW_VAL             (0x01 << 9)
+#define BIT_REG_SCK_OUT_OW_VAL              (0x01 << 11)
+#define BIT_REG_MOSI_OUT_OW_VAL             (0x01 << 12)
+#define BIT_REG_MISO_OUT_OW_VAL             (0x01 << 13)
+#define BIT_REG_WPN_OUT_OW_VAL              (0x01 << 14)
+#define BIT_REG_HOLDN_OUT_OW_VAL            (0x01 << 15)
+#define BIT_REG_CSN0_OEN_OW_EN              (0x01 << 16)
+#define BIT_REG_CSN1_OEN_OW_EN              (0x01 << 17)
+#define BIT_REG_SCK_OEN_OW_EN               (0x01 << 19)
+#define BIT_REG_MOSI_OEN_OW_EN              (0x01 << 20)
+#define BIT_REG_MISO_OEN_OW_EN              (0x01 << 21)
+#define BIT_REG_WPN_OEN_OW_EN               (0x01 << 22)
+#define BIT_REG_HOLDN_OEN_OW_EN             (0x01 << 23)
+#define BIT_REG_CSN0_OEN_OW_VAL             (0x01 << 24)
+#define BIT_REG_CSN1_OEN_OW_VAL             (0x01 << 25)
+#define BIT_REG_SCK_OEN_OW_VAL              (0x01 << 27)
+#define BIT_REG_MOSI_OEN_OW_VAL             (0x01 << 28)
+#define BIT_REG_MISO_OEN_OW_VAL             (0x01 << 29)
+#define BIT_REG_WPN_OEN_OW_VAL              (0x01 << 30)
+#define BIT_REG_HOLDN_OEN_OW_VAL            (0x01 << 31)
+
+#define REG_SPI_NAND_IO_STATUS      0x02C
+#define BIT_REG_CSN0_VAL                (0x01 << 0)
+#define BIT_REG_CSN1_VAL                (0x01 << 1)
+#define BIT_REG_SCK_VAL                 (0x01 << 3)
+#define BIT_REG_MOSI_VAL                (0x01 << 4)
+#define BIT_REG_MISO_VAL                (0x01 << 5)
+#define BIT_REG_WPN_VAL                 (0x01 << 6)
+#define BIT_REG_HOLDN_VAL               (0x01 << 7)
+
+#define REG_SPI_NAND_TRX_CMD0       0x30
+#define BIT_REG_TRX_CMD_IDX             (0x01 << 0)
+#define BIT_REG_TRX_CMD_CONT0           (0x01 << 8)
+#define TRX_CMD_CONT0_SHIFT             (8)
+
+#define REG_SPI_NAND_TRX_CMD1           0x034
+//#define BIT_REG_TRX_CMD_CONT1               (0x01 << 0)
+
+#define REG_SPI_NAND_TRX_CS             0x3C
+#define BIT_REG_TRX_CS_SEL                  (0x01 << 0)
+
+#define REG_SPI_NAND_TRX_DMA_CTRL       0x40
+#define BIT_REG_DMA_WT_TH                   (0x01 << 0)
+#define BIT_REG_DMA_RD_TH                   (0x01 << 8)
+#define BIT_REG_DMA_REQ_SIZE                (0x01 << 16)
+#define BIT_REG_DMA_TX_EMPTY_SEL            (0x01 << 24)
+#define BIT_REG_DMA_RX_FULL_SEL             (0x01 << 25)
+
+#define REG_SPI_NAND_TRX_DMA_STATUS     0x44
+#define BIT_REG_DMA_REQ                     (0x01 << 0)
+#define BIT_REG_DMA_SINGLE                  (0x01 << 1)
+#define BIT_REG_DMA_LAST                    (0x01 << 2)
+#define BIT_REG_DMA_ACK                     (0x01 << 3)
+#define BIT_REG_DMA_FINISH                  (0x01 << 4)
+
+#define REG_SPI_NAND_TRX_DMA_SW         0x48
+#define BIT_REG_DMA_SW_MODE                 (0x01 << 0)
+#define BIT_REG_DMA_SW_ACK                  (0x01 << 8)
+#define BIT_REG_DMA_SW_FINISH               (0x01 << 9)
+
+#define REG_SPI_NAND_TX_FIFO_STATUS     0x50
+#define BIT_REG_TX_PUSH_EMPTY               (0x01 << 0)
+#define BIT_REG_TX_PUSH_AE                  (0x01 << 1)
+#define BIT_REG_TX_PUSH_HF                  (0x01 << 2)
+#define BIT_REG_TX_PUSH_AF                  (0x01 << 3)
+#define BIT_REG_TX_PUSH_FULL                (0x01 << 4)
+#define BIT_REG_TX_PUSH_ERROR               (0x01 << 5)
+#define BIT_REG_TX_PUSH_WORD_COUNT          (0x01 << 8)
+#define BIT_REG_TX_POP_EMPTY                (0x01 << 16)
+#define BIT_REG_TX_POP_AE                   (0x01 << 17)
+#define BIT_REG_TX_POP_HF                   (0x01 << 18)
+#define BIT_REG_TX_POP_AF                   (0x01 << 19)
+#define BIT_REG_TX_POP_FULL                 (0x01 << 20)
+#define BIT_REG_TX_POP_ERROR                (0x01 << 21)
+#define BIT_REG_TX_POP_WORD_COUNT           (0x01 << 24)
+
+#define REG_SPI_NAND_RX_FIFO_STATUS     0x54
+#define BIT_REG_RX_PUSH_EMPTY               (0x01 << 0)
+#define BIT_REG_RX_PUSH_AE                  (0x01 << 1)
+#define BIT_REG_RX_PUSH_HF                  (0x01 << 2)
+#define BIT_REG_RX_PUSH_AF                  (0x01 << 3)
+#define BIT_REG_RX_PUSH_FULL                (0x01 << 4)
+#define BIT_REG_RX_PUSH_ERROR               (0x01 << 5)
+#define BIT_REG_RX_PUSH_WORD_COUNT          (0x01 << 8)
+#define BIT_REG_RX_POP_EMPTY                (0x01 << 16)
+#define BIT_REG_RX_POP_AE                   (0x01 << 17)
+#define BIT_REG_RX_POP_HF                   (0x01 << 18)
+#define BIT_REG_RX_POP_AF                   (0x01 << 19)
+#define BIT_REG_RX_POP_FULL                 (0x01 << 20)
+#define BIT_REG_RX_POP_ERROR                (0x01 << 21)
+#define BIT_REG_RX_POP_WORD_COUNT           (0x01 << 24)
+
+#define REG_SPI_NAND_CMPLT_BYTE_CNT     0x58
+#define BIT_REG_CMPLT_CNT                   (0x01 << 0)
+
+#define REG_SPI_NAND_TX_DATA            0x60
+#define BIT_REG_TX_DATA                     (0x01 << 0)
+
+#define REG_SPI_NAND_RX_DATA            0x64
+#define BIT_REG_RX_DATA                     (0x01 << 0)
+
+#define REG_SPI_NAND_RSP_POLLING        0x68
+#define BIT_REG_RSP_EXP_MSK                 (0x01 << 0)
+#define BIT_REG_RSP_EXP_VAL                 (0x01 << 8)
+#define BIT_REG_RSP_WAIT_TIME_OFFSET        (16)
+
+#define REG_SPI_NAND_SPARE0             0x70
+#define BIT_REG_SPARE0                      (0x01 << 0)
+
+#define REG_SPI_NAND_SPARE1             0x74
+#define BIT_REG_SPARE1                      (0x01 << 0)
+
+#define REG_SPI_NAND_SPARE_RO           0x78
+#define BIT_REG_SPARE_RO                    (0x01 << 0)
+
+#define REG_SPI_NAND_TX_FIFO            0x800
+#define BIT_REG_TX_FIFO                     (0x01 << 0)
+
+#define REG_SPI_NAND_RX_FIFO            0xC00
+#define BIT_REG_RX_FIFO                     (0x01 << 0)
+
+#define SPI_NAND_ID_GD5F1GQ4U           0xD1C8  // SPI NAND 1Gbit 3.3V
+#define SPI_NAND_ID_GD5F1GQ4R           0xC1C8  // SPI NAND 1Gbit 1.8V
+
+#define SPI_NAND_BLOCK_RA_SHIFT         (6)     // RA<15:6>
+
+#define SPI_NAND_BLOCK_RA_NUM           (10)    // RA<15:6>
+#define SPI_NAND_PAGE_RA_NUM            (6)     // RA<5:0>
+
+#define SPI_NAND_PAGE_SIZE              (2048)
+
+/*
+ * P_FAIL : Program Fail
+ *	This bit indicates that a program failure has occurred (P_FAIL set to 1). It will also be
+ *	set if the user attempts to program an invalid address or a protected region, including
+ *	the OTP area. This bit is cleared during the PROGRAM EXECUTE command
+ *	sequence or a RESET command (P_FAIL = 0).
+ *
+ * E_FAIL : Erase Fail
+ *	This bit indicates that an erase failure has occurred (E_FAIL set to 1). It will also be
+ *	set if the user attempts to erase a locked region. This bit is cleared (E_FAIL = 0) at the
+ *	start of the BLOCK ERASE command sequence or the RESET command.
+ *
+ * WEL : Write Enable  Latch
+ *	This bit indicates the current status of the write enable latch (WEL) and must be set
+ *	(WEL = 1), prior to issuing a PROGRAM EXECUTE or BLOCK ERASE command. It
+ *	is set by issuing the WRITE ENABLE command. WEL can also be disabled (WEL =
+ *	0), by issuing the WRITE DISABLE command.
+ *
+ * OIP : Operation In Progress
+ *	This bit is set (OIP = 1 ) when a PROGRAM EXECUTE, PAGE READ, BLOCK
+ *	ERASE, or RESET command is executing, indicating the device is busy. When the bit
+ *	is 0, the interface is in the ready state
+ *
+ * Register Addr. 7        6        5      4      3        2        1        0
+ * Status C0H     Reserved Reserved ECCS1  ECCS0  P_FAIL   E_FAIL   WEL      OIP
+ * Status F0H     Reserved Reserved ECCSE1 ECCSE0 Reserved Reserved Reserved Reserved
+ *
+ * ECCS1 ECCS0 ECCSE1 ECCSE0 Description
+ *  0     0     x      x     No bit errors were detected during the previous read algorithm.
+ *  0     1     0      0     Bit errors(<4) were detected and corrected.
+ *  0     1     0      1     Bit errors(=5) were detected and corrected.
+ *  0     1     1      0     Bit errors(=6) were detected and corrected.
+ *  0     1     1      1     Bit errors(=7) were detected and corrected.
+ *  1     0     x      x     Bit errors greater than ECC capability(8 bits) and not corrected
+ *  1     1     x      x     Bit errors reach ECC capability( 8 bits) and corrected
+ */
+
+#define ECC_NOERR  0
+#define ECC_CORR   1
+#define ECC_UNCORR 2
+
+struct spinand_cmd {
+	uint8_t		cmd;
+	uint32_t		n_cmd_cont;		/* Number of command content */
+	uint8_t		content[3];	/* Command content */
+	uint32_t		n_dummy;	/* Dummy use */
+	uint32_t		n_tx;		/* Number of tx bytes */
+	uint32_t	*tx_buf;	/* Tx buf */
+	uint32_t		n_rx;		/* Number of rx bytes */
+	uint32_t		*rx_buf;	/* Rx buf */
+	uint32_t		flags;		/* Flags */
+};
+
+/*****************************************************************************/
+#define SPI_NAND_MAX_PAGESIZE			4096
+#define SPI_NAND_MAX_OOBSIZE			256
+
+#define CVSNFC_BUFFER_LEN	(SPI_NAND_MAX_PAGESIZE + SPI_NAND_MAX_OOBSIZE)
+
+/* DMA address align with 32 bytes. */
+#define CVSNFC_DMA_ALIGN			32
+
+#define CVSNFC_CHIP_DELAY			25
+
+#define CVSNFC_ADDR_CYCLE_MASK		0x2
+
+/*****************************************************************************/
+struct cvsfc_cmd_option {
+	unsigned char chipselect;
+	unsigned char command;
+	unsigned char last_cmd;
+	unsigned char address_h;
+	unsigned int address_l;
+	unsigned int date_num;
+	unsigned short option;
+	unsigned short op_config;
+};
+
+#define MAX_PAGE_SIZE	(4096)
+#define MAX_SPARE_SIZE	(256)
+
+struct cvsnfc_host;
+
+struct cvsnfc_host {
+	struct nand_chip *chip;
+	struct mtd_info *mtd;
+	struct cvsnfc_op spi[CONFIG_CVSNFC_MAX_CHIP];
+	struct cvsfc_cmd_option cmd_option;
+
+	void __iomem *tx_iobase;
+	void __iomem *rx_iobase;
+	void __iomem *regbase;
+	void __iomem *dmabase;
+
+	unsigned int NFC_CFG;
+
+	unsigned int offset;
+
+	struct device *dev;
+
+	unsigned int flags;
+
+	unsigned int addr_cycle;
+	unsigned int addr_value[2]; // 0:column, 1:row address
+	unsigned int cache_addr_value[2];
+	unsigned int column;
+	unsigned int block_page_cnt;
+	unsigned int block_page_mask;
+
+	unsigned int dma_buffer;
+	unsigned int dma_oob;
+
+	unsigned int ecctype;
+	unsigned int pagesize;
+	unsigned int oobsize;
+	unsigned long long diesize;
+
+	/* This is maybe an un-aligment address, only for malloc or free */
+	char *buforg;
+	char *buffer;
+
+	int add_partition;
+
+	/* BOOTROM read two bytes to detect the bad block flag */
+#define HINFC_BAD_BLOCK_POS              0
+	unsigned char *bbm;  /* nand bad block mark */
+	unsigned short *epm;  /* nand empty page mark */
+
+	unsigned int uc_er;
+
+	void (*set_system_clock)(struct spi_op_info *op, int clk_en);
+
+	void (*send_cmd_pageprog)(struct cvsnfc_host *host);
+	void (*send_cmd_status)(struct cvsnfc_host *host);
+	void (*send_cmd_readstart)(struct cvsnfc_host *host);
+	void (*send_cmd_erase)(struct cvsnfc_host *host);
+	void (*send_cmd_readid)(struct cvsnfc_host *host);
+	void (*send_cmd_reset)(struct cvsnfc_host *host);
+	struct cvsnfc_chip_info *nand_chip_info;
+};
+
+struct cvsnfc_dly_param_grp {
+	unsigned int start;
+	unsigned int count;
+};
+/*****************************************************************************/
+#define cvsfc_read(_host, _reg) \
+	readl((_host)->regbase + (_reg))
+
+#define cvsfc_write(_host, _reg, _value) \
+	writel((_value), ((_host)->regbase + (_reg)))
+
+void cvsnfc_register_dump(void);
+void cvsnfc_dump_save_register(void);
+
+/*****************************************************************************/
+#define DBG_BUG(fmt, args...) do { \
+	printf("%s(%d): BUG: " fmt, __FILE__, __LINE__, ##args); \
+	while (1) \
+		; \
+} while (0)
+
+/*****************************************************************************/
+#define CVSNFC_WAIT_TIMEOUT 1000000
+
+#define CVSNFC_CMD_WAIT_CPU_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), REG_SPI_NAND_INT); \
+		--timeout; \
+	} while ((regval & BIT_REG_TRX_DONE_INT) == 0 && timeout); \
+	if (!timeout) \
+		DBG_BUG("cvsnfc wait cmd cpu finish timeout!\n"); \
+} while (0)
+
+#define CVSNFC_WAIT_DMA_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), REG_SPI_NAND_INT); \
+		--timeout; \
+	} while ((regval & BIT_REG_DMA_DONE_INT) == 0 && timeout); \
+	if (!timeout) \
+		DBG_BUG("cvsnfc  wait dma finish timeout!\n"); \
+} while (0)
+
+/*****************************************************************************/
+#define CVSNFC_DMA_WAIT_INT_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), CVSNFC_INT); \
+		--timeout; \
+	} while ((!(regval & CVSNFC_INT_OP_DONE) && timeout)); \
+	if (!timeout) \
+		DBG_BUG("cvsnfc100 wait dma int finish timeout!\n"); \
+} while (0)
+
+/*****************************************************************************/
+#define CVSNFC_DMA_WAIT_CPU_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), CVSNFC_OP_CTRL); \
+		--timeout; \
+	} while ((regval & CVSNFC_OP_CTRL_OP_READY) && timeout); \
+	if (!timeout) \
+		DBG_BUG("dma wait cpu finish timeout\n"); \
+} while (0)
+
+static inline void CVSNFC_CLEAR_INT(struct cvsnfc_host *host)
+{
+	unsigned int regval;
+
+	regval = cvsfc_read((host), REG_SPI_NAND_INT);
+	cvsfc_write((host), REG_SPI_NAND_INT, regval);
+}
+
+void cvsnfc_ctrl_ecc(struct mtd_info *mtd, bool enable);
+int spi_nand_adjust_max_freq(struct cvsnfc_host *host, uint32_t *pattern1, uint32_t *pattern2);
+int check_and_update_fip_bin(void);
+int do_cvi_update_spinand(uint32_t component, void *addr);
+void bbt_dump_buf(char *s, void *buf, int len);
+struct cvsnfc_host *cvsnfc_get_host(void);
+int cvsnfc_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+		     uint8_t *buf, int bytes, int page);
+int cvsnfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		      const uint8_t *buf, int oob_required, int page);
+int cvsnfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+			 uint8_t *buf, int oob_required, int page);
+
+void cvsnfc_send_cmd_erase(struct cvsnfc_host *host);
+/******************************************************************************/
+#endif /* __CVSNFC_H__ */
+
diff --git a/include/cvsnfc_common.h b/include/cvsnfc_common.h
new file mode 100644
index 000000000..895451a39
--- /dev/null
+++ b/include/cvsnfc_common.h
@@ -0,0 +1,166 @@
+#ifndef __CVSNFC_COMMON_H__
+#define __CVSNFC_COMMON_H__
+
+#include <linux/mtd/rawnand.h>
+#include <linux/delay.h>
+
+/*****************************************************************************/
+#define _512B					(512)
+#define _1K					(1024)
+#define _2K					(2048)
+#define _4K					(4096)
+#define _8K					(8192)
+#define _16K					(16384)
+#define _32K					(32768)
+#define _64K					(0x10000UL)
+#define _128K					(0x20000UL)
+#define _256K					(0x40000UL)
+#define _512K					(0x80000UL)
+#define _1M					(0x100000UL)
+#define _2M					(0x200000UL)
+#define _4M					(0x400000UL)
+#define _8M					(0x800000UL)
+#define _16M					(0x1000000UL)
+#define _32M					(0x2000000UL)
+#define _64M					(0x4000000UL)
+#define _128M					(0x8000000UL)
+#define _256M					(0x10000000UL)
+#define _512M					(0x20000000UL)
+#define _1G					(0x40000000ULL)
+#define _2G					(0x80000000ULL)
+#define _4G					(0x100000000ULL)
+#define _8G					(0x200000000ULL)
+#define _16G					(0x400000000ULL)
+#define _64G					(0x1000000000ULL)
+
+/*****************************************************************************/
+#define NAND_PAGE_512B                   0
+#define NAND_PAGE_1K                     1
+#define NAND_PAGE_2K                     2
+#define NAND_PAGE_4K                     3
+#define NAND_PAGE_8K                     4
+#define NAND_PAGE_16K                    5
+#define NAND_PAGE_32K                    6
+
+/*****************************************************************************/
+#define NAND_ECC_NONE                    0
+#define NAND_ECC_0BIT                    0
+#define NAND_ECC_1BIT                    1
+#define NAND_ECC_1BIT_512                1
+#define NAND_ECC_4BIT                    2
+#define NAND_ECC_4BIT_512                2
+#define NAND_ECC_4BYTE                   2
+#define NAND_ECC_8BIT                    2
+#define NAND_ECC_8BIT_512                3
+#define NAND_ECC_8BYTE                   3
+#define NAND_ECC_13BIT                   4
+#define NAND_ECC_16BIT                   5
+#define NAND_ECC_18BIT                   6
+#define NAND_ECC_24BIT                   7
+#define NAND_ECC_27BIT                   8
+#define NAND_ECC_28BIT                   9
+#define NAND_ECC_32BIT                   10
+#define NAND_ECC_40BIT                   11
+#define NAND_ECC_41BIT                   12
+#define NAND_ECC_42BIT                   13
+#define NAND_ECC_48BIT                   14
+#define NAND_ECC_60BIT                   15
+#define NAND_ECC_64BIT                   16
+#define NAND_ECC_72BIT                   17
+#define NAND_ECC_80BIT                   18
+
+#define ERSTR_HARDWARE                   "Hardware configuration error."
+#define ERSTR_DRIVER                     "Driver does not support."
+
+#define DISABLE                          0
+#define ENABLE                           1
+
+#if defined(CONFIG_NAND_FLASH_CVSNFC)
+/*****************************************************************************/
+
+struct match_reg_type {
+	int reg;
+	int type;
+};
+
+struct match_type_str {
+	int type;
+	const char *str;
+};
+
+enum ecc_type {
+	et_ecc_none    = 0x00,
+	et_ecc_1bit    = 0x01,
+	et_ecc_4bit    = 0x02,
+	et_ecc_8bit    = 0x03,
+	et_ecc_24bit1k = 0x04,
+	et_ecc_40bit1k = 0x05,
+	et_ecc_64bit1k = 0x06,
+};
+
+enum page_type {
+	pt_pagesize_512   = 0x00,
+	pt_pagesize_2K    = 0x01,
+	pt_pagesize_4K    = 0x02,
+	pt_pagesize_8K    = 0x03,
+	pt_pagesize_16K   = 0x04,
+};
+
+struct nand_config_info {
+	unsigned int pagetype;
+	unsigned int ecctype;
+	unsigned int oobsize;
+	struct nand_ecclayout *layout;
+};
+
+#endif
+
+/*****************************************************************************/
+struct nand_flash_dev_ex {
+	struct nand_flash_dev flash_dev;
+
+	char *start_type;
+	unsigned char ids[8];
+	int oobsize;
+	int ecctype;
+
+#define NAND_RANDOMIZER        0x01 /* nand chip need randomizer */
+#define NAND_HW_AUTO           0x02 /*controller support hardware auto config*/
+#define NAND_SYNCHRONOUS       0x04 /* nand chip support synchronous */
+#define NAND_ASYNCHRONOUS      0x08 /* nand chip support asynchronous */
+#define NAND_SYNCHRONOUS_BOOT  0x10 /* nand boot from synchronous mode */
+#define NAND_CONFIG_DONE       0x20 /* current controller config finish */
+	int flags;
+	int is_randomizer;
+#define NAND_RR_NONE                   0x00
+#define NAND_RR_HYNIX_BG_BDIE          0x10
+#define NAND_RR_HYNIX_BG_CDIE          0x11
+#define NAND_RR_HYNIX_CG_ADIE          0x12
+#define NAND_RR_MICRON                 0x20
+#define NAND_RR_SAMSUNG                0x30
+#define NAND_RR_TOSHIBA_24nm           0x40
+#define NAND_RR_TOSHIBA_19nm           0x41
+#define NAND_RR_MASK                   0xF0
+	int read_retry_type;
+
+	int hostver; /* host controller version. */
+};
+
+/*****************************************************************************/
+int nandpage_size2type(int size);
+
+int nandpage_type2size(int size);
+
+/*****************************************************************************/
+extern int nand_get_ecctype(void);
+
+extern struct nand_flash_dev
+	*(*nand_get_spl_flash_type)(struct mtd_info *mtd,
+				    struct nand_chip *chip,
+				    struct nand_flash_dev_ex *flash_dev_ex);
+
+extern int (*nand_oob_resize)(struct mtd_info *mtd, struct nand_chip *chip,
+			      struct nand_flash_dev_ex *flash_dev_ex);
+
+#endif /* End of __CVSNFC_COMMON_H__ */
+
diff --git a/include/cvsnfc_spi_ids.h b/include/cvsnfc_spi_ids.h
new file mode 100644
index 000000000..f91453740
--- /dev/null
+++ b/include/cvsnfc_spi_ids.h
@@ -0,0 +1,167 @@
+#ifndef __CVSNFC_SPI_IDSH
+#define __CVSNFC_SPI_IDSH
+
+/*****************************************************************************/
+#define INFINITE			(0xFFFFFFFF)
+
+#define DEFAULT_ID_LEN			2
+#define MAX_ID_LEN			3
+#define MAX_SPI_NAND_OP			8
+
+#define BBP_LAST_PAGE			0x01
+#define BBP_FIRST_PAGE			0x02
+#define BBP_FIRST_2_PAGE		0x03
+
+/*****************************************************************************/
+#define SPI_IF_READ_STD			(0x01)
+#define SPI_IF_READ_FAST		(0x02)
+#define SPI_IF_READ_DUAL		(0x04)
+#define SPI_IF_READ_DUAL_ADDR		(0x08)
+#define SPI_IF_READ_QUAD		(0x10)
+#define SPI_IF_READ_QUAD_ADDR		(0x20)
+
+#define SPI_IF_WRITE_STD		(0x01)
+#define SPI_IF_WRITE_DUAL		(0x02)
+#define SPI_IF_WRITE_DUAL_ADDR		(0x04)
+#define SPI_IF_WRITE_QUAD		(0x08)
+#define SPI_IF_WRITE_QUAD_ADDR		(0x10)
+
+#define SPI_IF_ERASE_SECTOR_128K	(0x08)  /* 128K */
+#define SPI_IF_ERASE_SECTOR_256K	(0x10)  /* 256K */
+
+/******************************************************************************/
+#define CVSNFC_SUPPORT_READ		(SPI_IF_READ_STD \
+					| SPI_IF_READ_FAST \
+					| SPI_IF_READ_DUAL \
+					| SPI_IF_READ_DUAL_ADDR \
+					| SPI_IF_READ_QUAD \
+					| SPI_IF_READ_QUAD_ADDR)
+
+#define CVSNFC_SUPPORT_WRITE		(SPI_IF_WRITE_STD | SPI_IF_WRITE_QUAD)
+
+#define CVSNFC_SUPPORT_MAX_DUMMY	8
+
+#define SPI_NAND_READ			0
+#define SPI_NAND_WRITE			1
+
+#define CVSNFC_IFCYCLE_STD				0
+#define CVSNFC_IFCYCLE_DUAL				1
+#define CVSNFC_IFCYCLE_DUAL_ADDR			2
+#define CVSNFC_IFCYCLE_QUAD				3
+#define CVSNFC_IFCYCLE_QUAD_ADDR			4
+
+/*****************************************************************************/
+#define SPI_CMD_WREN			0x06   /* Write Enable */
+#define SPI_CMD_WRDI			0x04   /* Write Disable */
+
+#define SPI_CMD_GET_FEATURES		0x0F   /* Get Features */
+#define SPI_CMD_SET_FEATURE		0x1F   /* Set Feature */
+
+#define SPI_CMD_PAGE_READ		0x13   /* Page Read to Cache */
+#define SPI_CMD_READ_STD	0x03   /* Read From Cache at Standard Speed */
+#define SPI_CMD_READ_FAST	0x0B   /* Read From Cache at Higher Speed */
+#define SPI_CMD_READ_DUAL	0x3B   /* Read From Cache at Dual Output */
+#define SPI_CMD_READ_QUAD	0x6B   /* Read From Cache at Quad Output */
+#define SPI_CMD_READ_DUAL_ADDR	0xBB   /* Read From Cache at Dual I/O */
+#define SPI_CMD_READ_QUAD_ADDR	0xEB   /* Read From Cache at Quad I/O */
+
+#define SPI_CMD_RDID			0x9F   /* Read Identification */
+
+#define SPI_CMD_WRITE_STD	0x02   /* Page Load at Standard Input */
+#define SPI_CMD_WRITE_QUAD	0x32   /* Page Load at Quad Input */
+
+#define SPI_CMD_SE_128K			0xD8   /* 128KB sector Erase */
+#define SPI_CMD_SE_256K			0xD8   /* 256KB sector Erase */
+
+#define SPI_CMD_RESET			0xff   /* Reset the device */
+
+/*****************************************************************************/
+/* SPI operation information */
+struct spi_op_info {
+	unsigned char  iftype;
+	unsigned char  cmd;
+	unsigned char  dummy;
+	unsigned int   size;
+	unsigned int   clock;
+};
+
+struct spi_nand_driver;
+
+struct cvsnfc_op {
+	void *host;
+	struct spi_nand_driver *driver;
+	struct spi_op_info  read[1];
+	struct spi_op_info  write[1];
+	struct spi_op_info  erase[MAX_SPI_NAND_OP];
+};
+
+struct spi_nand_driver {
+	int (*wait_ready)(struct cvsnfc_op *spi);
+	int (*write_enable)(struct cvsnfc_op *spi);
+	int (*qe_enable)(struct cvsnfc_op *spi);
+	int (*ecc_enable)(struct cvsnfc_op *spi);
+	int (*select_die)(struct cvsnfc_op *spi, unsigned int id);
+	unsigned char ecc_uncorr;
+};
+
+#define FLAGS_SET_PLANE_BIT		BIT(0)
+#define NAND_SET_PLANE_BIT	BIT(0)
+#define SPI_NAND_MULTIPLANE_BIT		BIT(12)
+
+#define FLAGS_SET_QE_BIT		(BIT(1))
+#define FLAGS_ENABLE_X2_BIT		(BIT(2))
+#define FLAGS_ENABLE_X4_BIT		(BIT(3))
+#define FLAGS_OW_SETTING_BIT	(BIT(4))
+#define FLAGS_ONLY_ONEBIT_MODE_BIT	(BIT(5))
+#define FLAGS_CONTORL_WP_BIT		(BIT(6))
+#define FLAGS_SUPPORT_W_TWICE_DEBUG	(BIT(7))
+
+#define SPI_NAND_FREQ_XTAL	0 /* 6.25 Mhz */
+#define SPI_NAND_FREQ_23MHz	1 /* 23.4375 Mhz */
+#define SPI_NAND_FREQ_26MHz	2 /* 26.7857 Mhz */
+#define SPI_NAND_FREQ_31MHz	3 /* 31.25 Mhz */
+#define SPI_NAND_FREQ_37MHz	4 /* 37.5 Mhz */
+#define SPI_NAND_FREQ_46MHz	5 /* 46.875 Mhz */
+#define SPI_NAND_FREQ_62MHz	6 /* 62.5 Mhz */
+#define SPI_NAND_FREQ_93MHz	7 /* 93.75 Mhz */
+
+struct cvsnfc_chip_info {
+	char *name;
+	unsigned char id[MAX_ID_LEN];
+	unsigned char id_len;
+	unsigned long long chipsize;
+	unsigned long long diesize;
+	unsigned int erasesize;
+	unsigned int pagesize;
+	unsigned int oobsize;
+	unsigned int badblock_pos;
+	unsigned int flags;
+	struct spi_op_info *read[MAX_SPI_NAND_OP];
+	struct spi_op_info *write[MAX_SPI_NAND_OP];
+	struct spi_op_info *erase[MAX_SPI_NAND_OP];
+	struct spi_nand_driver *driver;
+	uint8_t ecc_en_feature_offset;
+	uint8_t ecc_en_mask;
+	uint8_t ecc_status_offset;
+	uint8_t ecc_status_mask;
+	uint8_t ecc_status_shift;
+	uint8_t ecc_status_uncorr_val;
+	uint8_t sck_l;
+	uint8_t sck_h;
+	uint16_t max_freq;
+	uint32_t sample_param;
+	uint8_t xtal_switch;
+};
+
+/*****************************************************************************/
+void spi_nand_ids_register(void);
+
+void cvsnfc_get_best_clock(unsigned int *clock);
+
+struct cvsnfc_host;
+
+void spi_feature_op(struct cvsnfc_host *host, int op, int addr, unsigned int *val);
+
+/******************************************************************************/
+
+#endif /* __CVSNFC_SPI_IDSH */
diff --git a/include/display_options.h b/include/display_options.h
index 43810cbe2..0b090e0e8 100644
--- a/include/display_options.h
+++ b/include/display_options.h
@@ -70,7 +70,7 @@ int print_buffer(ulong addr, const void *data, uint width, uint count,
  *
  */
 int hexdump_line(ulong addr, const void *data, uint width, uint count,
-		 uint linelen, char *out, int size);
+		 uint linelen, char *out, size_t size);
 
 /**
  * display_options() - display the version string / build tag
diff --git a/include/dt-bindings/clock/cv180x-clock.h b/include/dt-bindings/clock/cv180x-clock.h
new file mode 100644
index 000000000..afddc4db7
--- /dev/null
+++ b/include/dt-bindings/clock/cv180x-clock.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cv181x-clock.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_CLK_CV180X_H__
+#define __DT_BINDINGS_CLK_CV180X_H__
+
+#define CV180X_CLK_MPLL				0
+#define CV180X_CLK_TPLL				1
+#define CV180X_CLK_FPLL				2
+#define CV180X_CLK_MIPIMPLL			3
+#define CV180X_CLK_A0PLL				4
+#define CV180X_CLK_DISPPLL			5
+#define CV180X_CLK_CAM0PLL			6
+#define CV180X_CLK_CAM1PLL			7
+
+#define CV180X_CLK_A53				8
+#define CV180X_CLK_CPU_AXI0			9
+#define CV180X_CLK_CPU_GIC			10
+#define CV180X_CLK_XTAL_A53			11
+#define CV180X_CLK_TPU				12
+#define CV180X_CLK_TPU_FAB			13
+#define CV180X_CLK_AHB_ROM			14
+#define CV180X_CLK_DDR_AXI_REG			15
+#define CV180X_CLK_RTC_25M			16
+#define CV180X_CLK_TEMPSEN			17
+#define CV180X_CLK_SARADC				18
+#define CV180X_CLK_EFUSE				19
+#define CV180X_CLK_APB_EFUSE			20
+#define CV180X_CLK_DEBUG				21
+#define CV180X_CLK_XTAL_MISC			22
+#define CV180X_CLK_AXI4_EMMC			23
+#define CV180X_CLK_EMMC				24
+#define CV180X_CLK_100K_EMMC			25
+#define CV180X_CLK_AXI4_SD0			26
+#define CV180X_CLK_SD0				27
+#define CV180X_CLK_100K_SD0			28
+#define CV180X_CLK_AXI4_SD1			29
+#define CV180X_CLK_SD1				30
+#define CV180X_CLK_100K_SD1			31
+#define CV180X_CLK_SPI_NAND			32
+#define CV180X_CLK_500M_ETH0			33
+#define CV180X_CLK_AXI4_ETH0			34
+#define CV180X_CLK_500M_ETH1			35
+#define CV180X_CLK_AXI4_ETH1			36
+#define CV180X_CLK_APB_GPIO			37
+#define CV180X_CLK_APB_GPIO_INTR			38
+#define CV180X_CLK_GPIO_DB			39
+#define CV180X_CLK_AHB_SF				40
+#define CV180X_CLK_SDMA_AXI			41
+#define CV180X_CLK_SDMA_AUD0			42
+#define CV180X_CLK_SDMA_AUD1			43
+#define CV180X_CLK_SDMA_AUD2			44
+#define CV180X_CLK_SDMA_AUD3			45
+#define CV180X_CLK_APB_I2C			46
+#define CV180X_CLK_APB_WDT			47
+#define CV180X_CLK_PWM				48
+#define CV180X_CLK_APB_SPI0			49
+#define CV180X_CLK_APB_SPI1			50
+#define CV180X_CLK_APB_SPI2			51
+#define CV180X_CLK_APB_SPI3			52
+#define CV180X_CLK_CAM0_200			53
+#define CV180X_CLK_UART0				54
+#define CV180X_CLK_APB_UART0			55
+#define CV180X_CLK_UART1				56
+#define CV180X_CLK_APB_UART1			57
+#define CV180X_CLK_UART2				58
+#define CV180X_CLK_APB_UART2			59
+#define CV180X_CLK_UART3				60
+#define CV180X_CLK_APB_UART3			61
+#define CV180X_CLK_UART4				62
+#define CV180X_CLK_APB_UART4			63
+#define CV180X_CLK_APB_I2S0			64
+#define CV180X_CLK_APB_I2S1			65
+#define CV180X_CLK_APB_I2S2			66
+#define CV180X_CLK_APB_I2S3			67
+#define CV180X_CLK_AXI4_USB			68
+#define CV180X_CLK_APB_USB			69
+#define CV180X_CLK_125M_USB			70
+#define CV180X_CLK_33K_USB			71
+#define CV180X_CLK_12M_USB			72
+#define CV180X_CLK_AXI4				73
+#define CV180X_CLK_AXI6				74
+#define CV180X_CLK_DSI_ESC			75
+#define CV180X_CLK_AXI_VIP			76
+#define CV180X_CLK_SRC_VIP_SYS_0			77
+#define CV180X_CLK_SRC_VIP_SYS_1			78
+#define CV180X_CLK_DISP_SRC_VIP			79
+#define CV180X_CLK_AXI_VIDEO_CODEC		80
+#define CV180X_CLK_VC_SRC0			81
+#define CV180X_CLK_H264C				82
+#define CV180X_CLK_H265C				83
+#define CV180X_CLK_JPEG				84
+#define CV180X_CLK_APB_JPEG			85
+#define CV180X_CLK_APB_H264C			86
+#define CV180X_CLK_APB_H265C			87
+#define CV180X_CLK_CAM0				88
+#define CV180X_CLK_CAM1				89
+#define CV180X_CLK_CSI_MAC0_VIP			90
+#define CV180X_CLK_CSI_MAC1_VIP			91
+#define CV180X_CLK_ISP_TOP_VIP			92
+#define CV180X_CLK_IMG_D_VIP			93
+#define CV180X_CLK_IMG_V_VIP			94
+#define CV180X_CLK_SC_TOP_VIP			95
+#define CV180X_CLK_SC_D_VIP			96
+#define CV180X_CLK_SC_V1_VIP			97
+#define CV180X_CLK_SC_V2_VIP			98
+#define CV180X_CLK_SC_V3_VIP			99
+#define CV180X_CLK_DWA_VIP			100
+#define CV180X_CLK_BT_VIP				101
+#define CV180X_CLK_DISP_VIP			102
+#define CV180X_CLK_DSI_MAC_VIP			103
+#define CV180X_CLK_LVDS0_VIP			104
+#define CV180X_CLK_LVDS1_VIP			105
+#define CV180X_CLK_CSI0_RX_VIP			106
+#define CV180X_CLK_CSI1_RX_VIP			107
+#define CV180X_CLK_PAD_VI_VIP			108
+#define CV180X_CLK_1M				109
+#define CV180X_CLK_SPI				110
+#define CV180X_CLK_I2C				111
+#define CV180X_CLK_PM				112
+#define CV180X_CLK_TIMER0				113
+#define CV180X_CLK_TIMER1				114
+#define CV180X_CLK_TIMER2				115
+#define CV180X_CLK_TIMER3				116
+#define CV180X_CLK_TIMER4				117
+#define CV180X_CLK_TIMER5				118
+#define CV180X_CLK_TIMER6				119
+#define CV180X_CLK_TIMER7				120
+#define CV180X_CLK_APB_I2C0			121
+#define CV180X_CLK_APB_I2C1			122
+#define CV180X_CLK_APB_I2C2			123
+#define CV180X_CLK_APB_I2C3			124
+#define CV180X_CLK_APB_I2C4			125
+#define CV180X_CLK_WGN				126
+#define CV180X_CLK_WGN0				127
+#define CV180X_CLK_WGN1				128
+#define CV180X_CLK_WGN2				129
+#define CV180X_CLK_KEYSCAN			130
+#define CV180X_CLK_AHB_SF1			131
+#define CV180X_CLK_VC_SRC1			132
+#define CV180X_CLK_SRC_VIP_SYS_2			133
+#define CV180X_CLK_PAD_VI1_VIP			134
+#define CV180X_CLK_CFG_REG_VIP			135
+#define CV180X_CLK_CFG_REG_VC			136
+#define CV180X_CLK_AUDSRC				137
+#define CV180X_CLK_APB_AUDSRC			138
+#define CV180X_CLK_VC_SRC2			139
+#define CV180X_CLK_PWM_SRC			140
+#define CV180X_CLK_AP_DEBUG			141
+#define CV180X_CLK_SRC_RTC_SYS_0			142
+#define CV180X_CLK_PAD_VI2_VIP			143
+#define CV180X_CLK_CSI_BE_VIP			144
+#define CV180X_CLK_VIP_IP0			145
+#define CV180X_CLK_VIP_IP1			146
+#define CV180X_CLK_VIP_IP2			147
+#define CV180X_CLK_VIP_IP3			148
+#define CV180X_CLK_C906_0				149
+#define CV180X_CLK_C906_1				150
+#define CV180X_CLK_SRC_VIP_SYS_3			151
+#define CV180X_CLK_SRC_VIP_SYS_4			152
+#define CV180X_CLK_IVE_VIP			153
+#define CV180X_CLK_RAW_VIP			154
+#define CV180X_CLK_OSDC_VIP			155
+#define CV180X_CLK_CSI_MAC2_VIP			156
+#define CV180X_CLK_CAM0_VIP			157
+
+#endif /* __DT_BINDINGS_CLK_CV180X_H__ */
diff --git a/include/dt-bindings/clock/cv181x-clock.h b/include/dt-bindings/clock/cv181x-clock.h
new file mode 100644
index 000000000..fa041e452
--- /dev/null
+++ b/include/dt-bindings/clock/cv181x-clock.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cv181x-clock.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_CLK_CV181X_H__
+#define __DT_BINDINGS_CLK_CV181X_H__
+
+#define CV181X_CLK_MPLL				0
+#define CV181X_CLK_TPLL				1
+#define CV181X_CLK_FPLL				2
+#define CV181X_CLK_MIPIMPLL			3
+#define CV181X_CLK_A0PLL				4
+#define CV181X_CLK_DISPPLL			5
+#define CV181X_CLK_CAM0PLL			6
+#define CV181X_CLK_CAM1PLL			7
+
+#define CV181X_CLK_A53				8
+#define CV181X_CLK_CPU_AXI0			9
+#define CV181X_CLK_CPU_GIC			10
+#define CV181X_CLK_XTAL_A53			11
+#define CV181X_CLK_TPU				12
+#define CV181X_CLK_TPU_FAB			13
+#define CV181X_CLK_AHB_ROM			14
+#define CV181X_CLK_DDR_AXI_REG			15
+#define CV181X_CLK_RTC_25M			16
+#define CV181X_CLK_TEMPSEN			17
+#define CV181X_CLK_SARADC				18
+#define CV181X_CLK_EFUSE				19
+#define CV181X_CLK_APB_EFUSE			20
+#define CV181X_CLK_DEBUG				21
+#define CV181X_CLK_XTAL_MISC			22
+#define CV181X_CLK_AXI4_EMMC			23
+#define CV181X_CLK_EMMC				24
+#define CV181X_CLK_100K_EMMC			25
+#define CV181X_CLK_AXI4_SD0			26
+#define CV181X_CLK_SD0				27
+#define CV181X_CLK_100K_SD0			28
+#define CV181X_CLK_AXI4_SD1			29
+#define CV181X_CLK_SD1				30
+#define CV181X_CLK_100K_SD1			31
+#define CV181X_CLK_SPI_NAND			32
+#define CV181X_CLK_500M_ETH0			33
+#define CV181X_CLK_AXI4_ETH0			34
+#define CV181X_CLK_500M_ETH1			35
+#define CV181X_CLK_AXI4_ETH1			36
+#define CV181X_CLK_APB_GPIO			37
+#define CV181X_CLK_APB_GPIO_INTR			38
+#define CV181X_CLK_GPIO_DB			39
+#define CV181X_CLK_AHB_SF				40
+#define CV181X_CLK_SDMA_AXI			41
+#define CV181X_CLK_SDMA_AUD0			42
+#define CV181X_CLK_SDMA_AUD1			43
+#define CV181X_CLK_SDMA_AUD2			44
+#define CV181X_CLK_SDMA_AUD3			45
+#define CV181X_CLK_APB_I2C			46
+#define CV181X_CLK_APB_WDT			47
+#define CV181X_CLK_PWM				48
+#define CV181X_CLK_APB_SPI0			49
+#define CV181X_CLK_APB_SPI1			50
+#define CV181X_CLK_APB_SPI2			51
+#define CV181X_CLK_APB_SPI3			52
+#define CV181X_CLK_CAM0_200			53
+#define CV181X_CLK_UART0				54
+#define CV181X_CLK_APB_UART0			55
+#define CV181X_CLK_UART1				56
+#define CV181X_CLK_APB_UART1			57
+#define CV181X_CLK_UART2				58
+#define CV181X_CLK_APB_UART2			59
+#define CV181X_CLK_UART3				60
+#define CV181X_CLK_APB_UART3			61
+#define CV181X_CLK_UART4				62
+#define CV181X_CLK_APB_UART4			63
+#define CV181X_CLK_APB_I2S0			64
+#define CV181X_CLK_APB_I2S1			65
+#define CV181X_CLK_APB_I2S2			66
+#define CV181X_CLK_APB_I2S3			67
+#define CV181X_CLK_AXI4_USB			68
+#define CV181X_CLK_APB_USB			69
+#define CV181X_CLK_125M_USB			70
+#define CV181X_CLK_33K_USB			71
+#define CV181X_CLK_12M_USB			72
+#define CV181X_CLK_AXI4				73
+#define CV181X_CLK_AXI6				74
+#define CV181X_CLK_DSI_ESC			75
+#define CV181X_CLK_AXI_VIP			76
+#define CV181X_CLK_SRC_VIP_SYS_0			77
+#define CV181X_CLK_SRC_VIP_SYS_1			78
+#define CV181X_CLK_DISP_SRC_VIP			79
+#define CV181X_CLK_AXI_VIDEO_CODEC		80
+#define CV181X_CLK_VC_SRC0			81
+#define CV181X_CLK_H264C				82
+#define CV181X_CLK_H265C				83
+#define CV181X_CLK_JPEG				84
+#define CV181X_CLK_APB_JPEG			85
+#define CV181X_CLK_APB_H264C			86
+#define CV181X_CLK_APB_H265C			87
+#define CV181X_CLK_CAM0				88
+#define CV181X_CLK_CAM1				89
+#define CV181X_CLK_CSI_MAC0_VIP			90
+#define CV181X_CLK_CSI_MAC1_VIP			91
+#define CV181X_CLK_ISP_TOP_VIP			92
+#define CV181X_CLK_IMG_D_VIP			93
+#define CV181X_CLK_IMG_V_VIP			94
+#define CV181X_CLK_SC_TOP_VIP			95
+#define CV181X_CLK_SC_D_VIP			96
+#define CV181X_CLK_SC_V1_VIP			97
+#define CV181X_CLK_SC_V2_VIP			98
+#define CV181X_CLK_SC_V3_VIP			99
+#define CV181X_CLK_DWA_VIP			100
+#define CV181X_CLK_BT_VIP				101
+#define CV181X_CLK_DISP_VIP			102
+#define CV181X_CLK_DSI_MAC_VIP			103
+#define CV181X_CLK_LVDS0_VIP			104
+#define CV181X_CLK_LVDS1_VIP			105
+#define CV181X_CLK_CSI0_RX_VIP			106
+#define CV181X_CLK_CSI1_RX_VIP			107
+#define CV181X_CLK_PAD_VI_VIP			108
+#define CV181X_CLK_1M				109
+#define CV181X_CLK_SPI				110
+#define CV181X_CLK_I2C				111
+#define CV181X_CLK_PM				112
+#define CV181X_CLK_TIMER0				113
+#define CV181X_CLK_TIMER1				114
+#define CV181X_CLK_TIMER2				115
+#define CV181X_CLK_TIMER3				116
+#define CV181X_CLK_TIMER4				117
+#define CV181X_CLK_TIMER5				118
+#define CV181X_CLK_TIMER6				119
+#define CV181X_CLK_TIMER7				120
+#define CV181X_CLK_APB_I2C0			121
+#define CV181X_CLK_APB_I2C1			122
+#define CV181X_CLK_APB_I2C2			123
+#define CV181X_CLK_APB_I2C3			124
+#define CV181X_CLK_APB_I2C4			125
+#define CV181X_CLK_WGN				126
+#define CV181X_CLK_WGN0				127
+#define CV181X_CLK_WGN1				128
+#define CV181X_CLK_WGN2				129
+#define CV181X_CLK_KEYSCAN			130
+#define CV181X_CLK_AHB_SF1			131
+#define CV181X_CLK_VC_SRC1			132
+#define CV181X_CLK_SRC_VIP_SYS_2			133
+#define CV181X_CLK_PAD_VI1_VIP			134
+#define CV181X_CLK_CFG_REG_VIP			135
+#define CV181X_CLK_CFG_REG_VC			136
+#define CV181X_CLK_AUDSRC				137
+#define CV181X_CLK_APB_AUDSRC			138
+#define CV181X_CLK_VC_SRC2			139
+#define CV181X_CLK_PWM_SRC			140
+#define CV181X_CLK_AP_DEBUG			141
+#define CV181X_CLK_SRC_RTC_SYS_0			142
+#define CV181X_CLK_PAD_VI2_VIP			143
+#define CV181X_CLK_CSI_BE_VIP			144
+#define CV181X_CLK_VIP_IP0			145
+#define CV181X_CLK_VIP_IP1			146
+#define CV181X_CLK_VIP_IP2			147
+#define CV181X_CLK_VIP_IP3			148
+#define CV181X_CLK_C906_0				149
+#define CV181X_CLK_C906_1				150
+#define CV181X_CLK_SRC_VIP_SYS_3			151
+#define CV181X_CLK_SRC_VIP_SYS_4			152
+#define CV181X_CLK_IVE_VIP			153
+#define CV181X_CLK_RAW_VIP			154
+#define CV181X_CLK_OSDC_VIP			155
+#define CV181X_CLK_CSI_MAC2_VIP			156
+#define CV181X_CLK_CAM0_VIP			157
+
+#endif /* __DT_BINDINGS_CLK_CV181X_H__ */
diff --git a/include/dt-bindings/dma/cv180x-dmamap.h b/include/dt-bindings/dma/cv180x-dmamap.h
new file mode 100644
index 000000000..7be85e0a9
--- /dev/null
+++ b/include/dt-bindings/dma/cv180x-dmamap.h
@@ -0,0 +1,48 @@
+#ifndef __DT_BINDINGS_CV180X_DMAMAP_H__
+#define __DT_BINDINGS_CV180XS_DMAMAP_H__
+
+#define CVI_I2S0_RX     0
+#define CVI_I2S0_TX     1
+#define CVI_I2S1_RX     2
+#define CVI_I2S1_TX     3
+#define CVI_I2S2_RX     4
+#define CVI_I2S2_TX     5
+#define CVI_I2S3_RX     6
+#define CVI_I2S3_TX     7
+#define CVI_UART0_RX    8
+#define CVI_UART0_TX    9
+#define CVI_UART1_RX    10
+#define CVI_UART1_TX    11
+#define CVI_UART2_RX    12
+#define CVI_UART2_TX    13
+#define CVI_UART3_RX    14
+#define CVI_UART3_TX    15
+#define CVI_SPI0_RX     16
+#define CVI_SPI0_TX     17
+#define CVI_SPI1_RX     18
+#define CVI_SPI1_TX     19
+#define CVI_SPI2_RX     20
+#define CVI_SPI2_TX     21
+#define CVI_SPI3_RX     22
+#define CVI_SPI3_TX     23
+#define CVI_I2C0_RX     24
+#define CVI_I2C0_TX     25
+#define CVI_I2C1_RX     26
+#define CVI_I2C1_TX     27
+#define CVI_I2C2_RX     28
+#define CVI_I2C2_TX     29
+#define CVI_I2C3_RX     30
+#define CVI_I2C3_TX     31
+#define CVI_I2C4_RX     32
+#define CVI_I2C4_TX     33
+#define CVI_TDM0_RX     34
+#define CVI_TDM0_TX     35
+#define CVI_TDM1_RX     36
+#define CVI_AUDSRC      37
+#define CVI_SPI_NAND    38
+#define CVI_SPI_NOR     39
+#define CVI_UART4_RX    40
+#define CVI_UART4_TX    41
+#define CVI_SPI_NOR1    42
+
+#endif
diff --git a/include/dt-bindings/dma/cv181x-dmamap.h b/include/dt-bindings/dma/cv181x-dmamap.h
new file mode 100644
index 000000000..84a4c3664
--- /dev/null
+++ b/include/dt-bindings/dma/cv181x-dmamap.h
@@ -0,0 +1,48 @@
+#ifndef __DT_BINDINGS_CV181X_DMAMAP_H__
+#define __DT_BINDINGS_CV181X_DMAMAP_H__
+
+#define CVI_I2S0_RX     0
+#define CVI_I2S0_TX     1
+#define CVI_I2S1_RX     2
+#define CVI_I2S1_TX     3
+#define CVI_I2S2_RX     4
+#define CVI_I2S2_TX     5
+#define CVI_I2S3_RX     6
+#define CVI_I2S3_TX     7
+#define CVI_UART0_RX    8
+#define CVI_UART0_TX    9
+#define CVI_UART1_RX    10
+#define CVI_UART1_TX    11
+#define CVI_UART2_RX    12
+#define CVI_UART2_TX    13
+#define CVI_UART3_RX    14
+#define CVI_UART3_TX    15
+#define CVI_SPI0_RX     16
+#define CVI_SPI0_TX     17
+#define CVI_SPI1_RX     18
+#define CVI_SPI1_TX     19
+#define CVI_SPI2_RX     20
+#define CVI_SPI2_TX     21
+#define CVI_SPI3_RX     22
+#define CVI_SPI3_TX     23
+#define CVI_I2C0_RX     24
+#define CVI_I2C0_TX     25
+#define CVI_I2C1_RX     26
+#define CVI_I2C1_TX     27
+#define CVI_I2C2_RX     28
+#define CVI_I2C2_TX     29
+#define CVI_I2C3_RX     30
+#define CVI_I2C3_TX     31
+#define CVI_I2C4_RX     32
+#define CVI_I2C4_TX     33
+#define CVI_TDM0_RX     34
+#define CVI_TDM0_TX     35
+#define CVI_TDM1_RX     36
+#define CVI_AUDSRC      37
+#define CVI_SPI_NAND    38
+#define CVI_SPI_NOR     39
+#define CVI_UART4_RX    40
+#define CVI_UART4_TX    41
+#define CVI_SPI_NOR1    42
+
+#endif
diff --git a/include/dt-bindings/reset/cv180x-resets.h b/include/dt-bindings/reset/cv180x-resets.h
new file mode 100644
index 000000000..0265a4c41
--- /dev/null
+++ b/include/dt-bindings/reset/cv180x-resets.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cvi_template.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_RST_CV180X_H__
+#define __DT_BINDINGS_RST_CV180X_H__
+
+#define RST_MAINRST_AP	0
+#define RST_SECONDRST_AP	1
+#define RST_DDR	2
+#define RST_H264C	3
+#define RST_JPEG	4
+#define RST_H265C	5
+#define RST_VIPSYS	6
+#define RST_TDMA	7
+#define RST_TPU	8
+#define RST_TPUSYS	9
+#define RST_TSM	10
+#define RST_USB	11
+#define RST_ETH0	12
+#define RST_ETH1	13
+#define RST_NAND	14
+#define RST_EMMC	15
+#define RST_SD0	16
+#define RST_SD1	17
+#define RST_SDMA	18
+#define RST_I2S0	19
+#define RST_I2S1	20
+#define RST_I2S2	21
+#define RST_I2S3	22
+#define RST_UART0	23
+#define RST_UART1	24
+#define RST_UART2	25
+#define RST_UART3	26
+#define RST_I2C0	27
+#define RST_I2C1	28
+#define RST_I2C2	29
+#define RST_I2C3	30
+#define RST_I2C4	31
+#define RST_PWM0	32
+#define RST_PWM1	33
+#define RST_PWM2	34
+#define RST_PWM3	35
+#define RST_PWM4	36
+#define RST_PWM5	37
+#define RST_PWM6	38
+#define RST_PWM7	39
+#define RST_SPI0	40
+#define RST_SPI1	41
+#define RST_SPI2	42
+#define RST_SPI3	43
+#define RST_GPIO0	44
+#define RST_GPIO1	45
+#define RST_GPIO2	46
+#define RST_EFUSE	47
+#define RST_WDT	48
+#define RST_AHBRST_ROM	49
+#define RST_SPIC	50
+#define RST_TEMPSEN	51
+#define RST_SARADC	52
+#define RST_PCIERST_CDMA	53
+#define RST_PCIERST_SMMU	54
+#define RST_PCIERST_PCIE	55
+#define RST_PCIERST_FABS	56
+#define RST_PCIERST_IRQ	57
+#define RST_COMBORST_PHY0	58
+#define RST_COMBORST_PHY1	59
+#define RST_USB1	60
+#define RST_SPIRST_NAND	61
+#define RST_SE	62
+#define RST_RTCRST_SWRST_ONLY	63
+#define RST_CPUCORE0	64
+#define RST_CPUCORE1	65
+#define RST_CPUCORE2	66
+#define RST_CPUCORE3	67
+#define RST_DSIPHY	68
+#define RST_DSIPHYRST_APB	69
+#define RST_CSIPHY0	70
+#define RST_CSIPHY0RST_APB	71
+#define RST_CSIPHY1	72
+#define RST_CSIPHY1RST_APB	73
+#define RST_UART4	74
+#define RST_GPIO3	75
+#define RST_SYSTEM	76
+#define RST_TIMER	77
+#define RST_TIMER0	78
+#define RST_TIMER1	79
+#define RST_TIMER2	80
+#define RST_TIMER3	81
+#define RST_TIMER4	82
+#define RST_TIMER5	83
+#define RST_TIMER6	84
+#define RST_TIMER7	85
+#define RST_WGN0	86
+#define RST_WGN1	87
+#define RST_WGN2	88
+#define RST_KEYSCAN	89
+#define RST_SPIC1	90
+#define RST_AUDDAC	91
+#define RST_AUDDACRST_APB	92
+#define RST_AUDADC	93
+#define RST_AUDADCRST_APB	94
+#define RST_VCSYS	95
+#define RST_ETHPHY	96
+#define RST_ETHPHYRST_APB	97
+#define RST_AUDSRC	98
+#define RST_AUTO_CLEAR_CPUCORE0	99
+#define RST_AUTO_CLEAR_CPUCORE1	100
+#define RST_AUTO_CLEAR_CPUCORE2	101
+#define RST_AUTO_CLEAR_CPUCORE3	102
+#define RST_AUTO_CLEAR_MAINRST_AP	103
+#define RST_AUTO_CLEAR_SECONDRST_AP	104
+
+#define CLK_RST_A53		0
+#define CLK_RST_50M_A53		1
+#define CLK_RST_AHB_ROM		2
+#define CLK_RST_AXI_SRAM	3
+#define CLK_RST_DDR_AXI		4
+#define CLK_RST_EFUSE		5
+#define CLK_RST_APB_EFUSE	6
+#define CLK_RST_AXI_EMMC	7
+#define CLK_RST_EMMC		8
+#define CLK_RST_100K_EMMC	9
+#define CLK_RST_AXI_SD		10
+#define CLK_RST_SD		11
+#define CLK_RST_100K_SD		12
+#define CLK_RST_500M_ETH0	13
+#define CLK_RST_AXI_ETH0	14
+#define CLK_RST_500M_ETH1	15
+#define CLK_RST_AXI_ETH1	16
+#define CLK_RST_AXI_GDMA	17
+#define CLK_RST_APB_GPIO	18
+#define CLK_RST_APB_GPIO_INTR	19
+#define CLK_RST_GPIO_DB		20
+#define CLK_RST_AXI_MINER	21
+#define CLK_RST_AHB_SF		22
+#define CLK_RST_SDMA_AXI	23
+#define CLK_RST_SDMA_AUD	24
+#define CLK_RST_APB_I2C		25
+#define CLK_RST_APB_WDT		26
+#define CLK_RST_APB_JPEG	27
+#define CLK_RST_JPEG_AXI	28
+#define CLK_RST_AXI_NF		29
+#define CLK_RST_APB_NF		30
+#define CLK_RST_NF		31
+#define CLK_RST_APB_PWM		32
+#define CLK_RST_RV		33
+#define CLK_RST_APB_SPI		34
+#define CLK_RST_TPU_AXI		35
+#define CLK_RST_UART_500M	36
+#define CLK_RST_APB_UART	37
+#define CLK_RST_APB_I2S		38
+#define CLK_RST_AXI_USB		39
+#define CLK_RST_APB_USB		40
+#define CLK_RST_125M_USB	41
+#define CLK_RST_33K_USB		42
+#define CLK_RST_12M_USB		43
+#define CLK_RST_APB_VIDEO	44
+#define CLK_RST_VIDEO_AXI	45
+#define CLK_RST_VPP_AXI		46
+#define CLK_RST_APB_VPP		47
+#define CLK_RST_AXI1		48
+#define CLK_RST_AXI2		49
+#define CLK_RST_AXI3		50
+#define CLK_RST_AXI4		51
+#define CLK_RST_AXI5		52
+#define CLK_RST_AXI6		53
+
+#endif /* _DT_BINDINGS_RST_CV180X_H_ */
diff --git a/include/dt-bindings/reset/cv181x-resets.h b/include/dt-bindings/reset/cv181x-resets.h
new file mode 100644
index 000000000..e39435161
--- /dev/null
+++ b/include/dt-bindings/reset/cv181x-resets.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cvi_template.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_RST_CV181X_H__
+#define __DT_BINDINGS_RST_CV181X_H__
+
+#define RST_MAINRST_AP	0
+#define RST_SECONDRST_AP	1
+#define RST_DDR	2
+#define RST_H264C	3
+#define RST_JPEG	4
+#define RST_H265C	5
+#define RST_VIPSYS	6
+#define RST_TDMA	7
+#define RST_TPU	8
+#define RST_TPUSYS	9
+#define RST_TSM	10
+#define RST_USB	11
+#define RST_ETH0	12
+#define RST_ETH1	13
+#define RST_NAND	14
+#define RST_EMMC	15
+#define RST_SD0	16
+#define RST_SD1	17
+#define RST_SDMA	18
+#define RST_I2S0	19
+#define RST_I2S1	20
+#define RST_I2S2	21
+#define RST_I2S3	22
+#define RST_UART0	23
+#define RST_UART1	24
+#define RST_UART2	25
+#define RST_UART3	26
+#define RST_I2C0	27
+#define RST_I2C1	28
+#define RST_I2C2	29
+#define RST_I2C3	30
+#define RST_I2C4	31
+#define RST_PWM0	32
+#define RST_PWM1	33
+#define RST_PWM2	34
+#define RST_PWM3	35
+#define RST_PWM4	36
+#define RST_PWM5	37
+#define RST_PWM6	38
+#define RST_PWM7	39
+#define RST_SPI0	40
+#define RST_SPI1	41
+#define RST_SPI2	42
+#define RST_SPI3	43
+#define RST_GPIO0	44
+#define RST_GPIO1	45
+#define RST_GPIO2	46
+#define RST_EFUSE	47
+#define RST_WDT	48
+#define RST_AHBRST_ROM	49
+#define RST_SPIC	50
+#define RST_TEMPSEN	51
+#define RST_SARADC	52
+#define RST_PCIERST_CDMA	53
+#define RST_PCIERST_SMMU	54
+#define RST_PCIERST_PCIE	55
+#define RST_PCIERST_FABS	56
+#define RST_PCIERST_IRQ	57
+#define RST_COMBORST_PHY0	58
+#define RST_COMBORST_PHY1	59
+#define RST_USB1	60
+#define RST_SPIRST_NAND	61
+#define RST_SE	62
+#define RST_RTCRST_SWRST_ONLY	63
+#define RST_CPUCORE0	64
+#define RST_CPUCORE1	65
+#define RST_CPUCORE2	66
+#define RST_CPUCORE3	67
+#define RST_DSIPHY	68
+#define RST_DSIPHYRST_APB	69
+#define RST_CSIPHY0	70
+#define RST_CSIPHY0RST_APB	71
+#define RST_CSIPHY1	72
+#define RST_CSIPHY1RST_APB	73
+#define RST_UART4	74
+#define RST_GPIO3	75
+#define RST_SYSTEM	76
+#define RST_TIMER	77
+#define RST_TIMER0	78
+#define RST_TIMER1	79
+#define RST_TIMER2	80
+#define RST_TIMER3	81
+#define RST_TIMER4	82
+#define RST_TIMER5	83
+#define RST_TIMER6	84
+#define RST_TIMER7	85
+#define RST_WGN0	86
+#define RST_WGN1	87
+#define RST_WGN2	88
+#define RST_KEYSCAN	89
+#define RST_SPIC1	90
+#define RST_AUDDAC	91
+#define RST_AUDDACRST_APB	92
+#define RST_AUDADC	93
+#define RST_AUDADCRST_APB	94
+#define RST_VCSYS	95
+#define RST_ETHPHY	96
+#define RST_ETHPHYRST_APB	97
+#define RST_AUDSRC	98
+#define RST_AUTO_CLEAR_CPUCORE0	99
+#define RST_AUTO_CLEAR_CPUCORE1	100
+#define RST_AUTO_CLEAR_CPUCORE2	101
+#define RST_AUTO_CLEAR_CPUCORE3	102
+#define RST_AUTO_CLEAR_MAINRST_AP	103
+#define RST_AUTO_CLEAR_SECONDRST_AP	104
+
+#define CLK_RST_A53		0
+#define CLK_RST_50M_A53		1
+#define CLK_RST_AHB_ROM		2
+#define CLK_RST_AXI_SRAM	3
+#define CLK_RST_DDR_AXI		4
+#define CLK_RST_EFUSE		5
+#define CLK_RST_APB_EFUSE	6
+#define CLK_RST_AXI_EMMC	7
+#define CLK_RST_EMMC		8
+#define CLK_RST_100K_EMMC	9
+#define CLK_RST_AXI_SD		10
+#define CLK_RST_SD		11
+#define CLK_RST_100K_SD		12
+#define CLK_RST_500M_ETH0	13
+#define CLK_RST_AXI_ETH0	14
+#define CLK_RST_500M_ETH1	15
+#define CLK_RST_AXI_ETH1	16
+#define CLK_RST_AXI_GDMA	17
+#define CLK_RST_APB_GPIO	18
+#define CLK_RST_APB_GPIO_INTR	19
+#define CLK_RST_GPIO_DB		20
+#define CLK_RST_AXI_MINER	21
+#define CLK_RST_AHB_SF		22
+#define CLK_RST_SDMA_AXI	23
+#define CLK_RST_SDMA_AUD	24
+#define CLK_RST_APB_I2C		25
+#define CLK_RST_APB_WDT		26
+#define CLK_RST_APB_JPEG	27
+#define CLK_RST_JPEG_AXI	28
+#define CLK_RST_AXI_NF		29
+#define CLK_RST_APB_NF		30
+#define CLK_RST_NF		31
+#define CLK_RST_APB_PWM		32
+#define CLK_RST_RV		33
+#define CLK_RST_APB_SPI		34
+#define CLK_RST_TPU_AXI		35
+#define CLK_RST_UART_500M	36
+#define CLK_RST_APB_UART	37
+#define CLK_RST_APB_I2S		38
+#define CLK_RST_AXI_USB		39
+#define CLK_RST_APB_USB		40
+#define CLK_RST_125M_USB	41
+#define CLK_RST_33K_USB		42
+#define CLK_RST_12M_USB		43
+#define CLK_RST_APB_VIDEO	44
+#define CLK_RST_VIDEO_AXI	45
+#define CLK_RST_VPP_AXI		46
+#define CLK_RST_APB_VPP		47
+#define CLK_RST_AXI1		48
+#define CLK_RST_AXI2		49
+#define CLK_RST_AXI3		50
+#define CLK_RST_AXI4		51
+#define CLK_RST_AXI5		52
+#define CLK_RST_AXI6		53
+
+#endif /* _DT_BINDINGS_RST_CV181X_H_ */
diff --git a/include/env_default.h b/include/env_default.h
index 1ddd64ba8..e840425e4 100644
--- a/include/env_default.h
+++ b/include/env_default.h
@@ -43,6 +43,15 @@ const uchar default_environment[] = {
 #ifdef	CONFIG_NFSBOOTCOMMAND
 	"nfsboot="	CONFIG_NFSBOOTCOMMAND		"\0"
 #endif
+#ifdef	CONFIG_NANDBOOTCOMMAND
+	"nandboot="	CONFIG_NANDBOOTCOMMAND		"\0"
+#endif
+#ifdef	CONFIG_EMMCBOOTCOMMAND
+	"emmcboot="	CONFIG_EMMCBOOTCOMMAND		"\0"
+#endif
+#ifdef	CONFIG_NORBOOTCOMMAND
+	"norboot="	CONFIG_NORBOOTCOMMAND		"\0"
+#endif
 #if defined(CONFIG_BOOTDELAY)
 	"bootdelay="	__stringify(CONFIG_BOOTDELAY)	"\0"
 #endif
diff --git a/include/linux/mtd/cfi.h b/include/linux/mtd/cfi.h
index 3555518bd..3d87f5e00 100644
--- a/include/linux/mtd/cfi.h
+++ b/include/linux/mtd/cfi.h
@@ -11,22 +11,30 @@
 #define CFI_ID_ANY		0xFFFF
 #define CFI_MFR_CONTINUATION	0x007F
 
-#define CFI_MFR_AMD		0x0001
-#define CFI_MFR_AMIC		0x0037
-#define CFI_MFR_ATMEL		0x001F
-#define CFI_MFR_EON		0x001C
-#define CFI_MFR_FUJITSU		0x0004
-#define CFI_MFR_HYUNDAI		0x00AD
-#define CFI_MFR_INTEL		0x0089
-#define CFI_MFR_MACRONIX	0x00C2
-#define CFI_MFR_NEC		0x0010
-#define CFI_MFR_PMC		0x009D
-#define CFI_MFR_SAMSUNG		0x00EC
-#define CFI_MFR_SHARP		0x00B0
-#define CFI_MFR_SST		0x00BF
-#define CFI_MFR_ST		0x0020 /* STMicroelectronics */
-#define CFI_MFR_MICRON		0x002C	/* Micron */
-#define CFI_MFR_TOSHIBA		0x0098
-#define CFI_MFR_WINBOND		0x00DA
+#define CFI_MFR_AMD         0x0001
+#define CFI_MFR_AMIC        0x0037
+#define CFI_MFR_ATMEL       0x001F
+#define CFI_MFR_EON         0x001C
+#define CFI_MFR_FUJITSU     0x0004
+#define CFI_MFR_HYUNDAI     0x00AD
+#define CFI_MFR_INTEL       0x0089
+#define CFI_MFR_MACRONIX    0x00C2
+#define CFI_MFR_NEC         0x0010
+#define CFI_MFR_PMC         0x009D
+#define CFI_MFR_SAMSUNG     0x00EC
+#define CFI_MFR_SHARP       0x00B0
+#define CFI_MFR_SST         0x00BF
+#define CFI_MFR_ST          0x0020 /* STMicroelectronics */
+#define CFI_MFR_MICRON      0x002C /* Micron */
+#define CFI_MFR_TOSHIBA     0x0098
+#define CFI_MFR_WINBOND     0x00DA
+#define CFI_MFR_GIGADEVICE  0x00C8
+#define CFI_MFR_XMC         0x0020
+#define CFI_MFR_EON         0x001C
+#define CFI_MFR_ZBIT        0x005E
+#define CFI_MFR_XTX         0x000B
+#define CFI_MFR_FM          0x00F8
+#define CFI_MFR_JUYANG      0x004A
+#define CFI_MFR_BOYA        0x0068
 
 #endif /* __MTD_CFI_H__ */
diff --git a/include/linux/mtd/rawnand.h b/include/linux/mtd/rawnand.h
index 2fba9dc31..77ec0419d 100644
--- a/include/linux/mtd/rawnand.h
+++ b/include/linux/mtd/rawnand.h
@@ -184,6 +184,8 @@ enum nand_ecc_algo {
  * Option constants for bizarre disfunctionality and real
  * features.
  */
+/* Chip can not auto increment pages */
+#define NAND_NO_AUTOINCR    0x00000001
 /* Buswidth is 16 bit */
 #define NAND_BUSWIDTH_16	0x00000002
 /* Device supports partial programming without padding */
@@ -251,6 +253,11 @@ enum nand_ecc_algo {
  */
 #define NAND_USE_BOUNCE_BUFFER	0x00100000
 
+/*
+ * Some devices only support 1 bit transfer mode
+ */
+#define NAND_ONLY_ONE_BIT_MODE	0x10000000
+
 /* Options set by nand scan */
 /* bbt has already been read */
 #define NAND_BBT_SCANNED	0x40000000
@@ -945,7 +952,7 @@ struct nand_chip {
 	int jedec_version;
 	struct nand_onfi_params	onfi_params;
 	struct nand_jedec_params jedec_params;
- 
+
 	struct nand_data_interface *data_interface;
 
 	int read_retries;
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 4ceeae623..170db5ee5 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -19,7 +19,7 @@
  * Sometimes these are the same as CFI IDs, but sometimes they aren't.
  */
 #define SNOR_MFR_ATMEL		CFI_MFR_ATMEL
-#define SNOR_MFR_GIGADEVICE	0xc8
+#define SNOR_MFR_GIGADEVICE	CFI_MFR_GIGADEVICE
 #define SNOR_MFR_INTEL		CFI_MFR_INTEL
 #define SNOR_MFR_ST		CFI_MFR_ST /* ST Micro <--> Micron */
 #define SNOR_MFR_MICRON		CFI_MFR_MICRON /* ST Micro <--> Micron */
@@ -27,8 +27,16 @@
 #define SNOR_MFR_MACRONIX	CFI_MFR_MACRONIX
 #define SNOR_MFR_SPANSION	CFI_MFR_AMD
 #define SNOR_MFR_SST		CFI_MFR_SST
-#define SNOR_MFR_WINBOND	0xef /* Also used by some Spansion */
+#define SNOR_MFR_WINBOND	0xEF /* Also used by some Spansion */
 #define SNOR_MFR_CYPRESS	0x34
+#define SNOR_MFR_XMC		CFI_MFR_XMC
+#define SNOR_MFR_EON		CFI_MFR_EON
+#define SNOR_MFR_ZBIT		CFI_MFR_ZBIT
+#define SNOR_MFR_XTX		CFI_MFR_XTX
+#define SNOR_MFR_FM		CFI_MFR_FM
+#define SNOR_MFR_JUYANG		CFI_MFR_JUYANG
+#define SNOR_MFR_BOYA		CFI_MFR_BOYA
+#define SNOR_MFR_PY		0x85
 
 /*
  * Note on opcode nomenclature: some opcodes have a format like
@@ -43,7 +51,7 @@
 #define SPINOR_OP_RDSR		0x05	/* Read status register */
 #define SPINOR_OP_WRSR		0x01	/* Write status register 1 byte */
 #define SPINOR_OP_RDSR2		0x3f	/* Read status register 2 */
-#define SPINOR_OP_WRSR2		0x3e	/* Write status register 2 */
+#define SPINOR_OP_WRSR2		0x31	/* Write status register 2 */
 #define SPINOR_OP_READ		0x03	/* Read data bytes (low frequency) */
 #define SPINOR_OP_READ_FAST	0x0b	/* Read data bytes (high frequency) */
 #define SPINOR_OP_READ_1_1_2	0x3b	/* Read data bytes (Dual Output SPI) */
diff --git a/include/lmb.h b/include/lmb.h
index 3c4afdf9f..198429113 100644
--- a/include/lmb.h
+++ b/include/lmb.h
@@ -122,6 +122,7 @@ lmb_size_bytes(struct lmb_region *type, unsigned long region_nr)
 
 void board_lmb_reserve(struct lmb *lmb);
 void arch_lmb_reserve(struct lmb *lmb);
+void arch_lmb_reserve_generic(struct lmb *lmb, ulong sp, ulong end, ulong align);
 
 /* Low level functions */
 
diff --git a/include/mmc.h b/include/mmc.h
index b92e25534..a795c0327 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -478,7 +478,7 @@ struct dm_mmc_ops {
 	 */
 	int (*get_wp)(struct udevice *dev);
 
-#ifdef MMC_SUPPORTS_TUNING
+#ifdef CONFIG_MMC_SUPPORTS_TUNING
 	/**
 	 * execute_tuning() - Start the tuning process
 	 *
@@ -488,17 +488,19 @@ struct dm_mmc_ops {
 	 */
 	int (*execute_tuning)(struct udevice *dev, uint opcode);
 #endif
-
-	/**
-	 * wait_dat0() - wait until dat0 is in the target state
-	 *		(CLK must be running during the wait)
-	 *
-	 * @dev:	Device to check
-	 * @state:	target state
-	 * @timeout_us:	timeout in us
-	 * @return 0 if dat0 is in the target state, -ve on error
-	 */
+		/**
+		 * wait_dat0() - wait until dat0 is in the target state
+		 *		(CLK must be running during the wait)
+		 *
+		 * @dev:	Device to check
+		 * @state:	target state
+		 * @timeout:	timeout in us
+		 * @return 0 if dat0 is in the target state, -ve on error
+		 */
 	int (*wait_dat0)(struct udevice *dev, int state, int timeout_us);
+#ifdef CONFIG_MMC_UHS_SUPPORT
+	void (*set_voltage)(struct udevice *dev);
+#endif
 
 #if CONFIG_IS_ENABLED(MMC_HS400_ES_SUPPORT)
 	/* set_enhanced_strobe() - set HS400 enhanced strobe */
@@ -637,7 +639,7 @@ static inline bool mmc_is_mode_ddr(enum bus_mode mode)
 
 static inline bool supports_uhs(uint caps)
 {
-#if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
+#ifdef CONFIG_MMC_UHS_SUPPORT
 	return (caps & UHS_CAPS) ? true : false;
 #else
 	return false;
@@ -845,6 +847,7 @@ void print_mmc_devices(char separator);
  * @return 0 if there is no MMC device, else the number of devices
  */
 int get_mmc_num(void);
+int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value);
 int mmc_switch_part(struct mmc *mmc, unsigned int part_num);
 int mmc_hwpart_config(struct mmc *mmc, const struct mmc_hwpart_conf *conf,
 		      enum mmc_hwpart_conf_mode mode);
diff --git a/include/nand.h b/include/nand.h
index 80dd6469b..e90d4a2ea 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -43,6 +43,7 @@ extern int board_nand_init(struct nand_chip *nand);
 #endif
 
 extern int nand_curr_device;
+extern struct mtd_info *nand_info[];
 
 static inline int nand_read(struct mtd_info *info, loff_t ofs, size_t *len,
 			    u_char *buf)
@@ -97,6 +98,7 @@ struct nand_erase_options {
 
 typedef struct nand_erase_options nand_erase_options_t;
 
+int nand_read_device_id(struct mtd_info *mtd);
 int nand_read_skip_bad(struct mtd_info *mtd, loff_t offset, size_t *length,
 		       size_t *actual, loff_t lim, u_char *buffer);
 
@@ -153,4 +155,6 @@ void sunxi_nand_init(void);
  */
 struct mtd_info *get_nand_dev_by_index(int dev);
 
+void bbt_dump_buf(char *s, void *buf, int len);
+
 #endif /* _NAND_H_ */
diff --git a/include/phy.h b/include/phy.h
index 6b928636b..741136b26 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -519,6 +519,7 @@ int phy_atheros_init(void);
 int phy_broadcom_init(void);
 int phy_cortina_init(void);
 int phy_cortina_access_init(void);
+int phy_cv182xa_init(void);
 int phy_davicom_init(void);
 int phy_et1011c_init(void);
 int phy_lxt_init(void);
diff --git a/include/sdhci.h b/include/sdhci.h
index 44a0d84e5..9e4644587 100644
--- a/include/sdhci.h
+++ b/include/sdhci.h
@@ -14,7 +14,16 @@
 #include <asm/io.h>
 #include <mmc.h>
 #include <asm/gpio.h>
-
+#include <mmio.h>
+#if defined(CONFIG_TARGET_CVITEK_CV1835)
+#include <../../board/cvitek/cv1835/sdhci_reg.h>
+#elif defined(CONFIG_TARGET_CVITEK_CV1822)
+#include <../../board/cvitek/cv1822/sdhci_reg.h>
+#elif defined(CONFIG_TARGET_CVITEK_CV181X)
+#include <../../board/cvitek/cv181x/sdhci_reg.h>
+#elif defined(CONFIG_TARGET_CVITEK_CV180X)
+#include <../../board/cvitek/cv180x/sdhci_reg.h>
+#endif
 /*
  * Controller registers
  */
@@ -111,7 +120,9 @@
 #define  SDHCI_RESET_DATA	0x04
 
 #define SDHCI_INT_STATUS	0x30
+#define SDHCI_ERR_INT_STATUS	0x32
 #define SDHCI_INT_ENABLE	0x34
+#define SDHCI_ERR_INT_STATUS_EN  0x36
 #define SDHCI_SIGNAL_ENABLE	0x38
 #define  SDHCI_INT_RESPONSE	BIT(0)
 #define  SDHCI_INT_DATA_END	BIT(1)
@@ -147,6 +158,9 @@
 #define SDHCI_ACMD12_ERR	0x3C
 
 #define SDHCI_HOST_CONTROL2	0x3E
+#define SDHCI_HOST_VER4_ENABLE  BIT(12)
+#define SDHCI_HOST_ADDRESSING   BIT(13)
+#define SDHCI_HOST_ADMA2_LEN_MODE       BIT(10)
 #define  SDHCI_CTRL_UHS_MASK	0x0007
 #define  SDHCI_CTRL_UHS_SDR12	0x0000
 #define  SDHCI_CTRL_UHS_SDR25	0x0001
@@ -270,6 +284,8 @@ struct sdhci_ops {
 	int (*platform_execute_tuning)(struct mmc *host, u8 opcode);
 	int (*set_delay)(struct sdhci_host *host);
 	int	(*deferred_probe)(struct sdhci_host *host);
+	void (*reset)(struct sdhci_host *host, u8 mask);
+	void (*voltage_switch)(struct mmc *mmc);
 };
 
 #define ADMA_MAX_LEN	65532
@@ -492,15 +508,6 @@ void sdhci_set_uhs_timing(struct sdhci_host *host);
 int sdhci_probe(struct udevice *dev);
 int sdhci_set_clock(struct mmc *mmc, unsigned int clock);
 
-/**
- * sdhci_set_control_reg - Set control registers
- *
- * This is used set up control registers for voltage level and UHS speed
- * mode.
- *
- * @host: SDHCI host structure
- */
-void sdhci_set_control_reg(struct sdhci_host *host);
 extern const struct dm_mmc_ops sdhci_ops;
 #else
 #endif
diff --git a/include/spi.h b/include/spi.h
index dc3b21132..c0d871d09 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -156,6 +156,10 @@ struct spi_slave {
 #define SPI_XFER_BEGIN		BIT(0)	/* Assert CS before transfer */
 #define SPI_XFER_END		BIT(1)	/* Deassert CS after transfer */
 #define SPI_XFER_ONCE		(SPI_XFER_BEGIN | SPI_XFER_END)
+#define SPI_XFER_MMAP           BIT(2)  /* Memory Mapped start */
+#define SPI_XFER_MMAP_END       BIT(3)  /* Memory Mapped End */
+#define SPI_XFER_USER_DATA      BIT(4)  /* only xfer user data */
+#define SPI_XFER_CMD_DATA       BIT(5)  /* indicates that the data is not user data it could be 'cmd' or 'addr' */
 };
 
 /**
diff --git a/include/spi_flash.h b/include/spi_flash.h
index 3d747c925..910de2e79 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -13,6 +13,14 @@
 #include <linux/mtd/spi-nor.h>
 
 struct udevice;
+#define CONFIG_ENV_SPI_BUS	0
+#define CONFIG_ENV_SPI_CS	0
+#define CONFIG_ENV_SPI_MAX_HZ	75000000
+#define CONFIG_ENV_SPI_MODE	0x0
+
+/* Alec Todo: should move to spinor defconfig */
+#define CONFIG_SF_DEFAULT_CS 0
+#define CONFIG_SF_DEFAULT_BUS 0
 
 /* by default ENV use the same parameters than SF command */
 #ifndef CONFIG_ENV_SPI_BUS
diff --git a/lib/display_options.c b/lib/display_options.c
index 4da1f5244..67564c309 100644
--- a/lib/display_options.c
+++ b/lib/display_options.c
@@ -140,7 +140,7 @@ void print_size(uint64_t size, const char *s)
 #define DEFAULT_LINE_LENGTH_BYTES	16
 
 int hexdump_line(ulong addr, const void *data, uint width, uint count,
-		 uint linelen, char *out, int size)
+		 uint linelen, char *out, size_t size)
 {
 	/* linebuf as a union causes proper alignment */
 	union linebuf {
@@ -213,7 +213,7 @@ int print_buffer(ulong addr, const void *data, uint width, uint count,
 		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
 
 	while (count) {
-		uint thislinelen;
+		int thislinelen;
 		char buf[HEXDUMP_MAX_BUF_LENGTH(width * linelen)];
 
 		thislinelen = hexdump_line(addr, data, width, count, linelen,
diff --git a/lib/lmb.c b/lib/lmb.c
index 7bd1255f7..f95db9faf 100644
--- a/lib/lmb.c
+++ b/lib/lmb.c
@@ -11,6 +11,9 @@
 #include <lmb.h>
 #include <log.h>
 #include <malloc.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
 
 #define LMB_ALLOC_ANYWHERE	0
 
@@ -113,6 +116,37 @@ void lmb_init(struct lmb *lmb)
 	lmb->reserved.cnt = 0;
 }
 
+void arch_lmb_reserve_generic(struct lmb *lmb, ulong sp, ulong end, ulong align)
+{
+	ulong bank_end;
+	int bank;
+
+	/*
+	 * Reserve memory from aligned address below the bottom of U-Boot stack
+	 * until end of U-Boot area using LMB to prevent U-Boot from overwriting
+	 * that memory.
+	 */
+	debug("## Current stack ends at 0x%08lx ", sp);
+
+	/* adjust sp by 4K to be safe */
+	sp -= align;
+	for (bank = 0; bank < CONFIG_NR_DRAM_BANKS; bank++) {
+		if (!gd->bd->bi_dram[bank].size ||
+		    sp < gd->bd->bi_dram[bank].start)
+			continue;
+		/* Watch out for RAM at end of address space! */
+		bank_end = gd->bd->bi_dram[bank].start +
+			gd->bd->bi_dram[bank].size - 1;
+		if (sp > bank_end)
+			continue;
+		if (bank_end > end)
+			bank_end = end - 1;
+
+		lmb_reserve(lmb, sp, bank_end - sp + 1);
+		break;
+	}
+}
+
 static void lmb_reserve_common(struct lmb *lmb, void *fdt_blob)
 {
 	arch_lmb_reserve(lmb);
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 07696e86b..06c7ac9aa 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -190,7 +190,8 @@ dtc_cpp_flags  = -Wp,-MD,$(depfile).pre.tmp -nostdinc                    \
 		 -I$(srctree)/arch/$(ARCH)/include                       \
 		 -include $(srctree)/include/linux/kconfig.h             \
 		 -D__ASSEMBLY__                                          \
-		 -undef -D__DTS__
+		 -undef -D__DTS__                                        \
+		 -D__UBOOT__
 
 # Finds the multi-part object the current object will be linked into
 modname-multi = $(sort $(foreach m,$(multi-used),\
diff --git a/scripts/check-config.sh b/scripts/check-config.sh
index cc1c9a54d..6524e9a76 100755
--- a/scripts/check-config.sh
+++ b/scripts/check-config.sh
@@ -34,6 +34,7 @@ srctree="$3"
 configs="${path}.configs"
 suspects="${path}.suspects"
 ok="${path}.ok"
+sep="${path}.sep"
 new_adhoc="${path}.adhoc"
 
 export LC_ALL=C
@@ -44,10 +45,11 @@ cat ${path} |sed -nr 's/^#define (CONFIG_[A-Za-z0-9_]*).*/\1/p' |sort |uniq \
 
 comm -23 ${configs} ${whitelist} > ${suspects}
 
-cat `find ${srctree} -name "Kconfig*"` |sed -nr \
-	-e 's/^[[:blank:]]*config *([A-Za-z0-9_]*).*$/CONFIG_\1/p' \
+echo > ${sep}
+find ${srctree} -name "Kconfig*" -exec cat '{}' ${sep} ';' | sed -nE \
+	-e 's/^[[:blank:]]*config[[:blank:]]*([A-Za-z0-9_]*).*$/CONFIG_\1/p' \
 	-e 's/^[[:blank:]]*menuconfig ([A-Za-z0-9_]*).*$/CONFIG_\1/p' \
-	|sort |uniq > ${ok}
+	| sort |uniq > ${ok}
 comm -23 ${suspects} ${ok} >${new_adhoc}
 if [ -s ${new_adhoc} ]; then
 	echo >&2 "Error: You must add new CONFIG options using Kconfig"
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index a9c2380d1..782b6099d 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -216,6 +216,10 @@ CONFIG_CS8900_BUS32
 CONFIG_CTL_JTAG
 CONFIG_CTL_TBE
 CONFIG_CUSTOMER_BOARD_SUPPORT
+CONFIG_CVSNFC_BUFFER_BASE_ADDRESS
+CONFIG_CVSNFC_HARDWARE_PAGESIZE_ECC
+CONFIG_CVSNFC_MAX_CHIP
+CONFIG_CVSNFC_REG_BASE_ADDRESS
 CONFIG_D2NET_V2
 CONFIG_DA850_EVM_MAX_CPU_CLK
 CONFIG_DB_784MP_GP
@@ -331,6 +335,8 @@ CONFIG_EHCI_IS_TDI
 CONFIG_EHCI_MMIO_BIG_ENDIAN
 CONFIG_EHCI_MXS_PORT0
 CONFIG_EHCI_MXS_PORT1
+CONFIG_EMMCBOOTCOMMAND
+CONFIG_EMMC_SUPPORT
 CONFIG_EMU
 CONFIG_ENABLE_36BIT_PHYS
 CONFIG_ENABLE_MMU
@@ -937,6 +943,7 @@ CONFIG_MMCROOT
 CONFIG_MMC_DEFAULT_DEV
 CONFIG_MMC_RPMB_TRACE
 CONFIG_MMC_SUNXI_SLOT
+CONFIG_MMC_SUPPORTS_TUNING
 CONFIG_MMU
 CONFIG_MONITOR_IS_IN_RAM
 CONFIG_MPC83XX_GPIO_0_INIT_DIRECTION
@@ -950,6 +957,7 @@ CONFIG_MPC85XX_FEC
 CONFIG_MPC85XX_FEC_NAME
 CONFIG_MPC8xxx_DISABLE_BPTR
 CONFIG_MTD_CONCAT
+CONFIG_MTD_DEVICE
 CONFIG_MTD_NAND_MUSEUM_IDS
 CONFIG_MTD_NAND_VERIFY_WRITE
 CONFIG_MTD_ONENAND_VERIFY_WRITE
@@ -996,22 +1004,40 @@ CONFIG_MXS_AUART
 CONFIG_MXS_AUART_BASE
 CONFIG_MXS_OCOTP
 CONFIG_MY_OPTION
+CONFIG_NAND
+CONFIG_NANDBOOTCOMMAND
 CONFIG_NANDFLASH_SIZE
+CONFIG_NANDITBIMAGE_SIZE
 CONFIG_NAND_6BYTES_OOB_FREE_10BYTES_ECC
+CONFIG_NAND_ACTL
+CONFIG_NAND_ATMEL
 CONFIG_NAND_CS_INIT
 CONFIG_NAND_DATA_REG
+CONFIG_NAND_DAVINCI
+CONFIG_NAND_DENALI_ECC_SIZE
 CONFIG_NAND_ECC_BCH
 CONFIG_NAND_ENV_DST
+CONFIG_NAND_FLASH_CVSNFC
 CONFIG_NAND_FSL_ELBC
 CONFIG_NAND_FSL_IFC
+CONFIG_NAND_FSL_NFC
+CONFIG_NAND_FSMC
 CONFIG_NAND_KIRKWOOD
 CONFIG_NAND_KMETER1
 CONFIG_NAND_LPC32XX_MLC
+CONFIG_NAND_LPC32XX_SLC
 CONFIG_NAND_MODE_REG
+CONFIG_NAND_MXC
+CONFIG_NAND_MXC_V1_1
+CONFIG_NAND_NDFC
 CONFIG_NAND_OMAP_ECCSCHEME
+CONFIG_NAND_OMAP_ELM
+CONFIG_NAND_OMAP_GPMC
+CONFIG_NAND_OMAP_GPMC_PREFETCH
 CONFIG_NAND_OMAP_GPMC_WSCFG
 CONFIG_NAND_SECBOOT
 CONFIG_NAND_SPL
+CONFIG_NAND_SUPPORT
 CONFIG_NAND_U_BOOT
 CONFIG_NATSEMI
 CONFIG_NCEL2C100_BASE
@@ -1035,6 +1061,7 @@ CONFIG_NFS_TIMEOUT
 CONFIG_NOBQFMAN
 CONFIG_NON_SECURE
 CONFIG_NORBOOT
+CONFIG_NORBOOTCOMMAND
 CONFIG_NORFLASH_PS32BIT
 CONFIG_NO_ETH
 CONFIG_NO_RELOCATION
@@ -1309,6 +1336,7 @@ CONFIG_SIEMENS_MACH_TYPE
 CONFIG_SKIP_LOCAL_MAC_RANDOMIZATION
 CONFIG_SKIP_LOWLEVEL_INIT
 CONFIG_SKIP_LOWLEVEL_INIT_ONLY
+CONFIG_SKIP_RAMDISK
 CONFIG_SKIP_TRUNOFF_WATCHDOG
 CONFIG_SLIC
 CONFIG_SLTTMR
@@ -1349,6 +1377,7 @@ CONFIG_SPIFLASH
 CONFIG_SPI_ADDR
 CONFIG_SPI_BOOTING
 CONFIG_SPI_DATAFLASH_WRITE_VERIFY
+CONFIG_SPI_FLASH_CVSFC
 CONFIG_SPI_FLASH_QUAD
 CONFIG_SPI_FLASH_SIZE
 CONFIG_SPI_HALF_DUPLEX
@@ -3007,6 +3036,7 @@ CONFIG_SYS_READ_SPD
 CONFIG_SYS_RESET_ADDR
 CONFIG_SYS_RESET_ADDRESS
 CONFIG_SYS_RESET_SCTRL
+CONFIG_SYS_RESVIONSZ
 CONFIG_SYS_RFD
 CONFIG_SYS_RGMII1_PHY_ADDR
 CONFIG_SYS_RGMII2_PHY_ADDR
@@ -3415,6 +3445,7 @@ CONFIG_USB_ULPI_TIMEOUT
 CONFIG_USB_XHCI_EXYNOS
 CONFIG_USB_XHCI_OMAP
 CONFIG_USER_LOWLEVEL_INIT
+CONFIG_USE_DEFAULT_ENV
 CONFIG_USE_INTERRUPT
 CONFIG_USE_ONENAND_BOARD_INIT
 CONFIG_UTBIPAR_INIT_TBIPA
diff --git a/tools/Makefile b/tools/Makefile
index 4a86321f6..158b3ade4 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -117,7 +117,6 @@ dumpimage-mkimage-objs := aisimage.o \
 			imximage.o \
 			imx8image.o \
 			imx8mimage.o \
-			kwbimage.o \
 			lib/md5.o \
 			lpc32xximage.o \
 			mxsimage.o \
diff --git a/tools/env/fw_env.c b/tools/env/fw_env.c
index 2a61a5d6f..096eee917 100644
--- a/tools/env/fw_env.c
+++ b/tools/env/fw_env.c
@@ -1661,6 +1661,7 @@ static int check_device_config(int dev)
 		if (mtdinfo.type != MTD_NORFLASH &&
 		    mtdinfo.type != MTD_NANDFLASH &&
 		    mtdinfo.type != MTD_DATAFLASH &&
+			mtdinfo.type != MTD_MLCNANDFLASH &&
 		    mtdinfo.type != MTD_UBIVOLUME) {
 			fprintf(stderr, "Unsupported flash type %u on %s\n",
 				mtdinfo.type, DEVNAME(dev));
-- 
2.34.1

